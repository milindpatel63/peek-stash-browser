# Issues Found in v3.0.0-beta.9

**Date:** December 15, 2025
**To be addressed in separate branches before or after 3.0.0 release**

---

## Issue 1: Detail Page Tabs Not Loading (Non-Scenes Tabs)

**Severity:** HIGH - User-facing navigation broken

**Symptoms:**
- On Performer Detail, Studio Detail, Tag Detail, and Collection/Group Detail pages
- Clicking non-Scenes tabs (Galleries, Images, Groups) causes a flicker
- URL briefly shows `?tab=galleries` but immediately switches back to default (Scenes)
- Manually typing URL with `?tab=galleries` also reverts

**Root Cause Analysis:**

The issue is NOT related to tab filtering or counts. The `SearchControls` component completely replaces URL query params when syncing state to URL, obliterating the `?tab=` parameter.

**The Problem:**

In `client/src/components/ui/SearchControls.jsx:384`:
```javascript
setSearchParams(params, { replace: true });
```

And in `client/src/utils/urlParams.js:169`, `buildSearchParams()` creates a **brand new URLSearchParams()** that only includes filter/sort/page params - it does NOT preserve unknown params like `tab`.

**The Flow:**
1. User clicks "Galleries" tab → `TabNavigation` sets `?tab=galleries`
2. Tab content changes, `GalleryGrid` (via `SearchableGrid` → `SearchControls`) mounts
3. `SearchControls` initializes and calls `setSearchParams(params)` with only its filter params
4. `?tab=galleries` is **obliterated**, replaced with filter params (or empty string)
5. `activeTab` reads from URL, sees no `tab` param, defaults back to `scenes`

**Files to Fix:**
- `client/src/components/ui/SearchControls.jsx` - URL sync logic
- `client/src/utils/urlParams.js` - `buildSearchParams` function

**Fix Options:**
1. **Pass `syncToUrl={false}`** to grids rendered inside tabs (quick fix, breaks URL bookmarking for nested grids)
2. **Preserve unknown params** in `buildSearchParams` - accept existing params and merge rather than replace
3. **Namespace params** - use prefixes like `scene_sort=`, `gallery_sort=` to avoid conflicts

---

## Issue 2: Tags Query Performance

**Severity:** MEDIUM - Usability issue, not broken

**Symptoms:**
- Tags list page is slow to load
- Tag detail page is slow
- Not unusable but noticeably slower than other entity types

**Root Cause Analysis:**

The `enhanceTagsWithPerformerScenes()` function at `server/controllers/library/tags.ts:19-75` is O(n*m) where n=scenes and m=performers. It loads ALL scenes and ALL performers to calculate counts.

**Key Finding:** The real performance issue is that `enhanceTagsWithPerformerScenes()` is called at `tags.ts:261`, which is **AFTER** the filtered entity cache check (lines 151-254). This means:

- Tag filtering IS cached (via `filteredEntityCacheService`)
- But performer scene enhancement runs on **every single request**, even cache hits

The caching only helps with content restriction filtering, not with the expensive enhancement step.

**Files to Fix:**
- `server/controllers/library/tags.ts` - Move enhancement inside cache block or cache separately

**Fix Options:**
1. **Move enhancement inside cache block** - Include enhanced data in the cached result (simplest)
2. **Pre-compute counts on sync** - Store `scene_count_via_performers` in the StashTag table
3. **Use SQL aggregation** - Replace the in-memory calculation with a SQL COUNT query
4. **Separate cache for enhancement** - Cache the enhancement result with its own TTL
5. **Lazy load** - Only calculate performer scene counts when specifically requested (detail page)

---

## Issue 3: O History Stored in JSON Column

**Severity:** LOW - Technical debt, not user-facing

**Current Implementation:**

From `server/prisma/schema.prisma` line 72:
```prisma
oHistory Json @default("[]") // Array of timestamp strings when O was incremented
```

The O history is stored as a JSON array of timestamp strings within the WatchHistory table.

**Problems with this approach:**
1. Cannot efficiently query "all O events in the last week"
2. Cannot aggregate O events across scenes/performers without loading all JSON
3. JSON arrays don't scale well for users with thousands of O events
4. No referential integrity

**Proposed Schema:**

```prisma
model OEvent {
  id           Int       @id @default(autoincrement())
  userId       Int
  sceneId      String
  timestamp    DateTime  @default(now())

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchHistory WatchHistory? @relation(fields: [userId, sceneId], references: [userId, sceneId])

  @@index([userId])
  @@index([sceneId])
  @@index([timestamp])
  @@index([userId, timestamp])
}
```

**Migration Strategy:**
1. Create the new OEvent table
2. Write a data migration to move existing oHistory JSON arrays to the new table
3. Update all services that read/write oHistory to use the new table
4. Keep oHistory JSON for backward compatibility during migration period
5. Eventually deprecate and remove oHistory column

**Files to Change:**
- `server/prisma/schema.prisma` - Add OEvent model
- `server/controllers/watchHistory.ts` - Update increment-o endpoint
- `server/services/UserStatsService.ts` - Update O counter aggregation
- `server/services/SceneQueryBuilder.ts` - Update any O history queries

---

## Issue 4: O Counter UI Shows Stale Value After Playlist Navigation

**Severity:** MEDIUM - Confusing UX

**Symptoms:**
1. User increments O counter on Scene A (e.g., 0 → 1)
2. User navigates to next scene (Scene B) in playlist
3. Scene B shows O counter value of 1 (from Scene A) instead of Scene B's actual value
4. This persists as user navigates through playlist
5. If user goes back to Scene A and then navigates away again, it resets correctly

**Root Cause Analysis:**

The `NEXT_SCENE` and `PREV_SCENE` reducer actions do NOT reset `oCounter`, but `LOAD_SCENE_SUCCESS` **does** set it from the new scene's data at `client/src/contexts/scenePlayerReducer.js:108`:

```javascript
oCounter: action.payload.oCounter || 0,
```

The `useEffect` at `client/src/contexts/ScenePlayerContext.jsx:126-134` triggers `loadScene()` when `currentIndex` changes, which dispatches `LOAD_SCENE_SUCCESS`.

**Why the stale value persists:**

The issue is a **race condition** or **render timing issue**:
1. `NEXT_SCENE` dispatches → state updates with old `oCounter`
2. Component re-renders showing stale `oCounter`
3. `useEffect` fires (async) → `loadScene()` called
4. API request completes → `LOAD_SCENE_SUCCESS` dispatches with correct `oCounter`
5. Component re-renders with correct value

The user sees step 2 (stale) before step 5 (correct). If the API is slow or there's a render batching issue, the stale value is visible longer.

**Files to Fix:**
- `client/src/contexts/scenePlayerReducer.js` - Reset `oCounter` in navigation actions

**Recommended Fix:**
Reset `oCounter: 0` in `NEXT_SCENE` and `PREV_SCENE` cases. This provides immediate feedback that scene is changing, and `LOAD_SCENE_SUCCESS` will set the correct value once the API responds:

```javascript
// In NEXT_SCENE case (around line 244)
return {
  ...state,
  currentIndex: nextIndex,
  // ... existing resets
  oCounter: 0,  // ADD THIS - immediate reset
  // ...
};

// Same for PREV_SCENE case (around line 313)
```

---

## Summary Table

| # | Issue | Severity | Effort | Recommend Fix Before Release |
|---|-------|----------|--------|------------------------------|
| 1 | Detail page tabs not loading | HIGH | Medium | Yes |
| 2 | Tags query slow | MEDIUM | High | No (post-release) |
| 3 | O History JSON schema | LOW | High | No (post-release) |
| 4 | O Counter stale UI | MEDIUM | Low | Yes |

---

## Recommended Branch Strategy

1. **Branch: `bugfix/detail-page-tabs`** - Fix issue #1
2. **Branch: `bugfix/o-counter-stale-state`** - Fix issue #4
3. **Branch: `perf/tags-query-optimization`** - Fix issue #2 (post-release)
4. **Branch: `refactor/o-history-table`** - Fix issue #3 (post-release)
