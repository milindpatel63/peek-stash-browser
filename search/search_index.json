{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Peek Stash Browser","text":"<p>A modern web application for browsing and streaming your Stash media library with adaptive video streaming, playlists, and watch history tracking.</p> <ul> <li> Quick Start</li> </ul> <p>Get up and running in minutes with Docker or unRAID</p> <p> Installation</p> <ul> <li> Configuration</li> </ul> <p>Set up Peek to connect with your Stash server</p> <p> Setup Guide</p> <ul> <li> Troubleshooting</li> </ul> <p>Common issues and solutions</p> <p> Get Help</p>"},{"location":"#what-is-peek","title":"What is Peek?","text":"<p>Peek is a web-based browser for your Stash library, offering a sleek modern interface optimized for video streaming and playback.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Video Streaming - Proxied through Stash with quality selection (Direct, 1080p, 720p, 480p, 360p)</li> <li>Watch History Tracking - Automatic progress tracking and resume playback (Learn more)</li> <li>Playlist Management - Create, organize, and play custom playlists (Learn more)</li> <li>Modern Interface - Responsive React UI with theme support</li> <li>Full Keyboard Navigation - Complete TV remote and keyboard control support (Learn more)</li> <li>Mobile Ready - Optimized for all devices</li> <li>Scalable Library - SQLite-based storage supports 100k+ scenes</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"DockerunRAID <pre><code>docker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/stash/media:/app/media:ro \\\n  -v /path/to/peek/data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Open Community Applications</li> <li>Search for \"Peek Stash Browser\"</li> <li>Click Install and configure</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"#first-login","title":"First Login","text":"<p>On first access, you'll be guided through a setup wizard:</p> <ol> <li>Welcome - Introduction to Peek</li> <li>Create Admin - Set your admin username and password</li> <li>Connect to Stash - Enter your Stash URL and API key</li> <li>Complete - Setup finished!</li> </ol>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Stash server with GraphQL API enabled</li> <li>Docker (or unRAID)</li> <li>Network access between Peek and Stash</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Peek uses a single-container architecture:</p> <ul> <li>Frontend: React 19 app served by nginx</li> <li>Backend: Node.js/Express API server (proxied through nginx)</li> <li>Database: SQLite (embedded, no separate container)</li> <li>Streaming: Proxied through Stash (no local transcoding)</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Issues</li> <li>Stash Community: Discord - #third-party-integrations channel</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Built with Stash, React, Express, FFmpeg, and other amazing open source projects.</p>"},{"location":"design/cache-scalability-brainstorm/","title":"Cache Scalability Brainstorm","text":"<p>Issues: #135, #160 Branch: <code>feature/cache-scalability-investigation</code> Date: 2025-12-08</p>"},{"location":"design/cache-scalability-brainstorm/#problem-statement","title":"Problem Statement","text":"<p>Peek's cache initialization fails on large Stash libraries: - Issue #135: 24k scenes - GraphQL 422 error on groups fetch with <code>per_page: -1</code> - Issue #160: 104k scenes - Node.js <code>ERR_STRING_TOO_LONG</code> (~512MB string limit exceeded)</p> <p>Both issues stem from the same root cause: unbounded GraphQL queries that don't scale.</p>"},{"location":"design/cache-scalability-brainstorm/#current-architecture","title":"Current Architecture","text":""},{"location":"design/cache-scalability-brainstorm/#data-flow","title":"Data Flow","text":"<pre><code>Stash Server (source of truth)\n    \u2502\n    \u25bc per_page: -1 (fetch ALL)\nStashCacheManager (in-memory Maps)\n    \u2502\n    \u251c\u2500\u2500\u25ba FilteredEntityCacheService (per-user filtered views)\n    \u2502\n    \u2514\u2500\u2500\u25ba 18+ files (controllers, services, middleware)\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#why-the-cache-exists","title":"Why the Cache Exists","text":"<ol> <li>Performance: Avoid repeated GraphQL queries for browsing/filtering</li> <li>URL Transformation: Rewrite Stash URLs to Peek proxy URLs (hide API keys)</li> <li>User Restrictions: Cascade filtering (hidden performers \u2192 hidden scenes)</li> <li>Aggregations: \"Most watched performer\", \"Top tags by play count\"</li> <li>Multi-user Support: Different users see different filtered content</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#current-memory-estimates","title":"Current Memory Estimates","text":"<ul> <li>~3KB per scene (with nested performers, tags, studio, files, paths)</li> <li>~1KB per performer/tag/studio</li> <li>100k scenes \u2248 300MB just for scenes</li> <li>Total with galleries, groups, etc. \u2248 400-500MB for large libraries</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#the-scaling-wall","title":"The Scaling Wall","text":"Scenes Approximate JSON Size Status 10,000 ~30MB Works fine 25,000 ~75MB Works, slow startup 50,000 ~150MB Edge case, may fail 100,000 ~300MB Hits string limit, fails"},{"location":"design/cache-scalability-brainstorm/#questions-for-discussion","title":"Questions for Discussion","text":""},{"location":"design/cache-scalability-brainstorm/#q1-what-filtering-patterns-does-peek-actually-need","title":"Q1: What filtering patterns does Peek actually need?","text":"<p>Current usage patterns I observed: - Carousel: Random scenes, filtered by user restrictions - Browse: Paginated lists with sorting - Search: Text search across titles/performers - Stats: Aggregations like \"top performers by watch time\"</p> <p>Question: Are there filtering patterns that require all data in memory? Or could most be satisfied with paginated queries to Stash?</p>"},{"location":"design/cache-scalability-brainstorm/#q2-whats-the-acceptable-trade-off-between-memory-and-features","title":"Q2: What's the acceptable trade-off between memory and features?","text":"<p>Options range from: - Current: Everything in memory (fast, feature-rich, doesn't scale) - Hybrid: Metadata in memory, paginated queries for large result sets - Pass-through: Cache only IDs, query Stash for everything (slow, scales infinitely)</p> <p>Question: Which features would you sacrifice for scalability? Or is there a budget for more complex caching?</p>"},{"location":"design/cache-scalability-brainstorm/#q3-should-peek-own-its-own-entity-database","title":"Q3: Should Peek own its own entity database?","text":"<p>Currently Peek stores: - User data (watch history, ratings, favorites) - Path mappings, settings</p> <p>It does NOT store Stash entities (scenes, performers, etc.) - only caches them.</p> <p>Question: Would you consider syncing Stash entities to SQLite? This enables: - Pagination at the database level - SQL filtering/sorting - Survives restarts without re-fetching - Incremental updates via Stash webhooks</p> <p>Trade-off: Adds complexity, data duplication, sync challenges</p>"},{"location":"design/cache-scalability-brainstorm/#q4-whats-the-deployment-model-priority","title":"Q4: What's the deployment model priority?","text":"<p>Current: Docker-only (FFmpeg dependency)</p> <p>Future goal mentioned: Native binaries for Windows/Unix</p> <p>Question: Does the caching solution need to support both? SQLite works everywhere. Redis would complicate native deployment.</p>"},{"location":"design/cache-scalability-brainstorm/#solution-space","title":"Solution Space","text":""},{"location":"design/cache-scalability-brainstorm/#approach-a-paginated-fetching-minimal-change","title":"Approach A: Paginated Fetching (Minimal Change)","text":"<p>Idea: Keep current architecture, but fetch in pages to avoid string limit.</p> <pre><code>async function fetchAllScenes(): Promise&lt;Scene[]&gt; {\n  const PAGE_SIZE = 5000;\n  const allScenes: Scene[] = [];\n  let page = 1;\n\n  while (true) {\n    const result = await stash.findScenesCompact({\n      filter: { page, per_page: PAGE_SIZE }\n    });\n    allScenes.push(...result.findScenes.scenes);\n    if (allScenes.length &gt;= result.findScenes.count) break;\n    page++;\n  }\n  return allScenes;\n}\n</code></pre> <p>Pros: - Minimal code changes - Fixes the immediate crash - No architecture change</p> <p>Cons: - Still loads everything into memory - Memory still grows linearly with library size - 104k scenes still needs ~300MB RAM for scenes alone</p> <p>Verdict: Quick fix, not a real solution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-b-sqlite-entity-cache-full-sync","title":"Approach B: SQLite Entity Cache (Full Sync)","text":"<p>Idea: Sync Stash entities to local SQLite database. Query database instead of in-memory Maps.</p> <pre><code>Stash Server\n    \u2502\n    \u25bc Paginated sync\nSQLite Database (scenes, performers, studios, tags, galleries, groups)\n    \u2502\n    \u25bc Prisma queries\nControllers/Services\n</code></pre> <p>Schema additions: <pre><code>model CachedScene {\n  id          String @id\n  title       String?\n  date        String?\n  studioId    String?\n  rating100   Int?\n  duration    Int?\n  // ... minimal fields for filtering/sorting\n  rawData     String // JSON blob for full data\n  lastSynced  DateTime\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n}\n</code></pre></p> <p>Sync Strategy: - Initial: Paginated full sync (5000 at a time) - Refresh: Incremental via <code>updated_at &gt; lastSync</code> filter - Stash webhooks: Real-time updates (optional enhancement)</p> <p>Query Strategy: - Browse: SQL pagination with sorting - Filter: SQL WHERE clauses - Full data: Fetch <code>rawData</code> JSON and deserialize</p> <p>Pros: - Unlimited scalability (SQLite handles millions of rows) - Fast SQL queries with indexes - Survives restarts - Incremental sync possible - Works for native binaries</p> <p>Cons: - Significant refactor - Data duplication (Stash + Peek) - Sync complexity (what if entities deleted in Stash?) - Need to handle schema evolution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-c-hybrid-cache-metadata-in-memory-full-data-lazy-loaded","title":"Approach C: Hybrid Cache (Metadata in Memory, Full Data Lazy-Loaded)","text":"<p>Idea: Store minimal metadata in memory, fetch full data on-demand.</p> <pre><code>interface SceneMetadata {\n  id: string;\n  title: string;\n  date: string;\n  studioId: string;\n  performerIds: string[];\n  tagIds: string[];\n  rating100: number;\n  // No nested objects, no files, no paths\n}\n\n// In-memory: ~500 bytes per scene instead of ~3KB\nconst sceneMetadata = new Map&lt;string, SceneMetadata&gt;();\n\n// On-demand fetch for full data\nasync function getFullScene(id: string): Promise&lt;NormalizedScene&gt; {\n  const meta = sceneMetadata.get(id);\n  if (!meta) return null;\n\n  // Fetch full data from Stash (or a local cache)\n  const full = await stash.findScenes({ ids: [id] });\n  return transformScene(full.findScenes.scenes[0]);\n}\n</code></pre> <p>Pros: - 80% memory reduction - Most filtering works on metadata - Preserves current architecture patterns</p> <p>Cons: - Increases latency for full scene views - Complex to implement correctly - Still linear memory growth (just slower)</p>"},{"location":"design/cache-scalability-brainstorm/#approach-d-pass-through-to-stash-no-cache","title":"Approach D: Pass-through to Stash (No Cache)","text":"<p>Idea: Remove the cache entirely. Proxy all queries to Stash.</p> <p>Pros: - Simplest architecture - No sync issues - Stash handles all scalability</p> <p>Cons: - Loses user restrictions (can't filter without seeing all data) - Every request hits Stash (slower) - Can't aggregate stats across scenes - URL transformation happens on every request</p> <p>Verdict: Not viable - loses too many features</p>"},{"location":"design/cache-scalability-brainstorm/#approach-e-external-cache-redismemcached","title":"Approach E: External Cache (Redis/Memcached)","text":"<p>Idea: Use Redis for distributed caching.</p> <p>Pros: - Battle-tested scalability - Shared across instances - LRU eviction built-in</p> <p>Cons: - New dependency (complicates native deployment) - Overkill for single-user instances - Still need to handle large data serialization</p> <p>Verdict: Only makes sense for multi-node deployment, not the typical use case</p>"},{"location":"design/cache-scalability-brainstorm/#what-large-enterprise-apps-do","title":"What Large Enterprise Apps Do","text":""},{"location":"design/cache-scalability-brainstorm/#pattern-1-database-as-cache","title":"Pattern 1: Database as Cache","text":"<ul> <li>Example: Elasticsearch for search, PostgreSQL for source of truth</li> <li>Relevance: SQLite could serve as Peek's \"search index\"</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-2-materialized-views","title":"Pattern 2: Materialized Views","text":"<ul> <li>Example: Pre-computed aggregations stored separately</li> <li>Relevance: Peek's FilteredEntityCacheService is already doing this per-user</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-3-incremental-sync","title":"Pattern 3: Incremental Sync","text":"<ul> <li>Example: CDC (Change Data Capture), webhooks</li> <li>Relevance: Stash has a GraphQL subscription API for real-time updates</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-4-tiered-caching","title":"Pattern 4: Tiered Caching","text":"<ul> <li>Example: L1 (in-memory, small, hot), L2 (disk, large, warm), L3 (remote, cold)</li> <li>Relevance: Memory \u2192 SQLite \u2192 Stash API</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-5-pagination-cursor-based-navigation","title":"Pattern 5: Pagination + Cursor-based Navigation","text":"<ul> <li>Example: GraphQL connections with <code>after</code> cursor</li> <li>Relevance: Stash supports this, Peek could adopt it</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#recommendation-questions","title":"Recommendation Questions","text":"<p>Before I recommend a specific approach, I need clarity on:</p> <ol> <li>Scope of refactor acceptable?</li> <li> <p>Quick fix (paginated fetch) vs. medium (hybrid) vs. large (SQLite sync)</p> </li> <li> <p>Feature preservation priority?</p> </li> <li>User restrictions cascade filtering</li> <li>Cross-scene aggregations (stats)</li> <li> <p>Fast browsing/search</p> </li> <li> <p>Stash API capabilities?</p> </li> <li>Does Stash support filtering by <code>updated_at</code>? (for incremental sync)</li> <li> <p>Does Stash have webhook support? (for real-time sync)</p> </li> <li> <p>Testing strategy?</p> </li> <li>Do we have access to a 100k+ scene library for testing?</li> <li>Can we simulate with synthetic data?</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#decision-sqlite-entity-cache","title":"Decision: SQLite Entity Cache","text":"<p>After discussion, we've decided on Approach B: SQLite Entity Cache for the following reasons:</p>"},{"location":"design/cache-scalability-brainstorm/#why-sqlite","title":"Why SQLite?","text":"<ol> <li> <p>The pagination + filtering problem: If we paginate from Stash then apply user restrictions, we get fewer results than requested (e.g., request 50, restrictions remove 10, return 40). This breaks pagination. We need the full dataset locally.</p> </li> <li> <p>Memory doesn't scale: Current in-memory approach fails at ~50-100k scenes due to Node.js string limits and memory pressure.</p> </li> <li> <p>Minimal duplication: ~50-100MB for 100k scenes (vs 500MB+ in Stash). We store only what Peek needs.</p> </li> <li> <p>Offline resilience: Peek can serve browse requests even if Stash is temporarily unavailable.</p> </li> <li> <p>Native binary compatible: SQLite works everywhere - no Redis/external dependencies.</p> </li> </ol>"},{"location":"design/cache-scalability-brainstorm/#sync-strategy","title":"Sync Strategy","text":"<p>Sync Triggers: | Trigger | Type | When | |---------|------|------| | Startup | Full/Incremental | Peek server starts (full if first run) | | Scan complete | Incremental | Stash finishes scan (via WebSocket subscription) | | Polling | Incremental | Every N minutes (configurable, default 60, range 5-120) | | Manual | Full/Incremental | Admin triggers via UI | | Plugin webhook | Incremental | Optional - if Stash plugin installed |</p> <p>Sync Types: - Incremental: Query entities where <code>updated_at &gt; lastSyncTime</code>, upsert changes - Full: Paginated fetch of everything, used on first run or recovery</p> <p>Optional Real-Time Enhancement: A simple Stash plugin can POST to Peek on entity changes, enabling near real-time sync. This is optional - polling works without it, plugin makes it faster.</p>"},{"location":"design/cache-scalability-brainstorm/#entity-handling","title":"Entity Handling","text":"<ul> <li>Soft delete: Mark entities as deleted rather than hard-deleting</li> <li>Preserves Peek-specific data (watch history, ratings) if entity is re-added</li> <li>Allows user to see \"X scenes were removed from Stash\"</li> <li>Orphan detection: Periodic check for entities in Peek but not in Stash</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#key-features-to-preserve","title":"Key Features to Preserve","text":"<ul> <li>\u2705 User restrictions (cascade filtering)</li> <li>\u2705 Stats/aggregations (computed from local DB)</li> <li>\u2705 Fast browsing (SQL pagination with indexes)</li> <li>\u26a0\ufe0f Offline resilience (partial - can browse cached data)</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#next-steps","title":"Next Steps","text":"<ol> <li>Design the SQLite schema for cached entities</li> <li>Create migration strategy from in-memory to SQLite</li> <li>Implement incremental sync logic</li> <li>Add scanCompleteSubscribe WebSocket listener</li> <li>Update all 18+ dependent files to query SQLite instead of Maps</li> <li>Test with synthetic 100k+ scene dataset</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#appendix-memory-calculation-details","title":"Appendix: Memory Calculation Details","text":""},{"location":"design/cache-scalability-brainstorm/#current-scene-object-size","title":"Current Scene Object Size","text":"<pre><code>{\n  id: \"12345\",                    // 5 bytes\n  title: \"Example Scene Title\",   // ~30 bytes\n  date: \"2024-01-15\",            // 10 bytes\n  // ... base fields ~500 bytes\n\n  performers: [                   // ~200 bytes each\n    { id, name, image_path, gender, tags: [...] }\n  ],\n  tags: [                         // ~50 bytes each\n    { id, name, image_path, favorite }\n  ],\n  studio: { id, name, tags: [...] },  // ~150 bytes\n  files: [{                       // ~300 bytes each\n    path, basename, duration, video_codec, audio_codec, ...\n  }],\n  paths: {                        // ~400 bytes\n    preview, screenshot, sprite, vtt, webp, caption\n  },\n  sceneStreams: [...]            // ~150 bytes\n}\n\n// Total: ~2-4KB per scene depending on performers/tags\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#memory-projection-table","title":"Memory Projection Table","text":"Scenes Minimal (500B) Current (~3KB) With Galleries 10,000 5 MB 30 MB 40 MB 50,000 25 MB 150 MB 200 MB 100,000 50 MB 300 MB 400 MB 250,000 125 MB 750 MB 1 GB"},{"location":"design/cache-scalability-plan/","title":"SQLite Entity Cache Implementation Plan","text":"<p>Issue: #135, #160 - Cache fails on large libraries (24k-104k scenes) Design Docs: cache-scalability-brainstorm.md, sqlite-cache-schema.md Branch: <code>feature/cache-scalability-investigation</code></p>"},{"location":"design/cache-scalability-plan/#overview","title":"Overview","text":"<p>Replace the in-memory <code>StashCacheManager</code> with a SQLite-backed entity cache that: - Syncs Stash entities to local database using paginated fetches - Queries via Prisma instead of in-memory Maps - Supports incremental sync via <code>updated_at</code> timestamps - Scales to 100k+ scenes without memory issues</p>"},{"location":"design/cache-scalability-plan/#phase-1-database-schema","title":"Phase 1: Database Schema","text":""},{"location":"design/cache-scalability-plan/#task-11-add-cached-entity-tables-to-prisma-schema","title":"Task 1.1: Add Cached Entity Tables to Prisma Schema","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Add the following models after existing models:</p> <pre><code>// ============================================================================\n// CACHED STASH ENTITIES\n// These tables store synced data from Stash for scalable querying\n// ============================================================================\n\nmodel CachedScene {\n  id              String    @id                    // Stash scene ID\n  stashInstanceId String?                          // Which Stash server\n\n  // Indexed fields for filtering/sorting\n  title           String?\n  code            String?\n  date            String?                          // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                             // seconds (from file)\n  organized       Boolean   @default(false)\n\n  // Full entity data as JSON (performers, tags, files, paths, streams, etc.)\n  data            String                           // JSON blob\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?                        // Soft delete\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n\nmodel CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneTag[]\n  images          ImageTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGroup {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  date            String?\n  studioId        String?\n  rating100       Int?\n  duration        Int?\n  sceneCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGallery {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGallery[]\n  images          ImageGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedImage {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  oCounter        Int       @default(0)\n  organized       Boolean   @default(false)\n  width           Int?\n  height          Int?\n  fileSize        Int?\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  performers      ImagePerformer[]\n  tags            ImageTag[]\n  galleries       ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\n// Junction tables for efficient many-to-many queries\n\nmodel ScenePerformer {\n  sceneId         String\n  performerId     String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])\n}\n\nmodel SceneTag {\n  sceneId         String\n  tagId           String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])\n}\n\nmodel SceneGroup {\n  sceneId         String\n  groupId         String\n  sceneIndex      Int?\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group           CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId         String\n  galleryId       String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n\nmodel ImagePerformer {\n  imageId         String\n  performerId     String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId         String\n  tagId           String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId         String\n  galleryId       String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n\n// Sync state tracking per entity type\nmodel SyncState {\n  id                    Int       @id @default(autoincrement())\n  stashInstanceId       String?\n  entityType            String                     // 'scene', 'performer', etc.\n\n  lastFullSync          DateTime?\n  lastIncrementalSync   DateTime?\n  lastSyncCount         Int       @default(0)\n  lastSyncDurationMs    Int?\n  lastError             String?\n  totalEntities         Int       @default(0)\n\n  @@unique([stashInstanceId, entityType])\n}\n\n// Sync settings (admin configurable)\nmodel SyncSettings {\n  id                    Int       @id @default(1)  // Singleton\n  syncIntervalMinutes   Int       @default(60)     // Default 60 min (current behavior)\n  enableScanSubscription Boolean  @default(true)   // Subscribe to scanCompleteSubscribe\n  enablePluginWebhook   Boolean   @default(false)  // Accept webhook from Stash plugin\n\n  updatedAt             DateTime  @updatedAt\n}\n</code></pre> <p>Verification: Run <code>npx prisma validate</code> to ensure schema is valid.</p>"},{"location":"design/cache-scalability-plan/#task-12-create-prisma-migration","title":"Task 1.2: Create Prisma Migration","text":"<p>Commands: <pre><code>cd server\nnpx prisma migrate dev --name add_cached_entities\n</code></pre></p> <p>This creates the migration file and applies it to the development database.</p> <p>Verification: Check that <code>server/prisma/migrations/*_add_cached_entities/migration.sql</code> exists.</p>"},{"location":"design/cache-scalability-plan/#task-13-add-fts5-full-text-search-via-raw-sql-migration","title":"Task 1.3: Add FTS5 Full-Text Search via Raw SQL Migration","text":"<p>File: Create <code>server/prisma/migrations/YYYYMMDDHHMMSS_add_fts5_search/migration.sql</code> manually</p> <pre><code>-- Create FTS5 virtual tables for full-text search\n-- Note: These are created via raw SQL because Prisma doesn't support virtual tables\n\nCREATE VIRTUAL TABLE IF NOT EXISTS scene_fts USING fts5(\n  id UNINDEXED,\n  title,\n  details,\n  code\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS performer_fts USING fts5(\n  id UNINDEXED,\n  name,\n  aliases\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS studio_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS tag_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\n-- Triggers to keep FTS in sync with main tables\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_insert AFTER INSERT ON CachedPerformer BEGIN\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_update AFTER UPDATE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_delete AFTER DELETE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_insert AFTER INSERT ON CachedStudio BEGIN\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_update AFTER UPDATE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_delete AFTER DELETE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_insert AFTER INSERT ON CachedTag BEGIN\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_update AFTER UPDATE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_delete AFTER DELETE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\nEND;\n</code></pre> <p>Verification: Run <code>npx prisma migrate deploy</code> and verify FTS tables exist in database.</p>"},{"location":"design/cache-scalability-plan/#phase-2-sync-service","title":"Phase 2: Sync Service","text":""},{"location":"design/cache-scalability-plan/#task-21-create-stashsyncservice","title":"Task 2.1: Create StashSyncService","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>This service handles all sync operations between Stash and the local SQLite cache.</p> <p>Key responsibilities: 1. Full sync: Paginated fetch of all entities (5000 per batch) 2. Incremental sync: Fetch only entities where <code>updated_at &gt; lastSyncTime</code> 3. Deletion detection: Mark entities as deleted if not in Stash response 4. Junction table management: Keep scene\u2194performer, scene\u2194tag, etc. in sync 5. Progress reporting: Emit events for UI progress display</p> <p>Implementation outline:</p> <pre><code>// server/services/StashSyncService.ts\n\nimport { PrismaClient } from '@prisma/client';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { transformScene, transformPerformer, /* etc */ } from '../utils/pathMapping.js';\nimport { logger } from '../utils/logger.js';\nimport { EventEmitter } from 'events';\n\ninterface SyncProgress {\n  entityType: string;\n  phase: 'fetching' | 'processing' | 'complete' | 'error';\n  current: number;\n  total: number;\n  message?: string;\n}\n\nclass StashSyncService extends EventEmitter {\n  private prisma: PrismaClient;\n  private syncInProgress = false;\n  private readonly PAGE_SIZE = 5000;\n\n  constructor(prisma: PrismaClient) {\n    super();\n    this.prisma = prisma;\n  }\n\n  /**\n   * Full sync - fetches all entities from Stash\n   * Used on first run or when incremental sync fails\n   */\n  async fullSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      // Sync each entity type in order (dependencies first)\n      await this.syncStudios(stashInstanceId, true);\n      await this.syncTags(stashInstanceId, true);\n      await this.syncPerformers(stashInstanceId, true);\n      await this.syncGroups(stashInstanceId, true);\n      await this.syncGalleries(stashInstanceId, true);\n      await this.syncScenes(stashInstanceId, true);\n      await this.syncImages(stashInstanceId, true);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'full', Date.now() - startTime);\n\n      logger.info('Full sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Incremental sync - fetches only changed entities\n   */\n  async incrementalSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      logger.warn('Sync already in progress, skipping');\n      return;\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      const lastSync = await this.getLastSyncTime(stashInstanceId);\n\n      if (!lastSync) {\n        logger.info('No previous sync found, performing full sync');\n        await this.fullSync(stashInstanceId);\n        return;\n      }\n\n      // Sync each entity type (only changed)\n      await this.syncStudios(stashInstanceId, false, lastSync);\n      await this.syncTags(stashInstanceId, false, lastSync);\n      await this.syncPerformers(stashInstanceId, false, lastSync);\n      await this.syncGroups(stashInstanceId, false, lastSync);\n      await this.syncGalleries(stashInstanceId, false, lastSync);\n      await this.syncScenes(stashInstanceId, false, lastSync);\n      await this.syncImages(stashInstanceId, false, lastSync);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'incremental', Date.now() - startTime);\n\n      logger.info('Incremental sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Sync scenes with pagination\n   */\n  private async syncScenes(\n    stashInstanceId: string | undefined,\n    isFullSync: boolean,\n    lastSyncTime?: Date\n  ): Promise&lt;void&gt; {\n    const stash = stashInstanceManager.getDefault();\n    let page = 1;\n    let totalSynced = 0;\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'fetching',\n      current: 0,\n      total: 0,\n    } as SyncProgress);\n\n    while (true) {\n      // Build filter for incremental sync\n      const filter = lastSyncTime ? {\n        updated_at: { modifier: 'GREATER_THAN', value: lastSyncTime.toISOString() }\n      } : undefined;\n\n      const result = await stash.findScenesCompact({\n        filter: { page, per_page: this.PAGE_SIZE },\n        scene_filter: filter,\n      });\n\n      const scenes = result.findScenes.scenes;\n      const total = result.findScenes.count;\n\n      if (scenes.length === 0) break;\n\n      // Process batch\n      await this.processScenessBatch(scenes, stashInstanceId);\n\n      totalSynced += scenes.length;\n      this.emit('progress', {\n        entityType: 'scene',\n        phase: 'processing',\n        current: totalSynced,\n        total,\n      } as SyncProgress);\n\n      if (totalSynced &gt;= total) break;\n      page++;\n    }\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'complete',\n      current: totalSynced,\n      total: totalSynced,\n    } as SyncProgress);\n  }\n\n  /**\n   * Process a batch of scenes - upsert to database\n   */\n  private async processScenessBatch(scenes: any[], stashInstanceId?: string): Promise&lt;void&gt; {\n    for (const scene of scenes) {\n      const transformed = transformScene(scene);\n      const duration = scene.files?.[0]?.duration || null;\n\n      // Upsert scene\n      await this.prisma.cachedScene.upsert({\n        where: { id: scene.id },\n        update: {\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n          syncedAt: new Date(),\n          deletedAt: null, // Clear soft delete if re-synced\n        },\n        create: {\n          id: scene.id,\n          stashInstanceId,\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n        },\n      });\n\n      // Sync junction tables\n      await this.syncScenePerformers(scene.id, scene.performers || []);\n      await this.syncSceneTags(scene.id, scene.tags || []);\n      await this.syncSceneGroups(scene.id, scene.groups || []);\n      await this.syncSceneGalleries(scene.id, scene.galleries || []);\n    }\n  }\n\n  // Similar methods for other entity types...\n  // syncPerformers, syncStudios, syncTags, syncGroups, syncGalleries, syncImages\n\n  /**\n   * Sync scene\u2194performer junction table\n   */\n  private async syncScenePerformers(sceneId: string, performers: any[]): Promise&lt;void&gt; {\n    // Delete existing relationships\n    await this.prisma.scenePerformer.deleteMany({ where: { sceneId } });\n\n    // Insert new relationships\n    if (performers.length &gt; 0) {\n      await this.prisma.scenePerformer.createMany({\n        data: performers.map(p =&gt; ({ sceneId, performerId: p.id })),\n        skipDuplicates: true,\n      });\n    }\n  }\n\n  // Helper methods...\n}\n\nexport const stashSyncService = new StashSyncService(prisma);\n</code></pre> <p>Verification: Write unit tests for sync logic. Test with mock data.</p>"},{"location":"design/cache-scalability-plan/#task-22-create-sync-scheduler","title":"Task 2.2: Create Sync Scheduler","text":"<p>File: <code>server/services/SyncScheduler.ts</code></p> <p>Handles automatic sync triggers: - Startup sync - Polling interval (configurable, default 60 min) - Stash scan completion (WebSocket subscription) - Manual trigger</p> <p>Implementation outline:</p> <pre><code>// server/services/SyncScheduler.ts\n\nimport { stashSyncService } from './StashSyncService.js';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { logger } from '../utils/logger.js';\nimport prisma from '../prisma/singleton.js';\n\nclass SyncScheduler {\n  private intervalId: NodeJS.Timeout | null = null;\n  private wsConnection: WebSocket | null = null;\n\n  async start(): Promise&lt;void&gt; {\n    // Load settings\n    const settings = await prisma.syncSettings.findFirst() || {\n      syncIntervalMinutes: 60,\n      enableScanSubscription: true,\n    };\n\n    // Start polling interval\n    this.startPollingInterval(settings.syncIntervalMinutes);\n\n    // Start WebSocket subscription for scan events\n    if (settings.enableScanSubscription) {\n      this.startScanSubscription();\n    }\n\n    // Perform initial sync\n    await this.performStartupSync();\n  }\n\n  private startPollingInterval(intervalMinutes: number): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n\n    const intervalMs = intervalMinutes * 60 * 1000;\n\n    this.intervalId = setInterval(async () =&gt; {\n      logger.info('Scheduled sync triggered');\n      try {\n        await stashSyncService.incrementalSync();\n      } catch (error) {\n        logger.error('Scheduled sync failed', { error });\n      }\n    }, intervalMs);\n\n    logger.info(`Sync scheduler started (interval: ${intervalMinutes} min)`);\n  }\n\n  private startScanSubscription(): void {\n    // Connect to Stash GraphQL WebSocket for scanCompleteSubscribe\n    // Implementation depends on graphql-ws or similar library\n    // When scan completes, trigger incrementalSync()\n  }\n\n  private async performStartupSync(): Promise&lt;void&gt; {\n    const syncState = await prisma.syncState.findFirst({\n      where: { entityType: 'scene' },\n    });\n\n    if (!syncState?.lastFullSync) {\n      logger.info('No previous sync found, performing full sync on startup');\n      await stashSyncService.fullSync();\n    } else {\n      logger.info('Performing incremental sync on startup');\n      await stashSyncService.incrementalSync();\n    }\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    if (this.wsConnection) {\n      this.wsConnection.close();\n      this.wsConnection = null;\n    }\n  }\n}\n\nexport const syncScheduler = new SyncScheduler();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-23-add-webhook-endpoint-for-optional-stash-plugin","title":"Task 2.3: Add Webhook Endpoint for Optional Stash Plugin","text":"<p>File: <code>server/routes/sync.ts</code></p> <pre><code>// POST /api/sync/notify - Webhook from Stash plugin\nrouter.post('/notify', requireAdmin, async (req, res) =&gt; {\n  const { entity, id, action } = req.body;\n\n  // Validate request\n  if (!entity || !id || !action) {\n    return res.status(400).json({ error: 'Missing required fields' });\n  }\n\n  // Queue single entity sync\n  await stashSyncService.syncSingleEntity(entity, id, action);\n\n  res.json({ ok: true });\n});\n\n// POST /api/sync/trigger - Manual sync trigger\nrouter.post('/trigger', requireAdmin, async (req, res) =&gt; {\n  const { type = 'incremental' } = req.body;\n\n  if (type === 'full') {\n    await stashSyncService.fullSync();\n  } else {\n    await stashSyncService.incrementalSync();\n  }\n\n  res.json({ ok: true });\n});\n\n// GET /api/sync/status - Get sync status\nrouter.get('/status', requireAuth, async (req, res) =&gt; {\n  const states = await prisma.syncState.findMany();\n  const settings = await prisma.syncSettings.findFirst();\n\n  res.json({ states, settings });\n});\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-3-query-service","title":"Phase 3: Query Service","text":""},{"location":"design/cache-scalability-plan/#task-31-create-cachedentityqueryservice","title":"Task 3.1: Create CachedEntityQueryService","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>This service replaces direct <code>stashCacheManager</code> calls with Prisma queries.</p> <p>Key methods:</p> <pre><code>class CachedEntityQueryService {\n  /**\n   * Get all scenes with filtering, sorting, pagination\n   */\n  async getScenes(options: {\n    userId: number;\n    filters?: SceneFilters;\n    sort?: string;\n    direction?: 'asc' | 'desc';\n    limit?: number;\n    offset?: number;\n  }): Promise&lt;{ scenes: NormalizedScene[]; total: number }&gt; {\n    // Build Prisma where clause from filters\n    // Apply user restrictions (hidden entities, content restrictions)\n    // Execute query with pagination\n    // Parse JSON data field\n    // Merge with user ratings/watch history\n    // Return results\n  }\n\n  /**\n   * Get single scene by ID\n   */\n  async getScene(id: string, userId: number): Promise&lt;NormalizedScene | null&gt; {\n    const cached = await prisma.cachedScene.findFirst({\n      where: { id, deletedAt: null },\n    });\n\n    if (!cached) return null;\n\n    const data = JSON.parse(cached.data);\n    // Merge with user data\n    return this.mergeSceneWithUserData(data, userId);\n  }\n\n  /**\n   * Full-text search across scenes\n   */\n  async searchScenes(query: string, userId: number, limit = 50): Promise&lt;NormalizedScene[]&gt; {\n    // Use FTS5 for search\n    const results = await prisma.$queryRaw`\n      SELECT s.id, s.data\n      FROM scene_fts\n      INNER JOIN CachedScene s ON scene_fts.id = s.id\n      WHERE scene_fts MATCH ${query}\n        AND s.deletedAt IS NULL\n      ORDER BY rank\n      LIMIT ${limit}\n    `;\n\n    // Filter by user restrictions\n    // Merge with user data\n    return results;\n  }\n\n  // Similar methods for performers, studios, tags, groups, galleries, images\n}\n\nexport const cachedEntityQueryService = new CachedEntityQueryService();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-32-create-query-builders-for-complex-filters","title":"Task 3.2: Create Query Builders for Complex Filters","text":"<p>File: <code>server/utils/queryBuilders.ts</code></p> <p>Helper functions to build Prisma <code>where</code> clauses from UI filter objects:</p> <pre><code>/**\n * Build Prisma where clause for scene filters\n */\nexport function buildSceneWhereClause(\n  filters: PeekSceneFilter,\n  userId: number,\n  hiddenEntityIds: { scenes: string[]; performers: string[]; studios: string[]; tags: string[] }\n): Prisma.CachedSceneWhereInput {\n  const where: Prisma.CachedSceneWhereInput = {\n    deletedAt: null,\n    id: { notIn: hiddenEntityIds.scenes },\n  };\n\n  // Studio filter\n  if (filters.studioIds?.length) {\n    where.studioId = { in: filters.studioIds };\n  }\n\n  // Hidden studios\n  if (hiddenEntityIds.studios.length) {\n    where.studioId = {\n      ...where.studioId,\n      notIn: hiddenEntityIds.studios,\n    };\n  }\n\n  // Date range\n  if (filters.dateFrom || filters.dateTo) {\n    where.date = {};\n    if (filters.dateFrom) where.date.gte = filters.dateFrom;\n    if (filters.dateTo) where.date.lte = filters.dateTo;\n  }\n\n  // Rating filter\n  if (filters.minRating !== undefined) {\n    where.rating100 = { gte: filters.minRating };\n  }\n\n  // Performer filter (requires subquery)\n  if (filters.performerIds?.length) {\n    where.performers = {\n      some: { performerId: { in: filters.performerIds } },\n    };\n  }\n\n  // Tag filter\n  if (filters.tagIds?.length) {\n    where.tags = {\n      some: { tagId: { in: filters.tagIds } },\n    };\n  }\n\n  // Exclude hidden performers (cascade)\n  if (hiddenEntityIds.performers.length) {\n    where.performers = {\n      ...where.performers,\n      none: { performerId: { in: hiddenEntityIds.performers } },\n    };\n  }\n\n  return where;\n}\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-4-controller-migration","title":"Phase 4: Controller Migration","text":""},{"location":"design/cache-scalability-plan/#task-41-update-scene-controllers","title":"Task 4.1: Update Scene Controllers","text":"<p>Files to modify: - <code>server/controllers/library/scenes.ts</code> - <code>server/controllers/carousel.ts</code></p> <p>Replace <code>stashCacheManager.getAllScenes()</code> with <code>cachedEntityQueryService.getScenes()</code>.</p> <p>Before: <pre><code>const allScenes = stashCacheManager.getAllScenes();\nlet filtered = allScenes.filter(/* ... */);\nfiltered.sort(/* ... */);\nconst paginated = filtered.slice(offset, offset + limit);\n</code></pre></p> <p>After: <pre><code>const { scenes, total } = await cachedEntityQueryService.getScenes({\n  userId,\n  filters,\n  sort,\n  direction,\n  limit,\n  offset,\n});\n</code></pre></p>"},{"location":"design/cache-scalability-plan/#task-42-update-performer-controllers","title":"Task 4.2: Update Performer Controllers","text":"<p>File: <code>server/controllers/library/performers.ts</code></p> <p>Same pattern as scenes. Replace in-memory filtering with database queries.</p>"},{"location":"design/cache-scalability-plan/#task-43-update-studio-controllers","title":"Task 4.3: Update Studio Controllers","text":"<p>File: <code>server/controllers/library/studios.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-44-update-tag-controllers","title":"Task 4.4: Update Tag Controllers","text":"<p>File: <code>server/controllers/library/tags.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-45-update-group-controllers","title":"Task 4.5: Update Group Controllers","text":"<p>File: <code>server/controllers/library/groups.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-46-update-gallery-controllers","title":"Task 4.6: Update Gallery Controllers","text":"<p>File: <code>server/controllers/library/galleries.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-47-update-image-controllers","title":"Task 4.7: Update Image Controllers","text":"<p>File: <code>server/controllers/library/images.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-48-update-stats-controller","title":"Task 4.8: Update Stats Controller","text":"<p>File: <code>server/controllers/stats.ts</code></p> <p>Aggregations like \"top performers\" use SQL GROUP BY instead of in-memory loops.</p>"},{"location":"design/cache-scalability-plan/#task-49-update-user-services","title":"Task 4.9: Update User Services","text":"<p>Files: - <code>server/services/UserHiddenEntityService.ts</code> - <code>server/services/UserStatsService.ts</code></p> <p>These now query SQLite instead of in-memory cache.</p>"},{"location":"design/cache-scalability-plan/#task-410-update-auth-middleware","title":"Task 4.10: Update Auth Middleware","text":"<p>File: <code>server/middleware/auth.ts</code></p> <p>Replace <code>requireCacheReady()</code> with sync status check:</p> <pre><code>export const requireSyncComplete = async (req, res, next) =&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: { entityType: 'scene' },\n  });\n\n  if (!syncState?.lastFullSync &amp;&amp; !syncState?.lastIncrementalSync) {\n    return res.status(503).json({\n      error: 'Initial sync in progress',\n      message: 'Please wait for sync to complete',\n    });\n  }\n\n  next();\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-5-cleanup","title":"Phase 5: Cleanup","text":""},{"location":"design/cache-scalability-plan/#task-51-remove-stashcachemanager","title":"Task 5.1: Remove StashCacheManager","text":"<p>Delete file: <code>server/services/StashCacheManager.ts</code></p> <p>Remove imports from all 17 files that currently import it.</p>"},{"location":"design/cache-scalability-plan/#task-52-remove-filteredentitycacheservice","title":"Task 5.2: Remove FilteredEntityCacheService","text":"<p>Delete file: <code>server/services/FilteredEntityCacheService.ts</code></p> <p>SQLite queries with user filtering replace this entirely.</p>"},{"location":"design/cache-scalability-plan/#task-53-update-cache-initializer","title":"Task 5.3: Update Cache Initializer","text":"<p>File: <code>server/initializers/cache.ts</code></p> <p>Replace with sync initialization:</p> <pre><code>export const initializeSync = async () =&gt; {\n  logger.info('Starting sync scheduler...');\n  await syncScheduler.start();\n  logger.info('Sync scheduler started');\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-54-update-server-entry-point","title":"Task 5.4: Update Server Entry Point","text":"<p>File: <code>server/index.ts</code></p> <p>Replace cache initialization with sync initialization.</p>"},{"location":"design/cache-scalability-plan/#phase-6-testing-validation","title":"Phase 6: Testing &amp; Validation","text":""},{"location":"design/cache-scalability-plan/#task-61-create-synthetic-test-data-generator","title":"Task 6.1: Create Synthetic Test Data Generator","text":"<p>File: <code>server/scripts/generateTestData.ts</code></p> <p>Generate 100k+ fake scenes for testing scalability.</p>"},{"location":"design/cache-scalability-plan/#task-62-write-integration-tests","title":"Task 6.2: Write Integration Tests","text":"<ul> <li>Test full sync with large dataset</li> <li>Test incremental sync</li> <li>Test query performance</li> <li>Test FTS search</li> <li>Test user restrictions</li> </ul>"},{"location":"design/cache-scalability-plan/#task-63-performance-benchmarks","title":"Task 6.3: Performance Benchmarks","text":"<p>Compare: - Memory usage (before vs after) - Startup time - Query response times - Sync duration for various library sizes</p>"},{"location":"design/cache-scalability-plan/#phase-7-ui-updates","title":"Phase 7: UI Updates","text":""},{"location":"design/cache-scalability-plan/#task-71-add-sync-status-to-server-settings","title":"Task 7.1: Add Sync Status to Server Settings","text":"<p>Show: - Last sync time per entity type - Total entities synced - Sync progress (when running) - Error messages</p>"},{"location":"design/cache-scalability-plan/#task-72-add-sync-interval-setting","title":"Task 7.2: Add Sync Interval Setting","text":"<p>Allow admin to configure polling interval (5-120 minutes).</p>"},{"location":"design/cache-scalability-plan/#task-73-add-manual-sync-buttons","title":"Task 7.3: Add Manual Sync Buttons","text":"<ul> <li>\"Incremental Sync\" - sync changes only</li> <li>\"Full Sync\" - re-sync everything</li> </ul>"},{"location":"design/cache-scalability-plan/#verification-checklist","title":"Verification Checklist","text":"<p>After implementation, verify:</p> <ul> <li> Fresh install works (full sync on first run)</li> <li> Existing install migrates cleanly</li> <li> 100k scene library loads without errors</li> <li> Memory usage stays under 200MB</li> <li> Scene browsing responds in &lt;100ms</li> <li> Search works with FTS5</li> <li> User restrictions apply correctly</li> <li> Stats/aggregations work</li> <li> Incremental sync detects changes</li> <li> Soft delete works (removed scenes hidden but recoverable)</li> <li> All 17 dependent files updated</li> <li> No references to old StashCacheManager</li> </ul>"},{"location":"design/cache-scalability-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Keep old StashCacheManager code on a branch 2. Add feature flag to switch between old/new 3. Can revert by setting flag and redeploying</p>"},{"location":"design/cache-scalability-plan/#estimated-scope","title":"Estimated Scope","text":"Phase Tasks Complexity Phase 1: Schema 3 Medium Phase 2: Sync Service 3 High Phase 3: Query Service 2 Medium Phase 4: Controller Migration 10 Medium (repetitive) Phase 5: Cleanup 4 Low Phase 6: Testing 3 Medium Phase 7: UI 3 Low Total 28 tasks <p>This is a significant refactor but follows a clear progression: schema \u2192 sync \u2192 query \u2192 migrate \u2192 cleanup \u2192 test \u2192 UI.</p>"},{"location":"design/json-blob-elimination-plan/","title":"JSON Blob Elimination Plan","text":"<p>Date: 2025-12-09 Status: Planning Branch: <code>feature/cache-scalability-investigation</code> Related: sqlite-cache-schema.md, cache-scalability-plan.md</p>"},{"location":"design/json-blob-elimination-plan/#problem-statement","title":"Problem Statement","text":"<p>The current SQLite cache implementation stores entity data in a JSON blob column (<code>data</code>), which causes severe performance issues:</p> <ol> <li>Sync Performance: ~100 scenes/minute = 3.6 hours for 22k scenes</li> <li>JSON Serialization: Every upsert requires <code>JSON.stringify()</code> of large objects</li> <li>Junction Tables: 4 DELETE + 4 INSERT operations per scene (performers, tags, groups, galleries)</li> <li>Query Overhead: Every read requires <code>JSON.parse()</code> to access data</li> </ol> <p>The JSON blob approach was chosen for simplicity but doesn't scale. We need a proper normalized schema.</p>"},{"location":"design/json-blob-elimination-plan/#additional-problem-sync-state-logic","title":"Additional Problem: Sync State Logic","text":"<p>The current startup sync logic only checks for scene sync state:</p> <pre><code>// SyncScheduler.ts - performStartupSync()\nconst syncState = await prisma.syncState.findFirst({\n  where: { entityType: \"scene\" },\n});\n\nconst hasCompletedSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\nif (!hasCompletedSync) {\n  // Full sync triggered even though Studios, Tags, Performers etc may be complete\n  await stashSyncService.fullSync();\n}\n</code></pre> <p>Issues: 1. Only checks scene sync state - ignores other entity types 2. If scene sync fails/never completes, full sync is triggered every restart 3. Already-synced entities (Studios, Tags, Performers) are re-synced unnecessarily 4. Full sync doesn't use per-entity incremental logic</p> <p>Required Fix: Each entity type should independently check its own sync state and skip if nothing changed since last sync.</p>"},{"location":"design/json-blob-elimination-plan/#solution-eliminate-json-blob","title":"Solution: Eliminate JSON Blob","text":"<p>Store all consumed fields as individual database columns. Transform URLs at read time instead of storing transformed values.</p>"},{"location":"design/json-blob-elimination-plan/#key-insight-url-transformation","title":"Key Insight: URL Transformation","text":"<p>Currently, <code>transformScene()</code> converts Stash URLs to proxy URLs at sync time and stores them in the JSON blob. This is wasteful because:</p> <ol> <li>URLs contain the Stash host which may change</li> <li>We're storing redundant data (full nested objects)</li> <li>Transformation is a simple prefix replacement that can happen at read time</li> </ol> <p>New approach: Store only Stash entity IDs. Transform URLs when constructing the response.</p>"},{"location":"design/json-blob-elimination-plan/#phase-1-schema-redesign","title":"Phase 1: Schema Redesign","text":""},{"location":"design/json-blob-elimination-plan/#cachedscene-expanded-columns","title":"CachedScene - Expanded Columns","text":"<p>Replace JSON blob with explicit columns for all consumed fields:</p> <pre><code>model CachedScene {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields (already indexed) ===\n  title           String?\n  code            String?\n  date            String?                   // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                      // seconds (from primary file)\n  organized       Boolean   @default(false)\n\n  // === New fields from JSON blob ===\n  details         String?                   // Scene description (used in search)\n\n  // Primary file metadata\n  filePath        String?                   // Primary file path\n  fileBitRate     Int?                      // bits/second\n  fileFrameRate   Float?                    // fps\n  fileWidth       Int?                      // pixels\n  fileHeight      Int?                      // pixels\n  fileVideoCodec  String?                   // e.g., \"h264\", \"hevc\"\n  fileAudioCodec  String?                   // e.g., \"aac\", \"ac3\"\n  fileSize        BigInt?                   // bytes (can be &gt; 4GB)\n\n  // Stash paths (raw, transformed at read time)\n  pathScreenshot  String?                   // Screenshot URL path\n  pathPreview     String?                   // Preview video path\n  pathSprite      String?                   // Sprite sheet path\n  pathVtt         String?                   // VTT chapter path\n  pathChaptersVtt String?                   // Chapters VTT path\n  pathStream      String?                   // Primary stream path\n  pathCaption     String?                   // Caption path\n\n  // Scene streams (JSON array - small, rarely changes)\n  streams         String?                   // JSON: [{url, mime_type, label}]\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedperformer-expanded-columns","title":"CachedPerformer - Expanded Columns","text":"<pre><code>model CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields from JSON blob ===\n  aliasList       String?                   // JSON array of aliases\n  imagePath       String?                   // Raw image URL path\n  details         String?                   // Biography\n\n  // Additional performer metadata\n  country         String?\n  ethnicity       String?\n  hairColor       String?\n  eyeColor        String?\n  height          Int?                      // cm\n  weight          Int?                      // kg\n  measurements    String?                   // e.g., \"34D-24-34\"\n  tattoos         String?\n  piercings       String?\n  careerLength    String?\n  deathDate       String?\n  url             String?                   // Homepage\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n  tags            PerformerTag[]            // NEW: performers can have tags\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedstudio-expanded-columns","title":"CachedStudio - Expanded Columns","text":"<pre><code>model CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields ===\n  details         String?                   // Studio description\n  imagePath       String?                   // Raw logo URL path\n  url             String?                   // Studio website\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  tags            StudioTag[]               // NEW: studios can have tags\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedtag-expanded-columns","title":"CachedTag - Expanded Columns","text":"<pre><code>model CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  // === New fields ===\n  description     String?                   // Tag description\n  imagePath       String?                   // Tag image URL path\n  parentId        String?                   // Parent tag for hierarchy\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          SceneTag[]\n  images          ImageTag[]\n  performers      PerformerTag[]\n  studios         StudioTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([parentId])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#new-junction-tables","title":"New Junction Tables","text":"<pre><code>// Performer tags (for tag filtering that includes performer tags)\nmodel PerformerTag {\n  performerId     String\n  tagId           String\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([performerId, tagId])\n  @@index([tagId])\n}\n\n// Studio tags\nmodel StudioTag {\n  studioId        String\n  tagId           String\n  studio          CachedStudio    @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([studioId, tagId])\n  @@index([tagId])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-2-sync-optimization","title":"Phase 2: Sync Optimization","text":""},{"location":"design/json-blob-elimination-plan/#strategy-1-batch-upserts-with-raw-sql","title":"Strategy 1: Batch Upserts with Raw SQL","text":"<p>Replace Prisma individual upserts with bulk raw SQL:</p> <pre><code>private async processScenesBatchOptimized(\n  scenes: Scene[],\n  stashInstanceId: string | undefined\n): Promise&lt;void&gt; {\n  // Build batch INSERT...ON CONFLICT statement\n  const values = scenes.map(scene =&gt; {\n    const file = scene.files?.[0];\n    const paths = scene.paths;\n\n    return `(\n      '${scene.id}',\n      ${stashInstanceId ? `'${stashInstanceId}'` : 'NULL'},\n      ${escape(scene.title)},\n      ${escape(scene.code)},\n      ${escape(scene.date)},\n      ${scene.studio?.id ? `'${scene.studio.id}'` : 'NULL'},\n      ${scene.rating100 ?? 'NULL'},\n      ${file?.duration ? Math.round(file.duration) : 'NULL'},\n      ${scene.organized ? 1 : 0},\n      ${escape(scene.details)},\n      ${escape(file?.path)},\n      ${file?.bit_rate ?? 'NULL'},\n      ${file?.frame_rate ?? 'NULL'},\n      ${file?.width ?? 'NULL'},\n      ${file?.height ?? 'NULL'},\n      ${escape(file?.video_codec)},\n      ${escape(file?.audio_codec)},\n      ${file?.size ?? 'NULL'},\n      ${escape(paths?.screenshot)},\n      ${escape(paths?.preview)},\n      ${escape(paths?.sprite)},\n      ${escape(paths?.vtt)},\n      ${escape(paths?.chapters_vtt)},\n      ${escape(paths?.stream)},\n      ${escape(paths?.caption)},\n      ${escape(JSON.stringify(scene.sceneStreams || []))},\n      ${scene.created_at ? `'${scene.created_at}'` : 'NULL'},\n      ${scene.updated_at ? `'${scene.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedScene (\n      id, stashInstanceId, title, code, date, studioId, rating100, duration,\n      organized, details, filePath, fileBitRate, fileFrameRate, fileWidth,\n      fileHeight, fileVideoCodec, fileAudioCodec, fileSize, pathScreenshot,\n      pathPreview, pathSprite, pathVtt, pathChaptersVtt, pathStream, pathCaption,\n      streams, stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      code = excluded.code,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      duration = excluded.duration,\n      organized = excluded.organized,\n      details = excluded.details,\n      filePath = excluded.filePath,\n      fileBitRate = excluded.fileBitRate,\n      fileFrameRate = excluded.fileFrameRate,\n      fileWidth = excluded.fileWidth,\n      fileHeight = excluded.fileHeight,\n      fileVideoCodec = excluded.fileVideoCodec,\n      fileAudioCodec = excluded.fileAudioCodec,\n      fileSize = excluded.fileSize,\n      pathScreenshot = excluded.pathScreenshot,\n      pathPreview = excluded.pathPreview,\n      pathSprite = excluded.pathSprite,\n      pathVtt = excluded.pathVtt,\n      pathChaptersVtt = excluded.pathChaptersVtt,\n      pathStream = excluded.pathStream,\n      pathCaption = excluded.pathCaption,\n      streams = excluded.streams,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#strategy-2-batch-junction-table-operations","title":"Strategy 2: Batch Junction Table Operations","text":"<p>Instead of per-scene DELETE + INSERT, batch by page:</p> <pre><code>private async syncSceneJunctionTablesOptimized(\n  scenes: Scene[]\n): Promise&lt;void&gt; {\n  const sceneIds = scenes.map(s =&gt; s.id);\n\n  // Single DELETE per junction table for entire batch\n  await Promise.all([\n    prisma.$executeRawUnsafe(\n      `DELETE FROM ScenePerformer WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneTag WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGroup WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGallery WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n  ]);\n\n  // Collect all junction records\n  const performerRecords: string[] = [];\n  const tagRecords: string[] = [];\n  const groupRecords: string[] = [];\n  const galleryRecords: string[] = [];\n\n  for (const scene of scenes) {\n    for (const p of scene.performers || []) {\n      performerRecords.push(`('${scene.id}', '${p.id}')`);\n    }\n    for (const t of scene.tags || []) {\n      tagRecords.push(`('${scene.id}', '${t.id}')`);\n    }\n    for (const g of scene.groups || []) {\n      const index = g.scene_index ?? 'NULL';\n      groupRecords.push(`('${scene.id}', '${g.id}', ${index})`);\n    }\n    for (const g of scene.galleries || []) {\n      galleryRecords.push(`('${scene.id}', '${g.id}')`);\n    }\n  }\n\n  // Single INSERT per junction table\n  const inserts = [];\n\n  if (performerRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ScenePerformer (sceneId, performerId) VALUES ${performerRecords.join(',')}`\n    ));\n  }\n  if (tagRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneTag (sceneId, tagId) VALUES ${tagRecords.join(',')}`\n    ));\n  }\n  if (groupRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGroup (sceneId, groupId, sceneIndex) VALUES ${groupRecords.join(',')}`\n    ));\n  }\n  if (galleryRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGallery (sceneId, galleryId) VALUES ${galleryRecords.join(',')}`\n    ));\n  }\n\n  await Promise.all(inserts);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#expected-performance-improvement","title":"Expected Performance Improvement","text":"Operation Before After Improvement Scene upsert 1 Prisma call/scene 1 SQL/batch 100x fewer calls JSON.stringify Every scene None Eliminated Junction deletes 4 calls/scene 4 calls/batch 100x fewer calls Junction inserts 4 calls/scene 4 calls/batch 100x fewer calls Total per batch ~500 DB calls ~9 DB calls 55x reduction <p>With 100 scenes per batch: - Before: 500+ Prisma operations - After: 9 raw SQL operations</p> <p>Projected sync time for 22k scenes: ~4-6 minutes instead of 3.6 hours</p>"},{"location":"design/json-blob-elimination-plan/#phase-25-fix-sync-state-logic-priority","title":"Phase 2.5: Fix Sync State Logic (PRIORITY)","text":"<p>This should be implemented before the JSON blob elimination to prevent unnecessary re-syncing.</p>"},{"location":"design/json-blob-elimination-plan/#problem","title":"Problem","text":"<p>Current <code>performStartupSync()</code> only checks scene sync state: - If scenes never completed, ALL entity types are re-synced from scratch - Studios, Tags, Performers that already synced are re-fetched needlessly</p>"},{"location":"design/json-blob-elimination-plan/#solution-smart-per-entity-sync","title":"Solution: Smart Per-Entity Sync","text":"<p>Each entity type should: 1. Check its own SyncState record 2. Query Stash for count of entities updated since last sync 3. Skip if nothing changed (count = 0) 4. Only fetch changed entities if count &gt; 0</p>"},{"location":"design/json-blob-elimination-plan/#implementation","title":"Implementation","text":"<pre><code>// SyncScheduler.ts\nprivate async performStartupSync(): Promise&lt;void&gt; {\n  // Check sync state for ALL entity types, not just scenes\n  const syncStates = await prisma.syncState.findMany();\n  const syncStateMap = new Map(syncStates.map(s =&gt; [s.entityType, s]));\n\n  // If ANY entity type has a completed sync, use incremental for all\n  const hasAnySync = syncStates.some(s =&gt; s.lastFullSync || s.lastIncrementalSync);\n\n  if (!hasAnySync) {\n    logger.info(\"No previous sync found for any entity, performing full sync\");\n    await stashSyncService.fullSync();\n    return;\n  }\n\n  // Smart incremental sync - checks each entity independently\n  logger.info(\"Performing smart incremental sync on startup\");\n  await stashSyncService.smartIncrementalSync();\n}\n\n// StashSyncService.ts\nasync smartIncrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n  const results: SyncResult[] = [];\n\n  // Each entity type checks independently\n  for (const entityType of ['studio', 'tag', 'performer', 'group', 'gallery', 'scene', 'image']) {\n    const syncState = await this.getSyncState(stashInstanceId, entityType);\n    const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n    if (!lastSync) {\n      // Never synced this entity type - do full sync for just this type\n      logger.info(`No sync state for ${entityType}, performing full sync`);\n      const result = await this.syncEntityType(entityType, stashInstanceId, true);\n      results.push(result);\n    } else {\n      // Check if anything changed since last sync\n      const changeCount = await this.getChangeCount(entityType, lastSync);\n\n      if (changeCount === 0) {\n        logger.info(`${entityType}: No changes since ${lastSync.toISOString()}, skipping`);\n        results.push({\n          entityType,\n          synced: 0,\n          deleted: 0,\n          durationMs: 0,\n        });\n      } else {\n        logger.info(`${entityType}: ${changeCount} changes since ${lastSync.toISOString()}`);\n        const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n        results.push(result);\n      }\n    }\n  }\n\n  return results;\n}\n\nprivate async getChangeCount(entityType: string, since: Date): Promise&lt;number&gt; {\n  const stash = stashInstanceManager.getDefault();\n  const filter = {\n    updated_at: { modifier: \"GREATER_THAN\", value: since.toISOString() }\n  };\n\n  switch (entityType) {\n    case 'scene':\n      const sceneResult = await stash.findScenesCompact({\n        filter: { page: 1, per_page: 0 }, // Only get count, no data\n        scene_filter: filter,\n      });\n      return sceneResult.findScenes.count;\n\n    case 'performer':\n      const performerResult = await stash.findPerformersCompact({\n        filter: { page: 1, per_page: 0 },\n        performer_filter: filter,\n      });\n      return performerResult.findPerformers.count;\n\n    // Similar for other entity types...\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#benefits","title":"Benefits","text":"<ol> <li>Restart resilience: If scene sync fails, other entities don't re-sync</li> <li>Fast startup: Entities with no changes skip API calls entirely</li> <li>Incremental always: Even \"full sync\" uses per-entity incremental when possible</li> <li>Progress visibility: Each entity type reports its own status</li> </ol>"},{"location":"design/json-blob-elimination-plan/#test-scenario","title":"Test Scenario","text":"<p>After implementing: 1. Run full sync to completion (or partial - doesn't matter) 2. Restart server 3. Expected: \"Studios: No changes since X, skipping\" for already-synced types 4. Only entities that never completed or have changes get synced</p>"},{"location":"design/json-blob-elimination-plan/#phase-3-query-layer-updates","title":"Phase 3: Query Layer Updates","text":""},{"location":"design/json-blob-elimination-plan/#cachedentityqueryservice-changes","title":"CachedEntityQueryService Changes","text":"<p>Replace JSON parsing with direct column access and URL transformation:</p> <pre><code>class CachedEntityQueryService {\n  private transformSceneUrls(scene: CachedScene): NormalizedScene {\n    const baseUrl = this.getStashProxyBaseUrl();\n\n    return {\n      id: scene.id,\n      title: scene.title,\n      code: scene.code,\n      date: scene.date,\n      details: scene.details,\n      rating100: scene.rating100,\n      organized: scene.organized,\n\n      // File metadata\n      files: scene.filePath ? [{\n        path: scene.filePath,\n        duration: scene.duration,\n        bit_rate: scene.fileBitRate,\n        frame_rate: scene.fileFrameRate,\n        width: scene.fileWidth,\n        height: scene.fileHeight,\n        video_codec: scene.fileVideoCodec,\n        audio_codec: scene.fileAudioCodec,\n        size: scene.fileSize,\n      }] : [],\n\n      // Transformed URLs\n      paths: {\n        screenshot: this.transformUrl(scene.pathScreenshot),\n        preview: this.transformUrl(scene.pathPreview),\n        sprite: this.transformUrl(scene.pathSprite),\n        vtt: this.transformUrl(scene.pathVtt),\n        chapters_vtt: this.transformUrl(scene.pathChaptersVtt),\n        stream: this.transformUrl(scene.pathStream),\n        caption: this.transformUrl(scene.pathCaption),\n      },\n\n      // Parse streams JSON (small, rarely changes)\n      sceneStreams: scene.streams\n        ? JSON.parse(scene.streams).map(s =&gt; ({\n            ...s,\n            url: this.transformUrl(s.url),\n          }))\n        : [],\n\n      // Nested entities loaded separately\n      studio: null,      // Loaded via JOIN or separate query\n      performers: [],    // Loaded via junction table\n      tags: [],          // Loaded via junction table\n      groups: [],        // Loaded via junction table\n      galleries: [],     // Loaded via junction table\n\n      // Timestamps\n      created_at: scene.stashCreatedAt?.toISOString(),\n      updated_at: scene.stashUpdatedAt?.toISOString(),\n    };\n  }\n\n  private transformUrl(path: string | null): string | null {\n    if (!path) return null;\n    // Replace Stash host with proxy prefix\n    return `/api/proxy/stash${path}`;\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#loading-nested-entities","title":"Loading Nested Entities","text":"<p>For detail views that need performers/tags, use efficient batch loading:</p> <pre><code>async getSceneWithRelations(id: string): Promise&lt;NormalizedScene | null&gt; {\n  const scene = await prisma.cachedScene.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: {\n        include: { performer: true }\n      },\n      tags: {\n        include: { tag: true }\n      },\n      groups: {\n        include: { group: true }\n      },\n      galleries: {\n        include: { gallery: true }\n      },\n    },\n  });\n\n  if (!scene) return null;\n\n  const transformed = this.transformSceneUrls(scene);\n\n  // Add nested entities\n  transformed.performers = scene.performers.map(sp =&gt;\n    this.transformPerformerUrls(sp.performer)\n  );\n  transformed.tags = scene.tags.map(st =&gt;\n    this.transformTagUrls(st.tag)\n  );\n  transformed.groups = scene.groups.map(sg =&gt; ({\n    ...this.transformGroupUrls(sg.group),\n    scene_index: sg.sceneIndex,\n  }));\n  transformed.studio = scene.studioId\n    ? await this.getStudio(scene.studioId)\n    : null;\n\n  return transformed;\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-4-migration-path","title":"Phase 4: Migration Path","text":""},{"location":"design/json-blob-elimination-plan/#step-1-add-new-columns-non-breaking","title":"Step 1: Add New Columns (Non-Breaking)","text":"<p>Add new columns to existing schema without removing <code>data</code> column yet.</p>"},{"location":"design/json-blob-elimination-plan/#step-2-dual-write-during-sync","title":"Step 2: Dual-Write During Sync","text":"<p>Update sync to write both JSON blob AND individual columns. This allows rollback.</p>"},{"location":"design/json-blob-elimination-plan/#step-3-update-query-service","title":"Step 3: Update Query Service","text":"<p>Switch CachedEntityQueryService to read from columns instead of JSON.</p>"},{"location":"design/json-blob-elimination-plan/#step-4-remove-json-blob","title":"Step 4: Remove JSON Blob","text":"<p>After validation, remove <code>data</code> column from schema.</p>"},{"location":"design/json-blob-elimination-plan/#step-5-optimize-sync","title":"Step 5: Optimize Sync","text":"<p>Remove JSON.stringify, implement batch operations.</p>"},{"location":"design/json-blob-elimination-plan/#testing-plan","title":"Testing Plan","text":"<ol> <li>Sync Performance Test: Time full sync with 22k scenes</li> <li> <p>Target: &lt; 10 minutes (vs current 3.6 hours)</p> </li> <li> <p>Query Performance Test: Measure browse page response time</p> </li> <li> <p>Target: &lt; 100ms for paginated results</p> </li> <li> <p>Memory Test: Monitor memory during sync</p> </li> <li> <p>Target: &lt; 500MB peak usage</p> </li> <li> <p>Data Integrity Test: Compare output before/after migration</p> </li> <li>All scenes should have same field values</li> </ol>"},{"location":"design/json-blob-elimination-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Re-enable JSON blob writing 2. Switch query service back to JSON parsing 3. Performance will degrade but functionality preserved</p>"},{"location":"design/json-blob-elimination-plan/#files-to-modify","title":"Files to Modify","text":""},{"location":"design/json-blob-elimination-plan/#schema","title":"Schema","text":"<ul> <li><code>server/prisma/schema.prisma</code> - Add new columns</li> </ul>"},{"location":"design/json-blob-elimination-plan/#sync-service","title":"Sync Service","text":"<ul> <li><code>server/services/StashSyncService.ts</code> - Batch operations, remove JSON</li> </ul>"},{"location":"design/json-blob-elimination-plan/#query-service","title":"Query Service","text":"<ul> <li><code>server/services/CachedEntityQueryService.ts</code> - Direct column access</li> </ul>"},{"location":"design/json-blob-elimination-plan/#transformation","title":"Transformation","text":"<ul> <li><code>server/utils/pathMapping.ts</code> - Move URL transformation to query time</li> </ul>"},{"location":"design/json-blob-elimination-plan/#types","title":"Types","text":"<ul> <li><code>server/types/index.ts</code> - Update NormalizedScene type if needed</li> </ul>"},{"location":"design/json-blob-elimination-plan/#summary","title":"Summary","text":"<p>Root Cause: JSON blob storage creates O(n) serialization overhead and prevents SQL query optimization.</p> <p>Solution: 1. Store all fields as individual columns 2. Transform URLs at read time (not sync time) 3. Use batch SQL operations for sync 4. Reduce DB operations from ~500/batch to ~9/batch</p> <p>Expected Result: Sync time reduced from 3.6 hours to ~5 minutes for 22k scenes.</p>"},{"location":"design/sqlite-cache-schema/","title":"SQLite Entity Cache Schema Design","text":"<p>Related: cache-scalability-brainstorm.md Date: 2025-12-08</p>"},{"location":"design/sqlite-cache-schema/#design-goals","title":"Design Goals","text":"<ol> <li>Scalability: Support 100k+ scenes without memory issues</li> <li>Query Performance: Fast filtering, sorting, pagination via SQL indexes</li> <li>Minimal Storage: Store only what Peek needs for filtering/display</li> <li>Relationships: Maintain scene\u2194performer, scene\u2194tag, etc. for filtering</li> <li>Sync Tracking: Track what's synced, detect deletions, enable incremental updates</li> </ol>"},{"location":"design/sqlite-cache-schema/#schema-design-decisions","title":"Schema Design Decisions","text":""},{"location":"design/sqlite-cache-schema/#decision-1-normalized-vs-denormalized","title":"Decision 1: Normalized vs Denormalized","text":"<p>Option A: Fully Normalized (separate tables with junction tables) <pre><code>CachedScene, CachedPerformer, ScenePerformer (junction), etc.\n</code></pre> - Pros: Clean relationships, no data duplication - Cons: Complex JOINs for every query, harder to paginate</p> <p>Option B: Denormalized with JSON (store relationships as JSON) <pre><code>CachedScene { performerIds: \"[1,2,3]\", tagIds: \"[4,5,6]\" }\n</code></pre> - Pros: Simple queries, fast reads - Cons: Can't filter by \"scenes with performer X\" efficiently</p> <p>Option C: Hybrid (normalized + JSON for full data) <pre><code>CachedScene { studioId, performerIds JSON, tagIds JSON, fullData JSON }\n+ Junction tables for efficient filtering\n</code></pre> - Pros: Best of both - efficient filtering AND full data access - Cons: More storage, need to keep junction tables in sync</p> <p>Decision: Option C (Hybrid) - We need both efficient filtering AND full entity data.</p>"},{"location":"design/sqlite-cache-schema/#decision-2-what-to-index","title":"Decision 2: What to Index","text":"<p>For scene filtering, we need to support: - Filter by studio, performers, tags, groups - Sort by date, rating, title, created_at, play_count, random - Text search on title - Date range queries</p> <p>Indexes needed: - <code>studioId</code> - Filter by studio - <code>date</code> - Sort/filter by scene date - <code>createdAt</code> - Sort by when added to Stash - <code>rating100</code> - Sort by rating - <code>title</code> - Text search (use SQLite FTS5 for full-text search) - Junction table indexes for performer/tag/group filtering</p>"},{"location":"design/sqlite-cache-schema/#decision-3-soft-delete-strategy","title":"Decision 3: Soft Delete Strategy","text":"<p>When an entity is deleted from Stash: 1. Mark <code>deletedAt</code> timestamp in Peek 2. Don't show in browse results 3. Keep for 30 days (allows Peek data recovery if re-added) 4. Periodic cleanup job removes old deleted entities</p>"},{"location":"design/sqlite-cache-schema/#proposed-schema","title":"Proposed Schema","text":""},{"location":"design/sqlite-cache-schema/#core-entity-tables","title":"Core Entity Tables","text":"<pre><code>// Cached scene from Stash\n// Contains indexed fields for filtering + JSON blob for full data\nmodel CachedScene {\n  id            String    @id                    // Stash scene ID\n  stashInstanceId String?                        // Which Stash server (for multi-instance)\n\n  // === Indexed fields for filtering/sorting ===\n  title         String?\n  date          String?                          // YYYY-MM-DD format\n  studioId      String?\n  rating100     Int?\n  duration      Int?                             // seconds\n  organized     Boolean   @default(false)\n  oCounter      Int       @default(0)\n  playCount     Int       @default(0)\n\n  // === Full entity data (JSON) ===\n  // Contains: performers, tags, files, paths, streams, etc.\n  // Transformed with proxy URLs at sync time\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?                      // created_at from Stash\n  stashUpdatedAt  DateTime?                      // updated_at from Stash\n  syncedAt        DateTime  @default(now())      // When Peek last synced this entity\n  deletedAt       DateTime?                      // Soft delete timestamp\n\n  // Relationships (for efficient filtering)\n  performers    ScenePerformer[]\n  tags          SceneTag[]\n  groups        SceneGroup[]\n  galleries     SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])                      // For incremental sync\n}\n\nmodel CachedPerformer {\n  id            String    @id                    // Stash performer ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  gender        String?\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        ScenePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedStudio {\n  id            String    @id                    // Stash studio ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  parentId      String?                          // Parent studio ID\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        CachedScene[]                    // Direct relation (not junction)\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedTag {\n  id            String    @id                    // Stash tag ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  favorite      Boolean   @default(false)\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGroup {\n  id            String    @id                    // Stash group ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  date          String?\n  studioId      String?\n  rating100     Int?\n  duration      Int?\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGallery {\n  id            String    @id                    // Stash gallery ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  imageCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#junction-tables-for-efficient-many-to-many-filtering","title":"Junction Tables (for efficient many-to-many filtering)","text":"<pre><code>model ScenePerformer {\n  sceneId       String\n  performerId   String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])                         // For \"scenes with performer X\" queries\n}\n\nmodel SceneTag {\n  sceneId       String\n  tagId         String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])                               // For \"scenes with tag X\" queries\n}\n\nmodel SceneGroup {\n  sceneId       String\n  groupId       String\n  sceneIndex    Int?                             // Position in group\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group         CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId       String\n  galleryId     String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#sync-metadata-table","title":"Sync Metadata Table","text":"<pre><code>// Tracks sync state per entity type\nmodel SyncState {\n  id              Int       @id @default(autoincrement())\n  stashInstanceId String?\n  entityType      String                         // 'scene', 'performer', etc.\n\n  lastFullSync    DateTime?                      // Last complete sync\n  lastIncrementalSync DateTime?                  // Last incremental sync\n  lastSyncCount   Int       @default(0)          // Entities synced in last run\n  lastSyncDuration Int?                          // Milliseconds\n  lastError       String?                        // Error message if last sync failed\n\n  @@unique([stashInstanceId, entityType])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#query-patterns","title":"Query Patterns","text":""},{"location":"design/sqlite-cache-schema/#pattern-1-paginated-scene-browse","title":"Pattern 1: Paginated Scene Browse","text":"<pre><code>-- Get page 2 of scenes (50 per page), sorted by date DESC\n-- With user restrictions applied (exclude hidden, apply tag restrictions)\n\nSELECT s.id, s.data\nFROM CachedScene s\nWHERE s.deletedAt IS NULL\n  AND s.id NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'scene')\n  AND s.studioId NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'studio')\n  -- User restriction: only scenes with tag \"Favorite\"\n  AND EXISTS (SELECT 1 FROM SceneTag st WHERE st.sceneId = s.id AND st.tagId IN (?))\nORDER BY s.date DESC\nLIMIT 50 OFFSET 50;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-2-filter-by-performer","title":"Pattern 2: Filter by Performer","text":"<pre><code>-- Get all scenes featuring performer \"123\"\nSELECT s.id, s.data\nFROM CachedScene s\nINNER JOIN ScenePerformer sp ON sp.sceneId = s.id\nWHERE sp.performerId = '123'\n  AND s.deletedAt IS NULL\nORDER BY s.date DESC;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-3-aggregation-top-performers-by-play-count","title":"Pattern 3: Aggregation (Top Performers by Play Count)","text":"<pre><code>-- Top 10 performers by user's play count\nSELECT p.id, p.name, SUM(ups.playCount) as totalPlays\nFROM CachedPerformer p\nINNER JOIN UserPerformerStats ups ON ups.performerId = p.id\nWHERE ups.userId = ?\n  AND p.deletedAt IS NULL\nGROUP BY p.id\nORDER BY totalPlays DESC\nLIMIT 10;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#storage-estimates","title":"Storage Estimates","text":"Entity Count JSON Size Indexed Fields Total Scene 100,000 ~2KB ~200B ~220MB Performer 10,000 ~500B ~100B ~6MB Studio 1,000 ~300B ~50B ~350KB Tag 10,000 ~200B ~50B ~2.5MB Group 5,000 ~400B ~100B ~2.5MB Gallery 20,000 ~400B ~100B ~10MB Total ~240MB <p>Junction tables add ~10-20% overhead for relationships.</p> <p>Total estimated storage for 100k scene library: ~300MB</p>"},{"location":"design/sqlite-cache-schema/#migration-strategy","title":"Migration Strategy","text":""},{"location":"design/sqlite-cache-schema/#phase-1-add-schema-non-breaking","title":"Phase 1: Add Schema (Non-Breaking)","text":"<ol> <li>Add new Cached* tables via Prisma migration</li> <li>Keep existing StashCacheManager working</li> <li>Add new StashSyncService that populates SQLite</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-2-parallel-operation","title":"Phase 2: Parallel Operation","text":"<ol> <li>Both in-memory cache and SQLite populated</li> <li>Add feature flag to switch query source</li> <li>Test performance and correctness</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-3-switch-to-sqlite","title":"Phase 3: Switch to SQLite","text":"<ol> <li>Update all 18+ dependent files to use SQLite queries</li> <li>Remove in-memory cache</li> <li>Delete StashCacheManager</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-4-cleanup","title":"Phase 4: Cleanup","text":"<ol> <li>Remove FilteredEntityCacheService (SQLite replaces it)</li> <li>Clean up old code paths</li> <li>Performance tuning</li> </ol>"},{"location":"design/sqlite-cache-schema/#resolved-questions","title":"Resolved Questions","text":"<ol> <li>Full-text search: \u2705 Use SQLite FTS5 for title/name search (see FTS5 section below)</li> <li>Performer tags: TBD - defer until needed</li> <li>Image caching: \u2705 Yes, cache Images as separate entity (see CachedImage below)</li> <li>Multi-instance: TBD - current design supports it via stashInstanceId</li> </ol>"},{"location":"design/sqlite-cache-schema/#fts5-full-text-search","title":"FTS5 Full-Text Search","text":"<p>SQLite FTS5 provides fast, sophisticated text search with: - Word stemming (searching \"running\" matches \"run\") - Relevance ranking - Prefix matching (\"test*\" matches \"testing\") - Boolean operators (AND, OR, NOT)</p>"},{"location":"design/sqlite-cache-schema/#fts5-virtual-tables","title":"FTS5 Virtual Tables","text":"<pre><code>-- Create FTS5 virtual table for scene search\nCREATE VIRTUAL TABLE scene_fts USING fts5(\n  id,\n  title,\n  details,\n  content='CachedScene',\n  content_rowid='rowid'\n);\n\n-- Create FTS5 virtual table for performer search\nCREATE VIRTUAL TABLE performer_fts USING fts5(\n  id,\n  name,\n  aliases,\n  content='CachedPerformer',\n  content_rowid='rowid'\n);\n\n-- Triggers to keep FTS index in sync\nCREATE TRIGGER scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#fts5-query-example","title":"FTS5 Query Example","text":"<pre><code>-- Search for scenes matching \"blonde teacher\"\nSELECT s.id, s.data, rank\nFROM scene_fts\nINNER JOIN CachedScene s ON scene_fts.id = s.id\nWHERE scene_fts MATCH 'blonde teacher'\n  AND s.deletedAt IS NULL\nORDER BY rank\nLIMIT 50;\n</code></pre> <p>Note: Prisma doesn't support FTS5 virtual tables directly. We'll create these via raw SQL migrations.</p>"},{"location":"design/sqlite-cache-schema/#cachedimage-entity","title":"CachedImage Entity","text":"<pre><code>model CachedImage {\n  id            String    @id                    // Stash image ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  oCounter      Int       @default(0)\n  organized     Boolean   @default(false)\n\n  // File info (for display)\n  width         Int?\n  height        Int?\n  fileSize      Int?                             // bytes\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relationships\n  performers    ImagePerformer[]\n  tags          ImageTag[]\n  galleries     ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel ImagePerformer {\n  imageId       String\n  performerId   String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId       String\n  tagId         String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId       String\n  galleryId     String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n</code></pre> <p>Note: CachedPerformer and CachedTag need updated to include the new Image relations.</p>"},{"location":"design/sqlite-cache-schema/#next-steps","title":"Next Steps","text":"<ol> <li>Review this schema with stakeholder</li> <li>Create Prisma migration</li> <li>Implement StashSyncService</li> <li>Create SQL query builders for each access pattern</li> <li>Update controllers one by one</li> </ol>"},{"location":"development/content-restrictions/","title":"Content Restrictions System","text":""},{"location":"development/content-restrictions/#overview","title":"Overview","text":"<p>The Content Restrictions system allows administrators to control what content each user can see in Peek. This is a critical privacy/safety feature that enables hiding sensitive content (e.g., scenes with certain tags, studios, or groups) on a per-user basis.</p> <p>Current Version: 1.5.3+ Status: Fixed - Critical cascading bugs resolved (January 2025)</p>"},{"location":"development/content-restrictions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture</li> <li>Database Schema</li> <li>How It Works</li> <li>Cascading Logic</li> <li>Empty Entity Filtering</li> <li>Caching Strategy</li> <li>API Endpoints</li> <li>Code Flow</li> <li>Known Issues &amp; Edge Cases</li> <li>Testing Strategy</li> </ol>"},{"location":"development/content-restrictions/#architecture","title":"Architecture","text":"<p>The system consists of several cooperating services:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     User Request                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   Library Controller          \u2502\n         \u2502   (scenes, performers, etc.)  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 StashCacheManager \u2502    \u2502 UserRestriction    \u2502    \u2502 FilteredEntity  \u2502\n\u2502                   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Service            \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 CacheService    \u2502\n\u2502 (Server-wide data)\u2502    \u2502 (Apply restrictions)\u2502    \u2502 (Per-user cache)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 EmptyEntityFilter   \u2502\n                         \u2502 Service             \u2502\n                         \u2502 (Remove orphans)    \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/content-restrictions/#key-services","title":"Key Services","text":"<ol> <li>StashCacheManager (<code>server/services/StashCacheManager.ts</code>)</li> <li>Manages server-wide cache of all Stash entities</li> <li>Refreshes hourly from Stash GraphQL API</li> <li> <p>Provides fast Map-based lookups</p> </li> <li> <p>UserRestrictionService (<code>server/services/UserRestrictionService.ts</code>)</p> </li> <li>Applies per-user INCLUDE/EXCLUDE rules</li> <li>Filters Scenes based on Groups, Tags, Studios, Galleries</li> <li> <p>Filters organizational entities (Groups, Tags, Studios, Galleries)</p> </li> <li> <p>EmptyEntityFilterService (<code>server/services/EmptyEntityFilterService.ts</code>)</p> </li> <li>Removes \"orphaned\" entities with no visible content</li> <li>Handles complex dependency chains (Tags \u2192 Studios \u2192 Scenes)</li> <li> <p>Prevents showing empty organizational entities</p> </li> <li> <p>FilteredEntityCacheService (<code>server/services/FilteredEntityCacheService.ts</code>)</p> </li> <li>In-memory per-user cache of filtered results</li> <li>Avoids re-computing expensive filters on every request</li> <li>Invalidates on Stash cache updates or user restriction changes</li> </ol>"},{"location":"development/content-restrictions/#database-schema","title":"Database Schema","text":""},{"location":"development/content-restrictions/#usercontentrestriction-table","title":"UserContentRestriction Table","text":"<pre><code>model UserContentRestriction {\n  id            Int      @id @default(autoincrement())\n  userId        Int\n  entityType    String   // 'groups' | 'tags' | 'studios' | 'galleries'\n  mode          String   // 'INCLUDE' | 'EXCLUDE'\n  entityIds     String   // JSON array of entity IDs (stringified)\n  restrictEmpty Boolean  @default(false)  // If true, restrict items with no entities of this type\n  createdAt     DateTime @default(now())\n  updatedAt     DateTime @updatedAt\n\n  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n  @@index([userId])\n}\n</code></pre> <p>Important Notes: - One restriction per <code>(userId, entityType)</code> pair - <code>entityIds</code> is a JSON-stringified array of strings - <code>restrictEmpty</code> flag: if <code>true</code>, items with NO entities of this type are also excluded</p> <p>Example Records:</p> <pre><code>// User 5: Exclude Tag \"Extreme\" (ID: \"123\")\n{\n  \"userId\": 5,\n  \"entityType\": \"tags\",\n  \"mode\": \"EXCLUDE\",\n  \"entityIds\": \"[\\\"123\\\"]\",\n  \"restrictEmpty\": false\n}\n\n// User 6: INCLUDE only Studio \"Safe Studio\" (ID: \"456\")\n{\n  \"userId\": 6,\n  \"entityType\": \"studios\",\n  \"mode\": \"INCLUDE\",\n  \"entityIds\": \"[\\\"456\\\"]\",\n  \"restrictEmpty\": false\n}\n</code></pre>"},{"location":"development/content-restrictions/#how-it-works","title":"How It Works","text":""},{"location":"development/content-restrictions/#processing-order","title":"Processing Order","text":"<ol> <li>Apply INCLUDE filters (whitelist)</li> <li>If set, ONLY show entities matching ALL include filters</li> <li> <p>Acts as intersection across multiple entity types</p> </li> <li> <p>Apply EXCLUDE filters (blacklist)</p> </li> <li>Remove entities matching ANY exclude filter</li> <li> <p>Acts as difference/subtraction</p> </li> <li> <p>Apply restrictEmpty rules</p> </li> <li>Remove entities that have NO values for restricted entity type</li> </ol>"},{"location":"development/content-restrictions/#scene-filtering-example","title":"Scene Filtering Example","text":"<p>Scenario: User excludes Tag \"Extreme\" (ID: \"123\")</p> <pre><code>// UserContentRestriction record\n{\n  userId: 5,\n  entityType: \"tags\",\n  mode: \"EXCLUDE\",\n  entityIds: [\"123\"],\n  restrictEmpty: false\n}\n\n// Filtering logic\nscenes = scenes.filter(scene =&gt; {\n  const sceneTagIds = scene.tags.map(t =&gt; t.id); // [\"100\", \"123\", \"200\"]\n  const excludedIds = [\"123\"];\n  return !sceneTagIds.some(id =&gt; excludedIds.includes(id)); // FALSE - REMOVED\n});\n</code></pre> <p>Result: Any Scene with Tag \"123\" is hidden from User 5.</p>"},{"location":"development/content-restrictions/#include-vs-exclude-interaction","title":"Include vs Exclude Interaction","text":"<p>When a user has BOTH include and exclude restrictions:</p> <pre><code>// Step 1: Apply INCLUDE filters (intersection)\nfor (const includeRestriction of includeRestrictions) {\n  scenes = scenes.filter(scene =&gt; {\n    const sceneEntityIds = getSceneEntityIds(scene, includeRestriction.entityType);\n    const allowedIds = JSON.parse(includeRestriction.entityIds);\n    return sceneEntityIds.some(id =&gt; allowedIds.includes(id));\n  });\n}\n\n// Step 2: Apply EXCLUDE filters (difference)\nfor (const excludeRestriction of excludeRestrictions) {\n  scenes = scenes.filter(scene =&gt; {\n    const sceneEntityIds = getSceneEntityIds(scene, excludeRestriction.entityType);\n    const excludedIds = JSON.parse(excludeRestriction.entityIds);\n    return !sceneEntityIds.some(id =&gt; excludedIds.includes(id));\n  });\n}\n</code></pre> <p>Recommended Practice: Don't use INCLUDE mode (we warn users in GUI), as it's easy to accidentally hide everything.</p>"},{"location":"development/content-restrictions/#cascading-logic","title":"Cascading Logic","text":""},{"location":"development/content-restrictions/#current-implementation-direct-only","title":"Current Implementation (Direct Only)","text":"<p>What Works: - \u2705 Scene has excluded Tag \u2192 Scene hidden - \u2705 Scene belongs to excluded Studio \u2192 Scene hidden - \u2705 Scene in excluded Group \u2192 Scene hidden - \u2705 Gallery has excluded Tag \u2192 Gallery hidden</p> <p>What's Missing (Likely Bug Source): - \u274c Studio has excluded Tag \u2192 Studio NOT hidden (direct restriction only) - \u274c Studio has excluded Tag \u2192 Scenes from that Studio NOT hidden - \u274c Performer only in excluded Studio \u2192 Performer NOT hidden - \u274c Scene's Studio has excluded Tag \u2192 Scene NOT hidden</p>"},{"location":"development/content-restrictions/#expected-cascading-behavior","title":"Expected Cascading Behavior","text":"<p>According to user requirements, exclusions should cascade:</p> <pre><code>Tag \"Extreme\" (excluded)\n  \u2193 applied to Studio\nStudio \"Hardcore Productions\"\n  \u2193 produces\nScenes [Scene A, Scene B, Scene C]\n  \u2193 starring\nPerformers [Performer X, Performer Y]\n\nExpected Result:\n- Tag \"Extreme\" \u2192 Hidden\n- Studio \"Hardcore Productions\" \u2192 Hidden (has excluded tag)\n- Scene A, B, C \u2192 Hidden (belong to excluded studio)\n- Performer X, Y \u2192 Hidden (only appear in excluded scenes)\n</code></pre>"},{"location":"development/content-restrictions/#current-code-analysis","title":"Current Code Analysis","text":""},{"location":"development/content-restrictions/#scene-filtering-userrestrictionservicefilterscenesforuser","title":"Scene Filtering (<code>UserRestrictionService.filterScenesForUser</code>)","text":"<pre><code>private getSceneEntityIds(scene: NormalizedScene, entityType: string): string[] {\n  switch (entityType) {\n    case \"groups\":\n      return scene.groups?.map(g =&gt; String(g.id)) || [];\n    case \"tags\":\n      return scene.tags?.map(t =&gt; String(t.id)) || [];  // \u26a0\ufe0f ONLY scene.tags\n    case \"studios\":\n      return scene.studio ? [String(scene.studio.id)] : [];\n    case \"galleries\":\n      return scene.galleries?.map(g =&gt; String(g.id)) || [];\n    default:\n      return [];\n  }\n}\n</code></pre> <p>Bug #1: Scene tag filtering only checks <code>scene.tags</code>, NOT <code>scene.studio.tags</code> or <code>scene.performers[].tags</code></p> <p>Expected: <pre><code>case \"tags\":\n  const tagIds = new Set&lt;string&gt;();\n\n  // Direct scene tags\n  (scene.tags || []).forEach(t =&gt; tagIds.add(String(t.id)));\n\n  // Performer tags (cascading)\n  (scene.performers || []).forEach(p =&gt; {\n    (p.tags || []).forEach(t =&gt; tagIds.add(String(t.id)));\n  });\n\n  // Studio tags (cascading)\n  if (scene.studio?.tags) {\n    scene.studio.tags.forEach(t =&gt; tagIds.add(String(t.id)));\n  }\n\n  return Array.from(tagIds);\n</code></pre></p>"},{"location":"development/content-restrictions/#studioperformer-filtering","title":"Studio/Performer Filtering","text":"<pre><code>// Studios: Only checks if studio ID is in restricted list\nasync filterStudiosForUser(studios, userId) {\n  const studioRestriction = restrictions.find(r =&gt; r.entityType === \"studios\");\n  const restrictedIds = JSON.parse(studioRestriction.entityIds);\n\n  if (studioRestriction.mode === \"EXCLUDE\") {\n    return studios.filter(studio =&gt; !restrictedIds.includes(studio.id)); // \u26a0\ufe0f Direct only\n  }\n}\n</code></pre> <p>Bug #2: Studios are not checked for excluded Tags/Groups</p> <p>Expected: If Studio has an excluded Tag, the Studio itself should be hidden</p>"},{"location":"development/content-restrictions/#performers","title":"Performers","text":"<pre><code>async filterPerformersForUser(performers, _userId) {\n  // For now, return all performers\n  return performers;  // \u26a0\ufe0f NO FILTERING AT ALL\n}\n</code></pre> <p>Bug #3: Performers are NEVER filtered by user restrictions</p> <p>Expected: Performers should be filtered if they have excluded Tags</p>"},{"location":"development/content-restrictions/#empty-entity-filtering","title":"Empty Entity Filtering","text":"<p>After applying user restrictions, entities with no visible content are removed to prevent \"orphaned\" listings.</p>"},{"location":"development/content-restrictions/#filtering-order-dependencies","title":"Filtering Order (Dependencies)","text":"<pre><code>1. Galleries (no dependencies)\n   \u2514\u2500&gt; Keep if: image_count &gt; 0\n\n2. Groups (no dependencies, but tree traversal)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR has child groups with content\n\n3. Studios (depends on: Groups, Galleries)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR has visible groups OR has images OR has visible galleries\n\n4. Performers (depends on: Groups, Galleries)\n   \u2514\u2500&gt; Keep if: scene_count &gt; 0 OR image_count &gt; 0 OR in visible group OR has visible gallery\n\n5. Tags (depends on: ALL entities)\n   \u2514\u2500&gt; Keep if: attached to any visible entity OR has children with content\n</code></pre>"},{"location":"development/content-restrictions/#example-studio-empty-filtering","title":"Example: Studio Empty Filtering","text":"<pre><code>filterEmptyStudios(studios, visibleGroups, visibleGalleries) {\n  const visibleGroupIds = new Set(visibleGroups.map(g =&gt; g.id));\n  const visibleGalleryIds = new Set(visibleGalleries.map(g =&gt; g.id));\n\n  return studios.filter(studio =&gt; {\n    // Has scenes? Keep\n    if (studio.scene_count &amp;&amp; studio.scene_count &gt; 0) return true;\n\n    // Has images? Keep\n    if (studio.image_count &amp;&amp; studio.image_count &gt; 0) return true;\n\n    // Has visible groups? Keep\n    if (studio.groups?.some(g =&gt; visibleGroupIds.has(g.id))) return true;\n\n    // Has visible galleries? Keep\n    if (studio.galleries?.some(g =&gt; visibleGalleryIds.has(g.id))) return true;\n\n    // No content found\n    return false;\n  });\n}\n</code></pre> <p>Important: Empty entity filtering uses Stash's metadata counts (scene_count, image_count, etc.), which: - \u2705 Reflect Stash's view of the world - \u274c May NOT reflect user-restricted counts (if 100 scenes are all restricted, studio still shows scene_count=100)</p> <p>Potential Bug #4: Empty filtering may fail to remove entities because counts don't account for restrictions.</p> <p>Example: 1. Studio has 100 scenes 2. All 100 scenes have excluded Tag 3. Studio.scene_count = 100 (from Stash metadata) 4. Empty filter: <code>if (studio.scene_count &gt; 0)</code> \u2192 <code>true</code> \u2192 Studio NOT removed 5. User sees empty Studio in list</p>"},{"location":"development/content-restrictions/#caching-strategy","title":"Caching Strategy","text":""},{"location":"development/content-restrictions/#server-wide-cache-stashcachemanager","title":"Server-Wide Cache (StashCacheManager)","text":"<ul> <li>Scope: All entities for all users</li> <li>Storage: In-memory Map</li> <li>Refresh: Hourly + on-demand</li> <li>Invalidation: On cache refresh (version increment)</li> </ul>"},{"location":"development/content-restrictions/#per-user-filtered-cache-filteredentitycacheservice","title":"Per-User Filtered Cache (FilteredEntityCacheService)","text":"<ul> <li>Scope: Filtered entities per user</li> <li>Storage: In-memory Map with key <code>user:{userId}:{entityType}:v{cacheVersion}</code></li> <li>TTL: 1 hour</li> <li>Size Limit: 100MB total, 10MB per user</li> <li>Invalidation:</li> <li>User restrictions change \u2192 <code>invalidateUser(userId)</code></li> <li>Stash cache refresh \u2192 <code>invalidateAll()</code></li> </ul>"},{"location":"development/content-restrictions/#cache-flow","title":"Cache Flow","text":"<pre><code>Request: GET /api/library/scenes (User 5)\n  \u2193\n1. Get all scenes from StashCacheManager\n  \u2193\n2. Check FilteredEntityCacheService for user 5's filtered scenes\n  \u2193\n  \u251c\u2500 Cache HIT: Return cached filtered scenes\n  \u2502               \u2193\n  \u2502            4. Merge with fresh user data (ratings, watch history)\n  \u2502               \u2193\n  \u2502            5. Apply pagination, search, sort\n  \u2502\n  \u2514\u2500 Cache MISS:\n       \u2193\n     3a. Apply UserRestrictionService filters\n       \u2193\n     3b. Apply EmptyEntityFilterService\n       \u2193\n     3c. Store in FilteredEntityCacheService\n       \u2193\n     4. Merge with fresh user data...\n</code></pre> <p>Performance: - First request: ~500ms (compute filters) - Subsequent requests: ~50ms (cache hit) - Cache hit rate: 95%+</p>"},{"location":"development/content-restrictions/#api-endpoints","title":"API Endpoints","text":""},{"location":"development/content-restrictions/#admin-manage-user-restrictions","title":"Admin: Manage User Restrictions","text":""},{"location":"development/content-restrictions/#get-apiuseruseridrestrictions","title":"GET /api/user/:userId/restrictions","text":"<p>Auth: Admin only Response: <pre><code>{\n  \"restrictions\": [\n    {\n      \"id\": 1,\n      \"userId\": 5,\n      \"entityType\": \"tags\",\n      \"mode\": \"EXCLUDE\",\n      \"entityIds\": \"[\\\"123\\\",\\\"456\\\"]\",\n      \"restrictEmpty\": false\n    }\n  ]\n}\n</code></pre></p>"},{"location":"development/content-restrictions/#put-apiuseruseridrestrictions","title":"PUT /api/user/:userId/restrictions","text":"<p>Auth: Admin only Body: <pre><code>{\n  \"restrictions\": [\n    {\n      \"entityType\": \"tags\",\n      \"mode\": \"EXCLUDE\",\n      \"entityIds\": [\"123\", \"456\"],\n      \"restrictEmpty\": false\n    },\n    {\n      \"entityType\": \"studios\",\n      \"mode\": \"INCLUDE\",\n      \"entityIds\": [\"789\"],\n      \"restrictEmpty\": false\n    }\n  ]\n}\n</code></pre> Behavior: Replaces ALL existing restrictions for user</p>"},{"location":"development/content-restrictions/#delete-apiuseruseridrestrictions","title":"DELETE /api/user/:userId/restrictions","text":"<p>Auth: Admin only Response: <pre><code>{\n  \"success\": true,\n  \"message\": \"All content restrictions removed successfully\"\n}\n</code></pre></p>"},{"location":"development/content-restrictions/#client-library-queries","title":"Client: Library Queries","text":"<p>All library endpoints (<code>/api/library/scenes</code>, <code>/api/library/performers</code>, etc.) automatically apply: 1. User restrictions (if user is not ADMIN) 2. Empty entity filtering (if user is not ADMIN) 3. Caching (all users)</p> <p>Admins bypass restrictions and see all content.</p>"},{"location":"development/content-restrictions/#code-flow","title":"Code Flow","text":""},{"location":"development/content-restrictions/#scene-request-flow","title":"Scene Request Flow","text":"<pre><code>// server/controllers/library/scenes.ts\n\nexport const findScenes = async (req, res) =&gt; {\n  const userId = req.user.id;\n\n  // Step 1: Get ALL scenes from server-wide cache\n  let scenes = stashCacheManager.getAllScenes();\n\n  // Step 2: Determine if expensive filters needed\n  const requiresUserData = hasExpensiveFilters(filters);\n\n  if (requiresUserData) {\n    // OLD PATH: Merge user data for ALL scenes first (expensive)\n    scenes = await mergeScenesWithUserData(scenes, userId);\n    scenes = applyQuickSceneFilters(scenes, filters);\n    scenes = applyExpensiveSceneFilters(scenes, filters);\n\n    // Apply restrictions\n    if (req.user.role !== \"ADMIN\") {\n      scenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n    }\n\n    scenes = sortScenes(scenes, sortField, sortDirection);\n    const paginatedScenes = scenes.slice(startIndex, endIndex);\n\n  } else {\n    // NEW OPTIMIZED PATH: Filter/sort first, merge user data only for paginated scenes\n    scenes = applyQuickSceneFilters(scenes, filters);\n\n    // Apply restrictions\n    if (req.user.role !== \"ADMIN\") {\n      scenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n    }\n\n    scenes = sortScenes(scenes, sortField, sortDirection);\n    const paginatedScenes = scenes.slice(startIndex, endIndex);\n\n    // Merge user data ONLY for paginated scenes (huge performance win)\n    const scenesWithUserData = await mergeScenesWithUserData(paginatedScenes, userId);\n  }\n\n  return res.json({ scenes: scenesWithUserData });\n};\n</code></pre>"},{"location":"development/content-restrictions/#performer-request-flow","title":"Performer Request Flow","text":"<pre><code>// server/controllers/library/performers.ts\n\nexport const findPerformers = async (req, res) =&gt; {\n  const userId = req.user.id;\n  const cacheVersion = stashCacheManager.getCacheVersion();\n\n  // Step 1: Try cached filtered performers\n  let performers = filteredEntityCacheService.get(userId, \"performers\", cacheVersion);\n\n  if (performers === null) {\n    // Cache MISS: Compute filtered performers\n    performers = stashCacheManager.getAllPerformers();\n\n    // Apply user restrictions (non-admins only)\n    if (req.user.role !== \"ADMIN\") {\n      performers = await userRestrictionService.filterPerformersForUser(performers, userId);\n    }\n\n    // Filter empty performers (non-admins only)\n    if (req.user.role !== \"ADMIN\") {\n      // Get visible groups/galleries first\n      let allGalleries = stashCacheManager.getAllGalleries();\n      let allGroups = stashCacheManager.getAllGroups();\n\n      allGalleries = await userRestrictionService.filterGalleriesForUser(allGalleries, userId);\n      allGroups = await userRestrictionService.filterGroupsForUser(allGroups, userId);\n\n      const visibleGalleries = emptyEntityFilterService.filterEmptyGalleries(allGalleries);\n      const visibleGroups = emptyEntityFilterService.filterEmptyGroups(allGroups);\n\n      performers = emptyEntityFilterService.filterEmptyPerformers(\n        performers,\n        visibleGroups,\n        visibleGalleries\n      );\n    }\n\n    // Store in cache\n    filteredEntityCacheService.set(userId, \"performers\", performers, cacheVersion);\n  }\n\n  // Step 2: Merge with FRESH user data (ratings, stats)\n  performers = await mergePerformersWithUserData(performers, userId);\n\n  // Step 3: Apply filters, search, sort, paginate\n  // ...\n\n  return res.json({ performers });\n};\n</code></pre>"},{"location":"development/content-restrictions/#known-issues-edge-cases","title":"Known Issues &amp; Edge Cases","text":""},{"location":"development/content-restrictions/#fixed-bugs-january-2025","title":"Fixed Bugs (January 2025)","text":""},{"location":"development/content-restrictions/#1-fixed-empty-filtering-uses-stash-counts-not-restriction-aware","title":"1. \u2705 FIXED: Empty Filtering Uses Stash Counts (Not Restriction-Aware)","text":"<p>Original Issue: <code>scene_count</code>, <code>image_count</code> from Stash included ALL content, not user-visible content</p> <p>Example of Bug: - Studio has 100 scenes (all have excluded tag) - <code>studio.scene_count = 100</code> (from Stash) - Empty filter: <code>if (studio.scene_count &gt; 0)</code> \u2192 keeps Studio - User sees Studio with 0 visible scenes</p> <p>Root Cause: <code>EmptyEntityFilterService</code> methods (<code>filterEmptyTags</code>, <code>filterEmptyStudios</code>, <code>filterEmptyPerformers</code>) relied on Stash's metadata counts which don't account for user restrictions.</p> <p>Fix Applied: <pre><code>// BEFORE (broken)\nfilterEmptyStudios(studios, visibleGroups, visibleGalleries) {\n  return studios.filter(studio =&gt; {\n    if (studio.scene_count &amp;&amp; studio.scene_count &gt; 0) return true; // \u274c Wrong count\n    // ...\n  });\n}\n\n// AFTER (fixed)\nfilterEmptyStudios(studios, visibleGroups, visibleGalleries, visibleScenes?) {\n  // Build set of studios in visible scenes\n  const studiosInVisibleScenes = new Set&lt;string&gt;();\n  if (visibleScenes) {\n    for (const scene of visibleScenes) {\n      if (scene.studio) {\n        studiosInVisibleScenes.add(scene.studio.id);\n      }\n    }\n  }\n\n  return studios.filter(studio =&gt; {\n    // Check if studio appears in visible scenes\n    if (visibleScenes &amp;&amp; studiosInVisibleScenes.has(studio.id)) {\n      return true;\n    }\n    // Fallback to old logic if visibleScenes not provided (backward compatibility)\n    if (!visibleScenes &amp;&amp; studio.scene_count &amp;&amp; studio.scene_count &gt; 0) {\n      return true;\n    }\n    // ...\n  });\n}\n</code></pre></p> <p>Changes Made: 1. Added optional <code>visibleScenes</code> parameter to <code>filterEmptyTags</code>, <code>filterEmptyStudios</code>, <code>filterEmptyPerformers</code> 2. Methods now build Sets of entity IDs that appear in visible scenes 3. Check actual visibility instead of relying on Stash counts 4. Backward compatible - falls back to old logic if <code>visibleScenes</code> not provided</p> <p>Controllers Updated: - <code>server/controllers/library/tags.ts</code> - Filters scenes first, passes to empty filter - <code>server/controllers/library/studios.ts</code> - Filters scenes first, passes to empty filter - <code>server/controllers/library/performers.ts</code> - Filters scenes first, passes to empty filter</p> <p>Test Coverage: 5/5 integration tests passing, including: - \u2705 Studio that ONLY has content in excluded Group is hidden - \u2705 Performer that ONLY appears in excluded Group is hidden - \u2705 Tag that ONLY appears in excluded Group is hidden - \u2705 Full cascading integration test passes</p> <p>Performance Impact: +50-100ms on cache miss (minimal), 0ms on cache hit (cached results unaffected)</p> <p>Impact: CRITICAL BUG FIXED - Could expose illegal content in user's country</p>"},{"location":"development/content-restrictions/#2-fixed-broken-tag-cascade-logic","title":"2. \u2705 FIXED: Broken Tag Cascade Logic","text":"<p>Original Issue: <code>filterTagsForUser()</code> tried to check <code>tag.groups</code> and <code>tag.galleries</code> arrays which don't exist</p> <p>Root Cause: Stash tags only have count fields (<code>group_count</code>, <code>gallery_count</code>), not arrays of groups/galleries</p> <p>Fix Applied: Removed broken cascade logic (lines 259-309 in <code>UserRestrictionService.ts</code>). The correct approach is now handled by <code>EmptyEntityFilterService.filterEmptyTags()</code> which checks if tags appear on visible scenes/performers/studios.</p> <p>Impact: MEDIUM - Prevented incorrect filtering logic</p>"},{"location":"development/content-restrictions/#3-fixed-no-cascading-tag-restrictions-on-scenes","title":"3. \u2705 FIXED: No Cascading Tag Restrictions on Scenes","text":"<p>Original Issue: If Studio has excluded Tag, Scenes from that Studio were NOT hidden</p> <p>Status: Already working correctly! The <code>getSceneEntityIds()</code> method in <code>UserRestrictionService</code> implements full cascading:</p> <pre><code>case \"tags\": {\n  const tagIds = new Set&lt;string&gt;();\n\n  // Direct scene tags\n  (scene.tags || []).forEach((t: EntityWithId) =&gt; {\n    tagIds.add(String(t.id));\n  });\n\n  // Studio tags (cascading)\n  if (scene.studio?.tags) {\n    (scene.studio.tags as EntityWithId[]).forEach((t: EntityWithId) =&gt; {\n      tagIds.add(String(t.id));\n    });\n  }\n\n  // Performer tags (cascading)\n  if (scene.performers) {\n    scene.performers.forEach((performer) =&gt; {\n      if ((performer as any).tags) {\n        ((performer as any).tags as EntityWithId[]).forEach((t: EntityWithId) =&gt; {\n          tagIds.add(String(t.id));\n        });\n      }\n    });\n  }\n\n  return Array.from(tagIds);\n}\n</code></pre> <p>Verified: Integration tests confirm this works correctly</p>"},{"location":"development/content-restrictions/#edge-cases","title":"Edge Cases","text":""},{"location":"development/content-restrictions/#1-include-exclude-conflict","title":"1. Include + Exclude Conflict","text":"<p>Scenario: User has INCLUDE Studio A, but EXCLUDE Tag X. Studio A produces Scene with Tag X.</p> <p>Current Behavior: Include runs first, then Exclude removes scene \u2192 Scene hidden</p> <p>Question: Is this expected? Or should Include take precedence?</p>"},{"location":"development/content-restrictions/#2-restrictempty-flag","title":"2. restrictEmpty Flag","text":"<p>Current Use: Rarely used, purpose unclear</p> <p>Behavior: If <code>true</code>, items with NO entities of this type are also excluded</p> <p>Example: <pre><code>{\n  \"entityType\": \"tags\",\n  \"mode\": \"EXCLUDE\",\n  \"entityIds\": [\"123\"],\n  \"restrictEmpty\": true\n}\n</code></pre> Result: Exclude scenes with Tag \"123\" AND scenes with NO tags at all</p> <p>Question: Is this feature needed? If not, should be removed to reduce complexity.</p>"},{"location":"development/content-restrictions/#3-circular-group-hierarchies","title":"3. Circular Group Hierarchies","text":"<p>Scenario: Group A is child of Group B, Group B is child of Group A</p> <p>Current Behavior: <code>checkHasContent()</code> uses <code>visited</code> Set to prevent infinite loops</p> <p>Status: HANDLED \u2705</p>"},{"location":"development/content-restrictions/#4-tag-dag-complexity","title":"4. Tag DAG Complexity","text":"<p>Scenario: Tags form directed acyclic graph with multiple parents</p> <p>Current Behavior: Tag kept if ANY child has content (OR logic)</p> <p>Question: Is this correct? Or should ALL parents be required (AND logic)?</p>"},{"location":"development/content-restrictions/#testing-strategy","title":"Testing Strategy","text":""},{"location":"development/content-restrictions/#unit-tests-needed","title":"Unit Tests Needed","text":""},{"location":"development/content-restrictions/#1-userrestrictionservice","title":"1. UserRestrictionService","text":"<pre><code>describe('UserRestrictionService', () =&gt; {\n  describe('filterScenesForUser', () =&gt; {\n    it('should exclude scenes with excluded tags', () =&gt; {});\n    it('should exclude scenes from excluded studios', () =&gt; {});\n    it('should exclude scenes in excluded groups', () =&gt; {});\n    it('should cascade: exclude scenes if studio has excluded tag', () =&gt; {});\n    it('should cascade: exclude scenes if performer has excluded tag', () =&gt; {});\n    it('should apply INCLUDE filters first', () =&gt; {});\n    it('should apply EXCLUDE filters after INCLUDE', () =&gt; {});\n    it('should respect restrictEmpty flag', () =&gt; {});\n    it('should return all scenes for admin users', () =&gt; {});\n  });\n\n  describe('filterStudiosForUser', () =&gt; {\n    it('should exclude studios with excluded studio IDs', () =&gt; {});\n    it('should CASCADE: exclude studios with excluded tags', () =&gt; {});  // BUG\n    it('should CASCADE: exclude studios with excluded groups', () =&gt; {});  // BUG\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n\n  describe('filterPerformersForUser', () =&gt; {\n    it('should exclude performers with excluded tags', () =&gt; {});  // BUG (currently returns all)\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n\n  describe('filterTagsForUser', () =&gt; {\n    it('should exclude tags by ID', () =&gt; {});\n    it('should apply INCLUDE mode correctly', () =&gt; {});\n  });\n});\n</code></pre>"},{"location":"development/content-restrictions/#2-emptyentityfilterservice","title":"2. EmptyEntityFilterService","text":"<pre><code>describe('EmptyEntityFilterService', () =&gt; {\n  describe('filterEmptyGalleries', () =&gt; {\n    it('should remove galleries with no images', () =&gt; {});\n    it('should keep galleries with images', () =&gt; {});\n  });\n\n  describe('filterEmptyGroups', () =&gt; {\n    it('should remove groups with no scenes', () =&gt; {});\n    it('should keep groups with scenes', () =&gt; {});\n    it('should keep parent groups if child has scenes', () =&gt; {});\n    it('should handle circular group hierarchies', () =&gt; {});\n  });\n\n  describe('filterEmptyStudios', () =&gt; {\n    it('should remove studios with no scenes and no groups', () =&gt; {});\n    it('should keep studios with scenes', () =&gt; {});\n    it('should keep studios with visible groups', () =&gt; {});\n    it('should keep studios with visible galleries', () =&gt; {});\n    it('should use restriction-aware counts', () =&gt; {});  // BUG\n  });\n\n  describe('filterEmptyPerformers', () =&gt; {\n    it('should remove performers with no scenes and no images', () =&gt; {});\n    it('should keep performers with scenes', () =&gt; {});\n    it('should keep performers in visible groups', () =&gt; {});\n    it('should keep performers with visible galleries', () =&gt; {});\n  });\n\n  describe('filterEmptyTags', () =&gt; {\n    it('should remove tags not attached to any entities', () =&gt; {});\n    it('should keep tags with scenes', () =&gt; {});\n    it('should keep tags with images', () =&gt; {});\n    it('should keep parent tags if child has content', () =&gt; {});\n    it('should handle complex tag DAG', () =&gt; {});\n  });\n});\n</code></pre>"},{"location":"development/content-restrictions/#3-integration-tests","title":"3. Integration Tests","text":"<pre><code>describe('Content Restrictions Integration', () =&gt; {\n  it('should cascade: Tag \u2192 Studio \u2192 Scene \u2192 Performer', async () =&gt; {\n    // Setup:\n    // - Tag \"Extreme\" applied to Studio \"XYZ\"\n    // - Studio \"XYZ\" produces Scene A\n    // - Performer \"John\" only in Scene A\n    // - User excludes Tag \"Extreme\"\n\n    // Expected:\n    // - Tag \"Extreme\" hidden\n    // - Studio \"XYZ\" hidden\n    // - Scene A hidden\n    // - Performer \"John\" hidden (only in excluded scene)\n  });\n\n  it('should handle INCLUDE + EXCLUDE interaction', async () =&gt; {\n    // User INCLUDEs Studio A, EXCLUDEs Tag X\n    // Scene from Studio A has Tag X\n    // Expected: Scene hidden (exclude takes precedence after include)\n  });\n\n  it('should not filter admin users', async () =&gt; {});\n\n  it('should invalidate cache when restrictions change', async () =&gt; {});\n});\n</code></pre>"},{"location":"development/content-restrictions/#manual-test-scenarios","title":"Manual Test Scenarios","text":""},{"location":"development/content-restrictions/#scenario-1-basic-tag-exclusion","title":"Scenario 1: Basic Tag Exclusion","text":"<ol> <li>Admin creates restriction: User 5 excludes Tag \"Extreme\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u274c Tag \"Extreme\" not in tag list</li> <li>\u274c Scenes with Tag \"Extreme\" not in scene list</li> <li>\u274c Studios that ONLY produce \"Extreme\" tagged content are hidden</li> <li>\u274c Performers that ONLY appear in \"Extreme\" scenes are hidden</li> </ol>"},{"location":"development/content-restrictions/#scenario-2-cascading-tag-exclusion","title":"Scenario 2: Cascading Tag Exclusion","text":"<ol> <li>Admin creates restriction: User 5 excludes Tag \"Extreme\"</li> <li>Tag \"Extreme\" is applied to Studio \"XYZ Productions\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u274c Studio \"XYZ Productions\" is hidden</li> <li>\u274c ALL scenes from \"XYZ Productions\" are hidden</li> <li>\u274c Performers only in \"XYZ Productions\" scenes are hidden</li> </ol>"},{"location":"development/content-restrictions/#scenario-3-group-exclusion-with-cascading-fixed","title":"Scenario 3: Group Exclusion with Cascading \u2705 FIXED","text":"<ol> <li>Admin creates restriction: User 5 excludes Group \"Extreme Collection\"</li> <li>Studio \"ABC\" produces scenes in \"Extreme Collection\"</li> <li>Login as User 5</li> <li>Verify:</li> <li>\u2705 Group \"Extreme Collection\" not in group list</li> <li>\u2705 Scenes in \"Extreme Collection\" not in scene list</li> <li>\u2705 Studio \"ABC\" is hidden if ALL its scenes are in excluded group</li> </ol>"},{"location":"development/content-restrictions/#scenario-4-empty-studio-after-restriction-fixed","title":"Scenario 4: Empty Studio After Restriction \u2705 FIXED","text":"<ol> <li>Studio \"XYZ\" has 10 scenes</li> <li>ALL 10 scenes have Tag \"Extreme\"</li> <li>User 5 excludes Tag \"Extreme\"</li> <li>Verify:</li> <li>\u2705 Studio \"XYZ\" is NOT shown (all scenes hidden, studio is now \"empty\")</li> </ol>"},{"location":"development/content-restrictions/#summary","title":"Summary","text":""},{"location":"development/content-restrictions/#what-works-january-2025","title":"What Works (January 2025)","text":"<ul> <li>\u2705 Direct exclusions (Scene has Tag \u2192 Scene hidden)</li> <li>\u2705 INCLUDE/EXCLUDE modes</li> <li>\u2705 restrictEmpty flag</li> <li>\u2705 Caching for performance</li> <li>\u2705 FIXED: Empty entity filtering now checks actual visibility</li> <li>\u2705 FIXED: Tags, Studios, Performers that only exist in excluded content are hidden</li> <li>\u2705 Admin bypass</li> <li>\u2705 Tag cascading (Tag \u2192 Studio \u2192 Scene) - was already working</li> <li>\u2705 Tag cascading (Tag \u2192 Performer \u2192 Scene) - was already working</li> <li>\u2705 Group cascading (Group \u2192 Scene \u2192 Studio/Performer/Tag hidden if no other content)</li> </ul>"},{"location":"development/content-restrictions/#test-coverage","title":"Test Coverage","text":"<ul> <li>\u2705 315/315 tests passing</li> <li>\u2705 Comprehensive TDD integration tests in <code>server/services/__tests__/UserRestrictionService.integration.test.ts</code></li> <li>\u2705 Real-world \"Bestiality\" Group exclusion scenario tested</li> <li>\u2705 Full cascading verified:</li> <li>Scene filtering</li> <li>Studio filtering (studios with no visible scenes hidden)</li> <li>Performer filtering (performers with no visible scenes hidden)</li> <li>Tag filtering (tags with no visible content hidden)</li> </ul>"},{"location":"development/content-restrictions/#known-limitations","title":"Known Limitations","text":"<ul> <li>Performer direct restrictions not implemented (only cascade filtering works)</li> <li><code>restrictEmpty</code> flag edge cases not fully tested</li> </ul>"},{"location":"development/content-restrictions/#next-steps","title":"Next Steps","text":"<ol> <li>Monitor production for any edge cases</li> <li>Add more comprehensive unit tests for individual services</li> <li>Consider implementing direct performer restrictions if needed</li> <li>Document performance characteristics with large datasets</li> </ol> <p>Document Version: 2.0 Last Updated: 2025-01-20 Author: Claude Code</p>"},{"location":"development/regression-testing/","title":"Regression Testing Guide","text":"<p>This guide provides comprehensive regression testing procedures for Peek Stash Browser. Use this checklist before releasing new versions to ensure core functionality remains stable.</p> <p>Report Inaccuracies</p> <p>If you find any errors, outdated information, or inaccurate testing steps in this document, please report them via GitHub Issues with the label <code>documentation</code>. This helps keep the testing guide accurate and useful for everyone.</p>"},{"location":"development/regression-testing/#testing-environment-setup","title":"Testing Environment Setup","text":"<p>Before beginning regression testing:</p> <ol> <li>Test Data: Ensure your Stash library has:</li> <li>Multiple scenes with various file formats (MP4, MKV, etc.)</li> <li>Scenes with different durations (short &lt;5min, medium 5-30min, long &gt;30min)</li> <li>Multiple performers, studios, tags</li> <li>At least one gallery and one group/movie</li> <li>Network Conditions: Test on stable network connection</li> <li>Browsers: Test on at least two browsers (Chrome/Edge and Firefox recommended)</li> <li>Clean State: Clear browser cache and cookies before testing critical flows</li> </ol>"},{"location":"development/regression-testing/#test-execution-guidelines","title":"Test Execution Guidelines","text":"<ul> <li>Mark Pass/Fail: Check off tests as you complete them</li> <li>Document Failures: Note version, browser, and steps to reproduce any failures</li> <li>Severity Levels:</li> <li>Critical: Blocks core functionality (video playback, login, etc.)</li> <li>High: Major feature broken (search, playlists, filtering)</li> <li>Medium: Feature degraded but usable</li> <li>Low: Minor UI/UX issue</li> </ul>"},{"location":"development/regression-testing/#core-feature-tests","title":"Core Feature Tests","text":""},{"location":"development/regression-testing/#1-authentication-user-management","title":"1. Authentication &amp; User Management","text":""},{"location":"development/regression-testing/#11-first-time-setup","title":"1.1 First-Time Setup","text":"<p>Precondition: Fresh installation with no existing database</p> <ul> <li> Setup wizard appears on first access</li> <li> Can configure path mappings successfully</li> <li> Path mappings are validated (invalid paths show error)</li> <li> Default admin user is created</li> <li> After setup, redirects to login page</li> </ul>"},{"location":"development/regression-testing/#12-login-flow","title":"1.2 Login Flow","text":"<ul> <li> Can log in with valid credentials</li> <li> Invalid credentials show error message</li> <li> Session persists after page refresh</li> <li> JWT token expires after 24 hours (requires waiting or manual token expiry)</li> <li> Expired token redirects to login page</li> </ul>"},{"location":"development/regression-testing/#13-user-preferences","title":"1.3 User Preferences","text":"<p>Precondition: Logged in as any user</p> <ul> <li> Settings page loads without errors</li> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Preferences persist after logout/login</li> <li> Preferences apply immediately (theme change, etc.)</li> </ul>"},{"location":"development/regression-testing/#14-user-management-admin-only","title":"1.4 User Management (Admin Only)","text":"<p>Precondition: Logged in as admin user</p> <ul> <li> Can view list of all users</li> <li> Can create new user (Admin or User role)</li> <li> Can delete non-admin users</li> <li> Cannot delete own admin account</li> <li> Can change user passwords</li> <li> Can toggle user roles (Admin \u2194 User)</li> </ul>"},{"location":"development/regression-testing/#2-video-playback","title":"2. Video Playback","text":""},{"location":"development/regression-testing/#21-direct-playback-no-transcoding","title":"2.1 Direct Playback (No Transcoding)","text":"<p>Precondition: Select quality \"Direct\" in video player</p> <ul> <li> Video starts playing within 3 seconds</li> <li> Playback is smooth (no stuttering)</li> <li> Audio syncs with video</li> <li> Can pause and resume</li> <li> Can seek to different timestamps (beginning, middle, end)</li> <li> Volume control works</li> <li> Fullscreen toggle works</li> <li> Player shows correct duration</li> <li> Timeline/scrubber reflects current position</li> </ul>"},{"location":"development/regression-testing/#22-transcoded-playback-hls","title":"2.2 Transcoded Playback (HLS)","text":"<p>Precondition: Select quality \"720p\" or lower in video player</p> <ul> <li> HLS stream starts within 5 seconds</li> <li> Quality selector shows available qualities (360p, 480p, 720p, 1080p)</li> <li> Can switch between qualities mid-playback</li> <li> Playback resumes at same position after quality change</li> <li> Seeking works correctly (forward and backward)</li> <li> Far seeks (&gt;2 minutes ahead) restart transcoding session properly</li> <li> Segments load progressively (check Network tab)</li> <li> No missing segments or 404 errors</li> <li> Transcoding session cleans up after 90 seconds of inactivity</li> </ul> <p>Test Scenarios:</p> <ul> <li> Short video (&lt;5min): Plays from start to finish without errors</li> <li> Long video (&gt;30min): Can seek to middle and end without issues</li> <li> Multiple quality switches: Switch between 360p \u2192 720p \u2192 480p during playback</li> <li> Rapid seeking: Seek multiple times in quick succession (shouldn't crash)</li> </ul>"},{"location":"development/regression-testing/#23-resume-playback","title":"2.3 Resume Playback","text":"<p>Precondition: Previously watched a scene partially (not to completion)</p> <ul> <li> Scene shows resume position indicator (progress bar on thumbnail)</li> <li> Clicking scene shows \"Resume\" and \"Restart\" options</li> <li> \"Resume\" starts playback at last position (within 5 seconds accuracy)</li> <li> \"Restart\" starts playback at 0:00</li> <li> Resume position updates as video plays</li> <li> Watching to completion clears resume position</li> </ul>"},{"location":"development/regression-testing/#24-watch-history-tracking","title":"2.4 Watch History Tracking","text":"<ul> <li> Play count increments after watching</li> <li> Play duration accumulates correctly</li> <li> O-counter increments when marking scenes</li> <li> Last played timestamp updates</li> <li> Watch history appears in \"Recently Watched\" carousel (if implemented)</li> <li> Watch history persists across sessions</li> </ul>"},{"location":"development/regression-testing/#3-scene-search-filtering-and-sorting","title":"3. Scene Search, Filtering, and Sorting","text":""},{"location":"development/regression-testing/#31-search-functionality","title":"3.1 Search Functionality","text":"<p>Location: Scenes page, search bar at top</p> <ul> <li> Typing in search bar shows results in real-time</li> <li> Search matches scene titles</li> <li> Search matches performer names</li> <li> Search matches studio names</li> <li> Search matches tag names</li> <li> Empty search shows all scenes</li> <li> Search results update immediately (&lt;500ms)</li> <li> Clearing search resets to full library</li> </ul>"},{"location":"development/regression-testing/#32-filtering","title":"3.2 Filtering","text":"<p>Location: Scenes page, filter panel (sidebar or modal)</p>"},{"location":"development/regression-testing/#basic-filters","title":"Basic Filters","text":"<ul> <li> Filter by performer (single selection)</li> <li> Filter by multiple performers (AND logic)</li> <li> Filter by studio (single selection)</li> <li> Filter by tag (single selection)</li> <li> Filter by multiple tags (AND/OR logic based on settings)</li> <li> Filter by rating (min/max range)</li> <li> Filter by organized status (Yes/No/All)</li> <li> Filter by O-counter value (min/max range)</li> </ul>"},{"location":"development/regression-testing/#advanced-filters","title":"Advanced Filters","text":"<ul> <li> Filter by duration (min/max range in minutes)</li> <li> Filter by resolution (SD/HD/4K/etc.)</li> <li> Filter by interactive (Yes/No if applicable)</li> <li> Combining multiple filters applies AND logic correctly</li> <li> Clearing filters resets to full library</li> </ul>"},{"location":"development/regression-testing/#filter-presets","title":"Filter Presets","text":"<ul> <li> Can save current filter state as preset</li> <li> Can load saved filter preset</li> <li> Can delete saved filter preset</li> <li> Presets persist across sessions</li> <li> Default presets load on page visit (if configured)</li> </ul>"},{"location":"development/regression-testing/#hidden-items-filter","title":"Hidden Items Filter","text":"<ul> <li> Filter shows \"Show Hidden Items\" toggle</li> <li> Hidden scenes are excluded by default</li> <li> Toggling \"Show Hidden Items\" reveals hidden scenes</li> <li> Hidden scenes display with visual indicator (dimmed, badge, etc.)</li> </ul>"},{"location":"development/regression-testing/#33-sorting","title":"3.3 Sorting","text":"<p>Location: Scenes page, sort dropdown</p> <ul> <li> Sort by Date Added (newest first)</li> <li> Sort by Date Added (oldest first)</li> <li> Sort by Title (A-Z)</li> <li> Sort by Title (Z-A)</li> <li> Sort by Duration (longest first)</li> <li> Sort by Duration (shortest first)</li> <li> Sort by Rating (highest first)</li> <li> Sort by Rating (lowest first)</li> <li> Sort by Play Count (most played first)</li> <li> Sort by Random (different order on each load)</li> <li> Sort order persists when navigating away and back</li> <li> Sort works correctly with active filters</li> </ul>"},{"location":"development/regression-testing/#34-paginationinfinite-scroll","title":"3.4 Pagination/Infinite Scroll","text":"<p>Precondition: Library has &gt;40 scenes (default page size)</p> <ul> <li> Initial page loads first 40 scenes</li> <li> Scrolling to bottom loads next page automatically</li> <li> Loading indicator appears while fetching</li> <li> No duplicate scenes appear</li> <li> Can scroll through entire library without errors</li> <li> Scroll position maintained when navigating back from scene details</li> </ul>"},{"location":"development/regression-testing/#4-scene-grid-and-preview-playback","title":"4. Scene Grid and Preview Playback","text":""},{"location":"development/regression-testing/#41-scene-cards-display","title":"4.1 Scene Cards Display","text":"<ul> <li> Scene thumbnails load correctly</li> <li> Scene titles display correctly</li> <li> Scene metadata visible (duration, rating, date, etc.)</li> <li> Performer names display (truncated if too many)</li> <li> Studio name displays (if applicable)</li> <li> Watch history indicators show (resume bar, play count, O-counter)</li> <li> Cards have hover effects (preview, actions, etc.)</li> </ul>"},{"location":"development/regression-testing/#42-preview-playback-on-hover","title":"4.2 Preview Playback on Hover","text":"<p>Precondition: Preview feature enabled in settings</p> <ul> <li> Hovering over scene card for 2 seconds starts preview</li> <li> Preview plays short clip from scene</li> <li> Preview has no audio (or low volume)</li> <li> Preview loops continuously while hovering</li> <li> Moving mouse away stops preview immediately</li> <li> Preview quality matches user preference (Low/Medium/High)</li> <li> Preview doesn't interfere with clicking/navigation</li> <li> Multiple rapid hovers don't cause errors</li> </ul>"},{"location":"development/regression-testing/#43-scene-card-actions","title":"4.3 Scene Card Actions","text":"<p>Location: Hover over scene card or three-dot menu</p> <ul> <li> Can play scene directly (navigates to player page)</li> <li> Can add scene to playlist (opens playlist selector)</li> <li> Can mark scene as watched</li> <li> Can mark O-counter increment</li> <li> Can rate scene (opens rating modal or inline rating)</li> <li> Can hide scene (requires confirmation, scene disappears)</li> <li> Can view scene details (navigates to details page)</li> <li> Can download original file (triggers download)</li> </ul>"},{"location":"development/regression-testing/#5-playlists","title":"5. Playlists","text":""},{"location":"development/regression-testing/#51-playlist-creation","title":"5.1 Playlist Creation","text":"<p>Location: Playlists page or scene card menu</p> <ul> <li> Can create new playlist with name</li> <li> Can create new playlist with description (optional)</li> <li> Empty playlists are allowed</li> <li> Duplicate playlist names are allowed (or prevented based on requirements)</li> <li> New playlist appears in playlists list immediately</li> </ul>"},{"location":"development/regression-testing/#52-addingremoving-scenes","title":"5.2 Adding/Removing Scenes","text":"<ul> <li> Can add scene to playlist from scene card menu</li> <li> Can add multiple scenes to playlist in batch</li> <li> Can remove scene from playlist (via playlist view)</li> <li> Can reorder scenes in playlist (drag-and-drop or up/down buttons)</li> <li> Playlist item count updates immediately</li> <li> Playlist thumbnail updates to first scene</li> </ul>"},{"location":"development/regression-testing/#53-playlist-playback","title":"5.3 Playlist Playback","text":"<p>Precondition: Playlist has at least 3 scenes</p> <ul> <li> Clicking playlist plays first scene</li> <li> Auto-advances to next scene after current finishes</li> <li> \"Previous\" button goes to previous scene</li> <li> \"Next\" button goes to next scene</li> <li> Playlist progress indicator shows (e.g., \"2 of 5\")</li> <li> Can exit playlist playback and return later (resumes at last scene)</li> <li> Shuffle mode randomizes playback order</li> <li> Repeat mode restarts playlist after last scene</li> <li> Shuffle + Repeat combination works correctly</li> </ul>"},{"location":"development/regression-testing/#54-playlist-management","title":"5.4 Playlist Management","text":"<ul> <li> Can rename playlist</li> <li> Can edit playlist description</li> <li> Can delete playlist (requires confirmation)</li> <li> Deleting playlist doesn't delete scenes</li> <li> Can duplicate playlist</li> <li> Can export playlist as M3U (downloads file with relative paths)</li> <li> Can clear all scenes from playlist</li> </ul>"},{"location":"development/regression-testing/#6-performers-studios-tags-galleries-groups","title":"6. Performers, Studios, Tags, Galleries, Groups","text":""},{"location":"development/regression-testing/#61-performers-page","title":"6.1 Performers Page","text":"<ul> <li> Performers grid loads with thumbnails</li> <li> Can search performers by name</li> <li> Can filter performers by tag (if applicable)</li> <li> Can sort performers (name, scene count, etc.)</li> <li> Clicking performer navigates to performer details</li> <li> Performer details show bio, image, scene count</li> <li> Performer details show list of scenes</li> <li> Can filter scenes on performer page (same filters as main scenes page)</li> <li> Can rate performer (if rating feature exists)</li> <li> Can mark performer as favorite</li> </ul>"},{"location":"development/regression-testing/#62-studios-page","title":"6.2 Studios Page","text":"<ul> <li> Studios grid loads with logos/thumbnails</li> <li> Can search studios by name</li> <li> Can sort studios (name, scene count, etc.)</li> <li> Clicking studio navigates to studio details</li> <li> Studio details show scene count and scene list</li> <li> Can filter scenes on studio page</li> <li> Can rate studio (if rating feature exists)</li> <li> Can mark studio as favorite</li> </ul>"},{"location":"development/regression-testing/#63-tags-page","title":"6.3 Tags Page","text":"<ul> <li> Tags list loads (grid or list view)</li> <li> Can search tags by name</li> <li> Can sort tags (name, scene count, etc.)</li> <li> Clicking tag navigates to tag details or filters scenes</li> <li> Tag details show scene count and scene list</li> <li> Can filter scenes by tag combinations (multiple tags)</li> <li> Can hide/show tag categories (if hierarchical)</li> </ul>"},{"location":"development/regression-testing/#64-galleries-page","title":"6.4 Galleries Page","text":"<ul> <li> Galleries grid loads with cover images</li> <li> Can search galleries by title</li> <li> Can filter galleries by performer/studio/tag</li> <li> Clicking gallery navigates to gallery viewer</li> <li> Gallery viewer shows all images in grid or slideshow</li> <li> Can navigate images with arrow keys or swipe</li> <li> Can zoom images</li> <li> Can download images</li> <li> Can rate gallery (if rating feature exists)</li> </ul>"},{"location":"development/regression-testing/#65-groupsmovies-page","title":"6.5 Groups/Movies Page","text":"<ul> <li> Groups grid loads with cover images</li> <li> Can search groups by name</li> <li> Can filter groups by studio/performer/tag</li> <li> Clicking group navigates to group details</li> <li> Group details show scene list in correct order</li> <li> Can play group as playlist (scenes in order)</li> <li> Can reorder scenes in group (if editing is allowed)</li> </ul>"},{"location":"development/regression-testing/#7-ratings-and-favorites","title":"7. Ratings and Favorites","text":""},{"location":"development/regression-testing/#71-rating-scenes","title":"7.1 Rating Scenes","text":"<ul> <li> Can rate scene from 0-100 (or 0-5 stars)</li> <li> Rating updates immediately on scene card</li> <li> Rating persists across sessions</li> <li> Can change rating multiple times</li> <li> Can clear rating (set to null/unrated)</li> <li> Average rating shown alongside user rating (if Stash has community ratings)</li> </ul>"},{"location":"development/regression-testing/#72-favorite-scenes","title":"7.2 Favorite Scenes","text":"<ul> <li> Can mark scene as favorite (heart icon)</li> <li> Favorite status toggles on/off</li> <li> Favorite indicator visible on scene card</li> <li> Can filter scenes to show only favorites</li> <li> Favorites persist across sessions</li> </ul>"},{"location":"development/regression-testing/#73-rating-other-entities","title":"7.3 Rating Other Entities","text":"<p>Test for Performers, Studios, Tags, Galleries, Groups:</p> <ul> <li> Can rate each entity type</li> <li> Can favorite each entity type</li> <li> Ratings and favorites persist</li> <li> Can filter by rating/favorite status</li> </ul>"},{"location":"development/regression-testing/#8-user-settings-and-preferences","title":"8. User Settings and Preferences","text":""},{"location":"development/regression-testing/#81-general-settings","title":"8.1 General Settings","text":"<p>Location: Settings page \u2192 General Settings section</p> <ul> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can toggle preview autoplay on hover (On/Off)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Can change default sort order for scenes</li> <li> Can change scenes per page (if configurable)</li> <li> Settings save immediately or on \"Save\" button click</li> <li> Settings apply immediately (no page refresh required for most)</li> </ul>"},{"location":"development/regression-testing/#82-carousel-preferences","title":"8.2 Carousel Preferences","text":"<p>Location: Settings page \u2192 Homepage Carousels section</p> <ul> <li> Can toggle hardcoded carousels on/off (Continue Watching, High Rated, etc.)</li> <li> Can reorder carousels with up/down buttons</li> <li> Changes reflect on home page after save</li> </ul>"},{"location":"development/regression-testing/#83-custom-carousels","title":"8.3 Custom Carousels","text":"<p>Location: Settings page \u2192 Homepage Carousels \u2192 Create Carousel</p> <ul> <li> Can create custom carousel with title and icon</li> <li> Can add filter rules (performers, tags, rating, etc.)</li> <li> Preview shows matching scenes before save</li> <li> Save is disabled until preview succeeds</li> <li> Can edit existing custom carousel</li> <li> Can delete custom carousel</li> <li> Custom carousel appears on homepage</li> <li> Maximum 15 custom carousels enforced</li> <li> Filter options are sorted alphabetically</li> <li> Scene titles use basename fallback when no title</li> </ul>"},{"location":"development/regression-testing/#84-navigation-preferences","title":"8.4 Navigation Preferences","text":"<p>Location: Settings page \u2192 Navigation Settings section</p> <ul> <li> Can toggle sidebar visibility (always visible, collapsible, hidden)</li> <li> Can toggle top bar elements (show/hide search, user menu, etc.)</li> <li> Can configure keyboard shortcuts (if customizable)</li> </ul>"},{"location":"development/regression-testing/#85-filter-presets","title":"8.5 Filter Presets","text":"<p>Location: Settings page \u2192 Filter Presets section</p> <ul> <li> Can view saved filter presets</li> <li> Can edit filter preset name/description</li> <li> Can delete filter preset</li> <li> Can set default filter preset (auto-loads on scenes page)</li> <li> Can export/import filter presets (JSON file)</li> </ul>"},{"location":"development/regression-testing/#86-hidden-items-user-feature","title":"8.6 Hidden Items (User Feature)","text":"<p>Location: Settings page \u2192 link to Hidden Items page</p> <ul> <li> Can hide individual scenes, performers, studios, tags, galleries, groups</li> <li> Hidden items link in Settings navigates to Hidden Items page</li> <li> Hidden Items page shows all hidden entities grouped by type</li> <li> Can unhide items from Hidden Items page</li> <li> \"Show Hidden Items\" toggle on filter panels reveals hidden content</li> <li> Hidden items persist across sessions</li> </ul>"},{"location":"development/regression-testing/#86-content-restrictions-admin-feature","title":"8.6 Content Restrictions (Admin Feature)","text":"<p>Location: User Management page \u2192 Content Restrictions modal (admin only)</p> <p>Note: This is an admin-only feature for managing per-user content restrictions, separate from user-level hidden items.</p> <ul> <li> Admin can access Content Restrictions modal from User Management</li> <li> Can set INCLUDE mode (user sees only specified groups/tags/studios/galleries)</li> <li> Can set EXCLUDE mode (user doesn't see specified groups/tags/studios/galleries)</li> <li> Can select multiple groups, tags, studios, galleries for restriction</li> <li> Restrictions apply only to the selected user</li> <li> Restrictions apply immediately across all pages for that user</li> <li> Restrictions persist across sessions</li> <li> Can clear all restrictions for a user</li> </ul>"},{"location":"development/regression-testing/#9-keyboard-navigation-and-shortcuts","title":"9. Keyboard Navigation and Shortcuts","text":""},{"location":"development/regression-testing/#91-global-shortcuts","title":"9.1 Global Shortcuts","text":"<p>Precondition: Focus on main application (not in text input)</p> <ul> <li> <code>Space</code> or <code>K</code> pauses/plays video (in player)</li> <li> <code>F</code> toggles fullscreen (in player)</li> <li> <code>M</code> toggles mute (in player)</li> <li> <code>Left/Right</code> arrow keys seek video (\u00b15 seconds)</li> <li> <code>Up/Down</code> arrow keys adjust volume (\u00b15%)</li> <li> <code>J/L</code> keys seek video (\u00b110 seconds)</li> <li> <code>Home/End</code> keys jump to start/end of video</li> <li> <code>Shift+&gt;/Shift+&lt;</code> adjust playback speed</li> <li> <code>Shift+N/Shift+P</code> next/previous scene in playlist</li> <li> Media hardware keys (Play/Pause, FastForward, Rewind, TrackNext, TrackPrevious)</li> <li> <code>0-9</code> seek to percentage (1 = 10%, 5 = 50%, etc.)</li> <li> <code>Esc</code> exits fullscreen or closes modals</li> <li> <code>/</code> focuses search bar</li> <li> <code>?</code> opens keyboard shortcuts help modal (if implemented)</li> </ul>"},{"location":"development/regression-testing/#92-scene-grid-navigation","title":"9.2 Scene Grid Navigation","text":"<p>Precondition: Focus on scenes grid (not in search/filter)</p> <ul> <li> Arrow keys navigate between scene cards</li> <li> <code>Enter</code> plays selected scene</li> <li> <code>A</code> adds selected scene to playlist</li> <li> <code>H</code> hides selected scene</li> <li> <code>R</code> opens rating modal for selected scene</li> <li> Tab/Shift+Tab navigates focusable elements</li> </ul>"},{"location":"development/regression-testing/#93-tv-mode-navigation","title":"9.3 TV Mode Navigation","text":"<p>Precondition: TV Mode enabled (if applicable)</p> <ul> <li> D-pad navigation works (arrow keys simulate remote)</li> <li> Enter/Select button activates items</li> <li> Back button exits player or modals</li> <li> Focus indicators are clearly visible</li> <li> No keyboard traps (can always navigate out)</li> </ul>"},{"location":"development/regression-testing/#10-server-settings-and-admin-features","title":"10. Server Settings and Admin Features","text":""},{"location":"development/regression-testing/#101-server-information","title":"10.1 Server Information","text":"<p>Precondition: Logged in as admin</p> <p>Location: Settings page \u2192 Server tab</p> <ul> <li> Server version displayed correctly (matches package.json)</li> <li> Stash server URL displayed</li> <li> Stash server version displayed (fetched from Stash API)</li> <li> Database location displayed</li> <li> Cache directory location displayed</li> <li> Uptime displayed (time since server start)</li> </ul>"},{"location":"development/regression-testing/#102-cache-management","title":"10.2 Cache Management","text":"<p>Location: Settings page \u2192 Server tab \u2192 Cache section</p> <ul> <li> Can view cache status (last refresh time, entity counts)</li> <li> Can manually refresh cache (button triggers refresh)</li> <li> Cache refresh shows progress indicator</li> <li> Cache refresh completes without errors</li> <li> Scene count updates after cache refresh</li> <li> New scenes from Stash appear after cache refresh</li> </ul>"},{"location":"development/regression-testing/#103-path-mappings","title":"10.3 Path Mappings","text":"<p>Location: Settings page \u2192 Server tab \u2192 Path Mappings section</p> <ul> <li> Can view existing path mappings (Stash path \u2192 Peek path)</li> <li> Can add new path mapping</li> <li> Can edit existing path mapping</li> <li> Can delete path mapping (requires confirmation)</li> <li> Invalid paths show validation error</li> <li> Path mappings apply immediately (no restart required)</li> <li> Test path translation feature works (if exists)</li> </ul>"},{"location":"development/regression-testing/#104-update-checker","title":"10.4 Update Checker","text":"<p>Location: Settings page \u2192 Server tab \u2192 Updates section</p> <ul> <li> Current version displayed</li> <li> \"Check for updates\" button queries GitHub API</li> <li> If update available, shows banner with version number and changelog link</li> <li> If no update, shows \"Up to date\" message</li> <li> Clicking changelog link opens GitHub release page in new tab</li> </ul>"},{"location":"development/regression-testing/#11-error-handling-and-edge-cases","title":"11. Error Handling and Edge Cases","text":""},{"location":"development/regression-testing/#111-network-errors","title":"11.1 Network Errors","text":"<p>Test Scenarios:</p> <ul> <li> Stash server offline: App shows error message, doesn't crash</li> <li> Stash server slow: Loading indicators appear, requests timeout gracefully</li> <li> Invalid Stash API key: Setup wizard or settings page shows authentication error</li> <li> Network interruption during playback: Video pauses, shows buffering indicator, resumes when network recovers</li> </ul>"},{"location":"development/regression-testing/#112-invalid-data-handling","title":"11.2 Invalid Data Handling","text":"<p>Test Scenarios:</p> <ul> <li> Scene with missing file: Shows error message instead of playing, doesn't crash app</li> <li> Scene with invalid path mapping: Shows error message, allows user to update path mappings</li> <li> Corrupted video file: FFmpeg fails gracefully, shows error message</li> <li> Scene with no duration: Displays \"Unknown duration\" or defaults to 0, doesn't crash</li> <li> Scene with no title: Displays filename or \"Untitled\" instead of crashing</li> </ul>"},{"location":"development/regression-testing/#113-permission-errors","title":"11.3 Permission Errors","text":"<p>Test Scenarios:</p> <ul> <li> Non-admin tries to access admin features: Redirected or shown \"Access Denied\" message</li> <li> Expired JWT token: Redirected to login page with message \"Session expired\"</li> <li> Invalid JWT token: Redirected to login page, doesn't crash</li> </ul>"},{"location":"development/regression-testing/#114-database-errors","title":"11.4 Database Errors","text":"<p>Test Scenarios (requires simulating DB issues):</p> <ul> <li> Database locked: Shows error message, retries operation</li> <li> Database migration fails: Server logs error, shows setup wizard or maintenance page</li> <li> Database corruption: Server detects and shows recovery instructions</li> </ul>"},{"location":"development/regression-testing/#115-browser-compatibility","title":"11.5 Browser Compatibility","text":"<p>Test on Multiple Browsers:</p> <ul> <li> Chrome/Edge: All features work</li> <li> Firefox: All features work</li> <li> Safari: All features work (if targeting macOS/iOS)</li> <li> Mobile browsers: Responsive layout, touch controls work</li> </ul>"},{"location":"development/regression-testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/regression-testing/#121-load-times","title":"12.1 Load Times","text":"<ul> <li> Initial page load: &lt;3 seconds on broadband connection</li> <li> Scene grid load: &lt;2 seconds for first 40 scenes</li> <li> Video player load: &lt;3 seconds to first frame (direct playback)</li> <li> HLS stream start: &lt;5 seconds to first frame (transcoded playback)</li> <li> Search/filter response: &lt;500ms for typical library (&lt;10,000 scenes)</li> </ul>"},{"location":"development/regression-testing/#122-resource-usage","title":"12.2 Resource Usage","text":"<p>Precondition: Monitor browser DevTools Performance tab</p> <ul> <li> Memory usage: No memory leaks during 30-minute session</li> <li> CPU usage: &lt;20% CPU during idle browsing (not playing video)</li> <li> Network usage: Only necessary requests (no redundant API calls)</li> </ul>"},{"location":"development/regression-testing/#123-concurrent-sessions","title":"12.3 Concurrent Sessions","text":"<p>Test Scenarios:</p> <ul> <li> Multiple browser tabs: Can play different videos in 2+ tabs simultaneously</li> <li> Multiple users: 2+ users can log in and use app concurrently without interference</li> <li> Transcoding sessions: Multiple concurrent HLS streams don't exhaust server resources</li> </ul>"},{"location":"development/regression-testing/#mobile-and-responsive-testing","title":"Mobile and Responsive Testing","text":""},{"location":"development/regression-testing/#131-mobile-layout","title":"13.1 Mobile Layout","text":"<p>Precondition: Test on mobile device or browser DevTools mobile emulation</p> <ul> <li> Scenes grid adapts to narrow viewport (1-2 columns)</li> <li> Navigation menu becomes hamburger or bottom nav</li> <li> Scene cards remain readable and tappable (no tiny text/buttons)</li> <li> Video player controls are touch-friendly (large buttons)</li> <li> Search bar and filters accessible on mobile</li> <li> Settings page scrollable and functional</li> </ul>"},{"location":"development/regression-testing/#132-touch-controls","title":"13.2 Touch Controls","text":"<ul> <li> Tap scene card to play</li> <li> Swipe to scroll scene grid</li> <li> Pinch to zoom images (in galleries)</li> <li> Tap player controls to pause/play/seek</li> <li> Double-tap player to toggle fullscreen</li> <li> Swipe to navigate between scenes in playlist (if applicable)</li> </ul>"},{"location":"development/regression-testing/#post-release-monitoring","title":"Post-Release Monitoring","text":"<p>After deploying a new version to production:</p> <ol> <li>Check server logs: Look for errors or warnings in first 24 hours</li> <li>Monitor user reports: Track GitHub issues for bug reports</li> <li>Check update notifications: Verify users see update banner if applicable</li> <li>Database migrations: Confirm migrations ran successfully on user instances</li> <li>Performance: Monitor server resource usage (CPU, memory, disk) for anomalies</li> </ol>"},{"location":"development/regression-testing/#test-report-template","title":"Test Report Template","text":"<p>After completing regression testing, document results:</p> <pre><code>**Peek Stash Browser - Regression Test Report**\n\n**Version Tested**: 1.X.X\n**Test Date**: YYYY-MM-DD\n**Tester**: [Your Name]\n**Environment**:\n- Docker Version: X.X.X\n- Browser(s): Chrome X.X, Firefox X.X\n- Stash Version: X.X.X\n- Test Library Size: X scenes, Y performers, Z studios\n\n**Test Results Summary**:\n- Total Tests: X\n- Passed: X\n- Failed: X\n- Skipped: X (with reason)\n\n**Critical Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**High Priority Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**Medium/Low Priority Issues**:\n- [Brief list]\n\n**Recommendation**: \u2705 Ready for release / \u26a0\ufe0f Release with known issues / \u274c Do not release\n\n**Additional Notes**:\n[Any observations, performance notes, or suggestions]\n</code></pre>"},{"location":"development/regression-testing/#automation-recommendations","title":"Automation Recommendations","text":"<p>For future improvements, consider automating these tests:</p> <ul> <li>Unit tests: Core utility functions (path mapping, filter logic, etc.)</li> <li>Integration tests: API endpoints with mock data</li> <li>End-to-end tests: Playwright or Cypress for critical user flows (login, playback, search)</li> <li>Visual regression tests: Screenshot comparison for UI changes</li> <li>Performance tests: Lighthouse CI for page load metrics</li> </ul>"},{"location":"development/regression-testing/#updating-this-document","title":"Updating This Document","text":"<p>As new features are added, update this regression testing guide:</p> <ol> <li>Add new test sections for new features (e.g., \"14. Social Features\")</li> <li>Update existing tests if feature behavior changes</li> <li>Archive obsolete tests (mark as \"Deprecated\" if removed)</li> <li>Keep test steps concise and actionable</li> <li>Include preconditions and expected results for clarity</li> </ol> <p>Last Updated: 2025-01-21 (Version 1.6.0)</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Peek Stash Browser is configured through environment variables and the setup wizard. This page documents all available configuration options.</p>"},{"location":"getting-started/configuration/#stash-connection-setup-wizard","title":"Stash Connection (Setup Wizard)","text":"<p>As of v2.0, Stash connection details are configured via the Setup Wizard and stored in the database:</p> <ul> <li>Stash URL: Your Stash GraphQL endpoint (e.g., <code>http://192.168.1.100:9999/graphql</code>)</li> <li>Stash API Key: API key from Stash Settings \u2192 Security</li> </ul> <p>The wizard runs automatically on first access. No environment variables needed for Stash connection!</p> <p>Upgrading from v1.x? Your existing <code>STASH_URL</code> and <code>STASH_API_KEY</code> environment variables will auto-migrate to the database on first start. You can remove them from your container configuration after successful migration.</p>"},{"location":"getting-started/configuration/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>JWT_SECRET</code> JWT signing key Generate with <code>openssl rand -base64 32</code>"},{"location":"getting-started/configuration/#generating-jwt-secret","title":"Generating JWT Secret","text":"<p>Linux/macOS/unRAID: <pre><code>openssl rand -base64 32\n</code></pre></p> <p>Windows PowerShell: <pre><code>$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n[Convert]::ToBase64String($bytes)\n</code></pre></p>"},{"location":"getting-started/configuration/#optional-environment-variables","title":"Optional Environment Variables","text":"<p>These settings have sensible defaults but can be customized:</p> Variable Description Default Notes <code>DATABASE_URL</code> SQLite database file <code>file:/app/data/peek-stash-browser.db</code> Path inside container <code>CONFIG_DIR</code> App data directory <code>/app/data</code> Database + HLS cache <code>TMP_DIR</code> Transcoding temp directory <code>/app/tmp</code> Needs fast I/O <code>NODE_ENV</code> Environment mode <code>production</code> <code>development</code> or <code>production</code>"},{"location":"getting-started/configuration/#video-streaming-v20","title":"Video Streaming (v2.0+)","text":"<p>As of v2.0, Peek streams video directly through Stash - no local media access required!</p> <ul> <li>Videos are proxied through the Stash API</li> <li>No media volume mounts needed</li> <li>No path mapping configuration required</li> <li>Simpler container setup</li> </ul> <p>This is a significant simplification from v1.x which required mounting media directories and configuring path mappings.</p>"},{"location":"getting-started/configuration/#security-settings","title":"Security Settings","text":"Variable Description Default When to Use <code>SECURE_COOKIES</code> Enable secure cookie flag <code>false</code> Set to <code>true</code> when using HTTPS reverse proxy <p>Security Best Practices</p> <ul> <li>Set a strong <code>JWT_SECRET</code> during installation (required)</li> <li>Set <code>SECURE_COOKIES=true</code> when using HTTPS</li> <li>Don't expose Peek directly to the internet without a reverse proxy</li> <li>Admin credentials are created during setup wizard (no default passwords)</li> <li>Stash API key is stored securely in the database (not in environment variables)</li> </ul>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#minimal-production-configuration-v20","title":"Minimal Production Configuration (v2.0+)","text":"<pre><code># Required\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Stash connection configured via Setup Wizard (stored in database)\n# All other settings use defaults\n</code></pre>"},{"location":"getting-started/configuration/#complete-production-configuration","title":"Complete Production Configuration","text":"<pre><code># Authentication (Required)\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Database (Optional - defaults shown)\nDATABASE_URL=file:/app/data/peek-stash-browser.db\nCONFIG_DIR=/app/data\n\n# Security (Optional)\nSECURE_COOKIES=true\n\n# Environment (Optional)\nNODE_ENV=production\n\n# Stash connection configured via Setup Wizard (stored in database)\n</code></pre>"},{"location":"getting-started/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code># Authentication\nJWT_SECRET=dev-secret-change-in-production\n\n# Database (local SQLite file)\nDATABASE_URL=file:./data/peek-db.db\n\n# Development\nNODE_ENV=development\n\n# Stash connection configured via Setup Wizard\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-example","title":"Docker Compose Example","text":"<pre><code>services:\n  peek:\n    image: carrotwaxr/peek-stash-browser:latest\n    container_name: peek-stash-browser\n    ports:\n      - \"6969:80\"\n    volumes:\n      - peek-data:/app/data\n    environment:\n      - JWT_SECRET=${JWT_SECRET}\n      # Optional\n      - NODE_ENV=production\n      - SECURE_COOKIES=false\n    restart: unless-stopped\n\nvolumes:\n  peek-data:\n</code></pre> <p>Stash Connection</p> <p>Stash URL and API key are configured via the Setup Wizard on first access and stored in the database.</p>"},{"location":"getting-started/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"getting-started/configuration/#cannot-connect-to-stash","title":"Cannot Connect to Stash","text":"<p>Check:</p> <ul> <li>Stash URL is accessible from the Peek container</li> <li>Stash API key is correct and not expired</li> <li>Stash GraphQL API is enabled</li> </ul> <p>Test connectivity:</p> <pre><code>docker exec peek-stash-browser curl http://your-stash-ip:9999/graphql\n</code></pre> <p>You can update Stash connection details in Settings \u2192 Stash Configuration.</p>"},{"location":"getting-started/configuration/#videos-wont-play","title":"Videos Won't Play","text":"<p>Check:</p> <ul> <li>Stash connection is configured correctly (Settings \u2192 Stash Configuration)</li> <li>Stash server is running and accessible</li> <li>The scene exists in Stash and has a valid video file</li> </ul>"},{"location":"getting-started/configuration/#authentication-issues","title":"Authentication Issues","text":"<p>Check:</p> <ul> <li><code>JWT_SECRET</code> is set</li> <li><code>SECURE_COOKIES</code> matches your HTTP/HTTPS setup</li> <li>Database is writable</li> </ul>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Peek Stash Browser can be deployed in several ways depending on your needs and environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Peek, ensure you have:</p> <ul> <li>Stash Server running with GraphQL API enabled</li> <li>Docker installed (Docker Compose only needed for development)</li> <li>Network access from container to Stash server</li> </ul>"},{"location":"getting-started/installation/#stash-configuration","title":"Stash Configuration","text":"<ol> <li>Enable API in Stash settings</li> <li>Generate API key in Settings \u2192 Security</li> <li>Note GraphQL endpoint (usually <code>http://stash-ip:9999/graphql</code>)</li> <li>Ensure network access from your Docker host to Stash</li> </ol> <p>Note: As of v2.0, Peek streams video directly through Stash - no media volume mounts required!</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#option-1-unraid","title":"Option 1: unRAID","text":""},{"location":"getting-started/installation/#community-applications-recommended","title":"Community Applications (Recommended)","text":"<p>Easiest Installation Method</p> <p>This is the recommended method for unRAID users - everything is pre-configured!</p> <ol> <li>Install from Community Applications:</li> <li>Search for \"Peek Stash Browser\" in unRAID's Community Applications</li> <li>Click install and configure your settings</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"getting-started/installation/#manual-template-installation","title":"Manual Template Installation","text":"<p>If Peek isn't available in Community Applications yet, or if you want to install the latest template manually:</p> <p>Step 1: Download the template file</p> <p>Get the template from GitHub:</p> <pre><code>https://raw.githubusercontent.com/carrotwaxr/peek-stash-browser/master/unraid-template.xml\n</code></pre> <p>Step 2: Install the template</p> <p>=== \"USB/Boot Share Exported (Easier)\" 1. Copy <code>unraid-template.xml</code> to your network share at: <code>\\\\your.server.ip.address\\flash\\config\\plugins\\dockerMan\\templates-user</code> 2. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>=== \"USB/Boot Share NOT Exported\" 1. Copy <code>unraid-template.xml</code> to any accessible share (e.g., <code>\\\\your.server.ip.address\\downloads</code>) 2. SSH into your unRAID server 3. Move the template file: <code>bash        cp /mnt/user/downloads/unraid-template.xml /boot/config/plugins/dockerMan/templates-user/</code> 4. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>No Restart Required</p> <p>You do NOT need to restart Docker or unRAID - the template is picked up automatically.</p> <p>Step 3: Configure the container</p> <ol> <li>Go to Docker tab \u2192 Add Container</li> <li>Select \"peek-stash-browser\" from User Templates dropdown</li> <li>Configure required settings:</li> <li>JWT Secret: Generate with <code>openssl rand -hex 32</code> in unRAID terminal</li> <li>App Data Directory: Path for Peek data (e.g., <code>/mnt/user/appdata/peek-stash-browser</code>)</li> <li>Click Apply</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> <li>Complete the Setup Wizard to connect to your Stash server</li> </ol>"},{"location":"getting-started/installation/#option-2-docker-single-container","title":"Option 2: Docker (Single Container)","text":"<p>Recommended for Production</p> <p>Single container includes everything - frontend, backend, and database</p> <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Volume Mounts:</p> <ul> <li><code>peek-data</code> - Database and app data (Docker named volume)</li> </ul> <p>Required Environment Variables:</p> <ul> <li><code>JWT_SECRET</code> - Secret for JWT authentication (recommended to set manually)</li> </ul> <p>Note: Stash URL and API key are configured via the Setup Wizard on first access - no environment variables needed!</p> <p>See Configuration Guide for all environment variables.</p>"},{"location":"getting-started/installation/#windows-examples","title":"Windows Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret (one-time)\n$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n$jwt = [Convert]::ToBase64String($bytes)\n\n# Run Peek\ndocker run -d `\n    --name peek-stash-browser `\n    -p 6969:80 `\n    -v peek-data:/app/data `\n    -e JWT_SECRET=$jwt `\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#linuxmacos-examples","title":"Linux/macOS Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate a secure random JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n    --name peek-stash-browser \\\n    -p 6969:80 \\\n    -v peek-data:/app/data \\\n    -e JWT_SECRET=\"${JWT_SECRET}\" \\\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Follow logs in real-time\ndocker logs -f peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#option-3-docker-compose-development","title":"Option 3: Docker Compose (Development)","text":"<p>For Development Only</p> <p>This method is for development with hot reloading enabled</p> <ol> <li>Clone and setup:</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n</code></pre> <ol> <li>Configure environment (edit <code>.env</code>):</li> </ol> <pre><code>JWT_SECRET=your-dev-secret-here\nDATABASE_URL=file:./data/peek-stash-browser.db\n</code></pre> <ol> <li>Start services:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Access the app: Open <code>http://localhost:6969</code></li> </ol>"},{"location":"getting-started/installation/#first-access-setup-wizard","title":"First Access &amp; Setup Wizard","text":"<p>After installation, access Peek in your browser for the first-time setup:</p> <ol> <li>Navigate to <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 4-step setup wizard:</li> <li>Welcome: Introduction to Peek</li> <li>Create Admin: Set your admin username and password</li> <li>Connect to Stash: Enter your Stash URL and API key</li> <li>Complete: Setup finished!</li> <li>Login with your newly created admin credentials</li> </ol>"},{"location":"getting-started/installation/#updating-peek","title":"Updating Peek","text":""},{"location":"getting-started/installation/#check-for-updates","title":"Check for Updates","text":"<p>Peek includes a built-in update checker:</p> <ol> <li>Navigate to Settings \u2192 Server Settings</li> <li>Scroll to the Version Information section</li> <li>Click Check for Updates</li> </ol> <p>The system will query GitHub for new releases and notify you if an update is available.</p>"},{"location":"getting-started/installation/#update-procedure","title":"Update Procedure","text":"<p>To update your Docker container to the latest version:</p> unRAIDLinux/macOSWindows <p>Easiest method: Click Force Update in the Docker tab to pull the latest image and restart.</p> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d `\n  --name peek-stash-browser `\n  -p 6969:80 `\n  -v peek-data:/app/data `\n  -e JWT_SECRET=$jwt `\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Your data persists across updates</p> <p>Database, user settings, Stash configuration, and playlists are stored in the <code>peek-data</code> volume and will not be lost.</p>"},{"location":"getting-started/installation/#version-pinning","title":"Version Pinning","text":"<p>To use a specific version instead of <code>:latest</code>:</p> <pre><code># Pull and use specific version\ndocker pull carrotwaxr/peek-stash-browser:1.0.0\ndocker run ... carrotwaxr/peek-stash-browser:1.0.0\n</code></pre> <p>Available versions: GitHub Releases</p>"},{"location":"getting-started/installation/#port-configuration","title":"Port Configuration","text":"Environment Port Service Description Production <code>6969</code> Complete App nginx serves frontend + proxies API Development <code>6969</code> Frontend UI Vite dev server with hot reloading Development <code>8000</code> Backend API Express server (internal Docker network) <p>Production uses only one port!</p> <p>Production deployment exposes only port <code>6969</code> - nginx handles everything internally</p>"},{"location":"getting-started/installation/#hardware-recommendations","title":"Hardware Recommendations","text":"Component Minimum Recommended CPU 2 cores 4+ cores (for multiple transcoding streams) RAM 2GB 4GB+ Storage SSD for database SSD for database, network storage for media Network 100 Mbps Gigabit (for 4K content)"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configure environment variables</li> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get Peek up and running in 5 minutes!</p>"},{"location":"getting-started/quick-start/#step-1-install-peek","title":"Step 1: Install Peek","text":"Docker (Fastest)unRAIDDocker Compose <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/media:/app/media:ro \\\n  -v peek-data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Search \"Peek Stash Browser\" in Community Applications</li> <li>Click Install</li> <li>Configure Stash URL and API key</li> <li>Generate JWT secret: <code>openssl rand -hex 32</code></li> <li>Click Apply</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n# Edit .env with your settings\ndocker-compose up -d\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-setup-wizard","title":"Step 2: Setup Wizard","text":"<ol> <li>Open browser: <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 5-step setup wizard:</li> <li>Welcome - Introduction to Peek</li> <li>Discover Libraries - Auto-discover your Stash library paths</li> <li>Configure Paths - Map Stash paths to Peek container paths</li> <li>Create Admin - Set your admin username and password</li> <li>Complete - Setup finished!</li> </ol> <p>Path Mapping Made Easy</p> <p>The wizard automatically discovers your Stash libraries and helps you configure path mappings correctly!</p>"},{"location":"getting-started/quick-start/#step-3-browse-your-library","title":"Step 3: Browse Your Library","text":"<ul> <li>Scenes: Browse all your video content</li> <li>Performers: View performers and their scenes</li> <li>Studios: Explore by production company</li> <li>Tags: Find content by tags</li> </ul>"},{"location":"getting-started/quick-start/#step-4-watch-videos","title":"Step 4: Watch Videos","text":"<ol> <li>Click any scene to view details</li> <li>Click Play to start video</li> <li>Quality automatically adjusts based on network</li> <li>Use timeline to seek through video</li> </ol>"},{"location":"getting-started/quick-start/#step-5-create-playlists","title":"Step 5: Create Playlists","text":"<p>Organize your favorite scenes into custom playlists:</p> <ol> <li>Click Playlists in the navigation menu</li> <li>Click Create Playlist</li> <li>Enter a name and optional description</li> <li>Click Create</li> </ol> <p>Adding Scenes: - Click the + icon on any scene card - Select your playlist from the menu - Scene is added instantly!</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start playback - Use Shuffle to randomize order - Use Repeat to loop your playlist</p> <p>Learn More</p> <p>See the Complete Playlists Guide for reordering scenes, editing playlists, and more!</p>"},{"location":"getting-started/quick-start/#common-tasks","title":"Common Tasks","text":""},{"location":"getting-started/quick-start/#update-admin-password","title":"Update Admin Password","text":"<ol> <li>Click user icon (top right)</li> <li>Select Settings</li> <li>Enter new password</li> <li>Click Save</li> </ol>"},{"location":"getting-started/quick-start/#create-additional-users","title":"Create Additional Users","text":"<ol> <li>Go to Users (admin only)</li> <li>Click Create User</li> <li>Enter username, email, password</li> <li>Select role (Admin or User)</li> <li>Click Create</li> </ol>"},{"location":"getting-started/quick-start/#configure-theme","title":"Configure Theme","text":"<ol> <li>Click theme toggle icon (moon/sun)</li> <li>Choose Dark or Light mode</li> <li>Theme preference is saved automatically</li> </ol>"},{"location":"getting-started/quick-start/#video-playback-tips","title":"Video Playback Tips","text":"<ul> <li>Direct Play: If browser supports the format, plays directly (no transcoding)</li> <li>Transcoded: HLS streaming with adaptive quality when needed</li> <li>Seeking: Full timeline scrubbing works in both modes</li> <li>Quality: Click quality button to manually select resolution</li> </ul>"},{"location":"getting-started/quick-start/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Space</code> Play/Pause <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>\u2191</code> Volume up <code>\u2193</code> Volume down <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>Full Keyboard Navigation</p> <p>Peek supports complete keyboard navigation including TV mode! See the Keyboard Navigation Guide for all shortcuts.</p>"},{"location":"getting-started/quick-start/#troubleshooting-first-time-issues","title":"Troubleshooting First-Time Issues","text":""},{"location":"getting-started/quick-start/#cant-login","title":"Can't Login","text":"<ul> <li>Check container logs: <code>docker logs peek-stash-browser</code></li> <li>Verify database was created in <code>/app/data</code></li> <li>Ensure <code>JWT_SECRET</code> is set (or auto-generated)</li> </ul>"},{"location":"getting-started/quick-start/#no-scenes-showing","title":"No Scenes Showing","text":"<ul> <li>Check <code>STASH_URL</code> is correct</li> <li>Verify <code>STASH_API_KEY</code> is valid</li> <li>Test Stash connectivity from container:   <pre><code>docker exec peek-stash-browser curl http://your-stash:9999/graphql\n</code></pre></li> </ul>"},{"location":"getting-started/quick-start/#videos-wont-play","title":"Videos Won't Play","text":"<ul> <li>Verify media path is mounted correctly:   <pre><code>docker exec peek-stash-browser ls /app/media\n</code></pre></li> <li>Check path mapping configuration</li> <li>Ensure FFmpeg is installed (included in official image)</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Full Configuration Guide</li> <li>Complete Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting Guide</li> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul>"},{"location":"getting-started/upgrading/","title":"Upgrading Peek","text":"<p>This guide covers upgrading Peek to new versions, including database migration procedures and backup strategies.</p>"},{"location":"getting-started/upgrading/#version-300-sqlite-entity-cache","title":"Version 3.0.0 - SQLite Entity Cache","text":"<p>Release Type: Stable</p> <p>Version 3.0.0 introduces a major architectural change: Stash entity data is now stored in SQLite tables instead of being held in memory. This provides:</p> <ul> <li>Scalability: Support for 100k+ scenes without memory exhaustion</li> <li>Performance: Sub-100ms query times with proper indexing</li> <li>Persistence: Library data survives container restarts</li> </ul>"},{"location":"getting-started/upgrading/#whats-changed","title":"What's Changed","text":"Before (v2.1.x) After (v3.0.0) In-memory cache SQLite tables ~3.6 hour sync for 22k scenes ~3 minute sync Memory-limited (~50k scenes max) Disk-limited (tested to 100k+) Data lost on restart Data persists"},{"location":"getting-started/upgrading/#database-changes-summary","title":"Database Changes Summary","text":"<p>The migration adds new tables only - it does NOT modify your existing user data tables:</p> <p>New Tables (23 total): - 7 entity tables: <code>StashScene</code>, <code>StashPerformer</code>, <code>StashStudio</code>, <code>StashTag</code>, <code>StashGroup</code>, <code>StashGallery</code>, <code>StashImage</code> - 14 junction tables for relationships (e.g., <code>ScenePerformer</code>, <code>SceneTag</code>, <code>PerformerTag</code>) - 2 sync management tables: <code>SyncState</code>, <code>SyncSettings</code></p> <p>Preserved Data: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - Scene/performer/studio/tag ratings and favorites - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"getting-started/upgrading/#pre-upgrade-checklist","title":"Pre-Upgrade Checklist","text":"<ol> <li>Back up your database (see Backup Procedure below)</li> <li>Note your current Peek version: Settings &gt; Server Statistics</li> <li>Ensure Docker has sufficient disk space (~500MB for 100k scenes)</li> </ol>"},{"location":"getting-started/upgrading/#backup-procedure","title":"Backup Procedure","text":"<p>Your Peek database is a single SQLite file. Back it up before upgrading:</p>"},{"location":"getting-started/upgrading/#option-1-docker-compose-recommended","title":"Option 1: Docker Compose (Recommended)","text":"<pre><code># Stop Peek to ensure clean backup\ndocker-compose stop peek-server\n\n# Find your data directory (check your docker-compose.yml volumes)\n# Default is ./data or a named volume\n\n# Copy the database file\ncp ./data/peek.db ./data/peek.db.backup-$(date +%Y%m%d)\n\n# Or if using a named volume:\ndocker run --rm -v peek_data:/data -v $(pwd):/backup alpine \\\n  cp /data/peek.db /backup/peek.db.backup-$(date +%Y%m%d)\n\n# Restart Peek\ndocker-compose start peek-server\n</code></pre>"},{"location":"getting-started/upgrading/#option-2-unraid-users","title":"Option 2: unRAID Users","text":"<ol> <li>Navigate to your Peek appdata folder (typically <code>/mnt/user/appdata/peek/</code>)</li> <li>Copy <code>peek.db</code> to a safe location outside the container</li> <li>Also copy <code>peek.db-wal</code> and <code>peek.db-shm</code> if they exist (WAL mode files)</li> </ol>"},{"location":"getting-started/upgrading/#option-3-while-running-less-safe","title":"Option 3: While Running (Less Safe)","text":"<p>SQLite supports hot backups, but stopping the container is safer:</p> <pre><code># If you can't stop the container\ndocker exec peek-server sqlite3 /app/data/peek.db \".backup '/app/data/peek-backup.db'\"\ndocker cp peek-server:/app/data/peek-backup.db ./peek.db.backup\n</code></pre>"},{"location":"getting-started/upgrading/#upgrade-steps","title":"Upgrade Steps","text":""},{"location":"getting-started/upgrading/#step-1-pull-the-new-image","title":"Step 1: Pull the New Image","text":"<pre><code># For docker-compose users\ndocker-compose pull\n\n# For manual docker users\ndocker pull carrotwaxr/peek-stash-browser:3.0.0\n# or for latest\ndocker pull carrotwaxr/peek-stash-browser:latest\n</code></pre>"},{"location":"getting-started/upgrading/#step-2-restart-the-container","title":"Step 2: Restart the Container","text":"<pre><code># Docker Compose\ndocker-compose down\ndocker-compose up -d\n\n# Manual Docker\ndocker stop peek-server\ndocker rm peek-server\ndocker run -d --name peek-server ... carrotwaxr/peek-stash-browser:3.0.0\n</code></pre>"},{"location":"getting-started/upgrading/#step-3-wait-for-migration","title":"Step 3: Wait for Migration","text":"<p>On first startup, Prisma will automatically apply the migration: - Check logs: <code>docker-compose logs -f peek-server</code> - Look for: <code>Applied migration: 20251211000000_stash_entities</code> - Migration typically completes in under 5 seconds</p>"},{"location":"getting-started/upgrading/#step-4-wait-for-initial-sync","title":"Step 4: Wait for Initial Sync","text":"<p>The sync starts automatically on first startup after migration. Watch the logs or the sync progress banner in the UI.</p> <p>Sync times depend on your library size: | Library Size | Expected Time | |--------------|---------------| | 1,000 scenes | ~15 seconds | | 10,000 scenes | ~1-2 minutes | | 50,000 scenes | ~5-8 minutes | | 100,000 scenes | ~15-20 minutes |</p>"},{"location":"getting-started/upgrading/#upgrading-from-300-beta-versions","title":"Upgrading from 3.0.0 Beta Versions","text":"<p>If you're upgrading from any v3.0.0-beta.x version, we recommend running a full sync after upgrading to ensure your database has all the latest fields populated correctly.</p> <p>Why a full sync is recommended: - beta.6 added <code>fileBasename</code> for gallery display - beta.9 added <code>fakeTits</code> for performer filtering</p> <p>How to run a full sync: 1. Go to Settings &gt; Server Settings 2. Click Sync from Stash 3. Select Full Sync (not incremental) 4. Wait for completion</p> <p>This ensures all new fields are populated for existing data.</p>"},{"location":"getting-started/upgrading/#rollback-procedure","title":"Rollback Procedure","text":"<p>If something goes wrong, you can restore your backup:</p> <pre><code># Stop Peek\ndocker-compose stop peek-server\n\n# Restore the backup\ncp ./data/peek.db.backup-YYYYMMDD ./data/peek.db\n\n# Restart with old image\ndocker-compose up -d\n</code></pre> <p>Note: If you need to downgrade the Docker image version, you may need to delete the migration record:</p> <pre><code># Only if downgrading AND experiencing migration errors\ndocker exec peek-server sqlite3 /app/data/peek.db \\\n  \"DELETE FROM _prisma_migrations WHERE migration_name = '20251211000000_stash_entities'\"\n</code></pre>"},{"location":"getting-started/upgrading/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/upgrading/#library-is-empty-after-upgrade","title":"\"Library is empty after upgrade\"","text":"<p>The sync should start automatically on first startup. If your library appears empty after waiting several minutes, check the logs for errors. You can also manually trigger a sync from Settings &gt; Sync.</p>"},{"location":"getting-started/upgrading/#migration-failed","title":"\"Migration failed\"","text":"<p>Check the logs for the specific error: <pre><code>docker-compose logs peek-server | grep -i migration\n</code></pre></p> <p>Common issues: - Disk full: Free up space and restart - Permission denied: Check volume mount permissions - Database locked: Stop other processes accessing the DB</p>"},{"location":"getting-started/upgrading/#sync-is-very-slow","title":"\"Sync is very slow\"","text":"<p>The initial sync after upgrade fetches all data from Stash. Subsequent syncs are incremental and much faster (typically &lt;30 seconds).</p>"},{"location":"getting-started/upgrading/#cant-connect-to-stash","title":"\"Can't connect to Stash\"","text":"<p>Verify your Stash configuration in Settings. The upgrade doesn't change your Stash connection settings.</p>"},{"location":"getting-started/upgrading/#performer-filters-not-working-correctly","title":"\"Performer filters not working correctly\"","text":"<p>If performer filters (like career length, ethnicity, eye color) aren't working as expected, run a full sync to ensure all performer fields are populated.</p>"},{"location":"getting-started/upgrading/#reporting-issues","title":"Reporting Issues","text":"<p>Found a bug? Please report it: - GitHub: github.com/carrotwaxr/peek-stash-browser/issues - Discourse: discourse.stashapp.cc</p> <p>Include: 1. Your Peek version (Settings &gt; Server Statistics) 2. Your Stash version 3. Library size (scene count) 4. Relevant log output 5. Steps to reproduce</p>"},{"location":"getting-started/upgrading/#previous-version-upgrades","title":"Previous Version Upgrades","text":""},{"location":"getting-started/upgrading/#v200-stash-proxy-streaming","title":"v2.0.0 - Stash Proxy Streaming","text":"<p>Version 2.0 removed local transcoding in favor of proxying streams directly through Stash.</p> <p>Key Changes: - Removed FFmpeg transcoding system - Removed path mapping configuration - Added StashInstance table for connection storage</p> <p>Migration: Automatic. No user action required.</p>"},{"location":"getting-started/upgrading/#v1x-to-v2x","title":"v1.x to v2.x","text":"<p>Users upgrading from v1.x will have their schema automatically updated via the schemaCatchup system. All user data is preserved.</p> <p>Migration: Automatic. The system detects legacy databases and applies necessary schema updates before running Prisma migrations.</p>"},{"location":"plans/2025-01-12-card-grid-followup/","title":"Card/Grid Refactor Follow-up Tasks","text":"<p>Created: 2025-01-12 Status: Pending Priority: Low</p> <p>Follow-up items identified during code review of the card/grid refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#background","title":"Background","text":"<p>The card/grid refactor (completed 2025-01-12) introduced: - Three-layer card architecture: Primitives -&gt; BaseCard -&gt; Entity Cards - Two-layer grid architecture: BaseGrid -&gt; SearchableGrid/Entity Grids</p> <p>Code review identified minor improvements that were not blockers for the initial refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#tasks","title":"Tasks","text":""},{"location":"plans/2025-01-12-card-grid-followup/#1-complete-search-page-migration-important","title":"1. Complete Search Page Migration (Important)","text":"<p>Current state: Search pages (Galleries, Groups, Studios, Tags) still have inline grid implementations instead of using entity grids.</p> <p>Blocker: TV navigation (<code>useGridPageTVNavigation</code>) needs to be integrated into SearchableGrid first.</p> <p>Files to migrate: - <code>client/src/components/pages/Galleries.jsx</code> - <code>client/src/components/pages/Groups.jsx</code> - <code>client/src/components/pages/Studios.jsx</code> - <code>client/src/components/pages/Tags.jsx</code></p> <p>Benefit: Removes ~250 lines of duplicated code across 4 search pages.</p> <p>Steps: 1. Add TV navigation support to SearchableGrid or entity grids 2. Add <code>isInitializing</code> state support to SearchableGrid for SyncProgressBanner 3. Migrate each search page to use its corresponding entity grid</p>"},{"location":"plans/2025-01-12-card-grid-followup/#2-add-entitytitle-to-rating-controls-nice-to-have","title":"2. Add entityTitle to Rating Controls (Nice to Have)","text":"<p>Issue: Entity cards don't pass <code>entityTitle</code> to ratingControlsProps, so rating dialogs show generic \"Rate this [entity]\" instead of \"Rate Studio Name\".</p> <p>Files to update: - <code>client/src/components/cards/PerformerCard.jsx</code> - add <code>entityTitle: performer.name</code> - <code>client/src/components/cards/GalleryCard.jsx</code> - add <code>entityTitle: gallery.title</code> - <code>client/src/components/cards/GroupCard.jsx</code> - add <code>entityTitle: group.name</code> - <code>client/src/components/cards/StudioCard.jsx</code> - add <code>entityTitle: studio.name</code> - <code>client/src/components/cards/TagCard.jsx</code> - add <code>entityTitle: tag.name</code> - <code>client/src/components/cards/ImageCard.jsx</code> - add <code>entityTitle: image.title</code></p>"},{"location":"plans/2025-01-12-card-grid-followup/#3-add-defensive-rating-fallback-nice-to-have","title":"3. Add Defensive Rating Fallback (Nice to Have)","text":"<p>Issue: GalleryCard uses only <code>gallery.rating100</code> but old implementation had fallback to <code>gallery.rating</code>.</p> <p>File: <code>client/src/components/cards/GalleryCard.jsx</code></p> <p>Change: <pre><code>// From\ninitialRating: gallery.rating100,\n\n// To\ninitialRating: gallery.rating100 ?? gallery.rating,\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#4-document-filter-merge-behavior-nice-to-have","title":"4. Document Filter Merge Behavior (Nice to Have)","text":"<p>Issue: SearchableGrid uses shallow merge for filters which could cause issues if both <code>newQuery</code> and <code>lockedFilters</code> have nested filter objects.</p> <p>File: <code>client/src/components/ui/SearchableGrid.jsx</code></p> <p>Change: Add explanatory comment: <pre><code>// Merge locked filters into query\n// Note: Uses shallow merge. Assumes lockedFilters and newQuery\n// use different filter keys (e.g., gallery_filter vs filter)\nconst mergedQuery = {\n  ...newQuery,\n  ...lockedFilters,\n};\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#5-verify-conditional-rating-controls-design-question","title":"5. Verify Conditional Rating Controls (Design Question)","text":"<p>Issue: TagCard and ImageCard conditionally render rating controls based on <code>rating100 !== undefined</code>. This may cause height inconsistency if some cards show rating row and others don't.</p> <p>Question: Should all entities always show rating controls (even when undefined/0)?</p> <p>Files: - <code>client/src/components/cards/TagCard.jsx</code> - <code>client/src/components/cards/ImageCard.jsx</code></p> <p>Action: Verify with product requirements whether all entities should show rating controls consistently.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/","title":"Card &amp; Grid Component Refactor Design","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#overview","title":"Overview","text":"<p>Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#goals","title":"Goals","text":"<ul> <li>Reduce duplication/drift risk across all card types</li> <li>Improve developer velocity for adding new entity types</li> <li>Maintain visual consistency with type-specific variants</li> <li>Keep SceneCard's full feature set (selection, sprites, TV mode, progress)</li> <li>Nested grids = full search pages with locked parent filter</li> <li>Design for future list item compatibility (don't implement yet)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#architecture","title":"Architecture","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#three-layer-card-system","title":"Three-Layer Card System","text":"<pre><code>Primitives (ui/CardComponents.jsx)\n    \u2514\u2500\u2500 CardContainer, CardImage, CardTitle, CardDescription,\n        CardIndicators, CardRatingRow, CardOverlay, useLazyLoad\n\nBaseCard (ui/BaseCard.jsx)\n    \u2514\u2500\u2500 Composes primitives, provides render slots for customization\n\nEntity Cards (components/cards/)\n    \u2514\u2500\u2500 SceneCard, PerformerCard, GalleryCard, GroupCard,\n        StudioCard, TagCard, ImageCard\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#two-layer-grid-system","title":"Two-Layer Grid System","text":"<pre><code>BaseGrid (ui/BaseGrid.jsx)\n    \u2514\u2500\u2500 Layout, responsive columns, pagination, loading/empty states\n\nSearchableGrid (ui/SearchableGrid.jsx)\n    \u2514\u2500\u2500 BaseGrid + search controls + data fetching + locked filters\n\nEntity Grids (components/grids/)\n    \u2514\u2500\u2500 SceneGrid, PerformerGrid, GalleryGrid, GroupGrid,\n        StudioGrid, TagGrid, ImageGrid\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#component-specifications","title":"Component Specifications","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#primitives-uicardcomponentsjsx","title":"Primitives (ui/CardComponents.jsx)","text":"<p>Existing components to keep: - <code>CardContainer</code> - Wrapper (Link or div) - <code>CardImage</code> - Image with aspect ratio, unified lazy loading - <code>CardTitle</code> - Title + optional subtitle - <code>CardDescription</code> - Clamped description text - <code>CardIndicators</code> - Row of icon+count badges - <code>CardRatingRow</code> - Rating, O-counter, favorite, menu</p> <p>New component: - <code>CardOverlay</code> - Positioned overlay for progress bars, selection checkboxes</p> <p>Remove: - <code>LazyImage</code> - fold into CardImage - <code>CardDefaultImage</code> - fold into CardImage</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basecard-uibasecardjsx","title":"BaseCard (ui/BaseCard.jsx)","text":"<pre><code>interface BaseCardProps {\n  // Data\n  entityType: EntityType;\n  imagePath: string;\n  title: ReactNode;\n  subtitle?: ReactNode;\n  description?: ReactNode;\n  linkTo?: string;\n\n  // Indicators &amp; Rating\n  indicators?: IndicatorConfig[];\n  ratingControlsProps?: RatingControlsProps;\n\n  // Display options\n  hideDescription?: boolean;\n  hideSubtitle?: boolean;\n  maxTitleLines?: number;\n  maxDescriptionLines?: number;\n\n  // Customization slots\n  renderOverlay?: () =&gt; ReactNode;\n  renderImageContent?: () =&gt; ReactNode;\n  renderAfterTitle?: () =&gt; ReactNode;\n\n  // Events &amp; behavior\n  onClick?: (e) =&gt; void;\n  onLongPress?: () =&gt; void;\n  className?: string;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-cards-componentscards","title":"Entity Cards (components/cards/)","text":"Component Complexity Type-Specific Behavior SceneCard Complex Selection mode, sprite preview, progress bar, TV mode, long-press PerformerCard Thin Gender icon after title, performer indicators GalleryCard Thin Image count indicator GroupCard Thin Scene count, performer count StudioCard Thin Scene count, child studio indicators TagCard Thin Scene/performer/gallery counts ImageCard Thin Resolution indicator, gallery link"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basegrid-uibasegridjsx","title":"BaseGrid (ui/BaseGrid.jsx)","text":"<pre><code>interface BaseGridProps {\n  items: any[];\n  renderItem: (item, index) =&gt; ReactNode;\n  gridType: 'scene' | 'standard';\n  loading?: boolean;\n  error?: Error;\n  emptyMessage?: string;\n  emptyDescription?: string;\n  currentPage?: number;\n  totalPages?: number;\n  onPageChange?: (page: number) =&gt; void;\n  skeletonCount?: number;\n  renderSkeleton?: () =&gt; ReactNode;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#searchablegrid-uisearchablegridjsx","title":"SearchableGrid (ui/SearchableGrid.jsx)","text":"<pre><code>interface SearchableGridProps {\n  entityType: EntityType;\n  lockedFilters?: FilterObject;\n  hideLockedFilters?: boolean;\n  gridType?: 'scene' | 'standard';\n  renderItem: (item) =&gt; ReactNode;\n  defaultSort?: SortConfig;\n  defaultFilters?: FilterObject;\n  onResultsChange?: (results) =&gt; void;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-grids-componentsgrids","title":"Entity Grids (components/grids/)","text":"<p>SceneGrid includes selection mode and bulk actions. All others are thin wrappers around SearchableGrid.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#usage-examples","title":"Usage Examples","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#main-search-page","title":"Main search page","text":"<pre><code>&lt;SceneGrid /&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#nested-grid-on-detail-page","title":"Nested grid on detail page","text":"<pre><code>&lt;SceneGrid\n  lockedFilters={{ performer_id: performer.id }}\n  hideLockedFilters\n/&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#multiple-nested-grids","title":"Multiple nested grids","text":"<pre><code>// PerformerDetail.jsx\n&lt;Tabs&gt;\n  &lt;Tab label=\"Scenes\"&gt;\n    &lt;SceneGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Groups\"&gt;\n    &lt;GroupGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Galleries\"&gt;\n    &lt;GalleryGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n&lt;/Tabs&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#file-structure","title":"File Structure","text":"<pre><code>client/src/\n  components/\n    cards/\n      SceneCard.jsx\n      PerformerCard.jsx\n      GalleryCard.jsx\n      GroupCard.jsx\n      StudioCard.jsx\n      TagCard.jsx\n      ImageCard.jsx\n      index.js\n\n    grids/\n      SceneGrid.jsx\n      PerformerGrid.jsx\n      GalleryGrid.jsx\n      GroupGrid.jsx\n      StudioGrid.jsx\n      TagGrid.jsx\n      ImageGrid.jsx\n      index.js\n\n    ui/\n      CardComponents.jsx\n      BaseCard.jsx\n      BaseGrid.jsx\n      SearchableGrid.jsx\n      useEntityImageAspectRatio.js\n\n  constants/\n    grids.js\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#migration-plan","title":"Migration Plan","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-delete","title":"Files to DELETE","text":"<ul> <li><code>ui/GridCard.jsx</code> - Replaced by BaseCard</li> <li><code>ui/EntityGrid.jsx</code> - Replaced by components/grids/*</li> <li><code>scene-search/SceneGrid.jsx</code> - Moved to components/grids/</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-move","title":"Files to MOVE","text":"<ul> <li><code>ui/SceneCard.jsx</code> \u2192 <code>components/cards/SceneCard.jsx</code></li> <li><code>ui/PerformerCard.jsx</code> \u2192 <code>components/cards/PerformerCard.jsx</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-create","title":"Files to CREATE","text":"<ul> <li><code>ui/BaseCard.jsx</code></li> <li><code>ui/BaseGrid.jsx</code></li> <li><code>ui/SearchableGrid.jsx</code></li> <li><code>components/cards/GalleryCard.jsx</code></li> <li><code>components/cards/GroupCard.jsx</code></li> <li><code>components/cards/StudioCard.jsx</code></li> <li><code>components/cards/TagCard.jsx</code></li> <li><code>components/cards/ImageCard.jsx</code></li> <li><code>components/cards/index.js</code></li> <li><code>components/grids/SceneGrid.jsx</code></li> <li><code>components/grids/PerformerGrid.jsx</code></li> <li><code>components/grids/GalleryGrid.jsx</code></li> <li><code>components/grids/GroupGrid.jsx</code></li> <li><code>components/grids/StudioGrid.jsx</code></li> <li><code>components/grids/TagGrid.jsx</code></li> <li><code>components/grids/ImageGrid.jsx</code></li> <li><code>components/grids/index.js</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-refactor","title":"Files to REFACTOR","text":"<ul> <li><code>ui/CardComponents.jsx</code> - Remove LazyImage/CardDefaultImage, add CardOverlay</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#pages-to-update","title":"Pages to UPDATE","text":"<ul> <li>Scenes, Performers, Galleries, Groups, Studios, Tags, Images (search pages)</li> <li>PerformerDetail, StudioDetail, TagDetail, GroupDetail, GalleryDetail (detail pages)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/","title":"Card &amp; Grid Component Refactor Implementation Plan","text":"<p>Status: COMPLETED - All 25 tasks implemented successfully on 2025-01-12.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#implementation-summary","title":"Implementation Summary","text":"<p>The card and grid refactor has been fully implemented with the following results:</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#new-architecture","title":"New Architecture","text":"<ul> <li>Card Layer 1 (Primitives): <code>CardComponents.jsx</code> - CardImage, CardTitle, CardOverlay, etc.</li> <li>Card Layer 2: <code>BaseCard.jsx</code> - Composable card with render slots</li> <li>Card Layer 3: Entity cards in <code>components/cards/</code> - PerformerCard, GalleryCard, GroupCard, StudioCard, TagCard, ImageCard</li> <li>Grid Layer 1: <code>BaseGrid.jsx</code> - Layout, pagination, loading/empty states</li> <li>Grid Layer 2: <code>SearchableGrid.jsx</code> - Integrated search controls and data fetching</li> <li>Grid Layer 3: Entity grids in <code>components/grids/</code> - PerformerGrid, GalleryGrid, GroupGrid, StudioGrid, TagGrid, ImageGrid</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#files-deleted","title":"Files Deleted","text":"<ul> <li><code>GridCard.jsx</code> - Replaced by BaseCard + entity cards</li> <li><code>EntityGrid.jsx</code> - Replaced by SearchableGrid + entity grids</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#additional-migrations","title":"Additional Migrations","text":"<p>During implementation, 4 main search pages (Galleries, Groups, Studios, Tags) were discovered to still use the deprecated GridCard. These were migrated to use the new shared entity cards.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#test-results","title":"Test Results","text":"<ul> <li>All 346 tests pass</li> <li>No lint errors (only pre-existing warnings in unrelated files)</li> </ul> <p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids with locked filters.</p> <p>Architecture: Three-layer card system (Primitives \u2192 BaseCard \u2192 Entity Cards) + Two-layer grid system (BaseGrid \u2192 SearchableGrid \u2192 Entity Grids). This eliminates the current duplication between SceneCard, PerformerCard, GridCard, and EntityGrid while preserving SceneCard's full feature set.</p> <p>Tech Stack: React 18, React Router 6, Tailwind CSS, CSS variables for theming, Lucide React icons</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-1-card-primitives-cleanup","title":"Phase 1: Card Primitives Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-1-add-cardoverlay-to-cardcomponentsjsx","title":"Task 1: Add CardOverlay to CardComponents.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:155-171</code> (after CardDefaultImage) - Modify: <code>client/src/components/ui/index.js:9-19</code> (add export)</p> <p>Step 1: Write the failing test</p> <p>Create test file first:</p> <pre><code>// client/src/components/ui/__tests__/CardComponents.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { CardOverlay } from \"../CardComponents\";\n\ndescribe(\"CardOverlay\", () =&gt; {\n  it(\"renders children in positioned overlay\", () =&gt; {\n    render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Test Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(screen.getByText(\"Test Content\")).toBeInTheDocument();\n  });\n\n  it(\"applies correct position classes for bottom-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for top-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"top-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"top-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for bottom-right\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-right\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"right-0\");\n  });\n\n  it(\"applies correct position classes for full\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"full\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"inset-0\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL with \"Cannot find module '../CardComponents'\" or similar</p> <p>Step 3: Write CardOverlay implementation</p> <p>Add to <code>client/src/components/ui/CardComponents.jsx</code> after line 171 (after CardDefaultImage):</p> <pre><code>/**\n * CardOverlay - Positioned overlay container for progress bars, selection checkboxes, etc.\n * @param {Object} props\n * @param {'top-left'|'top-right'|'bottom-left'|'bottom-right'|'full'} props.position - Position of overlay\n * @param {React.ReactNode} props.children - Content to render in overlay\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const CardOverlay = ({ position = \"bottom-left\", children, className = \"\" }) =&gt; {\n  const positionClasses = {\n    \"top-left\": \"absolute top-0 left-0\",\n    \"top-right\": \"absolute top-0 right-0\",\n    \"bottom-left\": \"absolute bottom-0 left-0\",\n    \"bottom-right\": \"absolute bottom-0 right-0\",\n    \"full\": \"absolute inset-0\",\n  };\n\n  return (\n    &lt;div className={`${positionClasses[position]} ${className}`}&gt;\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Update barrel export</p> <p>In <code>client/src/components/ui/index.js</code>, update the CardComponents export:</p> <pre><code>export {\n  CardContainer,\n  CardDefaultImage,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardOverlay,  // Add this\n  CardRatingRow,\n  CardTitle,\n  LazyImage,\n  useLazyLoad,\n} from \"./CardComponents.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/index.js client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"feat(cards): add CardOverlay primitive for positioned overlays\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-2-fold-lazyimage-into-cardimage","title":"Task 2: Fold LazyImage into CardImage","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:76-148</code> (CardImage and LazyImage sections)</p> <p>Step 1: Write the failing test</p> <p>Add to <code>client/src/components/ui/__tests__/CardComponents.test.jsx</code>:</p> <pre><code>import { CardImage } from \"../CardComponents\";\n\ndescribe(\"CardImage\", () =&gt; {\n  it(\"renders image with lazy loading when src provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\" /&gt;\n    );\n    expect(screen.getByRole(\"img\")).toHaveAttribute(\"src\", \"/test.jpg\");\n  });\n\n  it(\"renders placeholder when no src provided\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage aspectRatio=\"16/9\" entityType=\"scene\" /&gt;\n    );\n    // Should render default icon, not an img tag\n    expect(container.querySelector(\"img\")).toBeNull();\n    expect(container.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"applies aspect ratio style\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"2/3\" /&gt;\n    );\n    expect(container.firstChild).toHaveStyle({ aspectRatio: \"2/3\" });\n  });\n\n  it(\"renders children overlay when provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\"&gt;\n        &lt;span&gt;Overlay Content&lt;/span&gt;\n      &lt;/CardImage&gt;\n    );\n    expect(screen.getByText(\"Overlay Content\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL (CardImage doesn't accept src prop yet)</p> <p>Step 3: Refactor CardImage to include lazy loading</p> <p>Replace CardImage in <code>client/src/components/ui/CardComponents.jsx</code>:</p> <pre><code>/**\n * CardImage - Image container with aspect ratio and built-in lazy loading\n * @param {Object} props\n * @param {string} [props.src] - Image source URL\n * @param {string} [props.alt] - Alt text for image\n * @param {string} [props.aspectRatio] - CSS aspect ratio (e.g., \"16/9\", \"2/3\")\n * @param {string} [props.entityType] - Entity type for placeholder icon\n * @param {React.ReactNode} [props.children] - Overlay content\n * @param {string} [props.className] - Additional CSS classes\n * @param {Object} [props.style] - Additional inline styles\n * @param {Function} [props.onClick] - Click handler\n */\nexport const CardImage = ({\n  src,\n  alt = \"\",\n  aspectRatio = \"16/9\",\n  entityType,\n  children,\n  className = \"\",\n  style = {},\n  onClick,\n}) =&gt; {\n  const [ref, isVisible] = useLazyLoad();\n  const [hasError, setHasError] = useState(false);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  const showPlaceholder = !src || hasError;\n\n  const getPlaceholderIcon = () =&gt; {\n    const icons = {\n      performer: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      scene: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm3 2h6v4H7V5zm8 8v2h1v-2h-1zm-2-2H7v4h6v-4zm2 0h1V9h-1v2zm1-4V5h-1v2h1zM5 5v2H4V5h1zm0 4H4v2h1V9zm-1 4h1v2H4v-2z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      gallery: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      default: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n    };\n    return icons[entityType] || icons.default;\n  };\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`relative overflow-hidden ${className}`}\n      style={{\n        aspectRatio,\n        backgroundColor: \"var(--bg-secondary)\",\n        ...style,\n      }}\n      onClick={onClick}\n    &gt;\n      {showPlaceholder ? (\n        &lt;div\n          className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ color: \"var(--text-muted)\" }}\n        &gt;\n          {getPlaceholderIcon()}\n        &lt;/div&gt;\n      ) : (\n        &lt;&gt;\n          {/* Placeholder shown while loading */}\n          {!isLoaded &amp;&amp; (\n            &lt;div\n              className=\"absolute inset-0 animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n          )}\n          {/* Actual image - only render when visible for lazy loading */}\n          {isVisible &amp;&amp; (\n            &lt;img\n              src={src}\n              alt={alt}\n              className={`absolute inset-0 w-full h-full object-cover transition-opacity duration-200 ${\n                isLoaded ? \"opacity-100\" : \"opacity-0\"\n              }`}\n              onLoad={() =&gt; setIsLoaded(true)}\n              onError={() =&gt; setHasError(true)}\n            /&gt;\n          )}\n        &lt;/&gt;\n      )}\n      {/* Children rendered as overlay */}\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"refactor(cards): fold LazyImage into CardImage with built-in lazy loading\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-2-basecard-implementation","title":"Phase 2: BaseCard Implementation","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-3-create-basecard-component","title":"Task 3: Create BaseCard Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseCard.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseCard.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (add export)</p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseCard } from \"../BaseCard\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseCard\", () =&gt; {\n  const defaultProps = {\n    entityType: \"scene\",\n    imagePath: \"/test.jpg\",\n    title: \"Test Title\",\n  };\n\n  it(\"renders title\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} /&gt;);\n    expect(screen.getByText(\"Test Title\")).toBeInTheDocument();\n  });\n\n  it(\"renders subtitle when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" /&gt;);\n    expect(screen.getByText(\"Test Subtitle\")).toBeInTheDocument();\n  });\n\n  it(\"hides subtitle when hideSubtitle is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" hideSubtitle /&gt;\n    );\n    expect(screen.queryByText(\"Test Subtitle\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders description when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} description=\"Test Description\" /&gt;);\n    expect(screen.getByText(\"Test Description\")).toBeInTheDocument();\n  });\n\n  it(\"hides description when hideDescription is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} description=\"Test Description\" hideDescription /&gt;\n    );\n    expect(screen.queryByText(\"Test Description\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders as link when linkTo provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} linkTo=\"/test\" /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/test\");\n  });\n\n  it(\"renders indicators when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        indicators={[{ type: \"SCENES\", count: 5 }]}\n      /&gt;\n    );\n    expect(screen.getByText(\"5\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderOverlay slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderOverlay={() =&gt; &lt;span&gt;Custom Overlay&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"Custom Overlay\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderAfterTitle slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderAfterTitle={() =&gt; &lt;span&gt;After Title&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"After Title\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write BaseCard implementation</p> <pre><code>// client/src/components/ui/BaseCard.jsx\nimport { forwardRef } from \"react\";\nimport { useEntityImageAspectRatio } from \"../../hooks/useEntityImageAspectRatio.js\";\nimport {\n  CardContainer,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardRatingRow,\n  CardTitle,\n} from \"./CardComponents.jsx\";\n\n/**\n * BaseCard - Composable card component that assembles primitives\n * Provides render slots for entity-specific customization\n */\nexport const BaseCard = forwardRef(\n  (\n    {\n      // Data\n      entityType,\n      imagePath,\n      title,\n      subtitle,\n      description,\n      linkTo,\n\n      // Indicators &amp; Rating\n      indicators = [],\n      ratingControlsProps,\n\n      // Display options\n      hideDescription = false,\n      hideSubtitle = false,\n      maxTitleLines = 2,\n      maxDescriptionLines = 3,\n\n      // Customization slots\n      renderOverlay,\n      renderImageContent,\n      renderAfterTitle,\n\n      // Events &amp; behavior\n      onClick,\n      onLongPress,\n      className = \"\",\n      referrerUrl,\n      tabIndex,\n      style,\n      ...rest\n    },\n    ref\n  ) =&gt; {\n    const aspectRatio = useEntityImageAspectRatio(entityType);\n\n    return (\n      &lt;CardContainer\n        ref={ref}\n        entityType={entityType}\n        linkTo={linkTo}\n        onClick={onClick}\n        referrerUrl={referrerUrl}\n        className={className}\n        tabIndex={tabIndex}\n        style={style}\n        {...rest}\n      &gt;\n        {/* Image Section */}\n        &lt;CardImage\n          src={imagePath}\n          alt={typeof title === \"string\" ? title : \"\"}\n          aspectRatio={aspectRatio}\n          entityType={entityType}\n        &gt;\n          {/* Custom image content (e.g., sprite preview) */}\n          {renderImageContent?.()}\n          {/* Custom overlay (e.g., progress bar, selection checkbox) */}\n          {renderOverlay?.()}\n        &lt;/CardImage&gt;\n\n        {/* Title Section */}\n        &lt;CardTitle\n          title={title}\n          subtitle={hideSubtitle ? null : subtitle}\n          maxTitleLines={maxTitleLines}\n        /&gt;\n\n        {/* After Title Slot (e.g., gender icon) */}\n        {renderAfterTitle?.()}\n\n        {/* Description */}\n        {!hideDescription &amp;&amp; description &amp;&amp; (\n          &lt;CardDescription\n            description={description}\n            maxLines={maxDescriptionLines}\n          /&gt;\n        )}\n\n        {/* Indicators */}\n        {indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators indicators={indicators} /&gt;}\n\n        {/* Rating Controls */}\n        {ratingControlsProps &amp;&amp; (\n          &lt;CardRatingRow entityType={entityType} {...ratingControlsProps} /&gt;\n        )}\n      &lt;/CardContainer&gt;\n    );\n  }\n);\n\nBaseCard.displayName = \"BaseCard\";\n\nexport default BaseCard;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseCard } from \"./BaseCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseCard.jsx client/src/components/ui/__tests__/BaseCard.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(cards): add BaseCard component with render slots\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-3-entity-cards-directory-structure","title":"Phase 3: Entity Cards Directory Structure","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-4-create-cards-directory-and-move-performercard","title":"Task 4: Create cards directory and move PerformerCard","text":"<p>Files: - Create: <code>client/src/components/cards/</code> - Move: <code>client/src/components/ui/PerformerCard.jsx</code> \u2192 <code>client/src/components/cards/PerformerCard.jsx</code> - Create: <code>client/src/components/cards/index.js</code> - Modify: <code>client/src/components/ui/index.js</code> (re-export from new location)</p> <p>Step 1: Create directory and index file</p> <pre><code>// client/src/components/cards/index.js\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 2: Move PerformerCard</p> <p>Move file from <code>client/src/components/ui/PerformerCard.jsx</code> to <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Update imports in the moved file:</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { GenderIcon, GridCard } from \"../ui/index.js\";\n// ... rest of imports unchanged\n</code></pre> <p>Step 3: Update ui/index.js to re-export</p> <p>Replace the PerformerCard export in <code>client/src/components/ui/index.js</code>:</p> <pre><code>// Replace:\n// export { default as PerformerCard } from \"./PerformerCard.jsx\";\n// With:\nexport { PerformerCard } from \"../cards/index.js\";\n</code></pre> <p>Step 4: Run existing app to verify no breaking changes</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS with no errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/cards/ client/src/components/ui/index.js\ngit rm client/src/components/ui/PerformerCard.jsx\ngit commit -m \"refactor(cards): move PerformerCard to components/cards/\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-5-migrate-performercard-to-use-basecard","title":"Task 5: Migrate PerformerCard to use BaseCard","text":"<p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/PerformerCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerCard\", () =&gt; {\n  const mockPerformer = {\n    id: \"1\",\n    name: \"Test Performer\",\n    gender: \"FEMALE\",\n    image_path: \"/test.jpg\",\n    scene_count: 10,\n    o_counter: 5,\n    rating100: 80,\n    favorite: true,\n  };\n\n  it(\"renders performer name\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n  });\n\n  it(\"renders gender icon\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    // GenderIcon should be present\n    expect(document.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"links to performer detail page\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/performer/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"10\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify current implementation passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS (existing implementation should pass)</p> <p>Step 3: Refactor to use BaseCard</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { GenderIcon } from \"../ui/GenderIcon.jsx\";\n\n/**\n * PerformerCard - Card for displaying performer entities\n * Uses BaseCard with performer-specific configuration\n */\nconst PerformerCard = forwardRef(\n  ({ performer, referrerUrl, isTVMode, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const indicators = [\n      { type: \"PLAY_COUNT\", count: performer.play_count },\n      { type: \"SCENES\", count: performer.scene_count },\n      { type: \"GROUPS\", count: performer.group_count },\n      { type: \"IMAGES\", count: performer.image_count },\n      { type: \"GALLERIES\", count: performer.gallery_count },\n      { type: \"TAGS\", count: performer.tags?.length || 0 },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"performer\"\n        imagePath={performer.image_path}\n        title={performer.name}\n        linkTo={`/performer/${performer.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={indicators}\n        ratingControlsProps={{\n          entityId: performer.id,\n          initialRating: performer.rating100,\n          initialFavorite: performer.favorite || false,\n          initialOCounter: performer.o_counter,\n          onHideSuccess,\n        }}\n        renderAfterTitle={() =&gt; (\n          &lt;div className=\"flex items-center gap-1 mt-1\"&gt;\n            &lt;GenderIcon gender={performer.gender} size={16} /&gt;\n          &lt;/div&gt;\n        )}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nPerformerCard.displayName = \"PerformerCard\";\n\nexport default PerformerCard;\n</code></pre> <p>Step 4: Run test to verify it still passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Run full build to verify no regressions</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/PerformerCard.jsx client/src/components/cards/__tests__/PerformerCard.test.jsx\ngit commit -m \"refactor(cards): migrate PerformerCard to use BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-6-create-gallerycard","title":"Task 6: Create GalleryCard","text":"<p>Files: - Create: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GalleryCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryCard\", () =&gt; {\n  const mockGallery = {\n    id: \"1\",\n    title: \"Test Gallery\",\n    paths: { cover: \"/cover.jpg\" },\n    image_count: 25,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    performers: [{ id: \"1\", name: \"Performer 1\" }],\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 70,\n    favorite: false,\n  };\n\n  it(\"renders gallery title\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n  });\n\n  it(\"renders studio and date subtitle\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(/Test Studio/)).toBeInTheDocument();\n  });\n\n  it(\"links to gallery detail page\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/gallery/1\");\n  });\n\n  it(\"renders image count indicator\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"25\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write GalleryCard implementation</p> <pre><code>// client/src/components/cards/GalleryCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { TooltipEntityGrid } from \"../ui/TooltipEntityGrid.jsx\";\nimport { galleryTitle } from \"../../utils/gallery.js\";\n\n/**\n * GalleryCard - Card for displaying gallery entities\n */\nconst GalleryCard = forwardRef(\n  ({ gallery, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const galleryDate = gallery.date\n      ? new Date(gallery.date).toLocaleDateString()\n      : null;\n    const subtitle = (() =&gt; {\n      if (gallery.studio &amp;&amp; galleryDate) {\n        return `${gallery.studio.name} \u2022 ${galleryDate}`;\n      } else if (gallery.studio) {\n        return gallery.studio.name;\n      } else if (galleryDate) {\n        return galleryDate;\n      }\n      return null;\n    })();\n\n    // Build rich tooltip content for performers and tags\n    const performersTooltip =\n      gallery.performers &amp;&amp;\n      gallery.performers.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"performer\"\n          entities={gallery.performers}\n          title=\"Performers\"\n        /&gt;\n      );\n\n    const tagsTooltip =\n      gallery.tags &amp;&amp;\n      gallery.tags.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"tag\"\n          entities={gallery.tags}\n          title=\"Tags\"\n        /&gt;\n      );\n\n    const indicators = [\n      {\n        type: \"IMAGES\",\n        count: gallery.image_count,\n        tooltipContent:\n          gallery.image_count === 1 ? \"1 Image\" : `${gallery.image_count} Images`,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: gallery.performers?.length || 0,\n        tooltipContent: performersTooltip,\n        onClick:\n          gallery.performers?.length &gt; 0\n            ? () =&gt; navigate(`/performers?galleryId=${gallery.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: gallery.tags?.length || 0,\n        tooltipContent: tagsTooltip,\n        onClick:\n          gallery.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?galleryId=${gallery.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"gallery\"\n        imagePath={gallery.paths?.cover}\n        title={galleryTitle(gallery)}\n        subtitle={subtitle}\n        description={gallery.description}\n        linkTo={`/gallery/${gallery.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: gallery.id,\n          initialRating: gallery.rating100,\n          initialFavorite: gallery.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGalleryCard.displayName = \"GalleryCard\";\n\nexport default GalleryCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>// client/src/components/cards/index.js\nexport { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GalleryCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GalleryCard.test.jsx\ngit commit -m \"feat(cards): add GalleryCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-7-create-groupcard","title":"Task 7: Create GroupCard","text":"<p>Files: - Create: <code>client/src/components/cards/GroupCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GroupCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GroupCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GroupCard\", () =&gt; {\n  const mockGroup = {\n    id: \"1\",\n    name: \"Test Collection\",\n    front_image_path: \"/front.jpg\",\n    scene_count: 15,\n    sub_group_count: 3,\n    performer_count: 5,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 85,\n    favorite: true,\n  };\n\n  it(\"renders group name\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"Test Collection\")).toBeInTheDocument();\n  });\n\n  it(\"links to collection detail page\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/collection/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"15\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write GroupCard implementation</p> <pre><code>// client/src/components/cards/GroupCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * GroupCard - Card for displaying group/collection entities\n */\nconst GroupCard = forwardRef(\n  ({ group, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const subtitle = (() =&gt; {\n      if (group.studio &amp;&amp; group.date) {\n        return `${group.studio.name} \u2022 ${group.date}`;\n      } else if (group.studio) {\n        return group.studio.name;\n      } else if (group.date) {\n        return group.date;\n      }\n      return null;\n    })();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: group.scene_count,\n        onClick:\n          group.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"GROUPS\",\n        count: group.sub_group_count,\n        onClick:\n          group.sub_group_count &gt; 0\n            ? () =&gt; navigate(`/collections?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: group.performer_count,\n        onClick:\n          group.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: group.tags?.length || 0,\n        onClick:\n          group.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?groupIds=${group.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"group\"\n        imagePath={group.front_image_path || group.back_image_path}\n        title={group.name}\n        subtitle={subtitle}\n        description={group.description}\n        linkTo={`/collection/${group.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: group.id,\n          initialRating: group.rating100,\n          initialFavorite: group.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGroupCard.displayName = \"GroupCard\";\n\nexport default GroupCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GroupCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GroupCard.test.jsx\ngit commit -m \"feat(cards): add GroupCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-8-create-studiocard","title":"Task 8: Create StudioCard","text":"<p>Files: - Create: <code>client/src/components/cards/StudioCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/StudioCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { StudioCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"StudioCard\", () =&gt; {\n  const mockStudio = {\n    id: \"1\",\n    name: \"Test Studio\",\n    image_path: \"/studio.jpg\",\n    scene_count: 50,\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    details: \"Studio description\",\n    rating100: 90,\n    favorite: false,\n  };\n\n  it(\"renders studio name\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"Test Studio\")).toBeInTheDocument();\n  });\n\n  it(\"links to studio detail page\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/studio/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"50\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write StudioCard implementation</p> <pre><code>// client/src/components/cards/StudioCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * StudioCard - Card for displaying studio entities\n */\nconst StudioCard = forwardRef(\n  ({ studio, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: studio.scene_count,\n        onClick:\n          studio.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?studioId=${studio.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: studio.tags?.length || 0,\n        onClick:\n          studio.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?studioId=${studio.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"studio\"\n        imagePath={studio.image_path}\n        title={studio.name}\n        description={studio.details}\n        linkTo={`/studio/${studio.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: studio.id,\n          initialRating: studio.rating100,\n          initialFavorite: studio.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nStudioCard.displayName = \"StudioCard\";\n\nexport default StudioCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/StudioCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/StudioCard.test.jsx\ngit commit -m \"feat(cards): add StudioCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-9-create-tagcard","title":"Task 9: Create TagCard","text":"<p>Files: - Create: <code>client/src/components/cards/TagCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/TagCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { TagCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"TagCard\", () =&gt; {\n  const mockTag = {\n    id: \"1\",\n    name: \"Test Tag\",\n    image_path: \"/tag.jpg\",\n    scene_count: 30,\n    studio_count: 5,\n    performer_count: 10,\n    gallery_count: 8,\n    description: \"Tag description\",\n  };\n\n  it(\"renders tag name\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"Test Tag\")).toBeInTheDocument();\n  });\n\n  it(\"links to tag detail page\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/tags/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"30\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write TagCard implementation</p> <pre><code>// client/src/components/cards/TagCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * TagCard - Card for displaying tag entities\n */\nconst TagCard = forwardRef(\n  ({ tag, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: tag.scene_count,\n        onClick:\n          tag.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"STUDIOS\",\n        count: tag.studio_count,\n        onClick:\n          tag.studio_count &gt; 0\n            ? () =&gt; navigate(`/studios?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: tag.performer_count,\n        onClick:\n          tag.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"GALLERIES\",\n        count: tag.gallery_count,\n        onClick:\n          tag.gallery_count &gt; 0\n            ? () =&gt; navigate(`/galleries?tagIds=${tag.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"tag\"\n        imagePath={tag.image_path}\n        title={tag.name}\n        description={tag.description}\n        linkTo={`/tags/${tag.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={\n          tag.rating100 !== undefined\n            ? {\n                entityId: tag.id,\n                initialRating: tag.rating100,\n                initialFavorite: tag.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nTagCard.displayName = \"TagCard\";\n\nexport default TagCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/TagCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/TagCard.test.jsx\ngit commit -m \"feat(cards): add TagCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-10-create-imagecard","title":"Task 10: Create ImageCard","text":"<p>Files: - Create: <code>client/src/components/cards/ImageCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/ImageCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { ImageCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"ImageCard\", () =&gt; {\n  const mockImage = {\n    id: \"1\",\n    title: \"Test Image\",\n    paths: { thumbnail: \"/thumb.jpg\", image: \"/full.jpg\" },\n  };\n\n  it(\"renders image title\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByText(\"Test Image\")).toBeInTheDocument();\n  });\n\n  it(\"links to image detail page\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/image/1\");\n  });\n\n  it(\"uses fallback title when no title provided\", () =&gt; {\n    const imageNoTitle = { ...mockImage, title: null };\n    renderWithRouter(&lt;ImageCard image={imageNoTitle} /&gt;);\n    expect(screen.getByText(\"Image 1\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write ImageCard implementation</p> <pre><code>// client/src/components/cards/ImageCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * ImageCard - Card for displaying image entities\n */\nconst ImageCard = forwardRef(\n  ({ image, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"image\"\n        imagePath={image.paths?.thumbnail || image.paths?.image}\n        title={image.title || `Image ${image.id}`}\n        linkTo={`/image/${image.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={[]}\n        ratingControlsProps={\n          image.rating100 !== undefined\n            ? {\n                entityId: image.id,\n                initialRating: image.rating100,\n                initialFavorite: image.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nImageCard.displayName = \"ImageCard\";\n\nexport default ImageCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as ImageCard } from \"./ImageCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/ImageCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/ImageCard.test.jsx\ngit commit -m \"feat(cards): add ImageCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-4-grid-components","title":"Phase 4: Grid Components","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-11-create-basegrid-component","title":"Task 11: Create BaseGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseGrid.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseGrid.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseGrid.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseGrid } from \"../BaseGrid\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseGrid\", () =&gt; {\n  const mockItems = [\n    { id: \"1\", name: \"Item 1\" },\n    { id: \"2\", name: \"Item 2\" },\n    { id: \"3\", name: \"Item 3\" },\n  ];\n\n  it(\"renders items using renderItem function\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n      /&gt;\n    );\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 3\")).toBeInTheDocument();\n  });\n\n  it(\"shows loading skeleton when loading=true\", () =&gt; {\n    const { container } = renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        loading={true}\n        skeletonCount={3}\n      /&gt;\n    );\n    expect(container.querySelectorAll(\".animate-pulse\")).toHaveLength(3);\n  });\n\n  it(\"shows empty message when items is empty\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        emptyMessage=\"No items found\"\n      /&gt;\n    );\n    expect(screen.getByText(\"No items found\")).toBeInTheDocument();\n  });\n\n  it(\"renders pagination when totalPages &gt; 1\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n        currentPage={1}\n        totalPages={5}\n        onPageChange={() =&gt; {}}\n      /&gt;\n    );\n    // Should have pagination controls\n    expect(screen.getByRole(\"navigation\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write BaseGrid implementation</p> <pre><code>// client/src/components/ui/BaseGrid.jsx\nimport { SCENE_GRID_CONTAINER_CLASSNAMES, STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport EmptyState from \"./EmptyState.jsx\";\nimport Pagination from \"./Pagination.jsx\";\n\n/**\n * BaseGrid - Base grid component for layout, responsive columns, pagination, and loading/empty states\n *\n * @param {Object} props\n * @param {any[]} props.items - Array of items to render\n * @param {Function} props.renderItem - Function to render each item (item, index) =&gt; ReactNode\n * @param {'scene'|'standard'} props.gridType - Grid type for responsive columns\n * @param {boolean} [props.loading] - Show loading skeleton\n * @param {Error} [props.error] - Error to display\n * @param {string} [props.emptyMessage] - Message when no items\n * @param {string} [props.emptyDescription] - Description for empty state\n * @param {number} [props.currentPage] - Current page number\n * @param {number} [props.totalPages] - Total number of pages\n * @param {Function} [props.onPageChange] - Page change handler (page: number) =&gt; void\n * @param {number} [props.skeletonCount] - Number of skeleton cards to show while loading\n * @param {Function} [props.renderSkeleton] - Custom skeleton renderer\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const BaseGrid = ({\n  items,\n  renderItem,\n  gridType = \"standard\",\n  loading = false,\n  error,\n  emptyMessage = \"No items found\",\n  emptyDescription,\n  currentPage,\n  totalPages,\n  onPageChange,\n  skeletonCount = 12,\n  renderSkeleton,\n  className = \"\",\n}) =&gt; {\n  const gridClasses =\n    gridType === \"scene\"\n      ? SCENE_GRID_CONTAINER_CLASSNAMES\n      : STANDARD_GRID_CONTAINER_CLASSNAMES;\n\n  // Default skeleton renderer\n  const defaultRenderSkeleton = () =&gt; (\n    &lt;div\n      className=\"rounded-lg animate-pulse\"\n      style={{\n        backgroundColor: \"var(--bg-tertiary)\",\n        height: gridType === \"scene\" ? \"20rem\" : \"24rem\",\n      }}\n    /&gt;\n  );\n\n  const skeletonRenderer = renderSkeleton || defaultRenderSkeleton;\n\n  // Loading state\n  if (loading) {\n    return (\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {[...Array(skeletonCount)].map((_, i) =&gt; (\n          &lt;div key={i}&gt;{skeletonRenderer()}&lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  // Error state\n  if (error) {\n    return (\n      &lt;EmptyState\n        title=\"Error loading items\"\n        description={error.message || \"An error occurred\"}\n      /&gt;\n    );\n  }\n\n  // Empty state\n  if (!items || items.length === 0) {\n    return &lt;EmptyState title={emptyMessage} description={emptyDescription} /&gt;;\n  }\n\n  return (\n    &lt;&gt;\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {items.map((item, index) =&gt; renderItem(item, index))}\n      &lt;/div&gt;\n\n      {/* Pagination */}\n      {totalPages &gt; 1 &amp;&amp; onPageChange &amp;&amp; (\n        &lt;nav role=\"navigation\" aria-label=\"Pagination\" className=\"mt-6\"&gt;\n          &lt;Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            onPageChange={onPageChange}\n          /&gt;\n        &lt;/nav&gt;\n      )}\n    &lt;/&gt;\n  );\n};\n\nexport default BaseGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseGrid } from \"./BaseGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseGrid.jsx client/src/components/ui/__tests__/BaseGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add BaseGrid component for grid layout and pagination\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-12-create-searchablegrid-component","title":"Task 12: Create SearchableGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/SearchableGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/SearchableGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { SearchableGrid } from \"../SearchableGrid\";\n\n// Mock the libraryApi\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"SearchableGrid\", () =&gt; {\n  it(\"renders search controls\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    // Wait for initial load\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"applies locked filters without showing them in UI\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write SearchableGrid implementation</p> <pre><code>// client/src/components/ui/SearchableGrid.jsx\nimport { useCallback, useRef, useState } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport deepEqual from \"fast-deep-equal\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport BaseGrid from \"./BaseGrid.jsx\";\nimport SearchControls from \"./SearchControls.jsx\";\n\n/**\n * SearchableGrid - BaseGrid with integrated search controls and data fetching\n *\n * @param {Object} props\n * @param {'scene'|'performer'|'gallery'|'group'|'studio'|'tag'|'image'} props.entityType\n * @param {Object} [props.lockedFilters] - Filters that cannot be changed by user\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {'scene'|'standard'} [props.gridType] - Grid layout type\n * @param {Function} props.renderItem - Function to render each item\n * @param {Object} [props.defaultSort] - Default sort configuration\n * @param {Object} [props.defaultFilters] - Default filters\n * @param {Function} [props.onResultsChange] - Callback when results change\n * @param {string} [props.emptyMessage] - Empty state message\n * @param {string} [props.emptyDescription] - Empty state description\n * @param {number} [props.skeletonCount] - Number of skeleton items during loading\n * @param {boolean} [props.syncToUrl] - Whether to sync state to URL (default: true)\n */\nexport const SearchableGrid = ({\n  entityType,\n  lockedFilters = {},\n  hideLockedFilters = false,\n  gridType = \"standard\",\n  renderItem,\n  defaultSort = \"name\",\n  defaultFilters = {},\n  onResultsChange,\n  emptyMessage,\n  emptyDescription,\n  skeletonCount = 24,\n  syncToUrl = true,\n}) =&gt; {\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n  const [searchParams] = useSearchParams();\n\n  const [lastQuery, setLastQuery] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n\n  // API method mapping\n  const apiMethods = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Response key mapping\n  const responseKeys = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Data array key mapping\n  const dataKeys = {\n    scene: \"scenes\",\n    performer: \"performers\",\n    gallery: \"galleries\",\n    group: \"groups\",\n    studio: \"studios\",\n    tag: \"tags\",\n    image: \"images\",\n  };\n\n  const handleQueryChange = useCallback(\n    async (newQuery) =&gt; {\n      if (isAuthLoading || !isAuthenticated) {\n        return;\n      }\n\n      // Merge locked filters into query\n      const mergedQuery = {\n        ...newQuery,\n        ...lockedFilters,\n      };\n\n      // Avoid duplicate queries\n      if (lastQuery &amp;&amp; deepEqual(mergedQuery, lastQuery)) {\n        return;\n      }\n\n      try {\n        setIsLoading(true);\n        setLastQuery(mergedQuery);\n        setError(null);\n\n        const apiMethod = apiMethods[entityType];\n        const responseKey = responseKeys[entityType];\n        const dataKey = dataKeys[entityType];\n\n        const result = await libraryApi[apiMethod](mergedQuery);\n        const items = result[responseKey]?.[dataKey] || [];\n        const count = result[responseKey]?.count || 0;\n\n        setData(items);\n        setTotalCount(count);\n        onResultsChange?.({ items, count });\n      } catch (err) {\n        setError(err);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [entityType, lockedFilters, lastQuery, isAuthLoading, isAuthenticated, onResultsChange]\n  );\n\n  // Handle successful hide - remove item from local state\n  const handleHideSuccess = useCallback((entityId) =&gt; {\n    setData((prevData) =&gt; prevData.filter((item) =&gt; item.id !== entityId));\n    setTotalCount((prevCount) =&gt; Math.max(0, prevCount - 1));\n  }, []);\n\n  // Calculate pagination\n  const currentPerPage = lastQuery?.filter?.per_page || 24;\n  const totalPages = Math.ceil(totalCount / currentPerPage);\n\n  // Build filter key for locked filters if we need to hide them\n  const permanentFiltersMetadata = hideLockedFilters ? {} : lockedFilters;\n\n  return (\n    &lt;SearchControls\n      artifactType={entityType}\n      initialSort={defaultSort}\n      onQueryChange={handleQueryChange}\n      permanentFilters={lockedFilters}\n      permanentFiltersMetadata={permanentFiltersMetadata}\n      totalPages={totalPages}\n      totalCount={totalCount}\n      syncToUrl={syncToUrl}\n    &gt;\n      &lt;BaseGrid\n        items={data}\n        renderItem={(item, index) =&gt;\n          renderItem(item, index, { onHideSuccess: handleHideSuccess })\n        }\n        gridType={gridType}\n        loading={isLoading}\n        error={error}\n        emptyMessage={emptyMessage || `No ${entityType}s found`}\n        emptyDescription={emptyDescription}\n        skeletonCount={skeletonCount}\n      /&gt;\n    &lt;/SearchControls&gt;\n  );\n};\n\nexport default SearchableGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { SearchableGrid } from \"./SearchableGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/SearchableGrid.jsx client/src/components/ui/__tests__/SearchableGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add SearchableGrid with integrated search controls and data fetching\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-13-create-grids-directory-structure","title":"Task 13: Create grids directory structure","text":"<p>Files: - Create: <code>client/src/components/grids/</code> - Create: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Create directory and index</p> <pre><code>// client/src/components/grids/index.js\n// Entity grid components will be exported here\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/grids/\ngit commit -m \"chore: create grids directory structure\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-14-create-performergrid","title":"Task 14: Create PerformerGrid","text":"<p>Files: - Create: <code>client/src/components/grids/PerformerGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/PerformerGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\", image_path: \"/test.jpg\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerGrid\", () =&gt; {\n  it(\"renders performers from API\", async () =&gt; {\n    renderWithRouter(&lt;PerformerGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"supports locked filters for nested grids\", async () =&gt; {\n    renderWithRouter(\n      &lt;PerformerGrid\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write PerformerGrid implementation</p> <pre><code>// client/src/components/grids/PerformerGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { PerformerCard } from \"../cards/index.js\";\n\n/**\n * PerformerGrid - Grid for displaying performers with search and filtering\n *\n * @param {Object} [props.lockedFilters] - Filters locked for nested grid use\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {string} [props.emptyMessage] - Custom empty state message\n */\nconst PerformerGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No performers found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"performer\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"o_counter\"\n      renderItem={(performer, _index, { onHideSuccess }) =&gt; (\n        &lt;PerformerCard\n          key={performer.id}\n          performer={performer}\n          onHideSuccess={() =&gt; onHideSuccess(performer.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default PerformerGrid;\n</code></pre> <p>Step 4: Update grids/index.js</p> <pre><code>export { default as PerformerGrid } from \"./PerformerGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/grids/PerformerGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/PerformerGrid.test.jsx\ngit commit -m \"feat(grids): add PerformerGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-15-create-gallerygrid","title":"Task 15: Create GalleryGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GalleryGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/GalleryGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findGalleries: jest.fn().mockResolvedValue({\n      findGalleries: {\n        galleries: [\n          { id: \"1\", title: \"Test Gallery\", paths: { cover: \"/test.jpg\" } },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryGrid\", () =&gt; {\n  it(\"renders galleries from API\", async () =&gt; {\n    renderWithRouter(&lt;GalleryGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test, write implementation, verify</p> <pre><code>// client/src/components/grids/GalleryGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { GalleryCard } from \"../cards/index.js\";\n\nconst GalleryGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No galleries found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"gallery\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"date\"\n      renderItem={(gallery, _index, { onHideSuccess }) =&gt; (\n        &lt;GalleryCard\n          key={gallery.id}\n          gallery={gallery}\n          onHideSuccess={() =&gt; onHideSuccess(gallery.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default GalleryGrid;\n</code></pre> <p>Step 3: Update index, run test, commit</p> <pre><code>git add client/src/components/grids/GalleryGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/GalleryGrid.test.jsx\ngit commit -m \"feat(grids): add GalleryGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-16-create-groupgrid","title":"Task 16: Create GroupGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GroupGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern to GalleryGrid - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add GroupGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-17-create-studiogrid","title":"Task 17: Create StudioGrid","text":"<p>Files: - Create: <code>client/src/components/grids/StudioGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add StudioGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-18-create-taggrid","title":"Task 18: Create TagGrid","text":"<p>Files: - Create: <code>client/src/components/grids/TagGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add TagGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-19-create-imagegrid","title":"Task 19: Create ImageGrid","text":"<p>Files: - Create: <code>client/src/components/grids/ImageGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add ImageGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-5-migration-cleanup","title":"Phase 5: Migration &amp; Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-20-update-performerdetail-to-use-new-grid-components","title":"Task 20: Update PerformerDetail to use new grid components","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code></p> <p>Step 1: Verify existing behavior works</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to a performer detail page and verify tabs work.</p> <p>Step 2: Update imports</p> <pre><code>// In PerformerDetail.jsx, replace:\nimport { EntityGrid } from \"../ui/index.js\";\n\n// With:\nimport { GalleryGrid, GroupGrid } from \"../grids/index.js\";\n</code></pre> <p>Step 3: Replace EntityGrid usage</p> <p>Replace galleries tab content: <pre><code>{activeTab === 'galleries' &amp;&amp; (\n  &lt;GalleryGrid\n    lockedFilters={{\n      gallery_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No galleries found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Replace groups tab content: <pre><code>{activeTab === 'groups' &amp;&amp; (\n  &lt;GroupGrid\n    lockedFilters={{\n      group_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No collections found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Step 4: Verify changes work</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to performer detail page, verify all tabs still work.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx\ngit commit -m \"refactor(pages): update PerformerDetail to use new grid components\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-21-update-remaining-detail-pages","title":"Task 21: Update remaining detail pages","text":"<p>Files: - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code></p> <p>Follow same pattern as Task 20 for each page.</p> <p>Commit after each page: <pre><code>git commit -m \"refactor(pages): update StudioDetail to use new grid components\"\ngit commit -m \"refactor(pages): update TagDetail to use new grid components\"\n# etc.\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-22-delete-deprecated-gridcardjsx","title":"Task 22: Delete deprecated GridCard.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/GridCard.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (remove export)</p> <p>Step 1: Search for GridCard usages</p> <p>Run: <code>grep -r \"GridCard\" client/src --include=\"*.jsx\" --include=\"*.js\"</code></p> <p>Step 2: Ensure no remaining usages</p> <p>All usages should have been replaced by BaseCard-based components.</p> <p>Step 3: Delete and update exports</p> <pre><code>git rm client/src/components/ui/GridCard.jsx\n</code></pre> <p>Update index.js to remove: <pre><code>// Remove this line:\nexport { GridCard } from \"./GridCard.jsx\";\n</code></pre></p> <p>Step 4: Verify build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/index.js\ngit commit -m \"refactor(cards): delete deprecated GridCard.jsx\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-23-delete-deprecated-entitygridjsx","title":"Task 23: Delete deprecated EntityGrid.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/EntityGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Follow same pattern as Task 22.</p> <p>Commit: <pre><code>git commit -m \"refactor(grids): delete deprecated EntityGrid.jsx\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-24-run-full-test-suite-and-fix-any-issues","title":"Task 24: Run full test suite and fix any issues","text":"<p>Step 1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --watchAll=false</code></p> <p>Step 2: Fix any failing tests</p> <p>Update snapshots if needed, fix any regressions.</p> <p>Step 3: Run build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Step 4: Manual testing</p> <p>Test all pages in browser: - Scenes page - Performers page + detail - Galleries page + detail - Collections page + detail - Studios page + detail - Tags page + detail</p> <p>Step 5: Commit any fixes</p> <pre><code>git commit -m \"fix: address test failures after card/grid refactor\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-25-update-documentation","title":"Task 25: Update documentation","text":"<p>Files: - Modify: <code>docs/architecture/components.md</code> (if exists) - Or create brief documentation in README</p> <p>Document the new component hierarchy: - Primitives (CardComponents.jsx) - BaseCard + BaseGrid - Entity Cards (components/cards/) - Entity Grids (components/grids/)</p> <p>Commit: <pre><code>git commit -m \"docs: update component documentation for card/grid refactor\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#final-checklist","title":"Final Checklist","text":"<ul> <li> All tests pass</li> <li> Build succeeds without warnings</li> <li> All entity types have dedicated Card components</li> <li> All entity types have dedicated Grid components</li> <li> Nested grids work with locked filters on detail pages</li> <li> No deprecated components remain (GridCard, EntityGrid)</li> <li> Visual appearance matches pre-refactor state</li> <li> TV mode still functions correctly</li> <li> Selection mode in SceneGrid still works</li> </ul> <p>Plan complete and saved to <code>docs/plans/2025-01-12-card-grid-refactor-implementation.md</code>.</p> <p>Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/","title":"Empty Entity Filtering Bug Fix Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix the bug where non-admin users see drastically reduced entity counts (Performers: 180/7000+, Studios: 941/1101) due to missing relationship data in empty entity filtering.</p> <p>Architecture: Add new scene query methods that include performer/tag junction data, update <code>filterEmptyStudios</code> with parent/child traversal and gallery lookup, update <code>filterEmptyTags</code> to accept performer data for tag lookup.</p> <p>Tech Stack: TypeScript, Prisma ORM, Express controllers</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-1-add-getallsceneswithperformers-method","title":"Task 1: Add getAllScenesWithPerformers Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:185</code> (after getAllScenesWithTags) - Test: <code>server/services/__tests__/StashEntityService.test.ts</code> (if exists, otherwise manual verification)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithTags()</code> method (around line 185):</p> <pre><code>  /**\n   * Get all scenes with performers relation included\n   * Used for empty entity filtering which needs to know which performers appear in visible scenes\n   */\n  async getAllScenesWithPerformers(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformers: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformers method for empty entity filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-2-add-getallsceneswithperformersandtags-method","title":"Task 2: Add getAllScenesWithPerformersAndTags Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code> (after the method added in Task 1)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithPerformers()</code>:</p> <pre><code>  /**\n   * Get all scenes with both performers and tags relations included\n   * Used for tags filtering which needs both performer IDs and tag IDs\n   */\n  async getAllScenesWithPerformersAndTags(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n        tags: {\n          select: { tagId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      scene.tags = (c.tags?.map((t: { tagId: string }) =&gt; ({ id: t.tagId })) || []) as typeof scene.tags;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformersAndTags: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformersAndTags method for tags filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-3-update-filteremptystudios-with-parentchild-traversal","title":"Task 3: Update filterEmptyStudios with Parent/Child Traversal","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:269-332</code> (replace filterEmptyStudios method)</p> <p>Step 1: Replace the filterEmptyStudios method</p> <p>Find <code>filterEmptyStudios</code> method (starts around line 269) and replace entirely with:</p> <pre><code>  /**\n   * Filter studios with no content\n   * Hide if ALL of:\n   * - Not in any visible scene\n   * - No visible groups\n   * - No images\n   * - No visible galleries\n   * - No child studios with content\n   */\n  filterEmptyStudios&lt;T extends FilterableStudio&gt;(\n    studios: T[],\n    visibleGroups: FilterableGroup[],\n    visibleGalleries: FilterableGallery[],\n    visibleScenes?: Array&lt;{ id: string; studio?: { id: string } | null }&gt;\n  ): T[] {\n    // Build set of studios in visible scenes\n    const studiosInVisibleScenes = new Set&lt;string&gt;();\n    if (visibleScenes) {\n      for (const scene of visibleScenes) {\n        if (scene.studio) {\n          studiosInVisibleScenes.add(scene.studio.id);\n        }\n      }\n    }\n\n    // Build sets of visible group and gallery IDs for fast lookup\n    const visibleGroupIds = new Set(visibleGroups.map((g) =&gt; g.id));\n    const visibleGalleryIds = new Set(visibleGalleries.map((g) =&gt; g.id));\n\n    // Build set of studios that have visible galleries\n    const studiosWithVisibleGalleries = new Set&lt;string&gt;();\n    for (const gallery of visibleGalleries) {\n      const studioId = (gallery as { studio?: { id: string } }).studio?.id;\n      if (studioId) {\n        studiosWithVisibleGalleries.add(studioId);\n      }\n    }\n\n    // Build parent -&gt; children map for recursive check\n    const studioMap = new Map(studios.map((s) =&gt; [s.id, s]));\n    const childrenMap = new Map&lt;string, string[]&gt;();\n    for (const studio of studios) {\n      const parentId = (studio as { parent_studio?: { id: string } }).parent_studio?.id;\n      if (parentId) {\n        if (!childrenMap.has(parentId)) {\n          childrenMap.set(parentId, []);\n        }\n        childrenMap.get(parentId)!.push(studio.id);\n      }\n    }\n\n    // Track which studios have content\n    const hasContent = new Map&lt;string, boolean&gt;();\n\n    const checkHasContent = (studioId: string, visited = new Set&lt;string&gt;()): boolean =&gt; {\n      if (visited.has(studioId)) return false;\n      visited.add(studioId);\n\n      if (hasContent.has(studioId)) {\n        return hasContent.get(studioId)!;\n      }\n\n      const studio = studioMap.get(studioId);\n      if (!studio) return false;\n\n      // Check if studio appears in visible scenes\n      if (visibleScenes &amp;&amp; studiosInVisibleScenes.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Fallback to scene_count if visibleScenes not provided\n      if (!visibleScenes &amp;&amp; studio.scene_count &amp;&amp; studio.scene_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has images? Keep\n      if (studio.image_count &amp;&amp; studio.image_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible galleries? Keep\n      if (studiosWithVisibleGalleries.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible groups? Keep\n      if (studio.groups &amp;&amp; Array.isArray(studio.groups)) {\n        if (studio.groups.some((g) =&gt; visibleGroupIds.has(g.id))) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      // Check if any child studio has content\n      const children = childrenMap.get(studioId) || [];\n      for (const childId of children) {\n        if (checkHasContent(childId, visited)) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      hasContent.set(studioId, false);\n      return false;\n    };\n\n    // Check all studios\n    for (const studio of studios) {\n      checkHasContent(studio.id);\n    }\n\n    const filtered = studios.filter((studio) =&gt; hasContent.get(studio.id) === true);\n\n    logger.debug(\"Filtered empty studios\", {\n      original: studios.length,\n      filtered: filtered.length,\n      removed: studios.length - filtered.length,\n    });\n\n    return filtered;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: add parent/child traversal and gallery lookup to filterEmptyStudios\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-4-update-filteremptytags-to-accept-allperformers-parameter","title":"Task 4: Update filterEmptyTags to Accept allPerformers Parameter","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:342-515</code> (update filterEmptyTags method)</p> <p>Step 1: Update the method signature and add performer lookup</p> <p>Find <code>filterEmptyTags</code> method (starts around line 342). Update the signature and the performer tag lookup logic:</p> <p>Change the method signature from: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;;\n      studio?: { id: string; tags?: Array&lt;{ id: string }&gt; } | null;\n    }&gt;\n  ): T[] {\n</code></pre></p> <p>To: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string }&gt;;\n      studio?: { id: string } | null;\n    }&gt;,\n    allPerformers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;\n  ): T[] {\n</code></pre></p> <p>Then, inside the method, after line <code>const tagsOnVisibleEntities = new Set&lt;string&gt;();</code> add:</p> <pre><code>    // Build performer ID -&gt; tags lookup from allPerformers\n    const performerTagsMap = new Map&lt;string, string[]&gt;();\n    if (allPerformers) {\n      for (const performer of allPerformers) {\n        if (performer.tags) {\n          performerTagsMap.set(performer.id, performer.tags.map(t =&gt; t.id));\n        }\n      }\n    }\n</code></pre> <p>Then update the performer tags section (around lines 375-384) from: <pre><code>        // Tags on performers in visible scenes\n        if (scene.performers) {\n          for (const performer of scene.performers) {\n            if (performer.tags) {\n              for (const tag of performer.tags) {\n                tagsOnVisibleEntities.add(tag.id);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Tags on performers in visible scenes (lookup from allPerformers)\n        if (scene.performers &amp;&amp; allPerformers) {\n          for (const performer of scene.performers) {\n            const performerTags = performerTagsMap.get(performer.id);\n            if (performerTags) {\n              for (const tagId of performerTags) {\n                tagsOnVisibleEntities.add(tagId);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>Also update the studio tags section (around lines 386-391) from: <pre><code>        // Tags on studio in visible scenes\n        if (scene.studio?.tags) {\n          for (const tag of scene.studio.tags) {\n            tagsOnVisibleEntities.add(tag.id);\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Note: Studio tags are not loaded via scenes - they're on the studio entities\n        // This would require passing allStudios, but studio tags are a rare use case\n        // Skip for now - can be added later if needed\n</code></pre></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: update filterEmptyTags to accept allPerformers for tag lookup\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-5-update-performersts-to-use-getallsceneswithperformers","title":"Task 5: Update performers.ts to Use getAllScenesWithPerformers","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts:122</code> (findPerformers) - Modify: <code>server/controllers/library/performers.ts:605</code> (findPerformersMinimal)</p> <p>Step 1: Update findPerformers (line 122)</p> <p>Find line 122: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 2: Update findPerformersMinimal (line 605)</p> <p>Find line 605: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/performers.ts\ngit commit -m \"fix: use getAllScenesWithPerformers for performer filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-6-update-tagsts-to-use-getallsceneswithperformersandtags","title":"Task 6: Update tags.ts to Use getAllScenesWithPerformersAndTags","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts:180</code> (findTags) - Modify: <code>server/controllers/library/tags.ts:234-238</code> (filterEmptyTags call in findTags) - Modify: <code>server/controllers/library/tags.ts:763</code> (findTagsMinimal) - Modify: <code>server/controllers/library/tags.ts:815-819</code> (filterEmptyTags call in findTagsMinimal)</p> <p>Step 1: Update findTags scene fetching (line 180)</p> <p>Find line 180: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 2: Update filterEmptyTags call in findTags (around line 234-238)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes // \u2190 NEW: Pass visible scenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 3: Update findTagsMinimal scene fetching (line 763)</p> <p>Find line 763: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 4: Update filterEmptyTags call in findTagsMinimal (around line 815-819)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 5: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/controllers/library/tags.ts\ngit commit -m \"fix: use getAllScenesWithPerformersAndTags and pass allPerformers to tag filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-7-run-tests-and-verify","title":"Task 7: Run Tests and Verify","text":"<p>Files: - Test: All existing tests</p> <p>Step 1: Run the test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Fix any failing tests</p> <p>If any tests fail due to the new method signatures, update them accordingly.</p> <p>Step 3: Commit any test fixes</p> <pre><code>git add -A\ngit commit -m \"test: fix tests for empty entity filtering changes\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-8-manual-verification","title":"Task 8: Manual Verification","text":"<p>Step 1: Start the server</p> <p>Run: <code>npm run dev</code> (or however the dev server starts)</p> <p>Step 2: Log in as non-admin user</p> <p>Step 3: Verify counts</p> <ul> <li>Navigate to Performers page - should show 7,000+ (not 180)</li> <li>Navigate to Studios page - should show 1,101 (not 941)</li> <li>Navigate to Tags page - verify count looks correct</li> <li>Check that parent studios with only child content are visible</li> <li>Check that studios with only galleries are visible</li> </ul> <p>Step 4: Log in as admin and verify counts still match</p> <p>Step 5: Final commit if any adjustments needed</p> <pre><code>git add -A\ngit commit -m \"fix: empty entity filtering - complete fix for performer/studio/tag counts\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#summary","title":"Summary","text":"Task Description Files 1 Add getAllScenesWithPerformers StashEntityService.ts 2 Add getAllScenesWithPerformersAndTags StashEntityService.ts 3 Update filterEmptyStudios with parent/child EmptyEntityFilterService.ts 4 Update filterEmptyTags to accept allPerformers EmptyEntityFilterService.ts 5 Update performers.ts call sites performers.ts 6 Update tags.ts call sites tags.ts 7 Run tests - 8 Manual verification -"},{"location":"plans/2025-12-15-filter-chip-interaction-design/","title":"Filter Chip Interaction Improvements","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#overview","title":"Overview","text":"<p>Two UX improvements to filter interactions:</p> <ol> <li>Clickable filter chips - Clicking a filter chip opens the Filter Panel and highlights the corresponding filter control</li> <li>Clear All button in SearchableSelect - Add a \"Clear All\" button to multi-select dropdowns</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-1-clickable-filter-chips","title":"Feature 1: Clickable Filter Chips","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior","title":"Current Behavior","text":"<ul> <li>Filter chips display active filters with an X button to remove</li> <li>Only the X button is interactive; the chip body does nothing</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior","title":"New Behavior","text":"<ul> <li>Clicking anywhere on a chip (except X) opens the Filter Panel</li> <li>The corresponding filter control scrolls into view</li> <li>A border-pulse animation highlights the control for 1.5 seconds</li> <li>If the filter is in a collapsed section, that section expands first</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation","title":"Implementation","text":"<p>ActiveFilterChips.jsx: - Add <code>onChipClick</code> prop that receives the filter key - Make chip body clickable with <code>cursor-pointer</code> - X button uses <code>stopPropagation</code> to prevent triggering chip click</p> <p>SearchControls.jsx: - Add state: <code>highlightedFilterKey</code> (string | null) - Add handler <code>handleFilterChipClick(filterKey)</code>:   1. Open filter panel   2. Expand collapsed section if needed   3. Set <code>highlightedFilterKey</code> - Clear highlight after 1.5s via useEffect timeout - Pass <code>highlightedFilterKey</code> to FilterPanel</p> <p>FilterControls.jsx (FilterPanel): - Accept <code>highlightedFilterKey</code> prop - Store refs for each FilterControl by key - When <code>highlightedFilterKey</code> changes:   - Scroll the ref into view   - Apply <code>filter-highlight</code> CSS class</p> <p>CSS Animation: <pre><code>@keyframes filter-highlight-pulse {\n  0% {\n    border-color: var(--accent-primary);\n    box-shadow: 0 0 0 2px var(--accent-primary);\n  }\n  100% {\n    border-color: var(--border-color);\n    box-shadow: none;\n  }\n}\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n}\n</code></pre></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-2-searchableselect-clear-all-button","title":"Feature 2: SearchableSelect Clear All Button","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior_1","title":"Current Behavior","text":"<ul> <li>Multi-select shows selected items as chips inside the trigger area</li> <li>Each chip has an X to remove that individual item</li> <li>No way to clear all selections at once without opening dropdown</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior_1","title":"New Behavior","text":"<ul> <li>A \"Clear All\" X button appears next to the chevron when there are selections</li> <li>Clicking it clears all selections without opening the dropdown</li> <li>Visually distinct from individual chip X buttons (slightly larger)</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation_1","title":"Implementation","text":"<p>SearchableSelect.jsx:</p> <p>New handler: <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre></p> <p>Updated trigger layout: - From: <code>[selected chips] [chevron]</code> - To: <code>[selected chips] [clear-all X] [chevron]</code></p> <p>Clear button: - Only visible when <code>selectedItems.length &gt; 0</code> - <code>LucideX</code> icon at size 16 (vs 14 for chip X buttons) - Subtle gray color, darkens on hover - <code>aria-label=\"Clear all selections\"</code></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>client/src/components/ui/ActiveFilterChips.jsx</code> - Add click handler to chips</li> <li><code>client/src/components/ui/SearchControls.jsx</code> - Add highlight state and chip click handler</li> <li><code>client/src/components/ui/FilterControls.jsx</code> - Add highlight styling and scroll behavior</li> <li><code>client/src/components/ui/SearchableSelect.jsx</code> - Add Clear All button</li> <li><code>client/src/index.css</code> (or appropriate CSS file) - Add highlight animation</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/","title":"Filter Chip Interaction Improvements - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add clickable filter chips that highlight their corresponding filter control, and add a \"Clear All\" button to SearchableSelect dropdowns.</p> <p>Architecture: Two independent features: (1) Filter chips get click handlers that open the filter panel, expand collapsed sections, scroll to the control, and apply a pulse animation. (2) SearchableSelect gets a clear-all button in the trigger area.</p> <p>Tech Stack: React, Tailwind CSS, Lucide React icons, Vitest for testing</p>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-1-add-css-animation-for-filter-highlight","title":"Task 1: Add CSS Animation for Filter Highlight","text":"<p>Files: - Modify: <code>client/src/index.css</code></p> <p>Step 1: Add the highlight pulse animation</p> <p>Add at the end of <code>client/src/index.css</code>:</p> <pre><code>/* Filter control highlight animation - used when clicking filter chips */\n@keyframes filter-highlight-pulse {\n  0% {\n    box-shadow: 0 0 0 3px var(--accent-primary);\n  }\n  100% {\n    box-shadow: none;\n  }\n}\n\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n  border-radius: 0.375rem;\n}\n</code></pre> <p>Step 2: Verify the CSS is valid</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds without CSS errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/index.css\ngit commit -m \"feat: add filter highlight pulse animation\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-2-add-clear-all-button-to-searchableselect","title":"Task 2: Add Clear All Button to SearchableSelect","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx</code> - Create: <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code></p> <p>Step 2.1: Write the failing test for clear all functionality</p> <p>Create <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport SearchableSelect from \"../SearchableSelect\";\n\n// Mock the API\nvi.mock(\"../../../services/api.js\", () =&gt; ({\n  libraryApi: {\n    findPerformers: vi.fn().mockResolvedValue({ findPerformers: { performers: [] } }),\n    findPerformersMinimal: vi.fn().mockResolvedValue([]),\n  },\n}));\n\n// Mock the filter cache\nvi.mock(\"../../../utils/filterCache.js\", () =&gt; ({\n  getCache: vi.fn().mockReturnValue(null),\n  setCache: vi.fn(),\n}));\n\ndescribe(\"SearchableSelect\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(SearchableSelect).toBeDefined();\n    expect(typeof SearchableSelect).toBe(\"function\");\n  });\n\n  describe(\"Clear All button\", () =&gt; {\n    it(\"shows clear all button when there are selections in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      // Wait for component to load selected items\n      // The clear all button should be visible\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      expect(clearButton).toBeInTheDocument();\n    });\n\n    it(\"does not show clear all button when no selections\", () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = screen.queryByLabelText(\"Clear all selections\");\n      expect(clearButton).not.toBeInTheDocument();\n    });\n\n    it(\"calls onChange with empty array when clear all is clicked in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      expect(onChange).toHaveBeenCalledWith([]);\n    });\n\n    it(\"does not open dropdown when clear all is clicked\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      // Dropdown search input should not be visible\n      const searchInput = screen.queryByPlaceholderText(\"Search performers...\");\n      expect(searchInput).not.toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: FAIL - \"Clear all selections\" button not found</p> <p>Step 2.3: Implement the clear all button in SearchableSelect</p> <p>In <code>client/src/components/ui/SearchableSelect.jsx</code>, make these changes:</p> <ol> <li>Add the <code>handleClearAll</code> function after <code>handleRemove</code> (around line 272):</li> </ol> <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre> <ol> <li>Update the trigger area JSX (starting around line 281). Replace the existing return statement's outer div content with:</li> </ol> <p>Find this section (lines ~281-336): <pre><code>return (\n  &lt;div ref={dropdownRef} className=\"relative w-full\"&gt;\n    {/* Selected items display / Trigger button */}\n    &lt;div\n      onClick={() =&gt; setIsOpen(!isOpen)}\n      className=\"w-full pl-3 pr-[2px] py-2 rounded-md cursor-pointer border text-sm flex items-center justify-between gap-2\"\n      style={{\n        backgroundColor: \"var(--bg-card)\",\n        borderColor: \"var(--border-color)\",\n        color: \"var(--text-primary)\",\n      }}\n    &gt;\n      &lt;div className=\"flex flex-wrap gap-1 flex-1\"&gt;\n        {selectedItems.length === 0 ? (\n          &lt;span style={{ color: \"var(--text-muted)\" }}&gt;{placeholder}&lt;/span&gt;\n        ) : multi ? (\n          selectedItems.map((item) =&gt; (\n            ...\n          ))\n        ) : (\n          ...\n        )}\n      &lt;/div&gt;\n      &lt;LucideChevronDown\n        ...\n      /&gt;\n    &lt;/div&gt;\n</code></pre></p> <p>Replace the closing section (after the <code>&lt;/div&gt;</code> that wraps selected items, before <code>&lt;LucideChevronDown&gt;</code>) with:</p> <pre><code>      &lt;/div&gt;\n      &lt;div className=\"flex items-center gap-1 flex-shrink-0\"&gt;\n        {selectedItems.length &gt; 0 &amp;&amp; (\n          &lt;Button\n            onClick={handleClearAll}\n            variant=\"tertiary\"\n            className=\"hover:opacity-70 !p-1 !border-0\"\n            aria-label=\"Clear all selections\"\n            title=\"Clear all\"\n            icon={&lt;LucideX size={16} style={{ color: \"var(--text-muted)\" }} /&gt;}\n          /&gt;\n        )}\n        &lt;LucideChevronDown\n          size={14}\n          style={{\n            transform: isOpen ? \"rotate(180deg)\" : \"rotate(0deg)\",\n            transition: \"transform 0.2s\",\n            color: \"var(--text-muted)\",\n          }}\n        /&gt;\n      &lt;/div&gt;\n</code></pre> <p>Step 2.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: PASS</p> <p>Step 2.5: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx client/src/components/ui/__tests__/SearchableSelect.test.jsx\ngit commit -m \"feat: add clear all button to SearchableSelect\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-3-add-onchipclick-prop-to-activefilterchips","title":"Task 3: Add onChipClick Prop to ActiveFilterChips","text":"<p>Files: - Modify: <code>client/src/components/ui/ActiveFilterChips.jsx</code> - Create: <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code></p> <p>Step 3.1: Write failing test for chip click behavior</p> <p>Create <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport ActiveFilterChips from \"../ActiveFilterChips\";\n\nconst mockFilterOptions = [\n  { key: \"rating\", label: \"Rating\", type: \"range\" },\n  { key: \"favorite\", label: \"Favorite\", type: \"checkbox\" },\n  { key: \"performers\", label: \"Performers\", type: \"searchable-select\" },\n];\n\ndescribe(\"ActiveFilterChips\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(ActiveFilterChips).toBeDefined();\n    expect(typeof ActiveFilterChips).toBe(\"function\");\n  });\n\n  describe(\"chip click behavior\", () =&gt; {\n    it(\"calls onChipClick with filter key when chip body is clicked\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the chip body (the text part)\n      const chipText = screen.getByText(\"Favorite\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).toHaveBeenCalledWith(\"favorite\");\n      expect(onRemoveFilter).not.toHaveBeenCalled();\n    });\n\n    it(\"calls onRemoveFilter when X button is clicked, not onChipClick\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the remove button\n      const removeButton = screen.getByLabelText(\"Remove filter: Favorite\");\n      fireEvent.click(removeButton);\n\n      expect(onRemoveFilter).toHaveBeenCalledWith(\"favorite\");\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"does not call onChipClick for permanent filter chips\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{}}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n          permanentFilters={{ performers: [\"1\"] }}\n          permanentFiltersMetadata={{ performers: [{ id: \"1\", name: \"Test Performer\" }] }}\n        /&gt;\n      );\n\n      // Click the permanent chip\n      const chipText = screen.getByText(\"Performer: Test Performer\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"shows pointer cursor on clickable chips\", () =&gt; {\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={vi.fn()}\n          onChipClick={vi.fn()}\n        /&gt;\n      );\n\n      const chip = screen.getByText(\"Favorite\").closest(\"div\");\n      expect(chip).toHaveClass(\"cursor-pointer\");\n    });\n  });\n});\n</code></pre> <p>Step 3.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: FAIL - onChipClick not called / cursor-pointer class not found</p> <p>Step 3.3: Implement chip click handler in ActiveFilterChips</p> <p>In <code>client/src/components/ui/ActiveFilterChips.jsx</code>:</p> <ol> <li>Add <code>onChipClick</code> to the props (around line 14):</li> </ol> <pre><code>const ActiveFilterChips = ({\n  filters,\n  filterOptions,\n  onRemoveFilter,\n  onChipClick,\n  permanentFilters = {},\n  permanentFiltersMetadata = {},\n}) =&gt; {\n</code></pre> <ol> <li>Update the JSDoc to include the new prop (around line 4):</li> </ol> <pre><code>/**\n * Display active filters as removable chips/badges\n *\n * @param {Object} props\n * @param {Object} props.filters - Current filter values\n * @param {Array} props.filterOptions - Filter configuration from filterConfig.js\n * @param {Function} props.onRemoveFilter - Callback when a filter is removed\n * @param {Function} props.onChipClick - Callback when a chip body is clicked (receives filter key)\n * @param {Object} props.permanentFilters - Filters that can't be removed\n * @param {Object} props.permanentFiltersMetadata - Display names for permanent filters\n */\n</code></pre> <ol> <li>Update the chip rendering (around line 156-185). Replace the chip <code>&lt;div&gt;</code> with:</li> </ol> <pre><code>{allChips.map((chip) =&gt; (\n  &lt;div\n    key={chip.key}\n    onClick={() =&gt; !chip.isPermanent &amp;&amp; onChipClick?.(chip.key)}\n    className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm border transition-colors ${\n      !chip.isPermanent ? \"cursor-pointer hover:opacity-80\" : \"\"\n    }`}\n    style={{\n      backgroundColor: chip.isPermanent\n        ? \"var(--bg-tertiary)\"\n        : \"var(--bg-secondary)\",\n      borderColor: chip.isPermanent\n        ? \"var(--border-color)\"\n        : \"var(--accent-primary)\",\n      color: chip.isPermanent\n        ? \"var(--text-secondary)\"\n        : \"var(--text-primary)\",\n      opacity: chip.isPermanent ? 0.7 : 1,\n    }}\n  &gt;\n    &lt;span&gt;{chip.label}&lt;/span&gt;\n    {!chip.isPermanent &amp;&amp; (\n      &lt;Button\n        onClick={(e) =&gt; {\n          e.stopPropagation();\n          onRemoveFilter(chip.key);\n        }}\n        variant=\"tertiary\"\n        className=\"hover:opacity-70 !p-0 !border-0\"\n        aria-label={`Remove filter: ${chip.label}`}\n        title={`Remove filter: ${chip.label}`}\n        icon={&lt;LucideX className=\"w-3.5 h-3.5\" /&gt;}\n      /&gt;\n    )}\n  &lt;/div&gt;\n))}\n</code></pre> <p>Step 3.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: PASS</p> <p>Step 3.5: Commit</p> <pre><code>git add client/src/components/ui/ActiveFilterChips.jsx client/src/components/ui/__tests__/ActiveFilterChips.test.jsx\ngit commit -m \"feat: add onChipClick prop to ActiveFilterChips\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-4-add-highlight-support-to-filterpanel","title":"Task 4: Add Highlight Support to FilterPanel","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterControls.jsx</code></p> <p>Step 4.1: Update FilterPanel to accept highlight props</p> <p>In <code>client/src/components/ui/FilterControls.jsx</code>, update the <code>FilterPanel</code> component (around line 431):</p> <ol> <li>Add new props to FilterPanel:</li> </ol> <pre><code>export const FilterPanel = ({\n  children,\n  onClear,\n  hasActiveFilters,\n  isOpen,\n  onToggle,\n  onSubmit,\n  highlightedFilterKey,\n  filterRefs,\n}) =&gt; {\n</code></pre> <ol> <li>Add useEffect for scroll and highlight behavior. Add this inside FilterPanel, before the <code>if (!isOpen)</code> check:</li> </ol> <pre><code>// Scroll to highlighted filter when it changes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey &amp;&amp; filterRefs?.current?.[highlightedFilterKey]) {\n    const element = filterRefs.current[highlightedFilterKey];\n\n    // Small delay to ensure panel is rendered\n    setTimeout(() =&gt; {\n      element.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n    }, 100);\n  }\n}, [highlightedFilterKey, filterRefs]);\n</code></pre> <ol> <li>Add the useEffect import at the top of the file if not already present:</li> </ol> <pre><code>import { useEffect } from \"react\";\n</code></pre> <p>Step 4.2: Update FilterControl to accept ref and highlight class</p> <p>Update <code>FilterControl</code> component (around line 50) to forward a ref and apply highlight class:</p> <ol> <li>Import <code>forwardRef</code> at the top:</li> </ol> <pre><code>import { forwardRef, useEffect } from \"react\";\n</code></pre> <ol> <li>Wrap FilterControl with forwardRef and add highlight styling:</li> </ol> <pre><code>export const FilterControl = forwardRef(({\n  type = \"select\",\n  label,\n  value,\n  onChange,\n  options = [],\n  placeholder = \"\",\n  min,\n  max,\n  entityType,\n  multi,\n  modifierOptions,\n  modifierValue,\n  onModifierChange,\n  supportsHierarchy = false,\n  hierarchyLabel = \"Include children\",\n  hierarchyValue,\n  onHierarchyChange,\n  isHighlighted = false,\n}, ref) =&gt; {\n  // ... existing code ...\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`flex flex-col ${isHighlighted ? \"filter-highlight\" : \"\"}`}\n    &gt;\n      {/* ... rest of the component */}\n    &lt;/div&gt;\n  );\n});\n\nFilterControl.displayName = \"FilterControl\";\n</code></pre> <p>Step 4.3: Verify changes compile</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4.4: Commit</p> <pre><code>git add client/src/components/ui/FilterControls.jsx\ngit commit -m \"feat: add highlight support to FilterPanel and FilterControl\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-5-wire-up-chip-click-in-searchcontrols","title":"Task 5: Wire Up Chip Click in SearchControls","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 5.1: Add state and refs for highlighting</p> <p>In <code>client/src/components/ui/SearchControls.jsx</code>:</p> <ol> <li>Add <code>useRef</code> to the imports if not already there (line 1):</li> </ol> <pre><code>import React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n</code></pre> <ol> <li>Add state for highlighted filter key (around line 99, after other useState calls):</li> </ol> <pre><code>const [highlightedFilterKey, setHighlightedFilterKey] = useState(null);\nconst filterRefs = useRef({});\n</code></pre> <ol> <li>Add useEffect to clear highlight after animation (add after other useEffects, around line 400):</li> </ol> <pre><code>// Clear highlight after animation completes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey) {\n    const timer = setTimeout(() =&gt; {\n      setHighlightedFilterKey(null);\n    }, 1500);\n    return () =&gt; clearTimeout(timer);\n  }\n}, [highlightedFilterKey]);\n</code></pre> <p>Step 5.2: Add handler for chip clicks</p> <p>Add this handler after <code>handleRemoveFilter</code> (around line 486):</p> <pre><code>// Handle clicking on a filter chip to highlight that filter\nconst handleFilterChipClick = useCallback(\n  (filterKey) =&gt; {\n    // Open filter panel if not already open\n    setIsFilterPanelOpen(true);\n\n    // Find which section this filter belongs to\n    let sectionKey = null;\n    for (let i = 0; i &lt; filterOptions.length; i++) {\n      if (filterOptions[i].type === \"section-header\") {\n        sectionKey = filterOptions[i].key;\n      } else if (filterOptions[i].key === filterKey) {\n        break;\n      }\n    }\n\n    // Expand the section if it's collapsed\n    if (sectionKey &amp;&amp; collapsedSections[sectionKey]) {\n      setCollapsedSections((prev) =&gt; ({\n        ...prev,\n        [sectionKey]: false,\n      }));\n    }\n\n    // Set the highlighted filter key (triggers scroll and animation)\n    setHighlightedFilterKey(filterKey);\n  },\n  [filterOptions, collapsedSections]\n);\n</code></pre> <p>Step 5.3: Pass onChipClick to ActiveFilterChips</p> <p>Update the <code>ActiveFilterChips</code> component usage (around line 796):</p> <pre><code>{/* Active Filter Chips */}\n&lt;ActiveFilterChips\n  filters={filters}\n  filterOptions={filterOptions}\n  onRemoveFilter={handleRemoveFilter}\n  onChipClick={handleFilterChipClick}\n  permanentFilters={permanentFilters}\n  permanentFiltersMetadata={permanentFiltersMetadata}\n/&gt;\n</code></pre> <p>Step 5.4: Pass highlight props to FilterPanel</p> <p>Update the <code>FilterPanel</code> component usage (around line 831):</p> <pre><code>{/* Filter Panel */}\n&lt;FilterPanel\n  isOpen={isFilterPanelOpen}\n  onToggle={handleToggleFilterPanel}\n  onClear={clearFilters}\n  onSubmit={handleFilterSubmit}\n  hasActiveFilters={hasActiveFilters}\n  highlightedFilterKey={highlightedFilterKey}\n  filterRefs={filterRefs}\n&gt;\n</code></pre> <p>Step 5.5: Pass ref and isHighlighted to each FilterControl</p> <p>Update the FilterControl rendering in the map (around line 923-945):</p> <pre><code>return (\n  &lt;FilterControl\n    key={`FilterControl-${key}`}\n    ref={(el) =&gt; {\n      if (el) filterRefs.current[key] = el;\n    }}\n    isHighlighted={highlightedFilterKey === key}\n    onChange={(value) =&gt; handleFilterChange(key, value)}\n    value={filters[key] || defaultValue}\n    type={type}\n    modifierOptions={modifierOptions}\n    modifierValue={filters[modifierKey] || defaultModifier}\n    onModifierChange={(value) =&gt;\n      modifierKey &amp;&amp; handleFilterChange(modifierKey, value)\n    }\n    supportsHierarchy={supportsHierarchy}\n    hierarchyLabel={hierarchyLabel}\n    hierarchyValue={hierarchyKey ? filters[hierarchyKey] : undefined}\n    onHierarchyChange={\n      hierarchyKey\n        ? (value) =&gt; handleFilterChange(hierarchyKey, value)\n        : undefined\n    }\n    {...filterProps}\n  /&gt;\n);\n</code></pre> <p>Step 5.6: Verify changes compile and app works</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 5.7: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: wire up filter chip click to highlight filter controls\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-6-manual-testing-and-final-verification","title":"Task 6: Manual Testing and Final Verification","text":"<p>Step 6.1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm run test:run</code> Expected: All tests pass</p> <p>Step 6.2: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 6.3: Build for production</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 6.4: Manual testing checklist</p> <p>Start the dev server and verify:</p> <ol> <li>SearchableSelect Clear All:</li> <li> Clear button appears when items are selected</li> <li> Clear button disappears when no selections</li> <li> Clicking clear removes all selections</li> <li> <p> Dropdown does not open when clear is clicked</p> </li> <li> <p>Filter Chip Click:</p> </li> <li> Clicking a filter chip opens the filter panel</li> <li> The corresponding filter control scrolls into view</li> <li> A pulse animation highlights the control</li> <li> Animation fades after ~1.5 seconds</li> <li> Clicking the X still removes the filter (doesn't trigger chip click)</li> <li> <p> Permanent filter chips are not clickable</p> </li> <li> <p>Collapsed Sections:</p> </li> <li> Clicking a chip for a filter in a collapsed section expands that section</li> <li> Then scrolls to and highlights the filter</li> </ol> <p>Step 6.5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address issues from manual testing\"\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/","title":"Issues Found in v3.0.0-beta.9","text":"<p>Date: December 15, 2025 To be addressed in separate branches before or after 3.0.0 release</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-1-detail-page-tabs-not-loading-non-scenes-tabs","title":"Issue 1: Detail Page Tabs Not Loading (Non-Scenes Tabs)","text":"<p>Severity: HIGH - User-facing navigation broken</p> <p>Symptoms: - On Performer Detail, Studio Detail, Tag Detail, and Collection/Group Detail pages - Clicking non-Scenes tabs (Galleries, Images, Groups) causes a flicker - URL briefly shows <code>?tab=galleries</code> but immediately switches back to default (Scenes) - Manually typing URL with <code>?tab=galleries</code> also reverts</p> <p>Root Cause Analysis:</p> <p>The issue is NOT related to tab filtering or counts. The <code>SearchControls</code> component completely replaces URL query params when syncing state to URL, obliterating the <code>?tab=</code> parameter.</p> <p>The Problem:</p> <p>In <code>client/src/components/ui/SearchControls.jsx:384</code>: <pre><code>setSearchParams(params, { replace: true });\n</code></pre></p> <p>And in <code>client/src/utils/urlParams.js:169</code>, <code>buildSearchParams()</code> creates a brand new URLSearchParams() that only includes filter/sort/page params - it does NOT preserve unknown params like <code>tab</code>.</p> <p>The Flow: 1. User clicks \"Galleries\" tab \u2192 <code>TabNavigation</code> sets <code>?tab=galleries</code> 2. Tab content changes, <code>GalleryGrid</code> (via <code>SearchableGrid</code> \u2192 <code>SearchControls</code>) mounts 3. <code>SearchControls</code> initializes and calls <code>setSearchParams(params)</code> with only its filter params 4. <code>?tab=galleries</code> is obliterated, replaced with filter params (or empty string) 5. <code>activeTab</code> reads from URL, sees no <code>tab</code> param, defaults back to <code>scenes</code></p> <p>Files to Fix: - <code>client/src/components/ui/SearchControls.jsx</code> - URL sync logic - <code>client/src/utils/urlParams.js</code> - <code>buildSearchParams</code> function</p> <p>Fix Options: 1. Pass <code>syncToUrl={false}</code> to grids rendered inside tabs (quick fix, breaks URL bookmarking for nested grids) 2. Preserve unknown params in <code>buildSearchParams</code> - accept existing params and merge rather than replace 3. Namespace params - use prefixes like <code>scene_sort=</code>, <code>gallery_sort=</code> to avoid conflicts</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-2-tags-query-performance","title":"Issue 2: Tags Query Performance","text":"<p>Severity: MEDIUM - Usability issue, not broken</p> <p>Symptoms: - Tags list page is slow to load - Tag detail page is slow - Not unusable but noticeably slower than other entity types</p> <p>Root Cause Analysis:</p> <p>The <code>enhanceTagsWithPerformerScenes()</code> function at <code>server/controllers/library/tags.ts:19-75</code> is O(n*m) where n=scenes and m=performers. It loads ALL scenes and ALL performers to calculate counts.</p> <p>Key Finding: The real performance issue is that <code>enhanceTagsWithPerformerScenes()</code> is called at <code>tags.ts:261</code>, which is AFTER the filtered entity cache check (lines 151-254). This means:</p> <ul> <li>Tag filtering IS cached (via <code>filteredEntityCacheService</code>)</li> <li>But performer scene enhancement runs on every single request, even cache hits</li> </ul> <p>The caching only helps with content restriction filtering, not with the expensive enhancement step.</p> <p>Files to Fix: - <code>server/controllers/library/tags.ts</code> - Move enhancement inside cache block or cache separately</p> <p>Fix Options: 1. Move enhancement inside cache block - Include enhanced data in the cached result (simplest) 2. Pre-compute counts on sync - Store <code>scene_count_via_performers</code> in the StashTag table 3. Use SQL aggregation - Replace the in-memory calculation with a SQL COUNT query 4. Separate cache for enhancement - Cache the enhancement result with its own TTL 5. Lazy load - Only calculate performer scene counts when specifically requested (detail page)</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-3-o-history-stored-in-json-column","title":"Issue 3: O History Stored in JSON Column","text":"<p>Severity: LOW - Technical debt, not user-facing</p> <p>Current Implementation:</p> <p>From <code>server/prisma/schema.prisma</code> line 72: <pre><code>oHistory Json @default(\"[]\") // Array of timestamp strings when O was incremented\n</code></pre></p> <p>The O history is stored as a JSON array of timestamp strings within the WatchHistory table.</p> <p>Problems with this approach: 1. Cannot efficiently query \"all O events in the last week\" 2. Cannot aggregate O events across scenes/performers without loading all JSON 3. JSON arrays don't scale well for users with thousands of O events 4. No referential integrity</p> <p>Proposed Schema:</p> <pre><code>model OEvent {\n  id           Int       @id @default(autoincrement())\n  userId       Int\n  sceneId      String\n  timestamp    DateTime  @default(now())\n\n  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  watchHistory WatchHistory? @relation(fields: [userId, sceneId], references: [userId, sceneId])\n\n  @@index([userId])\n  @@index([sceneId])\n  @@index([timestamp])\n  @@index([userId, timestamp])\n}\n</code></pre> <p>Migration Strategy: 1. Create the new OEvent table 2. Write a data migration to move existing oHistory JSON arrays to the new table 3. Update all services that read/write oHistory to use the new table 4. Keep oHistory JSON for backward compatibility during migration period 5. Eventually deprecate and remove oHistory column</p> <p>Files to Change: - <code>server/prisma/schema.prisma</code> - Add OEvent model - <code>server/controllers/watchHistory.ts</code> - Update increment-o endpoint - <code>server/services/UserStatsService.ts</code> - Update O counter aggregation - <code>server/services/SceneQueryBuilder.ts</code> - Update any O history queries</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-4-o-counter-ui-shows-stale-value-after-playlist-navigation","title":"Issue 4: O Counter UI Shows Stale Value After Playlist Navigation","text":"<p>Severity: MEDIUM - Confusing UX</p> <p>Symptoms: 1. User increments O counter on Scene A (e.g., 0 \u2192 1) 2. User navigates to next scene (Scene B) in playlist 3. Scene B shows O counter value of 1 (from Scene A) instead of Scene B's actual value 4. This persists as user navigates through playlist 5. If user goes back to Scene A and then navigates away again, it resets correctly</p> <p>Root Cause Analysis:</p> <p>The <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> reducer actions do NOT reset <code>oCounter</code>, but <code>LOAD_SCENE_SUCCESS</code> does set it from the new scene's data at <code>client/src/contexts/scenePlayerReducer.js:108</code>:</p> <pre><code>oCounter: action.payload.oCounter || 0,\n</code></pre> <p>The <code>useEffect</code> at <code>client/src/contexts/ScenePlayerContext.jsx:126-134</code> triggers <code>loadScene()</code> when <code>currentIndex</code> changes, which dispatches <code>LOAD_SCENE_SUCCESS</code>.</p> <p>Why the stale value persists:</p> <p>The issue is a race condition or render timing issue: 1. <code>NEXT_SCENE</code> dispatches \u2192 state updates with old <code>oCounter</code> 2. Component re-renders showing stale <code>oCounter</code> 3. <code>useEffect</code> fires (async) \u2192 <code>loadScene()</code> called 4. API request completes \u2192 <code>LOAD_SCENE_SUCCESS</code> dispatches with correct <code>oCounter</code> 5. Component re-renders with correct value</p> <p>The user sees step 2 (stale) before step 5 (correct). If the API is slow or there's a render batching issue, the stale value is visible longer.</p> <p>Files to Fix: - <code>client/src/contexts/scenePlayerReducer.js</code> - Reset <code>oCounter</code> in navigation actions</p> <p>Recommended Fix: Reset <code>oCounter: 0</code> in <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> cases. This provides immediate feedback that scene is changing, and <code>LOAD_SCENE_SUCCESS</code> will set the correct value once the API responds:</p> <pre><code>// In NEXT_SCENE case (around line 244)\nreturn {\n  ...state,\n  currentIndex: nextIndex,\n  // ... existing resets\n  oCounter: 0,  // ADD THIS - immediate reset\n  // ...\n};\n\n// Same for PREV_SCENE case (around line 313)\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#summary-table","title":"Summary Table","text":"# Issue Severity Effort Recommend Fix Before Release 1 Detail page tabs not loading HIGH Medium Yes 2 Tags query slow MEDIUM High No (post-release) 3 O History JSON schema LOW High No (post-release) 4 O Counter stale UI MEDIUM Low Yes"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#recommended-branch-strategy","title":"Recommended Branch Strategy","text":"<ol> <li>Branch: <code>bugfix/detail-page-tabs</code> - Fix issue #1</li> <li>Branch: <code>bugfix/o-counter-stale-state</code> - Fix issue #4</li> <li>Branch: <code>perf/tags-query-optimization</code> - Fix issue #2 (post-release)</li> <li>Branch: <code>refactor/o-history-table</code> - Fix issue #3 (post-release)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/","title":"Peek v3.0.0 Release Announcement","text":"<p>Copy/paste-ready for Discord and Discourse</p>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discord-announcement-short","title":"Discord Announcement (short)","text":"<pre><code>**Peek v3.0.0 Released!**\n\nMajor update with SQLite-based entity storage for massive scalability improvements:\n\n- **100k+ scene support** - No more memory limits\n- **3-minute sync** for 22k scenes (was 3.6 hours)\n- **Persistent library** - Data survives restarts\n- **Comprehensive filtering** - All performer/scene filters now work correctly\n\n**Upgrading:**\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart container\n4. Wait for automatic sync\n\nAll user data (watch history, playlists, ratings) is preserved.\n\n**Beta users:** Run a full sync after upgrading to populate new fields.\n\nDocs: https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/\nIssues: https://github.com/carrotwaxr/peek-stash-browser/issues\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discourse-announcement-detailed","title":"Discourse Announcement (detailed)","text":"<pre><code># Peek v3.0.0 Released - SQLite Entity Cache\n\nAfter 9 beta versions, Peek 3.0.0 is now stable!\n\n## What's New\n\nVersion 3.0.0 is a major architectural change: your Stash library data is now stored in SQLite tables instead of in-memory. This provides:\n\n| Improvement | Before | After |\n|-------------|--------|-------|\n| Library size limit | ~50k scenes (memory) | 100k+ scenes (disk) |\n| Sync time (22k scenes) | ~3.6 hours | ~3 minutes |\n| Data persistence | Lost on restart | Survives restarts |\n| Query speed | Slow on large libs | Sub-100ms |\n\n## New Features in 3.0\n\n- **Unit Preference** - Choose metric or imperial for performer measurements\n- **Comprehensive Filters** - All performer attributes now filterable (career length, ethnicity, eye color, etc.)\n- **Filter Chip Interactions** - Click filter chips to highlight the corresponding control\n- **Improved Gallery Display** - Better fallback titles for unnamed galleries\n\n## Upgrading\n\n**From any previous version:**\n\n1. Back up your database (copy `peek.db` from your data volume)\n2. Pull the new image: `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart your container\n4. Wait for the automatic sync to complete\n\nYour user data is fully preserved:\n- User accounts\n- Watch history &amp; resume positions\n- Playlists\n- All ratings and favorites\n- Filter presets\n- Hidden entities\n\n**From 3.0.0 beta versions:**\n\nWe recommend running a **full sync** after upgrading to ensure new fields are populated:\n1. Settings &gt; Server Settings\n2. Click \"Sync from Stash\"\n3. Select \"Full Sync\"\n\nThis populates `fileBasename` (gallery display) and `fakeTits` (performer filtering) for existing data.\n\n## Breaking Changes from 2.x\n\n- Initial sync is required after upgrade (automatic)\n- Sync time depends on library size (see table in upgrade guide)\n\n## Documentation\n\n- [Upgrade Guide](https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/)\n- [Full Documentation](https://carrotwaxr.github.io/peek-stash-browser/)\n\n## Issues\n\nPlease report bugs on [GitHub Issues](https://github.com/carrotwaxr/peek-stash-browser/issues) with:\n- Your Peek version\n- Your Stash version\n- Library size\n- Steps to reproduce\n\nThanks to everyone who tested the beta versions!\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#github-release-notes","title":"GitHub Release Notes","text":"<pre><code>## What's Changed\n\n### Major Changes\n- **SQLite Entity Cache** - Library data now stored in SQLite for 100k+ scene support\n- **Persistent Storage** - Library data survives container restarts\n- **3x faster sync** - Initial sync is ~3 minutes for 22k scenes\n\n### New Features\n- Unit preference setting (metric/imperial) for performer measurements\n- Filter chip click-to-highlight interaction\n- Comprehensive performer filtering (career length, ethnicity, eye color, breast type)\n- Improved gallery title fallback display\n\n### Bug Fixes (across beta cycle)\n- Fixed performer filter case sensitivity\n- Fixed sorting by path, last_o_at, performer_count\n- Fixed O counter aggregation for performers/studios/tags\n- Fixed watch history tracking event timing\n- Fixed gallery cards showing \"Untitled Gallery\"\n- Fixed user menu accessibility in collapsed sidebar\n\n### Breaking Changes\n- Initial sync required after upgrade (automatic)\n- Migration adds new tables only - all user data preserved\n\n### Upgrade Instructions\n\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:3.0.0`\n3. Restart container\n4. Wait for automatic sync\n\n**Beta users:** Run a full sync to populate new fields (Settings &gt; Sync from Stash &gt; Full Sync)\n\n**Full Changelog**: https://github.com/carrotwaxr/peek-stash-browser/compare/v2.1.0...v3.0.0\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/","title":"Peek v3.0.0 Release Evaluation","text":"<p>Date: December 15, 2025 Evaluator: Claude Code (AI-assisted) Version Evaluated: v3.0.0-beta.9</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#executive-summary","title":"Executive Summary","text":"<p>Peek v3.0.0 represents a major architectural change from in-memory caching to SQLite-based entity storage. After 9 beta versions, the release is conditionally ready for production with the following considerations:</p> Area Status Notes Database Migrations Ready Clean upgrade paths from 1.x and 2.x verified Core Functionality Ready Major bugs addressed across beta cycle Filtering/Sorting Stable 13 fixes in beta cycle, now comprehensive Security Review Needed Non-blocking issues identified Documentation Needs Update Outdated references to beta.2 <p>Recommendation: Proceed with 3.0.0 release after updating documentation and noting user action items.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#1-database-migration-analysis","title":"1. Database Migration Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#migration-chain-7-migrations","title":"Migration Chain (7 migrations)","text":"# Migration Description Added In 1 <code>0_baseline</code> Core user tables (User, WatchHistory, Playlist, Ratings, etc.) v2.0.0 2 <code>20251126202944_add_user_carousel</code> UserCarousel table v2.1.0 3 <code>20251211000000_stash_entities</code> StashScene, StashPerformer, junction tables (23 new tables) v3.0.0-beta.1 4 <code>20251211100000_entity_counts</code> Count columns on Stash* tables v3.0.0-beta.1 5 <code>20251214000000_add_unit_preference</code> User.unitPreference column v3.0.0-beta.5 6 <code>20251214100000_gallery_file_basename</code> StashGallery.fileBasename v3.0.0-beta.6 7 <code>20251215000000_add_performer_fake_tits</code> StashPerformer.fakeTits v3.0.0-beta.9"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#upgrade-path-verification","title":"Upgrade Path Verification","text":"Source Version Migration Handling Status v1.x (pre-migration) schemaCatchup creates missing tables, marks baseline+carousel applied Verified v2.0.x schemaCatchup handles broken states, Prisma applies remaining Verified v2.1.x Prisma applies migrations 3-7 Verified v3.0.0-beta.1-4 Prisma applies migrations 4-7 Verified v3.0.0-beta.5-8 Prisma applies migrations 5-7 Verified v3.0.0-beta.9 No migrations needed Verified Fresh install All 7 migrations applied Verified"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#data-preservation","title":"Data Preservation","text":"<p>User data is fully preserved during upgrade: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - All ratings and favorites (Scene, Performer, Studio, Tag, Gallery, Group, Image) - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#potential-migration-issues","title":"Potential Migration Issues","text":"<p>None identified. The schemaCatchup.ts module handles all legacy database scenarios correctly.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#2-breaking-changes-v2x-to-v30","title":"2. Breaking Changes (v2.x to v3.0)","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#architectural-changes","title":"Architectural Changes","text":"<ol> <li>In-Memory Cache \u2192 SQLite Tables</li> <li>Entity data now persisted in SQLite</li> <li>Initial sync required after upgrade</li> <li> <p>Subsequent syncs are incremental</p> </li> <li> <p>Environment Variables</p> </li> <li><code>STASH_URL</code> and <code>STASH_API_KEY</code> no longer needed as env vars</li> <li>Connection configured via Setup Wizard, stored in database</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#removed-features","title":"Removed Features","text":"<ol> <li>Local Transcoding (removed in v2.0)</li> <li>Peek now proxies streams directly through Stash</li> <li> <p>No more FFmpeg dependency for streaming</p> </li> <li> <p>Path Mappings (removed in v2.0)</p> </li> <li>No longer needed since streaming proxies through Stash</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#new-features-requiring-user-action","title":"New Features Requiring User Action","text":"Feature User Action Unit Preference Optional: Set metric/imperial in Settings Full Sync Post-Beta Recommended: Run full sync to populate new fields (fileBasename, fakeTits)"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#3-beta-fix-analysis","title":"3. Beta Fix Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#fix-distribution-by-beta-version","title":"Fix Distribution by Beta Version","text":"Version Fix Count Primary Focus beta.1 \u2192 beta.2 1 Permissions beta.2 \u2192 beta.3 0 - beta.3 \u2192 beta.4 5 Filter data loading beta.4 \u2192 beta.5 13 Sorting/filtering (major) beta.5 \u2192 beta.6 6 UI, watch history, settings beta.6 \u2192 beta.7 1 O counter aggregation beta.7 \u2192 beta.8 1 Performer filter parsing beta.8 \u2192 beta.9 1 Case sensitivity, new field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#recurring-issue-patterns","title":"Recurring Issue Patterns","text":"<ol> <li>Performer Filters (4 fix iterations)</li> <li>Initial data loading issues</li> <li>Career length parsing complexity</li> <li>Case sensitivity</li> <li> <p>Missing fields (fakeTits)</p> </li> <li> <p>Sorting Implementation (8 fixes in beta.5)</p> </li> <li>Missing sort options</li> <li>Wrong SQL column names</li> <li> <p>Rating field confusion (Stash vs user)</p> </li> <li> <p>Schema/Migration Mismatches (3 fixes)</p> </li> <li>unitPreference migration missing</li> <li>fakeTits field sync</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#risk-assessment","title":"Risk Assessment","text":"Area Risk Level Notes Performer Filters LOW Comprehensive overhaul completed in beta.5, edge cases addressed in beta.8-9 Sorting LOW All 8 issues fixed in beta.5 Watch History LOW Event timing fixed in beta.5-6 Gallery Display LOW fileBasename fallback added"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#4-core-system-stability","title":"4. Core System Stability","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#stashsyncservice-stable-with-notes","title":"StashSyncService - STABLE with notes","text":"<p>Strengths: - Proper abort handling for cancellable syncs - Entity ID validation for SQL injection defense - Progress events for UI feedback - Soft-delete preserves data</p> <p>Areas for Future Improvement (non-blocking): - Transaction wrapping for atomic sync operations - Consider parameterized queries for additional safety</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#scenequerybuilder-stable","title":"SceneQueryBuilder - STABLE","text":"<p>Strengths: - Parameterized SQL queries throughout - Efficient exclusion filter handling - Count query optimization - Proper hierarchy expansion</p> <p>Minor Notes: - Exclusion sets &gt;500 items are truncated with warning (documented behavior)</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#database-initialization-stable","title":"Database Initialization - STABLE","text":"<p>Strengths: - Comprehensive legacy database handling - Idempotent schema catchup - Clear migration flow</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#authentication-stable","title":"Authentication - STABLE","text":"<p>Strengths: - HTTP-only cookies prevent XSS - bcrypt password hashing - Role-based access control</p> <p>Future Improvements (non-blocking): - Rate limiting on login endpoint - Token revocation on logout</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#5-issues-categorized-by-priority","title":"5. Issues Categorized by Priority","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#blockers-must-fix-before-release","title":"BLOCKERS (must fix before release)","text":"<p>None identified.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#should-fix-recommended-before-release","title":"SHOULD-FIX (recommended before release)","text":"Issue Description Effort Documentation Outdated upgrading.md references beta.2, needs update to beta.9/3.0.0 Low docs/index.md Outdated References transcoding, default credentials Low README Beta Banner Remove beta warning for stable release Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#nice-to-have-can-be-addressed-post-release","title":"NICE-TO-HAVE (can be addressed post-release)","text":"Issue Description Priority Rate Limiting Add to login endpoint Medium Token Revocation Implement logout blacklist Medium Query Timeout Add timeout for complex queries Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#6-user-action-items-for-v300","title":"6. User Action Items for v3.0.0","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#all-users","title":"All Users","text":"<ol> <li>Back up database before upgrading</li> <li>Wait for initial sync after upgrade (varies by library size)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-300-betax","title":"Users Upgrading from 3.0.0-beta.x","text":"<ol> <li>Run full sync via Settings \u2192 Sync to populate new fields:</li> <li><code>fileBasename</code> for gallery display (beta.6+)</li> <li><code>fakeTits</code> for performer filters (beta.9+)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-2x","title":"Users Upgrading from 2.x","text":"<p>No special action needed beyond backup and sync wait.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-1x","title":"Users Upgrading from 1.x","text":"<p>No special action needed beyond backup and sync wait. schemaCatchup handles legacy databases automatically.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#7-recommended-documentation-updates","title":"7. Recommended Documentation Updates","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#files-to-update","title":"Files to Update","text":"<ol> <li>README.md</li> <li>Remove beta warning banner</li> <li> <p>Update version references</p> </li> <li> <p>docs/getting-started/upgrading.md</p> </li> <li>Update \"Latest\" from beta.2 to 3.0.0</li> <li>Add beta.x \u2192 3.0.0 upgrade notes</li> <li> <p>Add full sync recommendation for beta upgraders</p> </li> <li> <p>docs/index.md</p> </li> <li>Remove transcoding references</li> <li> <p>Remove default credentials section (Setup Wizard now handles)</p> </li> <li> <p>CLAUDE.md</p> </li> <li>Update release status if needed</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#8-release-checklist","title":"8. Release Checklist","text":"<ul> <li> Update README.md (remove beta banner)</li> <li> Update docs/getting-started/upgrading.md (comprehensive update)</li> <li> Update docs/index.md (remove outdated info)</li> <li> Verify all tests pass</li> <li> Verify lint passes</li> <li> Tag v3.0.0</li> <li> Create GitHub release with release notes</li> <li> Update Docker Hub description</li> <li> Post to Discourse/Discord</li> </ul>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#appendix-version-history","title":"Appendix: Version History","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#v300-beta-timeline","title":"v3.0.0 Beta Timeline","text":"Version Date Key Changes beta.1 Dec 10 Initial SQLite entity cache beta.2 Dec 10 Tag visibility fix beta.3 Dec 12 Video player improvements beta.4 Dec 12 Filter data loading fixes beta.5 Dec 12 Major sorting/filtering overhaul beta.6 Dec 14 UI fixes, watch history, unit preference beta.7 Dec 14 O counter aggregation fix beta.8 Dec 14 Performer filter parsing beta.9 Dec 15 Case sensitivity, fakeTits field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#breaking-changes-by-major-version","title":"Breaking Changes by Major Version","text":"Version Breaking Changes v1.x \u2192 v2.0 Removed local transcoding, removed path mappings v2.x \u2192 v3.0 Architecture change (memory \u2192 SQLite), initial sync required"},{"location":"plans/2025-12-16-query-architecture-consolidation/","title":"Query Architecture Consolidation","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#problem","title":"Problem","text":"<p>Scene queries return inconsistent objects depending on which code path is used:</p> <ul> <li><code>SceneQueryBuilder.execute()</code> returns scenes with full relations (performers, tags, studio, groups, galleries)</li> <li><code>StashEntityService.getAllScenes()</code> returns scenes with empty relation arrays</li> <li>Various <code>getAllScenesWith*()</code> variants return partial relation data (IDs only)</li> </ul> <p>This causes bugs like Similar Scenes and Recommended Scenes cards not displaying performer/tag indicators.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#goal","title":"Goal","text":"<p>Single query architecture where every scene object returned has consistent shape with populated relations. DRY principle - one path, one place for bugs.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#design","title":"Design","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-1-lightweight-scoring-query","title":"Phase 1: Lightweight Scoring Query","text":"<p>Create a new method for scoring operations that returns minimal data needed:</p> <pre><code>// New method in StashEntityService\nasync getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n  // Returns: { id, performerIds, tagIds, studioId, oCounter, date }\n  // Single efficient query joining scene + junction tables\n  // No full entity hydration - just IDs for scoring\n}\n</code></pre> <p>This supports Similar Scenes and Recommended Scenes which need to score all scenes but only need IDs for the scoring logic.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-2-consolidate-to-scenequerybuilder","title":"Phase 2: Consolidate to SceneQueryBuilder","text":"<p>All scene queries that return <code>NormalizedScene[]</code> go through <code>SceneQueryBuilder</code>, which already has <code>populateRelations()</code>.</p> <p>Methods to remove from StashEntityService: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code></p> <p>Methods to keep/modify: - <code>getScenesByIds()</code> - Keep, but have it use SceneQueryBuilder internally - <code>getScenesByIdsWithRelations()</code> - Remove, redundant after consolidation</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-3-update-all-callers","title":"Phase 3: Update All Callers","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#similar-scenes-scenests1235","title":"Similar Scenes (<code>scenes.ts:1235</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: 1. Call <code>getScenesForScoring()</code> for lightweight scoring data 2. Score and sort to get top N scene IDs 3. Call <code>SceneQueryBuilder.execute({ filters: { ids } })</code> for final results</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#recommended-scenes-scenests1472","title":"Recommended Scenes (<code>scenes.ts:1472</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: Same pattern as Similar Scenes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#standard-carousels-carouselts402","title":"Standard Carousels (<code>carousel.ts:402</code>)","text":"<p>Before: <code>getAllScenes()</code> then filter/sort in memory After: <code>SceneQueryBuilder.execute()</code> with appropriate filters</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenes-browse-fallback-scenests994","title":"Scenes Browse Fallback (<code>scenes.ts:994</code>)","text":"<p>Before: <code>getAllScenes()</code> when SQL query builder disabled After: Always use <code>SceneQueryBuilder.execute()</code></p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#entity-visibility-filtering-tagsts-performersts-studiosts","title":"Entity Visibility Filtering (<code>tags.ts</code>, <code>performers.ts</code>, <code>studios.ts</code>)","text":"<p>Before: <code>getAllScenes*()</code> to check which entities have visible scenes After: New dedicated method <code>getVisibleEntityIds(userId, entityType)</code> that queries junction tables directly - doesn't need full scene data</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-enhancements","title":"SceneQueryBuilder Enhancements","text":"<p>Add support for: - Unpaginated mode (for getting all matching IDs) - ID-only mode (returns just scene IDs, no hydration)</p> <pre><code>interface SceneQueryOptions {\n  // ... existing options\n  returnIdsOnly?: boolean;  // Skip hydration, return string[]\n  unpaginated?: boolean;    // Return all matches, no LIMIT\n}\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Scene Query Requests                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Browse  \u2502  Similar  \u2502  Recommended  \u2502  Carousels  \u2502  Details   \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502           \u2502             \u2502              \u2502            \u2502\n     \u2502           \u25bc             \u25bc              \u2502            \u2502\n     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502            \u2502\n     \u2502    \u2502 getScenesForScoring()   \u2502        \u2502            \u2502\n     \u2502    \u2502 (lightweight IDs only)  \u2502        \u2502            \u2502\n     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u2502                \u25bc                      \u2502            \u2502\n     \u2502         Score &amp; Get IDs              \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u25bc                \u25bc                      \u25bc            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SceneQueryBuilder.execute()                   \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Build WHERE  \u2502\u2192 \u2502 Execute SQL  \u2502\u2192 \u2502 populateRelations()    \u2502 \u2502\n\u2502  \u2502 clauses      \u2502  \u2502 query        \u2502  \u2502 (batch load relations) \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                    NormalizedScene[] with\n                    consistent relations\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#migration-checklist","title":"Migration Checklist","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#stashentityservice-changes","title":"StashEntityService Changes","text":"<ul> <li> Add <code>getScenesForScoring()</code> method</li> <li> Add <code>getVisibleSceneIdsByEntity()</code> for entity filtering</li> <li> Deprecate <code>getAllScenes()</code> and variants</li> <li> Update <code>getScenesByIds()</code> to use SceneQueryBuilder</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-changes","title":"SceneQueryBuilder Changes","text":"<ul> <li> Add <code>returnIdsOnly</code> option</li> <li> Add <code>unpaginated</code> option</li> <li> Ensure all relation types populated (verify galleries, groups)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#controller-updates","title":"Controller Updates","text":"<ul> <li> <code>scenes.ts</code> - findSimilarScenes</li> <li> <code>scenes.ts</code> - getRecommendedScenes</li> <li> <code>scenes.ts</code> - findScenes fallback path</li> <li> <code>carousel.ts</code> - executeCarouselQuery standard path</li> <li> <code>carousel.ts</code> - custom carousel path (verify already correct)</li> <li> <code>tags.ts</code> - enhanceTagsWithPerformerScenes</li> <li> <code>tags.ts</code> - getTagsWithFilters visibility check</li> <li> <code>tags.ts</code> - getTag scene/group counts</li> <li> <code>tags.ts</code> - related tags visibility check</li> <li> <code>performers.ts</code> - getPerformersWithFilters visibility check</li> <li> <code>performers.ts</code> - getPerformer visibility check</li> <li> <code>studios.ts</code> - getStudiosWithFilters visibility check</li> <li> <code>studios.ts</code> - getStudio visibility check</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#testing","title":"Testing","text":"<ul> <li> Similar Scenes shows performer/tag indicators on cards</li> <li> Recommended Scenes shows performer/tag indicators on cards</li> <li> Homepage carousels show indicators</li> <li> Scenes browse works with all filter combinations</li> <li> Entity pages (performers, tags, studios) filter correctly for non-admin users</li> <li> Performance acceptable (measure query times)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#risks-mitigations","title":"Risks &amp; Mitigations","text":"<p>Risk: Regression in filtering behavior Mitigation: Comprehensive manual testing of all entity pages with non-admin user</p> <p>Risk: Performance degradation from additional relation loading Mitigation: <code>getScenesForScoring()</code> keeps scoring lightweight; only final page of results gets full hydration</p> <p>Risk: Edge cases in SceneQueryBuilder not covered Mitigation: Existing integration tests + add new tests for ID-only and unpaginated modes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#ui-impact-assessment","title":"UI Impact Assessment","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenecardjsx-data-requirements","title":"SceneCard.jsx Data Requirements","text":"<p>The frontend expects these fields on every scene object:</p> Field Used For Currently Broken? <code>scene.performers</code> Count indicator + tooltip grid Yes - empty array <code>scene.performers[].tags</code> Squashed tags calculation Yes - empty <code>scene.groups</code> Count indicator + tooltip grid Yes - empty array <code>scene.galleries</code> Count indicator + tooltip grid Yes - empty array <code>scene.tags</code> Count indicator + tooltip grid Yes - empty array <code>scene.studio</code> Subtitle display Yes - null <code>scene.studio.name</code> Studio name in subtitle Yes - null <code>scene.studio.tags</code> Squashed tags calculation Yes - null <code>scene.paths.*</code> Thumbnails, previews No - works <code>scene.files[0].*</code> Duration, resolution No - works <code>scene.rating/favorite/o_counter</code> Rating row No - works <code>scene.play_count</code> Play count indicator No - works <code>scene.resumeTime</code> Progress bar No - works"},{"location":"plans/2025-12-16-query-architecture-consolidation/#affected-ui-components","title":"Affected UI Components","text":"Component Data Source Issue ScenesLikeThis.jsx <code>/api/library/scenes/:id/similar</code> Missing relation data RecommendedSidebar.jsx <code>/api/library/scenes/:id/similar</code> Missing studio data SceneCard.jsx Various endpoints Shows \"0\" for all entity counts Home.jsx carousels Standard carousel endpoints Missing relation data"},{"location":"plans/2025-12-16-query-architecture-consolidation/#verification","title":"Verification","text":"<p>No UI code changes needed. The frontend already expects full scene objects with relations. The consolidation will fix the backend to return complete data.</p> <p>After implementation, verify: - [ ] Scene cards show correct performer counts (not 0) - [ ] Scene cards show correct tag counts (not 0) - [ ] Scene cards show correct group counts (not 0) - [ ] Scene cards show correct gallery counts (not 0) - [ ] Hovering indicators shows entity tooltip grids - [ ] Studio name appears in card subtitles - [ ] Similar Scenes section displays full card data - [ ] Recommended sidebar shows studio names</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#out-of-scope-future-work","title":"Out of Scope (Future Work)","text":"<ul> <li>Tag hierarchy normalization (<code>parentIds</code> JSON \u2192 <code>TagRelation</code> table)</li> <li>Alias normalization (performer/tag aliases \u2192 separate tables)</li> <li>Studio hierarchy improvements</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-implementation/","title":"Query Architecture Consolidation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Consolidate all scene queries to use SceneQueryBuilder so every scene object has consistent relations (performers, tags, studio, groups, galleries).</p> <p>Architecture: Two-phase query for scoring operations (lightweight IDs for scoring, then SceneQueryBuilder for final results). All other paths use SceneQueryBuilder directly.</p> <p>Tech Stack: TypeScript, Prisma, SQLite, Vitest</p>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-1-add-scenescoringdata-type","title":"Task 1: Add SceneScoringData Type","text":"<p>Files: - Modify: <code>server/types/entities.ts</code></p> <p>Step 1: Add the type definition</p> <p>Add after the existing type exports (around line 200):</p> <pre><code>/**\n * Lightweight scene data for scoring operations\n * Contains only IDs needed for similarity/recommendation scoring\n */\nexport interface SceneScoringData {\n  id: string;\n  studioId: string | null;\n  performerIds: string[];\n  tagIds: string[];\n  oCounter: number;\n  date: string | null;\n}\n</code></pre> <p>Step 2: Export from index</p> <p>Modify <code>server/types/index.ts</code> to add export:</p> <pre><code>export type {\n  NormalizedScene,\n  NormalizedPerformer,\n  NormalizedStudio,\n  NormalizedTag,\n  NormalizedGallery,\n  NormalizedGroup,\n  SceneScoringData,  // Add this line\n} from \"./entities.js\";\n</code></pre> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/types/entities.ts server/types/index.ts\ngit commit -m \"feat: add SceneScoringData type for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-2-add-getscenesforscoring-method","title":"Task 2: Add getScenesForScoring Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>server/services/__tests__/StashEntityService.scoring.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { StashEntityService } from \"../StashEntityService.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $queryRawUnsafe: vi.fn(),\n  },\n}));\n\ndescribe(\"StashEntityService.getScenesForScoring\", () =&gt; {\n  let service: StashEntityService;\n\n  beforeEach(() =&gt; {\n    service = new StashEntityService();\n    vi.clearAllMocks();\n  });\n\n  it(\"should return lightweight scoring data for all scenes\", async () =&gt; {\n    const mockRows = [\n      {\n        id: \"scene-1\",\n        studioId: \"studio-1\",\n        oCounter: 5,\n        date: \"2024-01-15\",\n        performerIds: \"perf-1,perf-2\",\n        tagIds: \"tag-1,tag-2,tag-3\",\n      },\n      {\n        id: \"scene-2\",\n        studioId: null,\n        oCounter: 0,\n        date: null,\n        performerIds: \"\",\n        tagIds: \"tag-1\",\n      },\n    ];\n\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue(mockRows);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual({\n      id: \"scene-1\",\n      studioId: \"studio-1\",\n      performerIds: [\"perf-1\", \"perf-2\"],\n      tagIds: [\"tag-1\", \"tag-2\", \"tag-3\"],\n      oCounter: 5,\n      date: \"2024-01-15\",\n    });\n    expect(result[1]).toEqual({\n      id: \"scene-2\",\n      studioId: null,\n      performerIds: [],\n      tagIds: [\"tag-1\"],\n      oCounter: 0,\n      date: null,\n    });\n  });\n\n  it(\"should return empty array when no scenes exist\", async () =&gt; {\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue([]);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toEqual([]);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: FAIL with \"getScenesForScoring is not a function\"</p> <p>Step 3: Implement the method</p> <p>Add to <code>server/services/StashEntityService.ts</code> after line 161 (after <code>getAllScenes</code>):</p> <pre><code>  /**\n   * Get lightweight scene data for scoring operations\n   * Returns only IDs needed for similarity/recommendation calculations\n   * Much more efficient than loading full scene objects\n   */\n  async getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n    const startTime = Date.now();\n\n    // Single query that aggregates performer and tag IDs\n    const sql = `\n      SELECT\n        s.id,\n        s.studioId,\n        s.oCounter,\n        s.date,\n        COALESCE(GROUP_CONCAT(DISTINCT sp.performerId), '') as performerIds,\n        COALESCE(GROUP_CONCAT(DISTINCT st.tagId), '') as tagIds\n      FROM StashScene s\n      LEFT JOIN ScenePerformer sp ON s.id = sp.sceneId\n      LEFT JOIN SceneTag st ON s.id = st.sceneId\n      WHERE s.deletedAt IS NULL\n      GROUP BY s.id\n    `;\n\n    const rows = await prisma.$queryRawUnsafe&lt;Array&lt;{\n      id: string;\n      studioId: string | null;\n      oCounter: number;\n      date: string | null;\n      performerIds: string;\n      tagIds: string;\n    }&gt;&gt;(sql);\n\n    const result: SceneScoringData[] = rows.map(row =&gt; ({\n      id: row.id,\n      studioId: row.studioId,\n      performerIds: row.performerIds ? row.performerIds.split(',').filter(Boolean) : [],\n      tagIds: row.tagIds ? row.tagIds.split(',').filter(Boolean) : [],\n      oCounter: row.oCounter || 0,\n      date: row.date,\n    }));\n\n    logger.info(`getScenesForScoring: ${Date.now() - startTime}ms, count=${result.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 4: Add import for SceneScoringData</p> <p>Update the import at top of <code>StashEntityService.ts</code>:</p> <pre><code>import type {\n  NormalizedGallery,\n  NormalizedGroup,\n  NormalizedPerformer,\n  NormalizedScene,\n  NormalizedStudio,\n  NormalizedTag,\n  SceneScoringData,  // Add this\n} from \"../types/index.js\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/services/__tests__/StashEntityService.scoring.test.ts\ngit commit -m \"feat: add getScenesForScoring for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-3-add-getscenesbyids-to-scenequerybuilder","title":"Task 3: Add getScenesByIds to SceneQueryBuilder","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code>:</p> <pre><code>  it(\"should fetch scenes by IDs with full relations\", async () =&gt; {\n    // First get some scene IDs\n    const initial = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 3,\n    });\n\n    if (initial.scenes.length &lt; 2) {\n      console.log(\"Skipping getByIds test - not enough scenes\");\n      return;\n    }\n\n    const idsToFetch = initial.scenes.slice(0, 2).map(s =&gt; s.id);\n\n    const result = await sceneQueryBuilder.getByIds({\n      userId: 1,\n      ids: idsToFetch,\n    });\n\n    expect(result.scenes).toHaveLength(2);\n    expect(result.scenes.map(s =&gt; s.id).sort()).toEqual(idsToFetch.sort());\n\n    // Verify relations are populated\n    for (const scene of result.scenes) {\n      expect(scene).toHaveProperty(\"performers\");\n      expect(scene).toHaveProperty(\"tags\");\n      expect(scene).toHaveProperty(\"groups\");\n      expect(scene).toHaveProperty(\"galleries\");\n      expect(Array.isArray(scene.performers)).toBe(true);\n      expect(Array.isArray(scene.tags)).toBe(true);\n    }\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: FAIL with \"getByIds is not a function\"</p> <p>Step 3: Add the interface</p> <p>Add after <code>SceneQueryResult</code> interface (around line 34) in <code>SceneQueryBuilder.ts</code>:</p> <pre><code>// Query by IDs options\nexport interface SceneByIdsOptions {\n  userId: number;\n  ids: string[];\n}\n</code></pre> <p>Step 4: Implement getByIds method</p> <p>Add before the closing brace of the class (around line 1760):</p> <pre><code>  /**\n   * Get scenes by IDs with full relations\n   * Used after scoring to fetch the final paginated results\n   */\n  async getByIds(options: SceneByIdsOptions): Promise&lt;SceneQueryResult&gt; {\n    const { userId, ids } = options;\n\n    if (ids.length === 0) {\n      return { scenes: [], total: 0 };\n    }\n\n    // Use execute with ID filter\n    return this.execute({\n      userId,\n      filters: {\n        ids: { value: ids, modifier: \"INCLUDES\" },\n      },\n      sort: \"created_at\", // Default sort, results will be reordered by caller if needed\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: ids.length, // Get all requested IDs\n    });\n  }\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"feat: add getByIds method to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-4-refactor-findsimilarscenes-to-use-new-architecture","title":"Task 4: Refactor findSimilarScenes to Use New Architecture","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Add imports</p> <p>At top of <code>scenes.ts</code>, add:</p> <pre><code>import { sceneQueryBuilder } from \"../../services/SceneQueryBuilder.js\";\n</code></pre> <p>And update the stashEntityService import to include SceneScoringData type.</p> <p>Step 2: Refactor findSimilarScenes</p> <p>Replace the <code>findSimilarScenes</code> function (lines 1219-1374) with:</p> <pre><code>/**\n * Find similar scenes based on weighted scoring\n * Performers: 3 points each\n * Tags: 1 point each\n * Studio: 1 point\n *\n * Uses two-phase query:\n * 1. Lightweight scoring query to score all scenes\n * 2. SceneQueryBuilder to fetch final results with relations\n */\nexport const findSimilarScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const { id } = req.params;\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = 12;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Get excluded scene IDs for this user\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n\n    // Filter out excluded scenes and current scene\n    const scoringData = allScoringData.filter(\n      s =&gt; s.id !== id &amp;&amp; !excludedIds.has(s.id)\n    );\n\n    // Find the current scene's data\n    const currentScene = allScoringData.find(s =&gt; s.id === id);\n    if (!currentScene) {\n      return res.status(404).json({ error: \"Scene not found\" });\n    }\n\n    // Check if current scene has any metadata\n    const hasMetadata =\n      currentScene.performerIds.length &gt; 0 ||\n      currentScene.studioId ||\n      currentScene.tagIds.length &gt; 0;\n\n    if (!hasMetadata) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n      });\n    }\n\n    // Build sets for fast lookup\n    const currentPerformerIds = new Set(currentScene.performerIds);\n    const currentTagIds = new Set(currentScene.tagIds);\n    const currentStudioId = currentScene.studioId;\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n      date: string | null;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n\n    for (const scene of scoringData) {\n      let score = 0;\n\n      // Score for matching performers (3 points each)\n      for (const performerId of scene.performerIds) {\n        if (currentPerformerIds.has(performerId)) {\n          score += 3;\n        }\n      }\n\n      // Score for matching studio (1 point)\n      if (currentStudioId &amp;&amp; scene.studioId === currentStudioId) {\n        score += 1;\n      }\n\n      // Score for matching tags (1 point each)\n      for (const tagId of scene.tagIds) {\n        if (currentTagIds.has(tagId)) {\n          score += 1;\n        }\n      }\n\n      if (score &gt; 0) {\n        scoredScenes.push({ id: scene.id, score, date: scene.date });\n      }\n    }\n\n    // Sort by score descending, then by date descending\n    scoredScenes.sort((a, b) =&gt; {\n      if (b.score !== a.score) {\n        return b.score - a.score;\n      }\n      const dateA = a.date ? new Date(a.date).getTime() : 0;\n      const dateB = b.date ? new Date(b.date).getTime() : 0;\n      return dateB - dateA;\n    });\n\n    // Paginate\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = scoredScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: scoredScenes.length,\n        page,\n        perPage,\n      });\n    }\n\n    // Phase 2: Fetch full scene data via SceneQueryBuilder\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order (getByIds may return in different order)\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: scoredScenes.length,\n      page,\n      perPage,\n    });\n  } catch (error) {\n    logger.error(\"Error finding similar scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to find similar scenes\" });\n  }\n};\n</code></pre> <p>Step 3: Run the application and test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Open a scene detail page and verify Similar Scenes shows performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: findSimilarScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-5-add-getexcludedsceneids-to-userrestrictionservice","title":"Task 5: Add getExcludedSceneIds to UserRestrictionService","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code></p> <p>Step 1: Check if method exists</p> <p>Search for existing <code>getExcludedSceneIds</code> method. If it doesn't exist:</p> <p>Step 2: Add the method</p> <pre><code>  /**\n   * Get set of scene IDs that should be excluded for a user\n   * @param userId - User ID\n   * @param hiddenOnly - If true, only return hidden entities (not content restrictions)\n   */\n  async getExcludedSceneIds(userId: number, hiddenOnly: boolean = false): Promise&lt;Set&lt;string&gt;&gt; {\n    const scenes = await stashEntityService.getAllScenes();\n    const filtered = await this.filterScenesForUser(scenes, userId, hiddenOnly);\n\n    const allIds = new Set(scenes.map(s =&gt; s.id));\n    const visibleIds = new Set(filtered.map(s =&gt; s.id));\n\n    const excludedIds = new Set&lt;string&gt;();\n    for (const id of allIds) {\n      if (!visibleIds.has(id)) {\n        excludedIds.add(id);\n      }\n    }\n\n    return excludedIds;\n  }\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"feat: add getExcludedSceneIds helper method\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-6-refactor-getrecommendedscenes","title":"Task 6: Refactor getRecommendedScenes","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Refactor the function</p> <p>Replace <code>getRecommendedScenes</code> (around line 1380) with similar two-phase pattern:</p> <pre><code>/**\n * Get recommended scenes based on user preferences and watch history\n * Uses favorites, ratings (80+), watch status, and engagement quality\n *\n * Two-phase query:\n * 1. Lightweight scoring data for all scenes\n * 2. SceneQueryBuilder for final paginated results\n */\nexport const getRecommendedScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = parseInt(req.query.per_page as string) || 24;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n\n    // Build preference sets\n    const favoritePerformers = new Set(\n      performerRatings.filter(r =&gt; r.favorite).map(r =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter(r =&gt; r.favorite).map(r =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter(r =&gt; r.favorite).map(r =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.tagId)\n    );\n\n    // Build watch history map\n    const watchMap = new Map(\n      watchHistory.map(wh =&gt; [\n        wh.sceneId,\n        {\n          playCount: wh.playCount || 0,\n          lastPlayedAt: wh.lastPlayedAt,\n        },\n      ])\n    );\n\n    // Get excluded scene IDs\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n    const scoringData = allScoringData.filter(s =&gt; !excludedIds.has(s.id));\n\n    // Count criteria for feedback\n    const criteriaCounts = {\n      favoritePerformers: favoritePerformers.size,\n      highlyRatedPerformers: highlyRatedPerformers.size,\n      favoriteStudios: favoriteStudios.size,\n      highlyRatedStudios: highlyRatedStudios.size,\n      favoriteTags: favoriteTags.size,\n      highlyRatedTags: highlyRatedTags.size,\n    };\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n    const now = new Date();\n\n    for (const scene of scoringData) {\n      let baseScore = 0;\n\n      // Score performers\n      for (const performerId of scene.performerIds) {\n        if (favoritePerformers.has(performerId)) {\n          baseScore += 50;\n        } else if (highlyRatedPerformers.has(performerId)) {\n          baseScore += 30;\n        }\n      }\n\n      // Score studio\n      if (scene.studioId) {\n        if (favoriteStudios.has(scene.studioId)) {\n          baseScore += 25;\n        } else if (highlyRatedStudios.has(scene.studioId)) {\n          baseScore += 15;\n        }\n      }\n\n      // Score tags\n      for (const tagId of scene.tagIds) {\n        if (favoriteTags.has(tagId)) {\n          baseScore += 10;\n        } else if (highlyRatedTags.has(tagId)) {\n          baseScore += 5;\n        }\n      }\n\n      if (baseScore === 0) continue;\n\n      // Watch status modifier\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        adjustedScore += 30; // Never watched bonus\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) / (24 * 60 * 60 * 1000);\n        if (daysSinceWatched &gt; 14) {\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          adjustedScore -= 10;\n        } else {\n          adjustedScore -= 30; // Very recently watched penalty\n        }\n      }\n\n      // Engagement multiplier\n      const engagementMultiplier = 1.0 + Math.min(scene.oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ id: scene.id, score: finalScore });\n      }\n    }\n\n    // Sort by score descending\n    scoredScenes.sort((a, b) =&gt; b.score - a.score);\n\n    // Cap at 500 and paginate\n    const cappedScenes = scoredScenes.slice(0, 500);\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = cappedScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: cappedScenes.length,\n        page,\n        perPage,\n        criteria: criteriaCounts,\n      });\n    }\n\n    // Phase 2: Fetch full scene data\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: cappedScenes.length,\n      page,\n      perPage,\n      criteria: criteriaCounts,\n    });\n  } catch (error) {\n    logger.error(\"Error getting recommended scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to get recommendations\" });\n  }\n};\n</code></pre> <p>Step 2: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Check homepage Recommended section shows performer/tag counts</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: getRecommendedScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-7-refactor-standard-carousels","title":"Task 7: Refactor Standard Carousels","text":"<p>Files: - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Find executeCarouselQuery function</p> <p>Locate the <code>executeCarouselQuery</code> function that uses <code>getAllScenes()</code>.</p> <p>Step 2: Refactor to use SceneQueryBuilder</p> <p>Replace the <code>getAllScenes()</code> path with SceneQueryBuilder. The function should: 1. Build filters from carousel query 2. Call <code>sceneQueryBuilder.execute()</code> 3. Return scenes with full relations</p> <p>Step 3: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Homepage carousels show performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/carousel.ts\ngit commit -m \"refactor: standard carousels use SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-8-remove-deprecated-methods","title":"Task 8: Remove Deprecated Methods","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Mark methods as deprecated</p> <p>Add JSDoc <code>@deprecated</code> tags to: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code> - <code>getScenesByIdsWithRelations()</code></p> <p>Step 2: Update remaining callers</p> <p>Search for any remaining usages and update them to use SceneQueryBuilder or <code>getScenesForScoring()</code>.</p> <p>Step 3: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: deprecate old scene query methods, update remaining callers\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-9-update-entity-visibility-filtering","title":"Task 9: Update Entity Visibility Filtering","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/studios.ts</code></p> <p>Step 1: Create getVisibleSceneIdsByEntity method</p> <p>Add to <code>StashEntityService.ts</code>:</p> <pre><code>  /**\n   * Get scene IDs visible to a user, grouped by entity type\n   * Used for empty entity filtering without loading full scenes\n   */\n  async getVisibleSceneIdsByPerformer(userId: number): Promise&lt;Map&lt;string, Set&lt;string&gt;&gt;&gt; {\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, false);\n\n    const junctions = await prisma.scenePerformer.findMany({\n      where: {\n        scene: { deletedAt: null },\n        sceneId: { notIn: Array.from(excludedIds) },\n      },\n      select: { sceneId: true, performerId: true },\n    });\n\n    const result = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const j of junctions) {\n      const set = result.get(j.performerId) || new Set();\n      set.add(j.sceneId);\n      result.set(j.performerId, set);\n    }\n\n    return result;\n  }\n</code></pre> <p>Step 2: Update performers.ts visibility checks</p> <p>Replace <code>getAllScenesWithPerformers()</code> calls with the new method.</p> <p>Step 3: Test manually</p> <p>Test non-admin user can browse performers page correctly.</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: entity visibility uses direct junction queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-10-final-cleanup-and-testing","title":"Task 10: Final Cleanup and Testing","text":"<p>Files: - All modified files</p> <p>Step 1: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Manual verification checklist</p> <ul> <li> Scene cards show correct performer counts (not 0)</li> <li> Scene cards show correct tag counts (not 0)</li> <li> Scene cards show correct group counts (not 0)</li> <li> Scene cards show correct gallery counts (not 0)</li> <li> Hovering indicators shows entity tooltip grids</li> <li> Studio name appears in card subtitles</li> <li> Similar Scenes section displays full card data</li> <li> Recommended sidebar shows studio names</li> <li> Homepage carousels show full card data</li> <li> Scenes browse works with filters</li> <li> Non-admin user filtering works correctly</li> </ul> <p>Step 4: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: query architecture consolidation complete\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#summary","title":"Summary","text":"<p>This plan consolidates all scene queries to use <code>SceneQueryBuilder</code>, ensuring consistent scene objects with populated relations. The key changes are:</p> <ol> <li>New <code>getScenesForScoring()</code> - Lightweight query for scoring operations</li> <li>New <code>getByIds()</code> on SceneQueryBuilder - Fetch specific scenes with relations</li> <li>Two-phase query pattern - Score with lightweight data, fetch with full relations</li> <li>Deprecated old methods - <code>getAllScenes*()</code> variants marked deprecated</li> <li>Direct junction queries - For entity visibility filtering</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/","title":"Recommendations Improvements Design","text":"<p>Date: 2025-12-16 Branch: <code>feature/recommendations-improvements</code> Related Issues: #181, #172</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#problem-statement","title":"Problem Statement","text":"<p>Users report the Recommended page shows no content despite having favorited/rated scenes. The current algorithm only considers explicit Performer, Studio, and Tag ratings\u2014not Scene ratings. Users naturally rate scenes first, leading to confusion when recommendations don't appear.</p> <p>Additionally, error messages are unhelpful and logging doesn't capture enough detail to diagnose issues.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#design-overview","title":"Design Overview","text":"<p>Four improvements:</p> <ol> <li>Scene-based recommendations - Derive entity preferences from rated/favorited scenes</li> <li>Inline user feedback - Show users what's missing when recommendations are empty</li> <li>Better error handling - Improved logging and user-facing error messages</li> <li>Unit tests - Test coverage for recommendation scoring logic</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#1-scene-based-recommendations","title":"1. Scene-Based Recommendations","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#concept","title":"Concept","text":"<p>When a user favorites or rates a scene highly, we extract its entities (performers, studio, tags) and add them to the preference pool with diminished weights compared to explicit entity ratings.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-formula","title":"Weight Formula","text":"<pre><code>// Skip scenes rated below threshold\nif (sceneRating &lt; 40) continue;\n\n// Favorited-only scenes get implicit rating\nconst effectiveRating = sceneRating ?? (isFavorited ? 85 : null);\nif (effectiveRating === null) continue;\n\n// Calculate weight multiplier\nconst BASE_WEIGHT = 0.4;\nconst FAVORITE_BONUS = 0.15;\n\nlet weightMultiplier = (effectiveRating / 100) * BASE_WEIGHT;\nif (isFavorited) {\n  weightMultiplier += FAVORITE_BONUS;\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-examples","title":"Weight Examples","text":"Scenario Multiplier Performer pts vs Explicit (5 pts) Scene rated 100 + favorited 0.55 2.75 55% Scene favorited only (\u219285) 0.49 2.45 49% Scene rated 100, not fav 0.40 2.00 40% Scene rated 80 + favorited 0.47 2.35 47% Scene rated 80, not fav 0.32 1.60 32% Scene rated 60, not fav 0.24 1.20 24% Scene rated 40, not fav 0.16 0.80 16% Scene rated 39 - 0 (skipped) -"},{"location":"plans/2025-12-16-recommendations-improvements-design/#implementation","title":"Implementation","text":"<p>In <code>getRecommendedScenes()</code>:</p> <ol> <li>Fetch <code>sceneRatings</code> alongside existing performer/studio/tag ratings</li> <li>Build derived preference maps from favorited/rated scenes:</li> <li><code>derivedPerformerWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedStudioWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedTagWeights: Map&lt;string, number&gt;</code></li> <li>When scoring, combine explicit preferences with derived weights</li> <li>Apply same sqrt diminishing returns to derived weights</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#derived-weight-accumulation","title":"Derived Weight Accumulation","text":"<p>When multiple scenes contribute to the same entity, weights accumulate but with diminishing returns:</p> <pre><code>// For each scene's performer\nconst sceneWeight = calculateSceneWeight(scene);\nconst currentWeight = derivedPerformerWeights.get(performerId) || 0;\nderivedPerformerWeights.set(performerId, currentWeight + sceneWeight);\n\n// When scoring, apply sqrt to accumulated derived weights\nconst derivedPerformerScore = Math.sqrt(derivedPerformerWeight) * 5;\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#2-inline-user-feedback","title":"2. Inline User Feedback","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#empty-state-message","title":"Empty State Message","text":"<p>When recommendations return empty, the API response includes diagnostic info:</p> <pre><code>// Response structure\n{\n  scenes: [],\n  count: 0,\n  page: 1,\n  perPage: 24,\n  message: \"No recommendations yet\",\n  criteria: {\n    favoritedPerformers: 0,\n    ratedPerformers: 0,\n    favoritedStudios: 0,\n    ratedStudios: 0,\n    favoritedTags: 0,\n    ratedTags: 0,\n    favoritedScenes: 3,\n    ratedScenes: 5\n  }\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-display","title":"Client Display","text":"<p>The Recommended page shows:</p> <p>No Recommendations Yet</p> <p>To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.</p> <p>Your current activity: - 0 favorited performers, 0 highly-rated performers - 0 favorited studios, 0 highly-rated studios - 0 favorited tags, 0 highly-rated tags - 3 favorited scenes, 5 rated scenes</p> <p>Tip: Rating more scenes helps us learn your preferences!</p> <p>If they have scene activity but no results, clarify:</p> <p>We're analyzing your rated scenes to find recommendations...</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#3-better-error-handling","title":"3. Better Error Handling","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#server-side-logging","title":"Server-Side Logging","text":"<p>Update the catch block to capture full error details:</p> <pre><code>catch (error) {\n  const err = error as Error;\n  logger.error(\"Error getting recommended scenes:\", {\n    message: err.message,\n    name: err.name,\n    stack: err.stack,\n    userId,\n  });\n\n  const errorType = err.name || \"Unknown error\";\n  res.status(500).json({\n    error: \"Failed to get recommended scenes\",\n    errorType\n  });\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-side-display","title":"Client-Side Display","text":"<pre><code>{error &amp;&amp; (\n  &lt;ErrorMessage&gt;\n    Unable to load recommendations. ({error.errorType || \"Please try again later\"})\n  &lt;/ErrorMessage&gt;\n)}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#4-unit-tests","title":"4. Unit Tests","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-file","title":"Test File","text":"<p>Create <code>server/tests/recommendations/recommendationScoring.test.ts</code></p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-cases","title":"Test Cases","text":"<p>Explicit entity scoring: - Favorited performer adds 5 points - Highly-rated performer (80+) adds 3 points - Favorited studio adds 3 points - Multiple performers use sqrt diminishing returns</p> <p>Scene-derived scoring: - Scene rated 100 derives 40% weight for entities - Scene rated 100 + favorited derives 55% weight - Scene favorited only uses implicit rating of 85 - Scene rated &lt; 40 contributes nothing - Multiple scenes for same performer accumulate with sqrt</p> <p>Edge cases: - User with no ratings/favorites returns empty with message - User with only scene ratings (no explicit) still gets recommendations - Scene with no performers/studio/tags contributes nothing - Combination of explicit + derived preferences</p> <p>Weight calculation: - <code>calculateSceneWeight(100, true)</code> returns 0.55 - <code>calculateSceneWeight(85, false)</code> returns 0.34 - <code>calculateSceneWeight(39, false)</code> returns 0 (below floor)</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#files-to-modify","title":"Files to Modify","text":"File Changes <code>server/controllers/library/scenes.ts</code> Update <code>getRecommendedScenes()</code> with scene-derived scoring, criteria response, error handling <code>client/src/components/pages/Recommended.jsx</code> Display criteria counts in empty state, show error type <code>server/tests/recommendations/recommendationScoring.test.ts</code> New test file"},{"location":"plans/2025-12-16-recommendations-improvements-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Negative signals from low-rated scenes (future enhancement)</li> <li>Collaborative filtering (\"users like you also liked\")</li> <li>Watch time / percentage watched as signal</li> <li>Admin diagnostic endpoint (replaced by inline feedback)</li> </ul>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#testing-plan","title":"Testing Plan","text":"<ol> <li>Unit tests pass for scoring logic</li> <li>Manual test: User with only scene favorites sees recommendations</li> <li>Manual test: Empty state shows correct criteria counts</li> <li>Manual test: Error state shows error type</li> <li>Verify existing explicit-rating users still get correct recommendations</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/","title":"Recommendations Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Enable scene-based recommendations, add inline user feedback, improve error handling, and add unit tests.</p> <p>Architecture: Extract a pure <code>RecommendationScoringService</code> from the controller to make scoring logic testable. The service calculates entity weights from both explicit ratings and scene-derived preferences. Controller handles HTTP concerns only.</p> <p>Tech Stack: TypeScript, Vitest, Prisma, React</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-1-extract-recommendation-scoring-service","title":"Task 1: Extract Recommendation Scoring Service","text":"<p>Create a pure service with testable scoring functions.</p> <p>Files: - Create: <code>server/services/RecommendationScoringService.ts</code></p> <p>Step 1: Create the service file with types and constants</p> <pre><code>// server/services/RecommendationScoringService.ts\nimport type { NormalizedScene } from \"../types/index.js\";\n\n// Configuration constants\nexport const SCENE_WEIGHT_BASE = 0.4;\nexport const SCENE_WEIGHT_FAVORITE_BONUS = 0.15;\nexport const SCENE_RATING_FLOOR = 40;\nexport const SCENE_FAVORITED_IMPLICIT_RATING = 85;\n\n// Explicit entity scoring weights (from current algorithm)\nexport const PERFORMER_FAVORITE_WEIGHT = 5;\nexport const PERFORMER_RATED_WEIGHT = 3;\nexport const STUDIO_FAVORITE_WEIGHT = 3;\nexport const STUDIO_RATED_WEIGHT = 2;\nexport const TAG_SCENE_FAVORITE_WEIGHT = 1.0;\nexport const TAG_SCENE_RATED_WEIGHT = 0.5;\nexport const TAG_PERFORMER_FAVORITE_WEIGHT = 0.3;\nexport const TAG_PERFORMER_RATED_WEIGHT = 0.15;\nexport const TAG_STUDIO_FAVORITE_WEIGHT = 0.5;\nexport const TAG_STUDIO_RATED_WEIGHT = 0.25;\n\nexport interface SceneRatingInput {\n  sceneId: string;\n  rating: number | null;\n  favorite: boolean;\n}\n\nexport interface EntityPreferences {\n  favoritePerformers: Set&lt;string&gt;;\n  highlyRatedPerformers: Set&lt;string&gt;;\n  favoriteStudios: Set&lt;string&gt;;\n  highlyRatedStudios: Set&lt;string&gt;;\n  favoriteTags: Set&lt;string&gt;;\n  highlyRatedTags: Set&lt;string&gt;;\n  // Derived weights from scenes (accumulated per entity)\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n}\n\nexport interface UserCriteriaCounts {\n  favoritedPerformers: number;\n  ratedPerformers: number;\n  favoritedStudios: number;\n  ratedStudios: number;\n  favoritedTags: number;\n  ratedTags: number;\n  favoritedScenes: number;\n  ratedScenes: number;\n}\n\n/**\n * Calculate weight multiplier for a scene based on rating and favorite status\n * Returns 0 if scene should be skipped (below floor, no rating/favorite)\n */\nexport function calculateSceneWeightMultiplier(\n  rating: number | null,\n  favorite: boolean\n): number {\n  // Determine effective rating\n  let effectiveRating: number | null = rating;\n\n  if (effectiveRating === null &amp;&amp; favorite) {\n    effectiveRating = SCENE_FAVORITED_IMPLICIT_RATING;\n  }\n\n  if (effectiveRating === null) {\n    return 0;\n  }\n\n  if (effectiveRating &lt; SCENE_RATING_FLOOR) {\n    return 0;\n  }\n\n  let multiplier = (effectiveRating / 100) * SCENE_WEIGHT_BASE;\n\n  if (favorite) {\n    multiplier += SCENE_WEIGHT_FAVORITE_BONUS;\n  }\n\n  return multiplier;\n}\n\n/**\n * Build derived entity weights from rated/favorited scenes\n */\nexport function buildDerivedWeightsFromScenes(\n  sceneRatings: SceneRatingInput[],\n  getSceneById: (sceneId: string) =&gt; NormalizedScene | undefined\n): {\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n} {\n  const derivedPerformerWeights = new Map&lt;string, number&gt;();\n  const derivedStudioWeights = new Map&lt;string, number&gt;();\n  const derivedTagWeights = new Map&lt;string, number&gt;();\n\n  for (const sceneRating of sceneRatings) {\n    const multiplier = calculateSceneWeightMultiplier(\n      sceneRating.rating,\n      sceneRating.favorite\n    );\n\n    if (multiplier === 0) continue;\n\n    const scene = getSceneById(sceneRating.sceneId);\n    if (!scene) continue;\n\n    // Accumulate performer weights\n    if (scene.performers) {\n      for (const performer of scene.performers) {\n        const performerId = String(performer.id);\n        const current = derivedPerformerWeights.get(performerId) || 0;\n        derivedPerformerWeights.set(performerId, current + multiplier);\n      }\n    }\n\n    // Accumulate studio weight\n    if (scene.studio) {\n      const studioId = String(scene.studio.id);\n      const current = derivedStudioWeights.get(studioId) || 0;\n      derivedStudioWeights.set(studioId, current + multiplier);\n    }\n\n    // Accumulate tag weights (scene tags only, not performer/studio tags)\n    if (scene.tags) {\n      for (const tag of scene.tags) {\n        const tagId = String(tag.id);\n        const current = derivedTagWeights.get(tagId) || 0;\n        derivedTagWeights.set(tagId, current + multiplier);\n      }\n    }\n  }\n\n  return {\n    derivedPerformerWeights,\n    derivedStudioWeights,\n    derivedTagWeights,\n  };\n}\n\n/**\n * Score a scene based on user preferences (explicit + derived)\n * Returns the base score before watch status modifiers\n */\nexport function scoreSceneByPreferences(\n  scene: NormalizedScene,\n  prefs: EntityPreferences\n): number {\n  let baseScore = 0;\n\n  // Score performers with diminishing returns (sqrt scaling)\n  if (scene.performers) {\n    let favoritePerformerCount = 0;\n    let highlyRatedPerformerCount = 0;\n    let derivedPerformerWeight = 0;\n\n    for (const performer of scene.performers) {\n      const performerId = String(performer.id);\n\n      if (prefs.favoritePerformers.has(performerId)) {\n        favoritePerformerCount++;\n      } else if (prefs.highlyRatedPerformers.has(performerId)) {\n        highlyRatedPerformerCount++;\n      }\n\n      // Add derived weight\n      const derived = prefs.derivedPerformerWeights.get(performerId);\n      if (derived) {\n        derivedPerformerWeight += derived;\n      }\n    }\n\n    if (favoritePerformerCount &gt; 0) {\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerCount);\n    }\n    if (highlyRatedPerformerCount &gt; 0) {\n      baseScore += PERFORMER_RATED_WEIGHT * Math.sqrt(highlyRatedPerformerCount);\n    }\n    if (derivedPerformerWeight &gt; 0) {\n      // Apply sqrt to accumulated derived weight, scale by favorite weight\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(derivedPerformerWeight);\n    }\n  }\n\n  // Score studio\n  if (scene.studio) {\n    const studioId = String(scene.studio.id);\n\n    if (prefs.favoriteStudios.has(studioId)) {\n      baseScore += STUDIO_FAVORITE_WEIGHT;\n    } else if (prefs.highlyRatedStudios.has(studioId)) {\n      baseScore += STUDIO_RATED_WEIGHT;\n    }\n\n    // Add derived studio weight\n    const derivedStudio = prefs.derivedStudioWeights.get(studioId);\n    if (derivedStudio) {\n      baseScore += STUDIO_FAVORITE_WEIGHT * Math.sqrt(derivedStudio);\n    }\n  }\n\n  // Score tags with source weighting\n  const sceneTags = new Set&lt;string&gt;();\n  const performerTags = new Set&lt;string&gt;();\n  const studioTags = new Set&lt;string&gt;();\n\n  (scene.tags || []).forEach((t) =&gt; sceneTags.add(String(t.id)));\n  (scene.performers || []).forEach((p) =&gt; {\n    (p.tags || []).forEach((t) =&gt; performerTags.add(String(t.id)));\n  });\n  if (scene.studio?.tags) {\n    scene.studio.tags.forEach((t) =&gt; studioTags.add(String(t.id)));\n  }\n\n  let favoriteSceneTagCount = 0;\n  let favoritePerformerTagCount = 0;\n  let favoriteStudioTagCount = 0;\n  let ratedSceneTagCount = 0;\n  let ratedPerformerTagCount = 0;\n  let ratedStudioTagCount = 0;\n  let derivedTagWeight = 0;\n\n  for (const tagId of sceneTags) {\n    if (prefs.favoriteTags.has(tagId)) favoriteSceneTagCount++;\n    else if (prefs.highlyRatedTags.has(tagId)) ratedSceneTagCount++;\n\n    const derived = prefs.derivedTagWeights.get(tagId);\n    if (derived) derivedTagWeight += derived;\n  }\n\n  for (const tagId of performerTags) {\n    if (!sceneTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoritePerformerTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedPerformerTagCount++;\n    }\n  }\n\n  for (const tagId of studioTags) {\n    if (!sceneTags.has(tagId) &amp;&amp; !performerTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoriteStudioTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedStudioTagCount++;\n    }\n  }\n\n  if (favoriteSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(favoriteSceneTagCount);\n  }\n  if (favoritePerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerTagCount);\n  }\n  if (favoriteStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_FAVORITE_WEIGHT * Math.sqrt(favoriteStudioTagCount);\n  }\n  if (ratedSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_RATED_WEIGHT * Math.sqrt(ratedSceneTagCount);\n  }\n  if (ratedPerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_RATED_WEIGHT * Math.sqrt(ratedPerformerTagCount);\n  }\n  if (ratedStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_RATED_WEIGHT * Math.sqrt(ratedStudioTagCount);\n  }\n  if (derivedTagWeight &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(derivedTagWeight);\n  }\n\n  return baseScore;\n}\n\n/**\n * Count user's criteria for feedback display\n */\nexport function countUserCriteria(\n  performerRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  studioRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  tagRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  sceneRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;\n): UserCriteriaCounts {\n  return {\n    favoritedPerformers: performerRatings.filter((r) =&gt; r.favorite).length,\n    ratedPerformers: performerRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedStudios: studioRatings.filter((r) =&gt; r.favorite).length,\n    ratedStudios: studioRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedTags: tagRatings.filter((r) =&gt; r.favorite).length,\n    ratedTags: tagRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedScenes: sceneRatings.filter((r) =&gt; r.favorite).length,\n    ratedScenes: sceneRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= SCENE_RATING_FLOOR).length,\n  };\n}\n\n/**\n * Check if user has any criteria that could generate recommendations\n */\nexport function hasAnyCriteria(counts: UserCriteriaCounts): boolean {\n  return (\n    counts.favoritedPerformers &gt; 0 ||\n    counts.ratedPerformers &gt; 0 ||\n    counts.favoritedStudios &gt; 0 ||\n    counts.ratedStudios &gt; 0 ||\n    counts.favoritedTags &gt; 0 ||\n    counts.ratedTags &gt; 0 ||\n    counts.favoritedScenes &gt; 0 ||\n    counts.ratedScenes &gt; 0\n  );\n}\n</code></pre> <p>Step 2: Run TypeScript compiler to verify no errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/RecommendationScoringService.ts\ngit commit -m \"feat: extract RecommendationScoringService with scoring logic\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-2-unit-tests-for-scene-weight-calculation","title":"Task 2: Unit Tests for Scene Weight Calculation","text":"<p>Files: - Create: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Create test file with weight calculation tests</p> <pre><code>// server/tests/recommendations/recommendationScoring.test.ts\nimport { describe, it, expect } from \"vitest\";\nimport {\n  calculateSceneWeightMultiplier,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n} from \"../../services/RecommendationScoringService.js\";\n\ndescribe(\"RecommendationScoringService\", () =&gt; {\n  describe(\"calculateSceneWeightMultiplier\", () =&gt; {\n    it(\"returns 0 for null rating without favorite\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(null, false)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for favorited-only scene (implicit 85)\", () =&gt; {\n      const expected = (SCENE_FAVORITED_IMPLICIT_RATING / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(expected, 5);\n      // Should be ~0.49 (0.34 + 0.15)\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(0.49, 2);\n    });\n\n    it(\"returns 0 for rating below floor (39)\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(39, false)).toBe(0);\n      expect(calculateSceneWeightMultiplier(39, true)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for rating at floor (40)\", () =&gt; {\n      const expected = (40 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(expected, 5);\n      // Should be 0.16\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(0.16, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 without favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(expected, 5);\n      // Should be 0.40\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(0.40, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 with favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(expected, 5);\n      // Should be 0.55\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(0.55, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 without favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(expected, 5);\n      // Should be 0.32\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(0.32, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 with favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(expected, 5);\n      // Should be 0.47\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(0.47, 2);\n    });\n\n    it(\"returns correct multiplier for rating 60 without favorite\", () =&gt; {\n      const expected = (60 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(expected, 5);\n      // Should be 0.24\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(0.24, 2);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene weight calculation\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-3-unit-tests-for-derived-weights-and-scoring","title":"Task 3: Unit Tests for Derived Weights and Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for buildDerivedWeightsFromScenes</p> <p>Add to the existing test file:</p> <pre><code>import {\n  calculateSceneWeightMultiplier,\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n  PERFORMER_FAVORITE_WEIGHT,\n  type SceneRatingInput,\n  type EntityPreferences,\n} from \"../../services/RecommendationScoringService.js\";\nimport type { NormalizedScene } from \"../../types/index.js\";\n\n// ... existing tests ...\n\ndescribe(\"buildDerivedWeightsFromScenes\", () =&gt; {\n  const mockScene1: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene 1\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" },\n      { id: \"perf2\", name: \"Performer 2\" },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\" },\n    tags: [\n      { id: \"tag1\", name: \"Tag 1\" },\n      { id: \"tag2\", name: \"Tag 2\" },\n    ],\n  } as NormalizedScene;\n\n  const mockScene2: NormalizedScene = {\n    id: \"scene2\",\n    title: \"Test Scene 2\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" }, // Same performer\n      { id: \"perf3\", name: \"Performer 3\" },\n    ],\n    studio: { id: \"studio2\", name: \"Studio 2\" },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }], // Same tag\n  } as NormalizedScene;\n\n  const sceneMap = new Map&lt;string, NormalizedScene&gt;([\n    [\"scene1\", mockScene1],\n    [\"scene2\", mockScene2],\n  ]);\n\n  const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n  it(\"extracts performer weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts studio weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedStudioWeights.get(\"studio1\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts tag weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedTagWeights.get(\"tag1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedTagWeights.get(\"tag2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"accumulates weights for same entity across multiple scenes\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false }, // perf1: 0.4\n      { sceneId: \"scene2\", rating: 100, favorite: false }, // perf1: +0.4 = 0.8\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.8, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf3\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"skips scenes rated below floor\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 39, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n    expect(result.derivedStudioWeights.size).toBe(0);\n    expect(result.derivedTagWeights.size).toBe(0);\n  });\n\n  it(\"handles favorited-only scenes with implicit rating\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: null, favorite: true },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    // Implicit 85 + favorite bonus = 0.49\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.49, 2);\n  });\n\n  it(\"handles scene not found in cache\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"nonexistent\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n  });\n});\n\ndescribe(\"countUserCriteria\", () =&gt; {\n  it(\"counts favorited and rated entities correctly\", () =&gt; {\n    const performerRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 85 },\n      { favorite: false, rating: 70 }, // Below 80, not counted as rated\n    ];\n    const studioRatings = [{ favorite: true, rating: 90 }];\n    const tagRatings = [\n      { favorite: false, rating: 80 },\n      { favorite: false, rating: 80 },\n    ];\n    const sceneRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 50 },\n      { favorite: false, rating: 30 }, // Below 40, not counted\n    ];\n\n    const counts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    expect(counts.favoritedPerformers).toBe(1);\n    expect(counts.ratedPerformers).toBe(1);\n    expect(counts.favoritedStudios).toBe(1);\n    expect(counts.ratedStudios).toBe(1);\n    expect(counts.favoritedTags).toBe(0);\n    expect(counts.ratedTags).toBe(2);\n    expect(counts.favoritedScenes).toBe(1);\n    expect(counts.ratedScenes).toBe(1); // Only rating &gt;= 40 counts\n  });\n});\n\ndescribe(\"hasAnyCriteria\", () =&gt; {\n  it(\"returns false when all counts are zero\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(false);\n  });\n\n  it(\"returns true when only scene favorites exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 1,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n\n  it(\"returns true when only scene ratings exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 3,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for derived weights and criteria counting\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-4-unit-tests-for-scene-scoring","title":"Task 4: Unit Tests for Scene Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for scoreSceneByPreferences</p> <p>Add to the existing test file:</p> <pre><code>describe(\"scoreSceneByPreferences\", () =&gt; {\n  const createEmptyPrefs = (): EntityPreferences =&gt; ({\n    favoritePerformers: new Set(),\n    highlyRatedPerformers: new Set(),\n    favoriteStudios: new Set(),\n    highlyRatedStudios: new Set(),\n    favoriteTags: new Set(),\n    highlyRatedTags: new Set(),\n    derivedPerformerWeights: new Map(),\n    derivedStudioWeights: new Map(),\n    derivedTagWeights: new Map(),\n  });\n\n  const mockScene: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\", tags: [] },\n      { id: \"perf2\", name: \"Performer 2\", tags: [] },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\", tags: [] },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }],\n  } as NormalizedScene;\n\n  it(\"returns 0 for scene with no matching preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    const score = scoreSceneByPreferences(mockScene, prefs);\n    expect(score).toBe(0);\n  });\n\n  it(\"scores favorite performer correctly (5 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT, 2); // 5 * sqrt(1) = 5\n  });\n\n  it(\"applies sqrt diminishing returns for multiple favorite performers\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n    prefs.favoritePerformers.add(\"perf2\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(2) \u2248 7.07\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(2), 2);\n  });\n\n  it(\"scores favorite studio correctly (3 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoriteStudios.add(\"studio1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBe(3);\n  });\n\n  it(\"scores derived performer weights with sqrt scaling\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    // Accumulated weight of 0.8 from two scenes\n    prefs.derivedPerformerWeights.set(\"perf1\", 0.8);\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(0.8) \u2248 4.47\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.8), 2);\n  });\n\n  it(\"combines explicit and derived preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\"); // 5 points\n    prefs.favoriteStudios.add(\"studio1\"); // 3 points\n    prefs.derivedPerformerWeights.set(\"perf2\", 0.4); // 5 * sqrt(0.4) \u2248 3.16\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    const expected =\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(1) + // perf1 explicit\n      3 + // studio\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.4); // perf2 derived\n\n    expect(score).toBeCloseTo(expected, 1);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene scoring with preferences\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-5-update-controller-to-use-scoring-service","title":"Task 5: Update Controller to Use Scoring Service","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1372-1687)</p> <p>Step 1: Add import for the scoring service</p> <p>At the top of the file with other imports, add:</p> <pre><code>import {\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  type EntityPreferences,\n  type SceneRatingInput,\n} from \"../../services/RecommendationScoringService.js\";\n</code></pre> <p>Step 2: Update getRecommendedScenes to fetch scene ratings</p> <p>Replace lines 1385-1392 (the Promise.all that fetches ratings):</p> <pre><code>    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n</code></pre> <p>Step 3: Update criteria checking to include scenes</p> <p>Replace lines 1394-1438 (building sets and hasCriteria check):</p> <pre><code>    // Build sets of favorite and highly-rated entities\n    const favoritePerformers = new Set(\n      performerRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.tagId)\n    );\n\n    // Count user criteria for feedback\n    const criteriaCounts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    // Check if user has any criteria (now includes scenes)\n    if (!hasAnyCriteria(criteriaCounts)) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No recommendations yet\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 4: Build derived weights from scene ratings</p> <p>After the hidden entities filtering (after line ~1468), add:</p> <pre><code>    // Build derived weights from rated/favorited scenes\n    const sceneRatingsForDerived: SceneRatingInput[] = sceneRatings.map((r) =&gt; ({\n      sceneId: r.sceneId,\n      rating: r.rating,\n      favorite: r.favorite,\n    }));\n\n    const sceneMap = new Map(allScenes.map((s) =&gt; [s.id, s]));\n    const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n    const {\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    } = buildDerivedWeightsFromScenes(sceneRatingsForDerived, getSceneById);\n\n    // Build entity preferences object\n    const prefs: EntityPreferences = {\n      favoritePerformers,\n      highlyRatedPerformers,\n      favoriteStudios,\n      highlyRatedStudios,\n      favoriteTags,\n      highlyRatedTags,\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    };\n</code></pre> <p>Step 5: Update scoring loop to use service</p> <p>Replace the scoring loop (lines ~1496-1619) with:</p> <pre><code>    for (const scene of allScenes) {\n      const baseScore = scoreSceneByPreferences(scene, prefs);\n\n      // Skip if no base score (doesn't match any criteria)\n      if (baseScore === 0) continue;\n\n      // Watch status modifier (reduced dominance: was +100/-100, now +30/-30)\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        // Never watched\n        adjustedScore += 30;\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) /\n          (24 * 60 * 60 * 1000);\n\n        if (daysSinceWatched &gt; 14) {\n          // Not recently watched\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          // Recently watched (1-14 days)\n          adjustedScore -= 10;\n        } else {\n          // Very recently watched (&lt;24 hours)\n          adjustedScore -= 30;\n        }\n      }\n\n      // Engagement quality multiplier\n      const oCounter = scene.o_counter || 0;\n      const engagementMultiplier = 1.0 + Math.min(oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      // Only include scenes with positive final scores\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ scene, score: finalScore });\n      }\n    }\n</code></pre> <p>Step 6: Run TypeScript compiler and lint</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: integrate scene-derived preferences into recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-6-add-criteria-to-empty-response","title":"Task 6: Add Criteria to Empty Response","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Update response when scenes found but scored to zero</p> <p>After the diversification/pagination logic, before the final res.json, add a check for empty results:</p> <pre><code>    // If no recommendations after scoring, include criteria for feedback\n    if (cappedScenes.length === 0) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No matching recommendations found\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: include criteria counts in empty recommendation responses\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-7-improve-error-handling-in-controller","title":"Task 7: Improve Error Handling in Controller","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1681-1686)</p> <p>Step 1: Update catch block with better error logging</p> <p>Replace the catch block:</p> <pre><code>  } catch (error) {\n    const err = error as Error;\n    logger.error(\"Error getting recommended scenes:\", {\n      message: err.message,\n      name: err.name,\n      stack: err.stack,\n      userId: req.user?.id,\n    });\n\n    const errorType = err.name || \"Unknown error\";\n    res.status(500).json({\n      error: \"Failed to get recommended scenes\",\n      errorType,\n    });\n  }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"fix: improve error logging and response for recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-8-update-client-to-display-criteria-feedback","title":"Task 8: Update Client to Display Criteria Feedback","text":"<p>Files: - Modify: <code>client/src/components/pages/Recommended.jsx</code></p> <p>Step 1: Add state for criteria</p> <p>Add to the state declarations (around line 25):</p> <pre><code>const [criteria, setCriteria] = useState(null);\n</code></pre> <p>Step 2: Update fetch handler to capture criteria</p> <p>Update the response destructuring (around line 52):</p> <pre><code>const { scenes: fetchedScenes, count, message: msg, criteria: criteriaCounts } = response.data;\n\nsetScenes(fetchedScenes);\nsetTotalCount(count);\nsetCriteria(criteriaCounts || null);\nif (msg) {\n  setMessage(msg);\n}\n</code></pre> <p>Step 3: Update error handling to capture errorType</p> <p>Update the error handling (around line 76):</p> <pre><code>setError({\n  message: err.response?.data?.error || \"Failed to load recommendations\",\n  errorType: err.response?.data?.errorType || null,\n});\n</code></pre> <p>Step 4: Update error display</p> <p>Update error prop passed to SceneGrid (around line 160):</p> <pre><code>error={!initMessage &amp;&amp; error ? error.message : null}\n</code></pre> <p>And add error type display after the PageHeader:</p> <pre><code>{error &amp;&amp; error.errorType &amp;&amp; (\n  &lt;div className=\"mb-4 text-sm text-gray-500\"&gt;\n    (Error type: {error.errorType})\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 5: Create criteria display component</p> <p>Add helper function before the return statement:</p> <pre><code>const renderCriteriaFeedback = () =&gt; {\n  if (!criteria) return null;\n\n  const hasAnyActivity =\n    criteria.favoritedPerformers &gt; 0 ||\n    criteria.ratedPerformers &gt; 0 ||\n    criteria.favoritedStudios &gt; 0 ||\n    criteria.ratedStudios &gt; 0 ||\n    criteria.favoritedTags &gt; 0 ||\n    criteria.ratedTags &gt; 0 ||\n    criteria.favoritedScenes &gt; 0 ||\n    criteria.ratedScenes &gt; 0;\n\n  if (!hasAnyActivity) {\n    return (\n      &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n        &lt;p&gt;To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n      &lt;p className=\"mb-2\"&gt;Your current activity:&lt;/p&gt;\n      &lt;ul className=\"list-disc list-inside space-y-1\"&gt;\n        &lt;li&gt;{criteria.favoritedPerformers} favorited performer{criteria.favoritedPerformers !== 1 ? 's' : ''}, {criteria.ratedPerformers} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedStudios} favorited studio{criteria.favoritedStudios !== 1 ? 's' : ''}, {criteria.ratedStudios} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedTags} favorited tag{criteria.favoritedTags !== 1 ? 's' : ''}, {criteria.ratedTags} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedScenes} favorited scene{criteria.favoritedScenes !== 1 ? 's' : ''}, {criteria.ratedScenes} rated scene{criteria.ratedScenes !== 1 ? 's' : ''}&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;p className=\"mt-2 italic\"&gt;Tip: Rating more scenes helps us learn your preferences!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 6: Update SceneGrid props to include criteria</p> <p>Update the SceneGrid component to pass criteria:</p> <pre><code>&lt;SceneGrid\n  scenes={scenes}\n  loading={loading}\n  error={!initMessage &amp;&amp; error ? error.message : null}\n  currentPage={page}\n  totalPages={totalPages}\n  onPageChange={handlePageChange}\n  onHideSuccess={handleHideSuccess}\n  perPage={perPage}\n  onPerPageChange={handlePerPageChange}\n  totalCount={totalCount}\n  emptyMessage={message || \"No Recommendations Yet\"}\n  emptyDescription={\n    criteria ? renderCriteriaFeedback() : \"Rate or Favorite more items to get personalized recommendations.\"\n  }\n/&gt;\n</code></pre> <p>Step 7: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing warnings)</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/Recommended.jsx\ngit commit -m \"feat: display criteria feedback on empty recommendations page\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-9-integration-test-manual-verification","title":"Task 9: Integration Test - Manual Verification","text":"<p>Files: None (manual testing)</p> <p>Step 1: Start the dev server</p> <p>Run: <code>npm run dev</code> (or your dev command)</p> <p>Step 2: Test with no ratings</p> <ol> <li>Log in as a user with no ratings/favorites</li> <li>Navigate to Recommended page</li> <li>Verify: Empty state shows criteria counts (all zeros)</li> <li>Verify: Message explains how to get recommendations</li> </ol> <p>Step 3: Test with only scene favorites</p> <ol> <li>Favorite 2-3 scenes from the library</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations appear (derived from scene content)</li> <li>Verify: Scenes with matching performers/studios/tags are shown</li> </ol> <p>Step 4: Test with explicit + scene ratings</p> <ol> <li>Also favorite a performer explicitly</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations include both explicit matches and derived matches</li> </ol> <p>Step 5: Test error display</p> <ol> <li>Temporarily break the database connection</li> <li>Navigate to Recommended page</li> <li>Verify: Error message shows with error type</li> </ol> <p>Step 6: Document results</p> <p>Note any issues found for follow-up.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-10-run-full-test-suite","title":"Task 10: Run Full Test Suite","text":"<p>Files: None</p> <p>Step 1: Run all server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 2: Run client tests (if any)</p> <p>Run: <code>cd client &amp;&amp; npm test</code> (if applicable) Expected: All tests PASS</p> <p>Step 3: Final commit for any cleanup</p> <p>If any issues found, fix and commit.</p> <p>Step 4: Push branch</p> <pre><code>git push -u origin feature/recommendations-improvements\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#summary","title":"Summary","text":"Task Description Files 1 Extract RecommendationScoringService <code>server/services/RecommendationScoringService.ts</code> 2 Unit tests for weight calculation <code>server/tests/recommendations/recommendationScoring.test.ts</code> 3 Unit tests for derived weights <code>server/tests/recommendations/recommendationScoring.test.ts</code> 4 Unit tests for scene scoring <code>server/tests/recommendations/recommendationScoring.test.ts</code> 5 Update controller to use service <code>server/controllers/library/scenes.ts</code> 6 Add criteria to empty response <code>server/controllers/library/scenes.ts</code> 7 Improve error handling <code>server/controllers/library/scenes.ts</code> 8 Update client for criteria feedback <code>client/src/components/pages/Recommended.jsx</code> 9 Manual integration testing - 10 Run full test suite -"},{"location":"plans/MULTI_INSTANCE_STASH/","title":"Multiple Stash Instances - Implementation Plan","text":"<p>Status: Deferred Created: 2025-11-25 Last Updated: 2025-11-25</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#overview","title":"Overview","text":"<p>This document outlines the implementation plan for supporting multiple Stash server instances in Peek, allowing users to aggregate content from multiple Stash libraries into a unified browsing experience.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#current-state-commit-1-complete","title":"Current State (Commit 1 Complete)","text":"<ul> <li><code>StashInstance</code> model exists in database with UUID primary key</li> <li><code>StashInstanceManager</code> service manages connections</li> <li>Single instance enforcement in place (<code>configs.length &gt; 1</code> throws error)</li> <li>Auto-migration from env vars to database on first startup</li> <li>Setup wizard allows configuring first Stash instance</li> <li>Server Settings shows current instance (read-only)</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#key-challenges","title":"Key Challenges","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#1-entity-id-collisions","title":"1. Entity ID Collisions","text":"<p>Stash uses auto-increment integer IDs per-instance. Scene ID <code>123</code> from Instance A is completely different from Scene ID <code>123</code> from Instance B.</p> <p>Options: - Composite key: Store <code>instanceId</code> + <code>sceneId</code> as separate columns (cleaner, preferred) - Prefixed ID: Concatenate as <code>{instanceId}_{sceneId}</code> string (simpler but messier)</p> <p>Decision: Use separate <code>instanceId</code> column for cleaner database architecture.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#2-entity-deduplication","title":"2. Entity Deduplication","text":"<p>The same performer/studio/tag may exist across multiple Stash instances: - Same performer with different local IDs - StashDB integration provides a common identifier (<code>stash_ids</code> field) - Need strategy to merge or deduplicate entities</p> <p>Considerations: - StashDB IDs can serve as deduplication key - If same StashDB ID exists on multiple instances, which one \"wins\"? - May need a \"primary\" instance concept for conflict resolution - Performers without StashDB IDs cannot be deduplicated automatically</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#3-filtering-across-instances","title":"3. Filtering Across Instances","text":"<p>Current filtering assumes single instance: - Tag filters reference tag IDs - Performer filters reference performer IDs - How do we filter when same logical entity has different IDs per instance?</p> <p>Options: - Filter by StashDB ID where available - Filter by name matching (fuzzy, less reliable) - Keep filters instance-scoped (simpler but less unified)</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#4-affected-entity-types","title":"4. Affected Entity Types","text":"<p>All Stash entities need instance tracking: - Scenes - Performers - Studios - Tags - Galleries - Groups - Images</p> <p>Each needs <code>instanceId</code> added to normalized types and cache storage.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#5-proxy-and-streaming","title":"5. Proxy and Streaming","text":"<p>Must route requests to correct instance: - Image proxy needs to know which instance to fetch from - Video streaming needs to use correct instance's file paths - Already have <code>getBaseUrl(instanceId)</code> and <code>getApiKey(instanceId)</code> methods</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#6-user-data-mapping","title":"6. User Data Mapping","text":"<p>Current user data (ratings, watch history, favorites) uses Stash entity IDs: - <code>WatchHistory.sceneId</code> references a scene - <code>SceneRating.sceneId</code> references a scene - Need composite key or migration strategy</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#phase-1-backend-multi-instance-support","title":"Phase 1: Backend Multi-Instance Support","text":"<ol> <li>Remove single-instance enforcement in StashInstanceManager</li> <li>Add <code>instanceId</code> to normalized types (NormalizedScene, NormalizedPerformer, etc.)</li> <li>Update StashCacheManager to fetch from all instances and merge</li> <li>Update cache key strategy to use <code>instanceId:entityId</code> composite</li> <li>Add instance CRUD endpoints:</li> <li><code>GET /api/setup/stash-instances</code> - List all</li> <li><code>POST /api/setup/stash-instance</code> - Create (admin only)</li> <li><code>PUT /api/setup/stash-instance/:id</code> - Update</li> <li><code>DELETE /api/setup/stash-instance/:id</code> - Delete</li> <li>Trigger cache rebuild after any instance change</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-2-entity-identification-refactor","title":"Phase 2: Entity Identification Refactor","text":"<ol> <li>Update all controllers to handle composite entity references</li> <li>Update proxy controller to route to correct instance</li> <li>Update video controller to stream from correct instance</li> <li>Update user data tables to include instanceId in composite keys</li> <li>Create migration for existing user data</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-3-deduplication-system","title":"Phase 3: Deduplication System","text":"<ol> <li>Research StashDB ID availability in Stash GraphQL schema</li> <li>Implement deduplication logic:</li> <li>Fetch StashDB IDs for all entities</li> <li>Group entities by StashDB ID</li> <li>Designate primary instance for conflicts</li> <li>Update UI to show deduplicated entities</li> <li>Handle entities without StashDB IDs (keep separate)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-4-ui-updates","title":"Phase 4: UI Updates","text":"<ol> <li>Update StashInstanceSection for full CRUD:</li> <li>List all instances with status indicators</li> <li>Add Instance button with connection test</li> <li>Edit instance (name, URL, API key)</li> <li>Delete instance with confirmation</li> <li>Enable/disable toggle per instance</li> <li>Update filters to work across instances</li> <li>Show instance badge on entities (optional, for debugging)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#database-schema-changes","title":"Database Schema Changes","text":"<pre><code>// Already exists\nmodel StashInstance {\n  id        String   @id @default(uuid())\n  name      String\n  url       String\n  apiKey    String\n  enabled   Boolean  @default(true)\n  priority  Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\n// Needs update - add instanceId to composite unique\nmodel WatchHistory {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\nmodel SceneRating {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\n// Similar changes for PerformerRating, StudioRating, etc.\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#normalized-type-changes","title":"Normalized Type Changes","text":"<pre><code>interface NormalizedScene {\n  id: string;\n  instanceId: string;  // NEW - which Stash instance this came from\n  // ... existing fields\n}\n\ninterface NormalizedPerformer {\n  id: string;\n  instanceId: string;  // NEW\n  stashDbId?: string;  // NEW - for deduplication\n  // ... existing fields\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#api-response-changes","title":"API Response Changes","text":"<p>Entities returned from API will include <code>instanceId</code>:</p> <pre><code>{\n  \"id\": \"12345\",\n  \"instanceId\": \"8dcbd5b1-73c1-4d1c-b3ce-0924c336e59f\",\n  \"title\": \"Scene Title\",\n  ...\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#open-questions","title":"Open Questions","text":"<ol> <li>Should deduplication be automatic or user-controlled?</li> <li>Automatic based on StashDB ID?</li> <li> <p>Let users manually merge entities?</p> </li> <li> <p>How to handle conflicting metadata?</p> </li> <li>Same performer, different bios on different instances</li> <li> <p>Which instance's data takes precedence?</p> </li> <li> <p>Performance impact of multi-instance cache?</p> </li> <li>Cache size doubles/triples with multiple instances</li> <li> <p>Refresh time increases proportionally</p> </li> <li> <p>Should users be able to filter by instance?</p> </li> <li>\"Show only scenes from Instance A\"</li> <li>Useful for debugging, maybe not for regular use</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-1-single-stash-instance-only","title":"Alternative 1: Single Stash Instance Only","text":"<p>Keep the current single-instance design. Users with multiple Stash servers would need to consolidate into one Stash instance.</p> <p>Pros: Simpler, no ID collision issues Cons: Limits use cases, some users have legitimate multi-instance setups</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-2-instance-scoped-everything","title":"Alternative 2: Instance-Scoped Everything","text":"<p>Keep instances completely separate - user switches between instances like switching accounts.</p> <p>Pros: No collision issues, simpler implementation Cons: No unified library view, poor UX for users who want to see everything together</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-3-external-aggregation","title":"Alternative 3: External Aggregation","text":"<p>Recommend users use Stash's built-in library merging features instead.</p> <p>Pros: No Peek changes needed Cons: May not exist, shifts burden to user</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#estimated-effort","title":"Estimated Effort","text":"<ul> <li>Phase 1: 1-2 days</li> <li>Phase 2: 2-3 days</li> <li>Phase 3: 2-3 days</li> <li>Phase 4: 1-2 days</li> </ul> <p>Total: ~1 week of focused development</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#dependencies","title":"Dependencies","text":"<ul> <li>Understanding of StashDB ID structure in Stash GraphQL</li> <li>Testing with multiple actual Stash instances</li> <li>User feedback on deduplication preferences</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#references","title":"References","text":"<ul> <li>Stash GraphQL Schema</li> <li>StashDB Integration Docs</li> <li>Commit 1: <code>291b428</code> - Single instance database storage</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/","title":"TikTok/Reels Implementation Analysis","text":""},{"location":"plans/REELS_IMPLEMENTATION/#overview","title":"Overview","text":"<p>This document analyzes what it would take to implement a TikTok/Reels-like experience in Peek, based on user requests referencing Stash TV and StashReels.</p> <p>Important: This would be a separate page/view, not replacing any existing functionality.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#what-users-want","title":"What Users Want","text":"<p>Based on StashReels and Stash TV implementations:</p>"},{"location":"plans/REELS_IMPLEMENTATION/#core-experience","title":"Core Experience","text":"<ul> <li>Vertical swipe/scroll through videos</li> <li>Auto-play when video comes into view</li> <li>Tap to pause/play</li> <li>Minimal, non-intrusive UI</li> <li>Filter-based playlists (use saved Stash filters)</li> <li>Infinite scrolling to load more content</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#key-features","title":"Key Features","text":"<ul> <li>Mute/unmute toggle</li> <li>Quality selector</li> <li>Fullscreen mode</li> <li>O-counter button</li> <li>Rating stars</li> <li>Video scrubbing with thumbnails</li> <li>Performer/tag links</li> <li>Scene info overlay (hideable)</li> <li>Landscape rotation support</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#technical-architecture","title":"Technical Architecture","text":""},{"location":"plans/REELS_IMPLEMENTATION/#route-page-structure","title":"Route &amp; Page Structure","text":"<pre><code>/reels (new page)\n  - Query params: ?filter=xyz&amp;index=123\n  - Separate from scene browse/grid view\n  - Can deep-link to specific position\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#navigation-integration","title":"Navigation Integration","text":"<pre><code>Current Navigation:\n- Home\n- Scenes (grid view)\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n\nWith Reels Added:\n- Home\n- Scenes (grid view) \u2190 unchanged\n- Reels \u2190 NEW PAGE\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#core-components","title":"Core Components","text":"<p>ReelsPage Component: - Main container with vertical scroll - Manages playlist state (current filter, scenes) - Handles pagination/infinite scroll - Filter selection UI</p> <p>ReelItem Component: - Simplified video player for each scene - Auto-play when in viewport (Intersection Observer) - Pause when scrolled away - Minimal overlay controls - Scene metadata display</p> <p>ReelsControls Component: - Floating UI for global controls - Filter/playlist selector - Settings panel - Exit button</p>"},{"location":"plans/REELS_IMPLEMENTATION/#critical-technical-challenges","title":"Critical Technical Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#1-memory-management-most-important","title":"1. Memory Management (MOST IMPORTANT)","text":"<p>Video.js players consume significant RAM. Cannot have 50 players initialized at once.</p> <p>Solution: Only render 3-5 video elements at a time - Current video (playing) - Next video (pre-buffering) - Previous video (for smooth back-scroll) - Dispose players that scroll out of range</p> <p>StashReels Approach:</p> <p>\"Loads only 11 scenes at once\u2014current scene plus five before and after\u2014to optimize browser memory\"</p> <p>Recommended Strategy:</p> <pre><code>Viewport:\n  [Video -2] \u2190 disposed, removed from DOM\n  [Video -1] \u2190 rendered but paused, player initialized\n  [Video  0] \u2190 CURRENT, playing, HLS session active\n  [Video +1] \u2190 rendered, pre-buffering, HLS starting\n  [Video +2] \u2190 rendered element, no player yet\n  [Video +3] \u2190 disposed, removed from DOM\n</code></pre> <p>Rules: - Only 3-4 Video.js players initialized - Only 1-2 active transcoding sessions - Dispose players &gt;2 positions away - Use Intersection Observer threshold for triggering</p>"},{"location":"plans/REELS_IMPLEMENTATION/#2-transcoding-session-management","title":"2. Transcoding Session Management","text":"<p>Each video creates HLS transcoding session. Can't have 20+ FFmpeg processes running.</p> <p>Solution: - Cleanup sessions immediately on scroll away - Pre-start transcoding for next video - Limit to 2-3 active sessions max - Extend <code>TranscodingManager</code> with session priority system</p>"},{"location":"plans/REELS_IMPLEMENTATION/#3-auto-play-restrictions","title":"3. Auto-Play Restrictions","text":"<p>Mobile browsers block autoplay without user interaction. iOS Safari is particularly restrictive.</p> <p>Solution: - First video requires user tap - After that, can auto-play with muted default - Unmute button shows when needed - Fallback UI: \"Tap to play\" message</p>"},{"location":"plans/REELS_IMPLEMENTATION/#4-scroll-performance","title":"4. Scroll Performance","text":"<p>Need smooth 60fps scrolling with videos.</p> <p>Solution: - CSS scroll-snap-type - Intersection Observer (not scroll events) - GPU-accelerated transforms - Virtual scrolling if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-advantages","title":"Implementation Advantages","text":""},{"location":"plans/REELS_IMPLEMENTATION/#what-peek-already-has","title":"What Peek Already Has \u2705","text":"<ul> <li>Video.js integration - Can reuse player setup</li> <li>HLS transcoding system - TranscodingManager ready</li> <li>Quality selection - Already implemented</li> <li>O-counter + rating - Existing buttons/tracking</li> <li>Watch history - Track viewed reels</li> <li>Scene metadata - Performers, tags, descriptions</li> <li>Theme system - Dark/light modes work</li> <li>Auth system - User preferences</li> <li>Mobile responsive - Touch-friendly UI</li> <li>Saved filters from Stash - Can fetch via GraphQL</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#whats-new-need-to-build","title":"What's New (Need to Build) \ud83c\udd95","text":"<ul> <li>Vertical scroll container - With snap points</li> <li>Intersection Observer logic - Trigger play/pause</li> <li>Player lifecycle management - Create/dispose on scroll</li> <li>Gesture handling - Swipe up/down, double-tap</li> <li>Prefetch strategy - Pre-buffer next video</li> <li>Memory monitoring - Track and cleanup aggressively</li> <li>Playlist management - Filter selection, pagination</li> <li>Minimal UI overlay - Different from full player</li> <li>Infinite scroll pagination - Load more scenes</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-effort-estimate","title":"Implementation Effort Estimate","text":""},{"location":"plans/REELS_IMPLEMENTATION/#phase-1-mvp-5-7-days","title":"Phase 1: MVP (5-7 days)","text":"<ul> <li>Basic vertical scroll with 3 videos</li> <li>Simple auto-play/pause on scroll</li> <li>Minimal controls (mute, close, O-counter)</li> <li>Single filter (e.g., \"Recently Added\")</li> <li>Desktop + mobile basic support</li> </ul> <p>Deliverable: Can swipe through videos with basic playback</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-2-full-features-5-7-days","title":"Phase 2: Full Features (5-7 days)","text":"<ul> <li>Filter selection modal</li> <li>Infinite scroll pagination</li> <li>Full controls (quality, scrubber, fullscreen)</li> <li>Rating integration</li> <li>Scene info overlay</li> <li>Memory optimization</li> <li>Prefetch next video</li> </ul> <p>Deliverable: Feature-complete reels experience</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-3-polish-3-5-days","title":"Phase 3: Polish (3-5 days)","text":"<ul> <li>Mobile gesture improvements (double-tap, swipe velocity)</li> <li>Keyboard shortcuts (arrow keys, space)</li> <li>Performance tuning (virtual scrolling if needed)</li> <li>iOS Safari fixes (autoplay, fullscreen)</li> <li>User preferences (default filter, default quality, mute state)</li> <li>Analytics/tracking</li> <li>Error states (network issues, empty playlists)</li> </ul> <p>Deliverable: Production-ready, polished experience</p> <p>Total Estimate: 13-19 days</p>"},{"location":"plans/REELS_IMPLEMENTATION/#key-technical-decisions","title":"Key Technical Decisions","text":""},{"location":"plans/REELS_IMPLEMENTATION/#scroll-implementation","title":"Scroll Implementation","text":"<p>Option A: Native CSS Scroll Snap (Recommended) <pre><code>.reels-container {\n  scroll-snap-type: y mandatory;\n  overflow-y: scroll;\n}\n\n.reel-item {\n  scroll-snap-align: start;\n  height: 100vh;\n}\n</code></pre></p> <p>Pros: Native, smooth, performant Cons: Less control over snap behavior</p> <p>Option B: Custom Scroll Logic Use wheel/touch events with programmatic scrolling</p> <p>Pros: Full control Cons: Complex, hard to get right, performance issues</p> <p>Recommendation: Start with Option A, fall back to B if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#video-player-approach","title":"Video Player Approach","text":"<p>Option A: Reuse existing <code>VideoPlayer</code> component - Pros: Less code duplication - Cons: Component is complex, has unused features for reels</p> <p>Option B: Create simplified <code>ReelVideoPlayer</code> - Pros: Optimized for reels, cleaner, lighter - Cons: Some code duplication</p> <p>Recommendation: Option B - Create <code>ReelVideoPlayer</code> that shares core Video.js setup but removes unnecessary UI (playlist controls, chapter markers, etc.)</p>"},{"location":"plans/REELS_IMPLEMENTATION/#state-management","title":"State Management","text":"<p>Relatively simple state: <pre><code>{\n  filter: currentFilterId,\n  scenes: [...scene IDs...],\n  currentIndex: 123,\n  hasMore: true,\n  loading: false,\n  muted: true,\n  quality: \"720p\"\n}\n</code></pre></p> <p>Recommendation: React Context or simple useState, no need for Redux/Zustand yet</p>"},{"location":"plans/REELS_IMPLEMENTATION/#transcoding-quality","title":"Transcoding Quality","text":"<p>Users on mobile may want lower quality for data usage.</p> <p>Options: 1. Default to 480p for reels 2. Remember user's last quality selection 3. Auto-select based on connection speed 4. Allow per-reel quality override</p> <p>Recommendation: Start with user's last selected quality, add auto-select later if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#risks-challenges","title":"Risks &amp; Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#high-risk","title":"High Risk","text":"<ol> <li>Memory leaks - Video.js players not properly disposed</li> <li>Transcoding overload - Too many FFmpeg sessions crash server</li> <li>iOS autoplay - Safari blocks autoplay, breaks experience</li> <li>Janky scroll - Videos lag during scroll</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#medium-risk","title":"Medium Risk","text":"<ol> <li>Network handling - Slow connections, failed loads</li> <li>Empty states - No scenes match filter</li> <li>Battery drain - Continuous video playback on mobile</li> <li>User getting \"lost\" - Infinite scroll, no clear endpoint</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Extensive memory profiling during development</li> <li>TranscodingManager session limits</li> <li>Fallback UI for autoplay failures (\"Tap to play\")</li> <li>Virtual scrolling if performance issues</li> <li>\"You've reached the end\" message after X videos</li> <li>Exit button always visible</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#user-experience-considerations","title":"User Experience Considerations","text":""},{"location":"plans/REELS_IMPLEMENTATION/#must-haves","title":"Must-Haves","text":"<ul> <li>\u26a1 Fast response - Video plays within 500ms of scroll</li> <li>\ud83c\udfaf Clear controls - Obvious how to mute, exit, etc.</li> <li>\ud83d\udcf1 Touch-friendly - Large tap targets, intuitive gestures</li> <li>\ud83d\udd01 Smooth transitions - No blank frames between videos</li> <li>\ud83d\udeaa Easy exit - Back button, close button work intuitively</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#nice-to-haves","title":"Nice-to-Haves","text":"<ul> <li>\u2328\ufe0f Keyboard shortcuts - Space (pause), arrows (next/prev)</li> <li>\ud83d\uddb1\ufe0f Mouse wheel - Desktop users can scroll with wheel</li> <li>\ud83d\udcca Progress indicator - \"Video 5 of 47\" or similar</li> <li>\ud83d\udd16 Remember position - Resume where you left off</li> <li>\ud83c\udfa8 Visual polish - Transitions, animations</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#integration-with-existing-features","title":"Integration with Existing Features","text":""},{"location":"plans/REELS_IMPLEMENTATION/#reuse-existing-components","title":"Reuse Existing Components","text":"<ul> <li><code>SceneStats</code> component (O-counter, rating)</li> <li><code>SceneMetadata</code> component (performers, tags)</li> <li><code>libraryApi</code> service (fetch scenes)</li> <li><code>watchHistoryApi</code> (track views)</li> <li><code>TranscodingManager</code> (HLS sessions)</li> <li>Quality selector UI</li> <li>Auth/theme contexts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#new-components","title":"New Components","text":"<ul> <li><code>ReelsPage.jsx</code> - Main page container</li> <li><code>ReelVideoPlayer.jsx</code> - Simplified player based on <code>VideoPlayer</code></li> <li><code>ReelItem.jsx</code> - Individual reel in scroll container</li> <li><code>ReelsControls.jsx</code> - Floating control UI</li> <li><code>useReelsPlayer.js</code> - Player lifecycle hook</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#modifications-needed","title":"Modifications Needed","text":"<ul> <li>Extend <code>TranscodingManager</code> with session priority (reels vs regular playback)</li> <li>Add reels-specific watch tracking (mark as viewed after X seconds)</li> <li>Add user preferences for reels (default filter, mute state, quality)</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#benefits-of-being-a-separate-page","title":"Benefits of Being a Separate Page","text":""},{"location":"plans/REELS_IMPLEMENTATION/#zero-risk-to-existing-features","title":"Zero Risk to Existing Features","text":"<ul> <li>All current pages (Scenes, Scene Detail, Playlists, etc.) remain untouched</li> <li>If reels page has bugs, doesn't affect main browsing</li> <li>Can be feature-flagged or hidden behind settings if needed</li> <li>Easy to disable if issues arise</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#simpler-implementation","title":"Simpler Implementation","text":"<ul> <li>Don't need to refactor existing components</li> <li>Can use completely different layout/structure</li> <li>Can ignore desktop optimizations if mobile-focused</li> <li>Different routing, different state management</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#gradual-rollout","title":"Gradual Rollout","text":"<ul> <li>Can release as \"beta\" feature</li> <li>Add nav link only when ready</li> <li>Can gather feedback without disrupting existing workflows</li> <li>Easy to A/B test</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#resource-isolation","title":"Resource Isolation","text":"<ul> <li>Reels page uses its own Video.js players (separate from scene detail)</li> <li>Can set different transcoding limits for reels vs regular playback</li> <li>Memory cleanup when navigating away (unmount entire page)</li> <li>No shared state conflicts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#mobile-first-design","title":"Mobile-First Design","text":"<ul> <li>Can optimize entirely for mobile without breaking desktop scene browsing</li> <li>Different UI paradigms (vertical vs grid) don't conflict</li> <li>Touch gestures won't interfere with click interactions elsewhere</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#rollback-safety","title":"Rollback Safety","text":"<p>If reels page has critical bugs: <pre><code>// In navigation or route config\nconst REELS_ENABLED = import.meta.env.VITE_ENABLE_REELS === 'true';\n\n// Or user setting\nif (user.preferences.showReels) {\n  // Show reels nav link\n}\n</code></pre></p> <p>Can disable without affecting anything else.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#recommended-implementation-path","title":"Recommended Implementation Path","text":""},{"location":"plans/REELS_IMPLEMENTATION/#option-a-mvp-first-recommended","title":"Option A: MVP First (Recommended)","text":"<ol> <li>Validate Demand - Confirm multiple users requesting this</li> <li>Build MVP (3-5 days):</li> <li>Single hardcoded filter (\"Recently Added\")</li> <li>No infinite scroll (just load 20 videos)</li> <li>Basic controls only</li> <li>Desktop-first (mobile later)</li> <li>User Testing - Get feedback before full build</li> <li>Iterate - Build out full features based on feedback</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#option-b-full-build","title":"Option B: Full Build","text":"<p>Skip MVP, build complete feature over 2-3 weeks. Higher risk but faster time-to-complete if MVP would be approved anyway.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#success-criteria","title":"Success Criteria","text":"<p>Technical: - Memory usage stays under 500MB even after 50+ videos viewed - Max 2-3 concurrent transcoding sessions - Smooth 60fps scroll on mobile devices - Video starts within 500ms of scroll</p> <p>User Experience: - 80%+ of users can navigate without instructions - &lt;5% bounce rate on reels page - Average session length &gt;5 minutes - Positive feedback in Discord/GitHub</p>"},{"location":"plans/REELS_IMPLEMENTATION/#conclusion","title":"Conclusion","text":"<p>Arguments For: - \ud83d\udc4d High user engagement (TikTok proves the UX works) - \ud83d\udc4d Differentiates Peek from Stash - \ud83d\udc4d Mobile-first feature (Peek's strength) - \ud83d\udc4d Peek has good infrastructure already (video player, transcoding) - \ud83d\udc4d Can be isolated page (low risk to existing features)</p> <p>Arguments Against: - \ud83d\udc4e Significant effort (2-3 weeks full-time) - \ud83d\udc4e Performance risks (memory, transcoding load) - \ud83d\udc4e Ongoing maintenance (iOS Safari bugs, etc.) - \ud83d\udc4e StashReels already exists for Stash users - \ud83d\udc4e May encourage mindless consumption</p> <p>Recommendation: If you have 2-3 weeks of development time and users are actively requesting this, it's worth building. Start with a minimal MVP to validate the approach, then iterate based on feedback.</p> <p>The key to success will be: 1. Aggressive memory management - Only 3-5 players max 2. Transcoding limits - Max 2 concurrent sessions 3. Mobile testing early - iOS Safari will be the pain point 4. Performance profiling - Measure memory/CPU continuously</p> <p>Last Updated: 2025-10-30 Status: Analysis complete, awaiting decision to proceed</p>"},{"location":"reference/faq/","title":"Frequently Asked Questions","text":"<p>Common questions about Peek Stash Browser.</p>"},{"location":"reference/faq/#general","title":"General","text":""},{"location":"reference/faq/#what-is-peek","title":"What is Peek?","text":"<p>Peek is a modern web application for browsing and streaming Stash media content with real-time HLS transcoding. It provides a fast, responsive interface with adaptive quality streaming.</p>"},{"location":"reference/faq/#how-is-peek-different-from-stash","title":"How is Peek different from Stash?","text":"<p>Peek is a browser/player focused on video playback, while Stash is a comprehensive media organizer. Peek:</p> <ul> <li>Focuses on smooth video playback with adaptive streaming</li> <li>Provides a simplified, browsing-focused interface</li> <li>Uses real-time transcoding for universal compatibility</li> <li>Complements Stash rather than replacing it</li> </ul>"},{"location":"reference/faq/#does-peek-modify-my-stash-library","title":"Does Peek modify my Stash library?","text":"<p>No. Peek is read-only. It connects to Stash's GraphQL API to read data but never modifies your library, files, or metadata.</p>"},{"location":"reference/faq/#installation","title":"Installation","text":""},{"location":"reference/faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<ul> <li>unRAID: Community Applications or manual Docker install</li> <li>Docker: Any platform supporting Docker</li> <li>Development: Node.js 18+ on Windows/Mac/Linux</li> </ul>"},{"location":"reference/faq/#do-i-need-a-separate-database-server","title":"Do I need a separate database server?","text":"<p>No. Peek uses embedded SQLite. No PostgreSQL, MySQL, or other database server needed.</p>"},{"location":"reference/faq/#can-i-run-peek-and-stash-on-the-same-server","title":"Can I run Peek and Stash on the same server?","text":"<p>Yes. They run as separate containers and don't conflict.</p>"},{"location":"reference/faq/#video-playback","title":"Video Playback","text":""},{"location":"reference/faq/#why-does-transcoding-take-so-long","title":"Why does transcoding take so long?","text":"<p>Transcoding is CPU-intensive. Performance depends on:</p> <ul> <li>Server CPU power</li> <li>Storage I/O speed (SSD vs HDD vs network)</li> <li>Original video codec and resolution</li> <li>Target quality selected</li> </ul> <p>For best performance, use local SSD storage and allocate 2-4 CPU cores.</p>"},{"location":"reference/faq/#can-i-play-videos-directly-without-transcoding","title":"Can I play videos directly without transcoding?","text":"<p>Yes! Direct play is available when your browser supports the video codec. Use the quality selector and choose Direct to play the original file without transcoding.</p> <p>When to use Direct: - Fastest playback (no transcoding delay) - Highest quality (original file) - Browser supports the video format</p> <p>When to use transcoding: - Browser doesn't support the format - Want adaptive quality (switch between 720p/480p/360p) - Slower network connections</p>"},{"location":"reference/faq/#can-i-download-the-original-video-file","title":"Can I download the original video file?","text":"<p>Not yet. Video downloads are planned for a future release. Currently, you can only stream videos through Peek's player.</p>"},{"location":"reference/faq/#configuration","title":"Configuration","text":""},{"location":"reference/faq/#where-are-my-settings-stored","title":"Where are my settings stored?","text":"<ul> <li>User preferences: SQLite database in <code>/app/data/peek-db.db</code></li> <li>Server config: Environment variables</li> <li>Temp files: <code>/app/data/hls-cache/</code> (auto-cleaned)</li> </ul>"},{"location":"reference/faq/#how-do-i-backup-my-data","title":"How do I backup my data?","text":"<pre><code># Backup SQLite database\ndocker exec peek-stash-browser sqlite3 /app/data/peek-db.db \".backup /app/data/backup.db\"\n\n# Copy backup out of container\ndocker cp peek-stash-browser:/app/data/backup.db ./peek-backup.db\n</code></pre>"},{"location":"reference/faq/#can-i-customize-the-theme","title":"Can I customize the theme?","text":"<p>Yes! Peek includes several built-in themes and a custom theme editor.</p> <p>Built-in Themes: - Light Mode - Dark Mode (default) - Deep Purple - The Hub</p> <p>Custom Theme Editor: 1. Go to Settings \u2192 My Settings 2. Scroll to Custom Themes section 3. Create your own theme by choosing colors 4. Customize fonts, backgrounds, text colors, and more 5. Save and apply your custom theme</p> <p>Toggle between themes using the theme icon in the navigation bar.</p>"},{"location":"reference/faq/#performance","title":"Performance","text":""},{"location":"reference/faq/#how-many-concurrent-streams-can-peek-handle","title":"How many concurrent streams can Peek handle?","text":"<p>Depends on server CPU:</p> <ul> <li>2 CPU cores: 1-2 streams at 720p</li> <li>4 CPU cores: 3-4 streams at 720p</li> <li>6+ CPU cores: 5+ streams at 720p</li> </ul> <p>Lower qualities (480p, 360p) require less CPU and support more concurrent streams.</p>"},{"location":"reference/faq/#why-is-my-media-loading-slowly","title":"Why is my media loading slowly?","text":"<p>Check storage speed:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>If &lt; 50 MB/s, media is likely on: - Network share (SMB/NFS) - Move to local storage - Slow HDD - Upgrade to SSD - USB drive - Use internal storage</p>"},{"location":"reference/faq/#how-much-disk-space-does-peek-need","title":"How much disk space does Peek need?","text":"<ul> <li>App data: ~100 MB (database, config)</li> <li>Temp files: ~50-100 MB per quality per minute of video</li> <li>Recommendation: 5-10 GB for temp storage on busy servers</li> </ul> <p>Temp files are automatically cleaned up after 30 minutes.</p>"},{"location":"reference/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/faq/#videos-wont-play","title":"Videos won't play","text":"<ol> <li>Check FFmpeg is installed: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Verify path mapping is correct</li> <li>Check file permissions on media</li> <li>Review backend logs for errors</li> </ol> <p>See: Troubleshooting Guide</p>"},{"location":"reference/faq/#cant-connect-to-stash","title":"Can't connect to Stash","text":"<ol> <li>Verify <code>STASH_URL</code> is correct and accessible from container</li> <li>Check Stash API key is valid</li> <li>Test connectivity: <code>docker exec peek-stash-browser curl http://stash:9999/graphql</code></li> </ol>"},{"location":"reference/faq/#login-doesnt-work","title":"Login doesn't work","text":"<ul> <li>Check cookies are enabled</li> <li>Verify <code>JWT_SECRET</code> is set</li> <li>Try incognito mode</li> <li>Clear browser cache</li> </ul>"},{"location":"reference/faq/#features","title":"Features","text":""},{"location":"reference/faq/#how-do-playlists-work","title":"How do playlists work?","text":"<p>Playlists are fully available! Create custom playlists of your favorite scenes.</p> <p>Creating a Playlist: 1. Click Playlists in the navigation 2. Click Create Playlist 3. Enter a name and description 4. Click Create</p> <p>Adding Scenes: - Click the + icon on any scene card - Select the playlist to add it to - Or go to a scene's detail page and click Add to Playlist</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start from the beginning - Use Shuffle to randomize playback order - Use Repeat (all or one) for continuous playback - Reorder scenes by dragging them in edit mode</p> <p>Learn More</p> <p>See the Complete Playlists Guide for detailed instructions on managing and playing playlists.</p>"},{"location":"reference/faq/#does-peek-track-watch-history","title":"Does Peek track watch history?","text":"<p>Yes! Peek automatically tracks your viewing progress and lets you resume playback from where you left off.</p> <p>Features: - Automatic progress tracking during playback - Resume from any device (synced to your user account) - \"Continue Watching\" section on home page - Progress bars on scene cards - Clear history for individual scenes or all at once</p> <p>Learn More</p> <p>See the Watch History Guide for complete details on managing your watch history.</p>"},{"location":"reference/faq/#can-i-use-keyboard-navigation","title":"Can I use keyboard navigation?","text":"<p>Yes! Peek supports complete keyboard navigation, perfect for TV remotes or wireless keyboards.</p> <p>Key features: - Arrow keys navigate scene grids and lists - Enter to select/play - Video player keyboard shortcuts (Space, arrows, F for fullscreen) - Playlist controls (N for next, P for previous) - TV Mode optimized for couch browsing</p> <p>Learn More</p> <p>See the Keyboard Navigation Guide for all keyboard shortcuts and TV mode setup.</p>"},{"location":"reference/faq/#can-i-use-peek-on-mobile","title":"Can I use Peek on mobile?","text":"<p>Yes. The web interface is responsive and works on mobile browsers. A dedicated mobile app is not currently planned.</p>"},{"location":"reference/faq/#does-peek-support-hardware-transcoding","title":"Does Peek support hardware transcoding?","text":"<p>Not yet. Hardware-accelerated transcoding (GPU) is planned for a future release to improve performance and reduce CPU usage.</p>"},{"location":"reference/faq/#can-i-use-peek-without-stash","title":"Can I use Peek without Stash?","text":"<p>No. Peek requires a Stash server for media library management and metadata. Peek is designed as a companion to Stash, not a replacement.</p>"},{"location":"reference/faq/#security","title":"Security","text":""},{"location":"reference/faq/#is-peek-secure","title":"Is Peek secure?","text":"<p>Peek includes: - JWT authentication - Bcrypt password hashing - Read-only media access - Session management</p> <p>Important: Change the default admin password immediately!</p>"},{"location":"reference/faq/#should-i-expose-peek-to-the-internet","title":"Should I expose Peek to the internet?","text":"<p>No. Peek is designed for local network use. For remote access: - Use VPN - Use reverse proxy with authentication layer - Don't expose directly to internet</p>"},{"location":"reference/faq/#support","title":"Support","text":""},{"location":"reference/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Stash Discord: #third-party-integrations channel</li> </ul>"},{"location":"reference/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<ol> <li>Search existing issues first</li> <li>Gather logs and error messages</li> <li>Create detailed issue on GitHub</li> <li>Include: version, platform, steps to reproduce</li> </ol> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#can-i-contribute","title":"Can I contribute?","text":"<p>Yes! Contributions are welcome: - Code improvements - Bug fixes - Documentation - Translations (future)</p> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Install Peek</li> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Create and manage custom playlists</li> <li>Troubleshooting - Fix common issues</li> </ul>"},{"location":"reference/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for Peek Stash Browser.</p>"},{"location":"reference/troubleshooting/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"reference/troubleshooting/#container-wont-start","title":"Container Won't Start","text":"<p>Check logs first:</p> <pre><code>docker logs peek-stash-browser\n</code></pre> <p>Common causes:</p> <ul> <li>Missing required environment variables (<code>STASH_URL</code>, <code>STASH_API_KEY</code>)</li> <li>Invalid <code>STASH_URL</code> (not accessible from container)</li> <li>Port conflicts (6969 already in use)</li> <li>Missing volume mappings</li> </ul> <p>Solution:</p> <pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove container\ndocker rm peek-stash-browser\n\n# Recreate with correct configuration\n# (use your template or docker-compose)\n</code></pre>"},{"location":"reference/troubleshooting/#cant-connect-to-stash","title":"Can't Connect to Stash","text":"<p>Test connectivity from container:</p> <pre><code>docker exec peek-stash-browser curl -X POST http://your-stash-ip:9999/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"ApiKey: your-api-key-12345\" \\\n  -d '{\n    \"query\": \"query FindTags { findTags(filter: { per_page: 1 }) { count tags { id name } } }\"\n  }'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>STASH_URL</code> is correct and accessible</li> <li>Check Stash API key is valid (Settings \u2192 Security \u2192 API Key)</li> <li>Ensure Stash GraphQL endpoint is enabled</li> <li>Check firewall rules between containers</li> </ul>"},{"location":"reference/troubleshooting/#video-playback","title":"Video Playback","text":""},{"location":"reference/troubleshooting/#videos-wont-play","title":"Videos Won't Play","text":"<ol> <li>Check FFmpeg: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Check file permissions: <code>docker exec peek-stash-browser ls -la /app/media</code></li> <li>Verify path mapping: Go to Settings \u2192 Path Mappings and use \"Test Path\" button</li> <li>Check media is mounted: <code>docker exec peek-stash-browser ls /app/media</code></li> <li>Check backend logs: <code>docker logs peek-stash-browser</code></li> </ol>"},{"location":"reference/troubleshooting/#slow-transcoding","title":"Slow Transcoding","text":"<p>Check I/O performance:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>Expected: 50+ MB/s for good performance</p> <p>Solutions:</p> <ul> <li>Move media to local storage (not network share)</li> <li>Use SSD for media and temp files</li> <li>Reduce quality preset</li> <li>Allocate more CPU to container</li> </ul>"},{"location":"reference/troubleshooting/#authentication","title":"Authentication","text":""},{"location":"reference/troubleshooting/#cant-login","title":"Can't Login","text":"<ul> <li>Verify username/password</li> <li>Check if cookies are enabled in browser</li> <li>Clear browser cache and cookies</li> <li>Try incognito/private browsing mode</li> </ul>"},{"location":"reference/troubleshooting/#session-expires-immediately","title":"Session Expires Immediately","text":"<ul> <li>Check <code>JWT_SECRET</code> is set</li> <li>Verify <code>SECURE_COOKIES</code> matches your setup (false for HTTP)</li> <li>Clear browser cookies</li> <li>Check system clock is correct</li> </ul>"},{"location":"reference/troubleshooting/#network-performance","title":"Network &amp; Performance","text":""},{"location":"reference/troubleshooting/#slow-page-loading","title":"Slow Page Loading","text":"<ul> <li>Check server CPU/memory usage</li> <li>Clear browser cache</li> <li>Verify network speed</li> <li>Check for console errors (F12 \u2192 Console)</li> </ul>"},{"location":"reference/troubleshooting/#images-not-loading","title":"Images Not Loading","text":"<ul> <li>Check Stash is accessible</li> <li>Verify <code>STASH_URL</code> is correct</li> <li>Check browser console for CORS errors</li> <li>Try clearing cache</li> </ul>"},{"location":"reference/troubleshooting/#database","title":"Database","text":""},{"location":"reference/troubleshooting/#database-locked-error","title":"Database Locked Error","text":"<pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove lock file\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db-wal\n\n# Restart container\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#reset-database","title":"Reset Database","text":"<p>This Deletes All Data</p> <p>This will delete all users, preferences, and playlists.</p> <pre><code>docker stop peek-stash-browser\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#logs-debugging","title":"Logs &amp; Debugging","text":""},{"location":"reference/troubleshooting/#viewing-logs","title":"Viewing Logs","text":"<pre><code># All logs\ndocker logs peek-stash-browser\n\n# Follow logs (live)\ndocker logs -f peek-stash-browser\n\n# Last 100 lines\ndocker logs --tail 100 peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Add to environment variables:</p> <pre><code>LOG_LEVEL=debug\n</code></pre>"},{"location":"reference/troubleshooting/#browser-console","title":"Browser Console","text":"<p>Check browser console for frontend errors:</p> <ol> <li>Press F12 to open DevTools</li> <li>Click Console tab</li> <li>Look for red errors</li> <li>Copy error messages when reporting issues</li> </ol>"},{"location":"reference/troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"reference/troubleshooting/#ffmpeg-not-found","title":"\"FFmpeg not found\"","text":"<p>Solution: FFmpeg should be included in the official image. If you see this error: - Pull the latest image: <code>docker pull carrotwaxr/peek-stash-browser:latest</code> - Rebuild your container with the latest image</p>"},{"location":"reference/troubleshooting/#path-not-found-or-path-related-errors","title":"\"Path not found\" or path-related errors","text":"<p>Solution: Check your path mappings: 1. Go to Settings \u2192 Path Mappings in Peek 2. Click Test Path for each mapping 3. Verify paths are accessible 4. Make sure media volumes are mounted to your container</p>"},{"location":"reference/troubleshooting/#session-not-found","title":"\"Session not found\"","text":"<p>Solution: Session expired (30 min timeout). Refresh page and try again.</p>"},{"location":"reference/troubleshooting/#unauthorized","title":"\"Unauthorized\"","text":"<p>Solution: Token expired. Logout and login again.</p>"},{"location":"reference/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"reference/troubleshooting/#before-asking-for-help","title":"Before Asking for Help","text":"<ol> <li>Check this troubleshooting guide</li> <li>Search existing GitHub Issues</li> <li>Check browser console for errors</li> <li>Gather logs and error messages</li> </ol>"},{"location":"reference/troubleshooting/#creating-a-bug-report","title":"Creating a Bug Report","text":"<p>Include:</p> <ul> <li>Peek version: Check Settings \u2192 About</li> <li>Platform: unRAID / Docker / Development</li> <li>Browser: Chrome 120 / Firefox 121 / etc.</li> <li>Stash version: Your Stash server version</li> <li>Error logs: Backend and browser console</li> <li>Steps to reproduce: Detailed steps</li> <li>Screenshots: If applicable</li> </ul>"},{"location":"reference/troubleshooting/#where-to-get-help","title":"Where to Get Help","text":"<ul> <li>GitHub Issues: https://github.com/carrotwaxr/peek-stash-browser/issues</li> <li>Stash Discord: #third-party-integrations channel</li> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> </ul>"},{"location":"reference/troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/custom-carousels/","title":"Custom Carousels","text":"<p>Create personalized homepage carousels using a visual query builder. Custom carousels let you define filter rules to automatically curate collections of scenes based on performers, tags, ratings, and more.</p>"},{"location":"user-guide/custom-carousels/#creating-a-custom-carousel","title":"Creating a Custom Carousel","text":"<ol> <li>Navigate to Settings \u2192 Homepage Carousels</li> <li>Click Create Carousel</li> <li>Configure your carousel:</li> <li>Title: Give your carousel a descriptive name</li> <li>Icon: Choose from a selection of icons</li> <li>Filter Rules: Add one or more rules to define which scenes appear</li> <li> <p>Sort: Choose how scenes are ordered (Random, Recently Added, etc.)</p> </li> <li> <p>Click Preview to see matching scenes</p> </li> <li>Click Save once you're satisfied with the preview</li> </ol>"},{"location":"user-guide/custom-carousels/#filter-rules","title":"Filter Rules","text":"<p>Each rule consists of a filter type, comparison operator, and value. All rules must match (AND logic) for a scene to appear in the carousel.</p>"},{"location":"user-guide/custom-carousels/#available-filters","title":"Available Filters","text":"Filter Description Performers Scenes featuring specific performers Tags Scenes with specific tags Studio Scenes from a specific studio Collections Scenes in specific groups/collections Rating Scenes within a rating range (0-100) Duration Scene length in minutes Resolution Video quality (480p, 720p, 1080p, etc.) Play Count Number of times you've watched O Count Your O count for the scene Favorite Scenes Only your favorited scenes Favorite Performers Scenes with your favorite performers Favorite Studios Scenes from your favorite studios Favorite Tags Scenes with your favorite tags Created Date When the scene was added Scene Date The scene's release date Last Played Date When you last watched Performer Age Performer age at time of scene Performer Count Number of performers in scene Bitrate Video bitrate in Mbps Title Contains Text search in scene title Details Contains Text search in scene description"},{"location":"user-guide/custom-carousels/#comparison-operators","title":"Comparison Operators","text":"<p>Different filter types support different operators:</p> <ul> <li>Entity filters (Performers, Tags, etc.): includes any of, includes all of, excludes</li> <li>Numeric filters (Rating, Duration, etc.): between, greater than, less than</li> <li>Boolean filters (Favorites): is true / is false</li> <li>Text filters: contains</li> </ul>"},{"location":"user-guide/custom-carousels/#managing-carousels","title":"Managing Carousels","text":""},{"location":"user-guide/custom-carousels/#reordering","title":"Reordering","text":"<p>Use the up/down arrow buttons next to each carousel to change the display order on your homepage.</p>"},{"location":"user-guide/custom-carousels/#visibility","title":"Visibility","text":"<p>Click the eye icon to show/hide individual carousels. Hidden carousels remain saved but won't appear on the homepage.</p>"},{"location":"user-guide/custom-carousels/#editing","title":"Editing","text":"<p>Click the pencil icon on any custom carousel to modify its rules, title, or icon.</p>"},{"location":"user-guide/custom-carousels/#deleting","title":"Deleting","text":"<p>Click the trash icon to delete a custom carousel. This action cannot be undone.</p>"},{"location":"user-guide/custom-carousels/#limits","title":"Limits","text":"<ul> <li>Maximum of 15 custom carousels per user</li> <li>Each carousel displays up to 12 scenes</li> <li>All filter rules use AND logic (scenes must match all rules)</li> </ul>"},{"location":"user-guide/custom-carousels/#tips","title":"Tips","text":"<ul> <li>Start simple: Begin with one or two rules and add more as needed</li> <li>Use Preview: Always preview before saving to ensure your rules work as expected</li> <li>Random sort: Great for variety - shows different scenes each time you visit</li> <li>Combine with favorites: Create carousels for \"Highly rated scenes with favorite performers\"</li> <li>Content restrictions: Custom carousels respect your hidden items and content restrictions</li> </ul>"},{"location":"user-guide/custom-carousels/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/custom-carousels/#carousel-shows-no-scenes-found","title":"Carousel shows \"No scenes found\"","text":"<ul> <li>Your filter rules may be too restrictive</li> <li>Try relaxing some rules or using different operators</li> <li>Check that you have scenes matching your criteria</li> </ul>"},{"location":"user-guide/custom-carousels/#carousel-not-appearing-on-homepage","title":"Carousel not appearing on homepage","text":"<ul> <li>Make sure the carousel is enabled (eye icon should be visible, not crossed out)</li> <li>Try refreshing the page</li> <li>Check Settings \u2192 Homepage Carousels to verify it's toggled on</li> </ul>"},{"location":"user-guide/external-player/","title":"External Player","text":"<p>Peek allows you to open scenes in external media players like VLC for enhanced playback features such as hardware acceleration, subtitle support, and advanced playback controls.</p>"},{"location":"user-guide/external-player/#platform-compatibility","title":"Platform Compatibility","text":"Platform Status Notes Android \u2705 Works Opens app chooser for any installed video player iOS \u2705 Works Opens directly in VLC (requires VLC for iOS) Windows (Edge/Chrome) \u2705 Works Requires protocol handler setup (see below) Windows (Firefox) \u26a0\ufe0f Limited May not work due to Firefox's protocol handling macOS \ud83d\udd2c Untested Should work with protocol handler Linux \ud83d\udd2c Untested Should work with protocol handler <p>Help Us Test</p> <p>We need community feedback on platform compatibility. If you test on a platform not marked as \"Works\", please report your results on GitHub so we can update this documentation.</p>"},{"location":"user-guide/external-player/#using-the-external-player-button","title":"Using the External Player Button","text":"<p>On the scene page, you'll find an external player button (external link icon) next to the \"View in Stash\" button. The behavior differs by platform:</p>"},{"location":"user-guide/external-player/#mobile-devices","title":"Mobile Devices","text":"<ul> <li>Android: Tapping the button opens a dialog to choose any installed video player app (VLC, MX Player, etc.)</li> <li>iOS: Tapping the button opens the scene directly in VLC (requires VLC for iOS to be installed)</li> </ul>"},{"location":"user-guide/external-player/#desktop-windowsmaclinux","title":"Desktop (Windows/Mac/Linux)","text":"<p>The button becomes a combo button with two parts:</p> <ol> <li>Main button (external link icon): Opens the scene in VLC</li> <li>Dropdown arrow: Click to reveal additional options:</li> <li>Copy Stream URL: Copies the direct stream URL to your clipboard</li> </ol>"},{"location":"user-guide/external-player/#setting-up-vlc-protocol-handler-desktop","title":"Setting Up VLC Protocol Handler (Desktop)","text":"<p>For the \"Open in VLC\" button to work on desktop, you need to install a protocol handler that registers the <code>vlc://</code> URL scheme with your operating system.</p> <p>Why is this needed? VLC doesn't natively understand <code>vlc://</code> URLs. The protocol handler intercepts these URLs, strips the <code>vlc://</code> prefix, and passes the actual video URL to VLC.</p>"},{"location":"user-guide/external-player/#windows-setup-recommended-method","title":"Windows Setup (Recommended Method)","text":"<p>The most reliable method for Windows is using a registry file with a PowerShell script. This approach handles URL encoding issues that browsers introduce.</p>"},{"location":"user-guide/external-player/#step-1-create-the-registry-file","title":"Step 1: Create the Registry File","text":"<ol> <li>Open Notepad</li> <li>Paste the following content:</li> </ol> <pre><code>Windows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\vlc]\n@=\"URL:VLC Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\vlc\\DefaultIcon]\n@=\"C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe,0\"\n\n[HKEY_CLASSES_ROOT\\vlc\\shell]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open\\command]\n@=\"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -WindowStyle Hidden -Command \\\"&amp; {$url='%1' -replace '^vlc://' -replace '^http//', 'http://' -replace '^https//', 'https://'; Start-Process -FilePath 'C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe' -ArgumentList $url}\\\"\"\n</code></pre> <ol> <li>Save as <code>vlc-protocol.reg</code> (make sure to select \"All Files\" as the file type)</li> </ol> <p>Adjust VLC Path if Needed</p> <p>If VLC is installed in a different location (e.g., <code>C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe</code>), update both paths in the registry file accordingly.</p>"},{"location":"user-guide/external-player/#step-2-install-the-registry-entries","title":"Step 2: Install the Registry Entries","text":"<ol> <li>Double-click the <code>vlc-protocol.reg</code> file</li> <li>Click \"Yes\" when prompted by User Account Control</li> <li>Click \"Yes\" when asked to confirm adding to the registry</li> <li>You should see \"The keys and values contained in [path] have been successfully added to the registry\"</li> </ol>"},{"location":"user-guide/external-player/#step-3-test-it","title":"Step 3: Test It","text":"<ol> <li>Open Peek in Edge or Chrome</li> <li>Navigate to a scene</li> <li>Click the external player button</li> <li>When prompted, allow the browser to open the VLC handler</li> <li>VLC should open and start playing the video</li> </ol>"},{"location":"user-guide/external-player/#how-the-powershell-script-works","title":"How the PowerShell Script Works","text":"<p>The PowerShell command in the registry performs these transformations:</p> <ol> <li>Removes the <code>vlc://</code> prefix from the URL</li> <li>Fixes <code>http//</code> \u2192 <code>http://</code> (browsers strip the colon for security)</li> <li>Fixes <code>https//</code> \u2192 <code>https://</code></li> <li>Launches VLC with the corrected URL</li> </ol>"},{"location":"user-guide/external-player/#alternative-third-party-protocol-handlers","title":"Alternative: Third-Party Protocol Handlers","text":"<p>These tools may also work, though results vary:</p> <ul> <li>player-protocol - Supports VLC and PotPlayer</li> <li>vlc-protocol - VLC-specific handler</li> </ul>"},{"location":"user-guide/external-player/#macos-setup","title":"macOS Setup","text":"<p>macOS users can try:</p> <ol> <li>Install a protocol handler like player-protocol</li> <li>Or use the \"Copy Stream URL\" fallback method</li> </ol> <p>macOS Testers Needed</p> <p>If you've successfully set up VLC protocol handling on macOS, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#linux-setup","title":"Linux Setup","text":"<p>Linux users can register protocol handlers via <code>xdg-mime</code> or desktop files. A typical approach:</p> <ol> <li>Create a <code>.desktop</code> file for handling <code>x-scheme-handler/vlc</code></li> <li>Register it with <code>xdg-mime default vlc-handler.desktop x-scheme-handler/vlc</code></li> </ol> <p>Linux Testers Needed</p> <p>If you've successfully set up VLC protocol handling on Linux, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#copying-the-stream-url-fallback-method","title":"Copying the Stream URL (Fallback Method)","text":"<p>If you don't want to set up a protocol handler, or it's not working on your platform, you can use the \"Copy Stream URL\" option:</p> <ol> <li>Click the dropdown arrow on the external player button</li> <li>Select \"Copy Stream URL\"</li> <li>Open VLC manually</li> <li>Go to Media \u2192 Open Network Stream (Ctrl+N on Windows/Linux, Cmd+N on macOS)</li> <li>Paste the URL and click Play</li> </ol> <p>This method works on all platforms without any additional setup.</p>"},{"location":"user-guide/external-player/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/external-player/#open-in-vlc-doesnt-work-windows","title":"\"Open in VLC\" doesn't work (Windows)","text":"<ol> <li>Check browser: Try Edge or Chrome instead of Firefox</li> <li>Verify registry: Open <code>regedit</code> and check that <code>HKEY_CLASSES_ROOT\\vlc</code> exists</li> <li>Check VLC path: Ensure the path in the registry matches your VLC installation</li> <li>Use fallback: Copy the stream URL and open it manually in VLC</li> </ol>"},{"location":"user-guide/external-player/#firefox-doesnt-open-vlc-windows","title":"Firefox doesn't open VLC (Windows)","text":"<p>Firefox handles custom protocols differently from Edge/Chrome and may not respect Windows registry protocol handlers. Known workarounds:</p> <ul> <li>Use Edge or Chrome for the \"Open in VLC\" feature</li> <li>Use the \"Copy Stream URL\" fallback method</li> <li>Set <code>network.protocol-handler.expose.vlc</code> to <code>false</code> in <code>about:config</code> (results may vary)</li> </ul> <p>Known Issue</p> <p>Firefox on Windows currently doesn't reliably support the <code>vlc://</code> protocol even with the registry handler installed. We're tracking this issue and welcome any solutions from the community.</p>"},{"location":"user-guide/external-player/#video-wont-play-in-vlc","title":"Video won't play in VLC","text":"<ul> <li>Ensure VLC is up to date (version 3.0 or later recommended)</li> <li>The stream URL goes through Peek's proxy, which should handle authentication automatically</li> <li>Try the \"Copy Stream URL\" method to verify the URL works</li> </ul>"},{"location":"user-guide/external-player/#android-no-app-found-to-handle-the-link","title":"Android: No app found to handle the link","text":"<ul> <li>Install a video player app (VLC, MX Player, etc.)</li> <li>The Android intent system should show a list of compatible apps</li> </ul>"},{"location":"user-guide/external-player/#ios-link-doesnt-open-vlc","title":"iOS: Link doesn't open VLC","text":"<ul> <li>Ensure VLC for iOS is installed from the App Store</li> <li>The <code>vlc-x-callback://</code> scheme is only supported by VLC</li> <li>Other iOS video players are not currently supported</li> </ul>"},{"location":"user-guide/external-player/#technical-details","title":"Technical Details","text":""},{"location":"user-guide/external-player/#url-formats-by-platform","title":"URL Formats by Platform","text":"Platform URL Format Example Android Intent URI <code>intent://host#Intent;action=android.intent.action.VIEW;scheme=https;type=video/mp4;...</code> iOS VLC x-callback <code>vlc-x-callback://x-callback-url/stream?url=...</code> Desktop VLC protocol <code>vlc://https://peek.example.com/api/scene/123/proxy-stream/stream</code>"},{"location":"user-guide/external-player/#stream-url","title":"Stream URL","text":"<p>The stream URL points to Peek's proxy endpoint, not directly to Stash. This ensures:</p> <ul> <li>API keys are not exposed in URLs</li> <li>Authentication is handled by Peek</li> <li>The URL format is: <code>{peek-url}/api/scene/{sceneId}/proxy-stream/stream</code></li> </ul>"},{"location":"user-guide/external-player/#contributing","title":"Contributing","text":"<p>If you've found a solution for a platform or browser that's not working, please:</p> <ol> <li>Open an issue with your platform details</li> <li>Describe the steps you took to get it working</li> <li>We'll update this documentation to help other users</li> </ol>"},{"location":"user-guide/hidden-items/","title":"Hidden Items","text":""},{"location":"user-guide/hidden-items/#overview","title":"Overview","text":"<p>The Hidden Items feature allows you to hide specific content from your personal view without affecting other users. Unlike Content Restrictions (which are admin-controlled), Hidden Items are entirely user-controlled and work for all users including admins.</p> <p>Key Difference from Content Restrictions: - Content Restrictions: Set by admins, restrict what a user CAN see (e.g., exclude certain tags/studios) - Hidden Items: Set by users themselves, hide individual items they don't want to see</p>"},{"location":"user-guide/hidden-items/#how-to-hide-items","title":"How to Hide Items","text":""},{"location":"user-guide/hidden-items/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Click the three-dot menu (\u22ee) on any scene card</li> <li>Select \"Hide Scene\"</li> <li>Confirm in the dialog (or check \"Don't ask again\" to skip future confirmations)</li> </ol>"},{"location":"user-guide/hidden-items/#from-entity-cards","title":"From Entity Cards","text":"<p>The same three-dot menu is available on: - Performer cards - Studio cards - Tag cards - Group/Collection cards - Gallery cards</p>"},{"location":"user-guide/hidden-items/#bulk-actions-scenes","title":"Bulk Actions (Scenes)","text":"<ol> <li>Enable multi-select mode by clicking the checkbox icon</li> <li>Select multiple scenes</li> <li>Click \"Hide Selected\" in the bulk action bar</li> </ol>"},{"location":"user-guide/hidden-items/#managing-hidden-items","title":"Managing Hidden Items","text":""},{"location":"user-guide/hidden-items/#viewing-hidden-items","title":"Viewing Hidden Items","text":"<ol> <li>Go to My Settings</li> <li>Scroll to the \"Hidden Items\" section</li> <li>Click View Hidden Items</li> </ol>"},{"location":"user-guide/hidden-items/#restoring-hidden-items","title":"Restoring Hidden Items","text":"<p>From the Hidden Items page: - Click Restore on individual items to unhide them - Click Restore All to restore all hidden items at once - Use the tabs to filter by entity type (Scenes, Performers, Studios, etc.)</p>"},{"location":"user-guide/hidden-items/#dont-ask-again","title":"Don't Ask Again","text":"<p>If you frequently hide items and want to skip the confirmation dialog: 1. Check \"Don't ask me again\" when hiding an item, OR 2. Go to My Settings &gt; Hidden Items section 3. Check \"Don't ask for confirmation when hiding items\"</p> <p>You can toggle this setting on/off at any time.</p>"},{"location":"user-guide/hidden-items/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/hidden-items/#for-regular-users","title":"For Regular Users","text":"<ul> <li>Hidden items are filtered from all views (search, carousels, recommendations)</li> <li>Hidden items persist across sessions and page refreshes</li> <li>Other users are not affected by your hidden items</li> </ul>"},{"location":"user-guide/hidden-items/#for-admin-users","title":"For Admin Users","text":"<ul> <li>Admins can hide content for themselves just like regular users</li> <li>Content Restrictions (INCLUDE/EXCLUDE rules) are bypassed for admins</li> <li>Hidden Items filtering is ALWAYS applied, even for admins</li> <li>This allows admins to maintain full admin access while personalizing their own view</li> </ul>"},{"location":"user-guide/hidden-items/#cascading-behavior","title":"Cascading Behavior","text":"<p>When you hide an entity: - Hiding a Scene: Only that scene is hidden - Hiding a Performer: That performer and scenes where they appear may be affected - Hiding a Studio: That studio and scenes from it may be affected - Hiding a Tag: That tag and related content may be affected</p> <p>Note: The exact cascading behavior depends on your Content Restrictions settings and whether hidden entities are the only content associated with related items.</p>"},{"location":"user-guide/hidden-items/#faq","title":"FAQ","text":""},{"location":"user-guide/hidden-items/#can-i-accidentally-hide-something-important","title":"Can I accidentally hide something important?","text":"<p>You can always restore hidden items from My Settings &gt; View Hidden Items. The Restore All button makes it easy to undo bulk actions.</p>"},{"location":"user-guide/hidden-items/#do-hidden-items-count-toward-my-stats","title":"Do hidden items count toward my stats?","text":"<p>Hidden items are excluded from most views but may still appear in certain statistics or reports.</p>"},{"location":"user-guide/hidden-items/#can-admins-see-what-ive-hidden","title":"Can admins see what I've hidden?","text":"<p>Admins can see that you have hidden items (via database access) but the hidden items feature is designed for personal use. Each user's hidden items are private to them.</p>"},{"location":"user-guide/hidden-items/#what-happens-if-content-ive-hidden-is-updated-in-stash","title":"What happens if content I've hidden is updated in Stash?","text":"<p>Hidden items remain hidden even if the underlying content is modified in Stash. The hiding is based on entity ID, not content characteristics.</p> <p>Document Version: 1.0 Last Updated: 2025-01-21</p>"},{"location":"user-guide/keyboard-navigation/","title":"Keyboard Navigation &amp; TV Mode","text":"<p>Peek provides complete keyboard navigation, making it perfect for TV remotes, wireless keyboards, or couch browsing.</p>"},{"location":"user-guide/keyboard-navigation/#why-keyboard-navigation","title":"Why Keyboard Navigation?","text":"<ul> <li>TV Mode - Use Peek on your TV with just a remote</li> <li>Accessibility - Full keyboard support for users who prefer or require it</li> <li>Efficiency - Navigate faster without reaching for the mouse</li> <li>Couch Browsing - Control everything from your couch with a wireless keyboard</li> </ul>"},{"location":"user-guide/keyboard-navigation/#global-navigation","title":"Global Navigation","text":""},{"location":"user-guide/keyboard-navigation/#primary-navigation-keys","title":"Primary Navigation Keys","text":"Key Action <code>Tab</code> Move to next focusable element <code>Shift+Tab</code> Move to previous focusable element <code>Enter</code> Activate/click the focused element <code>Space</code> Activate buttons (also play/pause in video player) <code>Escape</code> Go back or close modals"},{"location":"user-guide/keyboard-navigation/#arrow-key-navigation","title":"Arrow Key Navigation","text":"<p>Arrow keys navigate through grid layouts and lists:</p> Key Action <code>\u2191</code> Move focus up (in grids and lists) <code>\u2193</code> Move focus down (in grids and lists) <code>\u2190</code> Move focus left (in grids) <code>\u2192</code> Move focus right (in grids) <p>Grid Navigation: - Scene grids automatically respond to arrow keys - Focus moves intelligently between rows and columns - Works on Scenes, Performers, Studios, Tags pages</p> <p>List Navigation: - Arrow up/down navigates vertical lists - Works in playlists, search results, settings</p>"},{"location":"user-guide/keyboard-navigation/#scene-browsing","title":"Scene Browsing","text":""},{"location":"user-guide/keyboard-navigation/#scene-grid-navigation","title":"Scene Grid Navigation","text":"<p>Navigating scene cards:</p> <ol> <li>Use <code>Tab</code> or arrow keys to focus a scene card</li> <li>Press <code>Enter</code> to open the scene detail page</li> <li>Press <code>Escape</code> to go back to the grid</li> </ol> <p>Quick actions on scene cards:</p> Key Action <code>Enter</code> Open scene detail page <code>P</code> Play scene immediately (when focused) <code>+</code> Add to playlist (opens playlist selector) <code>F</code> Toggle favorite (when supported)"},{"location":"user-guide/keyboard-navigation/#scene-detail-page","title":"Scene Detail Page","text":"<p>While viewing scene details:</p> Key Action <code>Space</code> or <code>Enter</code> Play video <code>Escape</code> Return to previous page <code>Tab</code> Navigate between action buttons"},{"location":"user-guide/keyboard-navigation/#video-player-controls","title":"Video Player Controls","text":""},{"location":"user-guide/keyboard-navigation/#playback-controls","title":"Playback Controls","text":"Key Action <code>Space</code> or <code>K</code> Play/Pause <code>\u2190</code> Seek backward 10 seconds <code>\u2192</code> Seek forward 10 seconds <code>Shift+\u2190</code> Seek backward 5 seconds <code>Shift+\u2192</code> Seek forward 5 seconds <code>Home</code> Jump to beginning <code>End</code> Jump to end <code>0-9</code> Jump to 0%-90% of video <p>Examples: - Press <code>5</code> to jump to 50% of the video - Press <code>0</code> to jump to the start - Press <code>9</code> to jump to 90%</p>"},{"location":"user-guide/keyboard-navigation/#volume-controls","title":"Volume Controls","text":"Key Action <code>\u2191</code> Increase volume <code>\u2193</code> Decrease volume <code>M</code> Mute/unmute"},{"location":"user-guide/keyboard-navigation/#display-controls","title":"Display Controls","text":"Key Action <code>F</code> Toggle fullscreen <code>Escape</code> Exit fullscreen <code>T</code> Toggle theater mode (when available)"},{"location":"user-guide/keyboard-navigation/#playlist-playback","title":"Playlist Playback","text":"<p>While playing a playlist:</p> Key Action <code>N</code> or <code>Shift+\u2192</code> Next scene in playlist <code>P</code> or <code>Shift+\u2190</code> Previous scene in playlist <code>S</code> Toggle shuffle <code>R</code> Cycle repeat mode (Off \u2192 All \u2192 One) <code>Escape</code> Exit playlist playback"},{"location":"user-guide/keyboard-navigation/#search-filtering","title":"Search &amp; Filtering","text":""},{"location":"user-guide/keyboard-navigation/#search-box","title":"Search Box","text":"Key Action <code>/</code> or <code>Ctrl+F</code> Focus search box (from anywhere) <code>Escape</code> Clear search and exit search box <code>Enter</code> Submit search / apply filters <code>\u2193</code> Move to search results (from search box)"},{"location":"user-guide/keyboard-navigation/#filter-controls","title":"Filter Controls","text":"<p>While using filters:</p> Key Action <code>Tab</code> Move between filter options <code>Space</code> Toggle checkbox filters <code>Enter</code> Apply filters <code>Escape</code> Close filter panel"},{"location":"user-guide/keyboard-navigation/#playlists","title":"Playlists","text":""},{"location":"user-guide/keyboard-navigation/#playlist-management","title":"Playlist Management","text":"Key Action <code>N</code> Create new playlist (when on Playlists page) <code>Enter</code> Open focused playlist <code>Delete</code> Delete focused playlist (with confirmation)"},{"location":"user-guide/keyboard-navigation/#editing-playlists","title":"Editing Playlists","text":"<p>In edit mode:</p> Key Action <code>Tab</code> Navigate between scenes <code>Delete</code> Remove focused scene from playlist <code>Escape</code> Exit edit mode <code>Enter</code> Save changes <p>Reordering scenes: - Use mouse drag-and-drop for reordering - Keyboard reordering not currently supported</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode","title":"TV Mode","text":""},{"location":"user-guide/keyboard-navigation/#what-is-tv-mode","title":"What is TV Mode?","text":"<p>TV Mode is Peek's interface optimized for TV remotes and couch browsing:</p> <ul> <li>Large Focus Indicators - Easy to see what's selected from across the room</li> <li>Remote-Friendly Navigation - Arrow keys and Enter are all you need</li> <li>Auto-Scroll - Page scrolls to keep focused element visible</li> <li>Simplified Controls - Reduced clutter, bigger buttons</li> </ul>"},{"location":"user-guide/keyboard-navigation/#using-peek-on-tv","title":"Using Peek on TV","text":"<p>Recommended setup:</p> <ol> <li>Connect a computer to your TV (HDMI)</li> <li>Access Peek via web browser on that computer</li> <li>Use a wireless keyboard or TV remote (with keyboard features)</li> <li>Navigate entirely with arrow keys and Enter</li> </ol> <p>Popular remote options: - Amazon Fire TV remote (with Alexa) - Android TV remote apps - Wireless keyboards (Logitech K400, etc.) - Smart TV keyboards - Game controllers (via browser support)</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode-tips","title":"TV Mode Tips","text":"<ol> <li>Use fullscreen browser mode (F11) for immersive experience</li> <li>Enable auto-hide cursor in your OS settings</li> <li>Increase font size in browser settings (Ctrl +)</li> <li>Use dark theme for better viewing in dark rooms</li> <li>Disable screen saver on your PC/TV</li> </ol>"},{"location":"user-guide/keyboard-navigation/#settings-navigation","title":"Settings Navigation","text":""},{"location":"user-guide/keyboard-navigation/#navigating-settings-pages","title":"Navigating Settings Pages","text":"Key Action <code>Tab</code> Move between settings sections <code>Enter</code> Open/edit focused setting <code>Space</code> Toggle switches and checkboxes <code>Escape</code> Cancel without saving"},{"location":"user-guide/keyboard-navigation/#saving-settings","title":"Saving Settings","text":"Key Action <code>Enter</code> Save changes (when focused on Save button) <code>Escape</code> Cancel changes"},{"location":"user-guide/keyboard-navigation/#modal-dialogs","title":"Modal Dialogs","text":""},{"location":"user-guide/keyboard-navigation/#dialog-controls","title":"Dialog Controls","text":"Key Action <code>Enter</code> Confirm action (OK, Save, Submit) <code>Escape</code> Cancel and close dialog <code>Tab</code> Navigate between dialog buttons <p>Examples: - Delete confirmation dialogs - Playlist selector - Add to playlist modal - Login form</p>"},{"location":"user-guide/keyboard-navigation/#accessibility-features","title":"Accessibility Features","text":""},{"location":"user-guide/keyboard-navigation/#focus-indicators","title":"Focus Indicators","text":"<p>Peek shows clear visual focus indicators:</p> <ul> <li>Blue outline around focused elements</li> <li>Highlighted cards when focused in grids</li> <li>Button highlights when focused</li> <li>Scale effect on focused scene cards</li> </ul>"},{"location":"user-guide/keyboard-navigation/#screen-reader-support","title":"Screen Reader Support","text":"<p>Basic screen reader support:</p> <ul> <li>Alt text on images</li> <li>ARIA labels on buttons and controls</li> <li>Semantic HTML for proper navigation</li> <li>Keyboard-accessible everything</li> </ul> <p>Screen Reader Support</p> <p>Screen reader support is improving but may not be perfect. Please report accessibility issues on GitHub.</p>"},{"location":"user-guide/keyboard-navigation/#customizing-keyboard-shortcuts","title":"Customizing Keyboard Shortcuts","text":"<p>Currently not customizable. Keyboard shortcuts are built-in and cannot be changed.</p> <p>Future enhancement: Custom keyboard shortcuts may be added in a future update.</p>"},{"location":"user-guide/keyboard-navigation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/keyboard-navigation/#keyboard-navigation-not-working","title":"Keyboard navigation not working","text":"<p>Solution: - Click anywhere in the browser window to focus it - Try pressing <code>Tab</code> to activate focus mode - Check if a modal or dialog is open (press <code>Escape</code>) - Disable browser extensions that may interfere - Try a different browser</p>"},{"location":"user-guide/keyboard-navigation/#focus-indicator-not-visible","title":"Focus indicator not visible","text":"<p>Solution: - Your browser theme may be hiding focus outlines - Try a different theme in Peek (Settings \u2192 My Settings) - Check browser zoom level (Ctrl + 0 to reset) - Report as a bug if it persists</p>"},{"location":"user-guide/keyboard-navigation/#arrow-keys-scroll-page-instead-of-navigating","title":"Arrow keys scroll page instead of navigating","text":"<p>Solution: - Click on the scene grid to focus it first - Use <code>Tab</code> to focus an element, then arrow keys work - Some areas use <code>Tab</code> navigation only</p>"},{"location":"user-guide/keyboard-navigation/#video-player-shortcuts-not-working","title":"Video player shortcuts not working","text":"<p>Solution: - Make sure video player is focused (click on it) - Some shortcuts only work during playback - Check if another app is intercepting keys - Try clicking the video before using shortcuts</p>"},{"location":"user-guide/keyboard-navigation/#tips-for-power-users","title":"Tips for Power Users","text":""},{"location":"user-guide/keyboard-navigation/#speed-navigation","title":"Speed Navigation","text":"<ol> <li>Use <code>/</code> to search instantly from any page</li> <li>Use number keys (0-9) to scrub through videos quickly</li> <li>Press <code>Escape</code> repeatedly to navigate back multiple levels</li> <li>Use <code>Tab + Enter</code> combo for rapid clicking</li> </ol>"},{"location":"user-guide/keyboard-navigation/#couch-potato-mode","title":"Couch Potato Mode","text":"<p>Perfect setup for couch browsing:</p> <ol> <li>Open Peek in fullscreen (F11)</li> <li>Create a \"Favorites\" playlist</li> <li>Start playlist playback</li> <li>Use only these keys:</li> <li><code>Space</code> - Play/Pause</li> <li><code>N</code> - Next video</li> <li><code>P</code> - Previous video</li> <li><code>\u2191/\u2193</code> - Volume</li> <li><code>F</code> - Fullscreen on/off</li> </ol>"},{"location":"user-guide/keyboard-navigation/#workflow-optimization","title":"Workflow Optimization","text":"<p>Browse and queue efficiently:</p> <ol> <li>Navigate scene grid with arrow keys</li> <li>Press <code>+</code> on scenes you want to watch</li> <li>Add all to \"Watch Later\" playlist</li> <li>Open playlist and press Play</li> <li>Lean back and enjoy</li> </ol>"},{"location":"user-guide/keyboard-navigation/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Playlists - Create and manage custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"},{"location":"user-guide/playlists/","title":"Playlists","text":"<p>Create and manage custom playlists to organize your favorite scenes.</p>"},{"location":"user-guide/playlists/#creating-a-playlist","title":"Creating a Playlist","text":"<ol> <li>Click Playlists in the navigation menu</li> <li>Click the Create Playlist button</li> <li>Enter a name for your playlist</li> <li>Optionally add a description</li> <li>Click Create</li> </ol> <p>Your new playlist is now ready to use!</p>"},{"location":"user-guide/playlists/#adding-scenes-to-playlists","title":"Adding Scenes to Playlists","text":"<p>There are two ways to add scenes to your playlists:</p>"},{"location":"user-guide/playlists/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Find a scene you want to add (on any page with scene cards)</li> <li>Click the + (plus) icon on the scene card</li> <li>Select the playlist you want to add it to</li> <li>The scene is added instantly!</li> </ol>"},{"location":"user-guide/playlists/#from-scene-detail-page","title":"From Scene Detail Page","text":"<ol> <li>Click on a scene to open its detail page</li> <li>Click the Add to Playlist button</li> <li>Select the playlist you want to add it to</li> <li>Done!</li> </ol> <p>Multiple Playlists</p> <p>You can add the same scene to multiple playlists. Great for organizing scenes by different themes or moods!</p>"},{"location":"user-guide/playlists/#managing-your-playlists","title":"Managing Your Playlists","text":""},{"location":"user-guide/playlists/#viewing-playlist-contents","title":"Viewing Playlist Contents","text":"<ol> <li>Click Playlists in the navigation</li> <li>Click on any playlist to see its scenes</li> <li>Scroll through to see all scenes in the playlist</li> </ol>"},{"location":"user-guide/playlists/#editing-playlist-details","title":"Editing Playlist Details","text":"<ol> <li>Open a playlist</li> <li>Click the Edit button (pencil icon)</li> <li>Change the name or description</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#reordering-scenes","title":"Reordering Scenes","text":"<p>Want to change the playback order?</p> <ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Drag and drop scenes to reorder them</li> <li>Click Save when done</li> </ol> <p>The playlist will play scenes in the order you've arranged them.</p>"},{"location":"user-guide/playlists/#removing-scenes","title":"Removing Scenes","text":"<ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Click the \u00d7 (remove) icon on any scene</li> <li>Confirm removal</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#deleting-a-playlist","title":"Deleting a Playlist","text":"<p>Permanent Action</p> <p>Deleting a playlist cannot be undone. The scenes themselves are not deleted, just the playlist.</p> <ol> <li>Open the playlist you want to delete</li> <li>Click the Delete button (trash icon)</li> <li>Confirm deletion</li> <li>The playlist is permanently removed</li> </ol>"},{"location":"user-guide/playlists/#playing-playlists","title":"Playing Playlists","text":""},{"location":"user-guide/playlists/#basic-playback","title":"Basic Playback","text":"<ol> <li>Open a playlist</li> <li>Click the Play button</li> <li>Playback starts with the first scene</li> <li>When a scene ends, the next scene plays automatically</li> </ol>"},{"location":"user-guide/playlists/#shuffle-mode","title":"Shuffle Mode","text":"<p>Randomize the playback order:</p> <ol> <li>Open a playlist</li> <li>Click the Shuffle button (shuffle icon)</li> <li>Playlist will play scenes in random order</li> <li>Click Shuffle again to turn it off</li> </ol> <p>Shuffle Tip</p> <p>Shuffle is perfect for long playlists when you want variety!</p>"},{"location":"user-guide/playlists/#repeat-modes","title":"Repeat Modes","text":"<p>Choose how playback repeats:</p> <p>Repeat Off (default) - Playlist plays once and stops</p> <p>Repeat All - When playlist ends, it starts over from the beginning - Continues until you stop it</p> <p>Repeat One - Current scene repeats continuously - Great for favorite scenes!</p> <p>To change repeat mode: 1. Open a playlist 2. Click the Repeat button 3. Click again to cycle through modes: Off \u2192 All \u2192 One \u2192 Off</p>"},{"location":"user-guide/playlists/#navigation-during-playback","title":"Navigation During Playback","text":"<p>While watching a playlist:</p> <ul> <li>Next Scene: Click the next button or press N</li> <li>Previous Scene: Click the previous button or press P</li> <li>Exit Playlist: Click the back button to return to browsing</li> </ul>"},{"location":"user-guide/playlists/#playlist-tips-tricks","title":"Playlist Tips &amp; Tricks","text":""},{"location":"user-guide/playlists/#organization-ideas","title":"Organization Ideas","text":"<ul> <li>By Performer: Create playlists for your favorite performers</li> <li>By Studio: Group scenes from specific studios</li> <li>By Theme: Organize by categories or tags</li> <li>Watch Later: Save scenes you want to watch later</li> <li>Best Of: Curate your absolute favorites</li> <li>Mood-Based: Create playlists for different moods or occasions</li> </ul>"},{"location":"user-guide/playlists/#quick-access","title":"Quick Access","text":"<p>Your playlists are always accessible from: - The Playlists page (shows all playlists) - Any scene's Add to Playlist menu - The + icon on scene cards</p>"},{"location":"user-guide/playlists/#playlist-size","title":"Playlist Size","text":"<p>There's no limit to how many: - Playlists you can create - Scenes you can add to a playlist - Playlists a single scene can be in</p>"},{"location":"user-guide/playlists/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/playlists/#scene-wont-add-to-playlist","title":"Scene won't add to playlist","text":"<ul> <li>Make sure you're logged in</li> <li>Check that the playlist still exists</li> <li>Try refreshing the page</li> </ul>"},{"location":"user-guide/playlists/#playlist-wont-play","title":"Playlist won't play","text":"<ul> <li>Verify the playlist has scenes in it</li> <li>Check that you can play individual scenes</li> <li>Make sure your path mappings are configured correctly</li> </ul>"},{"location":"user-guide/playlists/#changes-arent-saving","title":"Changes aren't saving","text":"<ul> <li>Make sure to click Save after editing</li> <li>Check your internet connection</li> <li>Try refreshing and making changes again</li> </ul>"},{"location":"user-guide/playlists/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Troubleshooting - Fix common issues</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/watch-history/","title":"Watch History &amp; Resume Playback","text":"<p>Peek automatically tracks your viewing progress and lets you resume playback exactly where you left off.</p>"},{"location":"user-guide/watch-history/#how-watch-history-works","title":"How Watch History Works","text":""},{"location":"user-guide/watch-history/#automatic-tracking","title":"Automatic Tracking","text":"<p>Peek tracks your progress automatically while you watch:</p> <ul> <li>Progress is saved every few seconds during playback</li> <li>No manual action needed - just watch normally</li> <li>Per-user tracking - each user has their own watch history</li> <li>Syncs across devices - resume on any device where you're logged in</li> </ul>"},{"location":"user-guide/watch-history/#what-gets-tracked","title":"What Gets Tracked","text":"<p>For each scene you watch, Peek remembers:</p> <ul> <li>Current position - Exact timestamp where you stopped</li> <li>Total progress - Percentage watched (e.g., 65% complete)</li> <li>Last watched date - When you last viewed this scene</li> <li>Watch count - How many times you've watched it</li> </ul>"},{"location":"user-guide/watch-history/#resume-playback","title":"Resume Playback","text":""},{"location":"user-guide/watch-history/#automatic-resume","title":"Automatic Resume","text":"<p>When you click Play on a scene you've partially watched:</p> <ol> <li>Video player opens</li> <li>You see a \"Resume from [timestamp]\" notification</li> <li>Player automatically jumps to where you left off</li> <li>Click \"Start from beginning\" if you prefer to restart</li> </ol> <p>Quick Resume</p> <p>The resume prompt appears for 5 seconds. If you do nothing, playback continues from your last position automatically!</p>"},{"location":"user-guide/watch-history/#from-scene-cards","title":"From Scene Cards","text":"<p>Scene cards show your progress visually:</p> <ul> <li>Progress bar at the bottom of the thumbnail</li> <li>Percentage indicator (e.g., \"65% watched\")</li> <li>Blue progress bar fills from left to right as you watch</li> </ul> <p>To resume from a scene card: 1. Find the scene (look for the progress bar) 2. Click Play 3. Playback resumes automatically</p>"},{"location":"user-guide/watch-history/#continue-watching","title":"Continue Watching","text":""},{"location":"user-guide/watch-history/#quick-access-to-in-progress-scenes","title":"Quick Access to In-Progress Scenes","text":"<p>The Continue Watching section shows all partially-watched scenes:</p> <p>Location: Home page (top section)</p> <p>What appears here: - Scenes you've started but not finished - Sorted by most recently watched - Shows progress percentage - Limited to your last 20 in-progress scenes</p> <p>To resume: 1. Go to Home page 2. Find the scene in Continue Watching 3. Click Play 4. Resumes from where you stopped</p> <p>Fast Resume</p> <p>Continue Watching is the fastest way to pick up where you left off!</p>"},{"location":"user-guide/watch-history/#when-scenes-disappear-from-continue-watching","title":"When Scenes Disappear from Continue Watching","text":"<p>A scene is removed from Continue Watching when: - You watch to completion (95%+ watched counts as complete) - You manually clear watch history for that scene - It falls outside your last 20 in-progress scenes</p>"},{"location":"user-guide/watch-history/#managing-watch-history","title":"Managing Watch History","text":""},{"location":"user-guide/watch-history/#viewing-your-history","title":"Viewing Your History","text":"<p>Full watch history coming in future update. Currently:</p> <ul> <li>View in-progress scenes via Continue Watching on home page</li> <li>See progress bars on scene cards throughout the app</li> <li>Check scene detail page for watch progress</li> </ul>"},{"location":"user-guide/watch-history/#marking-as-watched","title":"Marking as Watched","text":"<p>To mark a scene as fully watched without watching it:</p> <ol> <li>Open the scene detail page</li> <li>Seek to the end of the video (last 5%)</li> <li>Let it play for a few seconds</li> <li>Scene is marked as watched</li> </ol> <p>Or manually skip to 95%+ completion to trigger \"watched\" status.</p>"},{"location":"user-guide/watch-history/#clearing-watch-history","title":"Clearing Watch History","text":"<p>For a single scene:</p> <ol> <li>Open the scene detail page</li> <li>Click the \u22ee (three dots) menu</li> <li>Select \"Clear watch history\"</li> <li>Progress is reset to 0%</li> </ol> <p>For all scenes:</p> <ol> <li>Go to Settings \u2192 My Settings</li> <li>Scroll to Watch History section</li> <li>Click \"Clear all watch history\"</li> <li>Confirm the action</li> <li>All progress is reset</li> </ol> <p>Cannot Be Undone</p> <p>Clearing watch history is permanent. You cannot restore cleared progress.</p>"},{"location":"user-guide/watch-history/#privacy-data","title":"Privacy &amp; Data","text":""},{"location":"user-guide/watch-history/#whats-stored","title":"What's Stored","text":"<p>Watch history is stored in Peek's database:</p> <ul> <li>User ID - Associated with your account</li> <li>Scene ID - Which scene you watched</li> <li>Progress position - Timestamp (in seconds)</li> <li>Last watched date - When you last viewed it</li> <li>Watch count - Total number of views</li> </ul>"},{"location":"user-guide/watch-history/#whats-not-stored","title":"What's NOT Stored","text":"<ul> <li>No video file access logs - Peek doesn't log file system access</li> <li>No sharing with Stash - Watch history stays in Peek only</li> <li>No external tracking - History never leaves your Peek instance</li> </ul>"},{"location":"user-guide/watch-history/#privacy-controls","title":"Privacy Controls","text":"<ul> <li>Per-user isolation - You only see your own history</li> <li>Admin cannot see - Even admins can't view other users' watch history</li> <li>Clear anytime - You control your history data</li> </ul>"},{"location":"user-guide/watch-history/#watch-history-tips","title":"Watch History Tips","text":""},{"location":"user-guide/watch-history/#efficient-binge-watching","title":"Efficient Binge Watching","text":"<ol> <li>Start watching scenes you want to explore</li> <li>Switch between different scenes freely</li> <li>Return to Continue Watching to resume any of them</li> <li>No need to finish in one sitting</li> </ol>"},{"location":"user-guide/watch-history/#organize-with-playlists","title":"Organize with Playlists","text":"<p>Combine watch history with playlists:</p> <ol> <li>Create a \"To Watch\" playlist</li> <li>Add scenes you plan to watch later</li> <li>Watch them at your own pace</li> <li>Progress tracked automatically</li> <li>Resume from Continue Watching or the playlist</li> </ol>"},{"location":"user-guide/watch-history/#track-rewatches","title":"Track Rewatches","text":"<p>Want to rewatch a favorite scene?</p> <ol> <li>Click Play on an already-watched scene</li> <li>Choose \"Start from beginning\" when prompted</li> <li>Watch count increments</li> <li>New progress tracked</li> </ol>"},{"location":"user-guide/watch-history/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/watch-history/#resume-not-working","title":"Resume not working","text":"<p>Solution: - Make sure you're logged in (watch history is per-user) - Check that you watched for at least 10 seconds (minimum tracking threshold) - Verify you're using the same user account - Try refreshing the page</p>"},{"location":"user-guide/watch-history/#progress-bar-not-showing","title":"Progress bar not showing","text":"<p>Solution: - Progress may not appear if you only watched a few seconds - Progress bars require at least 5% completion to display - Try playing the video for longer - Clear browser cache if progress seems stuck</p>"},{"location":"user-guide/watch-history/#continue-watching-is-empty","title":"Continue Watching is empty","text":"<p>Possible reasons: - You haven't started watching any scenes yet - All your in-progress scenes are completed - You cleared your watch history - You're using a different user account</p>"},{"location":"user-guide/watch-history/#progress-resets-unexpectedly","title":"Progress resets unexpectedly","text":"<p>Solution: - Check if someone else cleared watch history (admin action) - Verify you're logged in (anonymous users don't save history) - Check browser console for errors (F12 \u2192 Console) - Report as a bug if it persists</p>"},{"location":"user-guide/watch-history/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>While watching a video:</p> Key Action <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>Space</code> Play/Pause <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>See the Keyboard Navigation Guide for complete shortcuts.</p>"},{"location":"user-guide/watch-history/#next-steps","title":"Next Steps","text":"<ul> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Organize scenes into custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"}]}