{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>A modern mobile-friendly web application for browsing and streaming your Stash media library with support for multiple users, playlists, recommendations, and custom per-user theme and browsing preferences.</p> <p>Get started quickly:</p> <ul> <li>Installation - Get up and running with Docker or unRAID</li> <li>Configuration - Connect Peek to your Stash server</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multiple Users - Create multiple users with different roles, filter what content and capabilities each user has, and securely allow external access if desired</li> <li>Video Streaming - Uses Stash's video streams directly, eliminating the need to duplicate Stash's excellent transcoding support</li> <li>Watch History Tracking - Automatic progress tracking and resume playback (Learn more)</li> <li>Playlist Management - Create, organize, and play custom playlists (Learn more)</li> <li>Modern Interface - Responsive React UI with theme support and user customizability</li> <li>Mobile Ready - Optimized for all devices</li> <li>Scalable Library - Should scale easily with any library size - looking at you, data hoarders</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Stash server with GraphQL API enabled and an API key configured (Settings \u2192 Security)</li> <li>Docker (or Docker on unRAID)</li> <li>Network access between Peek and Stash</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Peek uses a single-container architecture:</p> <ul> <li>Frontend: React 19 app served by nginx</li> <li>Backend: Node.js/Express API server (proxied through nginx)</li> <li>Database: SQLite (embedded, no separate container)</li> <li>Streaming: Proxied through Stash (no local transcoding)</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Issues</li> <li>Stash Community: Discord - #community-projects channel</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Built with Stash, React, Express, FFmpeg, and other amazing open source projects.</p>"},{"location":"audits/2026-01-17-documentation-audit/","title":"Documentation Audit - 2026-01-17","text":"<p>Audit of the mkdocs documentation site for unused files and accuracy issues.</p>"},{"location":"audits/2026-01-17-documentation-audit/#part-1-unused-files-not-in-mkdocsyml-navigation","title":"Part 1: Unused Files (Not in mkdocs.yml Navigation)","text":"<p>The following files exist in <code>docs/</code> but are not included in the mkdocs navigation. They won't appear on the GitHub Pages site.</p>"},{"location":"audits/2026-01-17-documentation-audit/#root-level","title":"Root Level","text":"<ul> <li><code>CHANGES_SINCE_3.1.1.md</code> - Changelog fragment, likely temporary</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#audits","title":"audits/","text":"<ul> <li><code>2026-01-04-security-audit-unauthenticated-routes.md</code></li> <li><code>2026-01-04-frontend-api-usage-audit.md</code></li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#design","title":"design/","text":"<ul> <li><code>cache-scalability-brainstorm.md</code></li> <li><code>cache-scalability-plan.md</code></li> <li><code>json-blob-elimination-plan.md</code></li> <li><code>scalability-audit-500k-scenes.md</code></li> <li><code>sqlite-cache-schema.md</code></li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#plans-97-files","title":"plans/ (97 files)","text":"<p>All files in <code>docs/plans/</code> are internal development documents not linked in navigation: - <code>2024-12-23-3.0-polish-design.md</code> - <code>2024-12-23-3.0-polish-plan.md</code> - <code>2024-12-29-lightbox-enhancements-design.md</code> - <code>2024-12-29-lightbox-enhancements-impl.md</code> - <code>2024-12-30-view-tracking-request-cancellation-design.md</code> - ... (92+ additional plan files) - <code>MULTI_INSTANCE_STASH.md</code> - <code>REELS_IMPLEMENTATION.md</code></p>"},{"location":"audits/2026-01-17-documentation-audit/#releases","title":"releases/","text":"<ul> <li><code>3.1.0-testing-checklist.md</code></li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#recommendation","title":"Recommendation","text":"<p>These are internal working documents (designs, plans, audits). Consider: 1. Moving them to a separate <code>docs-internal/</code> folder outside the mkdocs site 2. Or add a \"Developer Notes\" section linking to them if intended for public reference</p>"},{"location":"audits/2026-01-17-documentation-audit/#part-2-development-documentation-accuracy-issues","title":"Part 2: Development Documentation Accuracy Issues","text":""},{"location":"audits/2026-01-17-documentation-audit/#sync-architecturemd","title":"sync-architecture.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#missing-full-sync-on-schema-migration","title":"Missing: Full Sync on Schema Migration","text":"<p>Issue: Document doesn't mention that Full Sync is automatically triggered when database migrations are applied between versions.</p> <p>Current triggers listed (line 21-28): - Initial setup (first sync) - Manual \"Full Sync\" button in UI - Recovery from corrupted state</p> <p>Missing trigger:</p> <p>Full Sync is automatically triggered on server startup when database schema migrations are detected (e.g., upgrading from one version to another).</p> <p>Code reference: - <code>server/services/SyncScheduler.ts:217-231</code> - <code>performStartupSync()</code> checks <code>wereMigrationsApplied()</code> and triggers <code>fullSync()</code> - <code>server/initializers/database.ts:106-124</code> - Counts migrations before/after to detect new schema changes</p> <p>Suggested addition to \"Full Sync\" section: <pre><code>**Triggered by:**\n- Initial setup (first sync)\n- Manual \"Full Sync\" button in UI\n- Recovery from corrupted state\n- **Database schema migrations on startup** (automatic when upgrading versions)\n</code></pre></p>"},{"location":"audits/2026-01-17-documentation-audit/#technical-overviewmd","title":"technical-overview.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#outdated-service-files-section-lines-509-525","title":"Outdated: Service Files Section (lines 509-525)","text":"<p>Issue: The \"Implementation Notes\" section references services that no longer exist in the codebase.</p> <p>Documented services that don't exist: | Service | Status | |---------|--------| | <code>UserRestrictionService.ts</code> | Does not exist - functionality moved | | <code>EmptyEntityFilterService.ts</code> | Does not exist - functionality moved | | <code>FilteredEntityCacheService.ts</code> | Does not exist - functionality moved | | <code>StashCacheManager.ts</code> | Does not exist - replaced by <code>StashEntityService.ts</code> |</p> <p>Actual services in <code>server/services/</code>: | Service | Purpose | |---------|---------| | <code>StashEntityService.ts</code> | Replaces StashCacheManager - database queries for Stash entities | | <code>UserHiddenEntityService.ts</code> | CRUD for user hidden entities | | <code>ExclusionComputationService.ts</code> | Pre-computes and maintains UserExcludedEntity table | | <code>EntityExclusionHelper.ts</code> | Helper for exclusion logic | | <code>SceneQueryBuilder.ts</code> | SQL-based scene queries with exclusion JOINs | | <code>PerformerQueryBuilder.ts</code> | SQL-based performer queries | | <code>StudioQueryBuilder.ts</code> | SQL-based studio queries | | <code>TagQueryBuilder.ts</code> | SQL-based tag queries | | <code>GroupQueryBuilder.ts</code> | SQL-based group queries | | <code>GalleryQueryBuilder.ts</code> | SQL-based gallery queries | | <code>ImageQueryBuilder.ts</code> | SQL-based image queries | | <code>RecommendationScoringService.ts</code> | Recommendation algorithm | | <code>UserStatsService.ts</code> | User statistics | | <code>UserStatsAggregationService.ts</code> | User stats aggregation |</p> <p>The architecture has changed from:</p> <p>In-memory filtering (load all \u2192 filter in JS \u2192 paginate)</p> <p>To:</p> <p>SQL-based pre-computed exclusions (query with exclusion JOINs \u2192 return filtered results)</p> <p>The \"Proposed Architecture\" section (lines 299-402) describing <code>UserExcludedEntity</code> is now implemented, not proposed.</p>"},{"location":"audits/2026-01-17-documentation-audit/#document-version-outdated","title":"Document Version Outdated","text":"<ul> <li>Line 581: <code>*Document Version: 3.0*</code></li> <li>Line 582: <code>*Last Updated: 2025-01-02*</code></li> </ul> <p>Should be updated to reflect current state.</p>"},{"location":"audits/2026-01-17-documentation-audit/#local-setupmd","title":"local-setup.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#minor-no-issues-found","title":"Minor: No issues found","text":"<p>Document appears accurate for development setup.</p>"},{"location":"audits/2026-01-17-documentation-audit/#api-referencemd","title":"api-reference.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#minor-auto-generated-appears-current","title":"Minor: Auto-generated, appears current","text":"<p>Last updated: 2026-01-04 (line 4)</p>"},{"location":"audits/2026-01-17-documentation-audit/#regression-testingmd","title":"regression-testing.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#minor-version-mismatch","title":"Minor: Version mismatch","text":"<ul> <li>Line 755: <code>**Last Updated**: 2025-01-21 (Version 1.6.0)</code></li> <li>Current version is 3.x</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#part-3-getting-started-documentation-issues","title":"Part 3: Getting Started Documentation Issues","text":""},{"location":"audits/2026-01-17-documentation-audit/#installationmd-configurationmd","title":"installation.md &amp; configuration.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#missing-whisparr-port-conflict-warning","title":"Missing: Whisparr Port Conflict Warning","text":"<p>Issue: Peek defaults to port 6969, which is also Whisparr's default port. Users running both will have a conflict.</p> <p>Suggested addition to Port Configuration section in <code>installation.md</code> (after line 275):</p> <pre><code>!!! warning \"Port Conflict with Whisparr\"\n    Peek's default port (6969) is the same as Whisparr's default port. If you're running Whisparr, you'll need to change Peek's port:\n\n    ```bash\n    # Use a different port (e.g., 6970)\n    docker run -d \\\n      --name peek-stash-browser \\\n      -p 6970:80 \\  # Changed from 6969:80\n      ...\n    ```\n\nSources: [Whisparr FAQ | Servarr Wiki](https://wiki.servarr.com/whisparr/faq)\n</code></pre> <p>Similar note should be added to: - <code>configuration.md</code> - in the Docker Compose example - <code>quick-start.md</code> - if port is mentioned - <code>docker-basics.md</code> - in port mapping section</p>"},{"location":"audits/2026-01-17-documentation-audit/#summary","title":"Summary","text":"Category Issue Priority Unused files 100+ files not in nav (mostly plans/) Low - intentional internal docs sync-architecture.md Missing \"Full Sync on migration\" trigger High - users should know this technical-overview.md 4 services referenced don't exist High - misleading for contributors technical-overview.md \"Proposed\" architecture is now implemented Medium installation.md Missing Whisparr port conflict warning High - common user issue configuration.md Missing Whisparr port conflict warning High regression-testing.md Outdated version number Low"},{"location":"audits/2026-01-17-documentation-audit/#part-4-user-guide-documentation-issues","title":"Part 4: User Guide Documentation Issues","text":""},{"location":"audits/2026-01-17-documentation-audit/#recommendationsmd","title":"recommendations.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#incorrect-rating-threshold","title":"Incorrect: Rating Threshold","text":"<p>Issue: Documentation states \"7.0+\" rating threshold, but code uses 80 (on 0-100 scale, equivalent to 8.0 on 10-point scale).</p> <p>Documentation (lines 10, 12, 14):</p> <p>\"Highly-rated performers - Scenes with performers you've rated 7.0+\"</p> <p>Actual code (<code>server/services/RecommendationScoringService.ts:283-287</code>): <pre><code>ratedPerformers: performerRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\nratedStudios: studioRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\nratedTags: tagRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n</code></pre></p> <p>Fix: Change \"7.0+\" to \"80+\" (or \"4+ stars\" if using 5-star display)</p>"},{"location":"audits/2026-01-17-documentation-audit/#accurate-scoring-weights","title":"Accurate: Scoring Weights","text":"<p>The weight table (lines 93-101) is accurate: - Favorited performer: weight = 5 (High) \u2713 - Highly-rated performer: weight = 3 (Medium-High) \u2713 - Favorited studio: weight = 3 (Medium) \u2713 - Highly-rated studio: weight = 2 (Medium) \u2713 - Favorited tags: weight = 1.0 (Low-Medium) \u2713 - Highly-rated tags: weight = 0.5 (Low) \u2713</p>"},{"location":"audits/2026-01-17-documentation-audit/#keyboard-navigationmd","title":"keyboard-navigation.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#incorrect-arrow-key-seek-duration","title":"Incorrect: Arrow Key Seek Duration","text":"<p>Issue: Documentation says arrow keys seek 10 seconds, but code does 5 seconds.</p> <p>Documentation (lines 79-80):</p> <p><code>\u2190</code> | Seek backward 10 seconds <code>\u2192</code> | Seek forward 10 seconds</p> <p>Actual code (<code>client/src/hooks/useMediaKeys.js:94-101</code>): - Arrow keys seek 5 seconds, not 10</p> <p>Fix: Change \"10 seconds\" to \"5 seconds\"</p>"},{"location":"audits/2026-01-17-documentation-audit/#not-implemented-shiftarrow-seeking","title":"Not Implemented: Shift+Arrow Seeking","text":"<p>Issue: Documentation describes Shift+arrow for 5-second seeking, but this is not implemented.</p> <p>Documentation (lines 82-83):</p> <p><code>Shift+\u2190</code> | Seek backward 5 seconds <code>Shift+\u2192</code> | Seek forward 5 seconds</p> <p>Actual code: No Shift+arrow handling found in <code>useMediaKeys.js</code></p> <p>Fix: Remove these rows or implement the feature</p>"},{"location":"audits/2026-01-17-documentation-audit/#missing-jl-keys-for-10-second-jumps","title":"Missing: J/L Keys for 10-Second Jumps","text":"<p>Issue: J and L keys for 10-second seeking ARE implemented but NOT documented.</p> <p>Actual code (<code>client/src/hooks/useMediaKeys.js:75-88</code>): - <code>J</code> seeks backward 10 seconds - <code>L</code> seeks forward 10 seconds</p> <p>Fix: Add to documentation: | <code>J</code> | Seek backward 10 seconds | | <code>L</code> | Seek forward 10 seconds |</p>"},{"location":"audits/2026-01-17-documentation-audit/#imagesmd","title":"images.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#incomplete-slideshow-timer-options","title":"Incomplete: Slideshow Timer Options","text":"<p>Issue: Documentation lists 4 options but code has 5.</p> <p>Documentation (line 65):</p> <p>\"Click the clock icon to adjust slideshow duration (3, 5, 10, or 15 seconds).\"</p> <p>Actual code (<code>client/src/components/ui/Lightbox.jsx:550-554</code>): - 2 seconds (MISSING from docs) - 3 seconds \u2713 - 5 seconds \u2713 - 10 seconds \u2713 - 15 seconds \u2713</p> <p>Fix: Change to \"(2, 3, 5, 10, or 15 seconds)\"</p>"},{"location":"audits/2026-01-17-documentation-audit/#misleading-rating-hotkeys-in-lightbox","title":"Misleading: Rating Hotkeys in Lightbox","text":"<p>Issue: Documentation implies direct number key rating, but it requires pressing <code>R</code> first.</p> <p>Documentation (lines 71-73):</p> <p>\"Number keys 1-5: Set star rating (1-5 stars)\" \"0: Clear rating\" \"F key: Toggle favorite\"</p> <p>Actual code (<code>client/src/components/ui/Lightbox.jsx:373-378</code>): - Must press <code>R</code> first to enter rating mode - Then press <code>0-5</code> to set rating (maps to 0%, 20%, 40%, 60%, 80%, 100%)</p> <p>Fix: Update to: <pre><code>- **R key**: Enter rating mode, then:\n  - **1-5**: Set rating (1=20%, 2=40%, 3=60%, 4=80%, 5=100%)\n  - **0**: Clear rating\n</code></pre></p>"},{"location":"audits/2026-01-17-documentation-audit/#accurate-view-tracking","title":"Accurate: View Tracking","text":"<ul> <li>\"View count: Incremented after viewing for 3+ seconds\" \u2713</li> <li>Code confirms 3-second threshold (<code>Lightbox.jsx:341-371</code>)</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#watch-historymd","title":"watch-history.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#minor-seek-duration-inconsistency","title":"Minor: Seek Duration Inconsistency","text":"<p>Issue: Documentation says arrows seek 10 seconds, but actual is 5 seconds (same issue as keyboard-navigation.md).</p> <p>Documentation (lines 215-216):</p> <p><code>\u2190</code> | Seek backward 10s <code>\u2192</code> | Seek forward 10s</p> <p>Fix: Change to \"5s\" to match actual implementation</p>"},{"location":"audits/2026-01-17-documentation-audit/#custom-carouselsmd","title":"custom-carousels.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#accurate-all-limits","title":"Accurate: All Limits","text":"<ul> <li>\"Maximum of 15 custom carousels per user\" \u2713 (Code: <code>MAX_CAROUSELS_PER_USER = 15</code>)</li> <li>\"Each carousel displays up to 12 scenes\" \u2713 (Code: <code>CAROUSEL_SCENE_LIMIT = 12</code>)</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#playlistsmd","title":"playlists.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#accurate-no-issues-found","title":"Accurate: No Issues Found","text":"<p>Documentation appears accurate for playlist features.</p>"},{"location":"audits/2026-01-17-documentation-audit/#hidden-itemsmd","title":"hidden-items.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#accurate-no-issues-found_1","title":"Accurate: No Issues Found","text":"<p>Documentation appears accurate for hidden items features.</p>"},{"location":"audits/2026-01-17-documentation-audit/#external-playermd","title":"external-player.md","text":""},{"location":"audits/2026-01-17-documentation-audit/#accurate-no-issues-found_2","title":"Accurate: No Issues Found","text":"<p>Documentation appears accurate for external player features.</p>"},{"location":"audits/2026-01-17-documentation-audit/#summary-all-issues","title":"Summary - All Issues","text":"Category Document Issue Priority Development sync-architecture.md Missing \"Full Sync on migration\" trigger High Development technical-overview.md 4 services referenced don't exist High Development technical-overview.md \"Proposed\" architecture is now implemented Medium Development regression-testing.md Outdated version number (1.6.0 vs 3.x) Low Getting Started installation.md Missing Whisparr port conflict warning High Getting Started configuration.md Missing Whisparr port conflict warning High User Guide recommendations.md Rating threshold wrong (7.0+ vs 80/100) High User Guide keyboard-navigation.md Arrow keys seek 5s, not 10s High User Guide keyboard-navigation.md Shift+arrow seeking not implemented Medium User Guide keyboard-navigation.md J/L keys (10s seek) not documented Medium User Guide images.md Slideshow 2s option not documented Low User Guide images.md Rating requires R prefix (not documented) High User Guide watch-history.md Seek duration inconsistency (same as above) Medium Unused Files docs/ 100+ internal files not in nav Low"},{"location":"audits/2026-01-17-documentation-audit/#fixes-applied-2026-01-17","title":"Fixes Applied (2026-01-17)","text":""},{"location":"audits/2026-01-17-documentation-audit/#completed","title":"Completed","text":"<ul> <li> Deleted 9 unused files (audits/, design/, releases/, CHANGES_SINCE_3.1.1.md)</li> <li> sync-architecture.md - Added migration trigger to Full Sync section</li> <li> installation.md - Added Whisparr port conflict warning</li> <li> configuration.md - Added Whisparr port conflict warning</li> <li> recommendations.md - Fixed rating threshold (7.0+ \u2192 4+ stars)</li> <li> keyboard-navigation.md - Fixed arrow keys (10s \u2192 5s), added J/L keys, removed Shift+arrow</li> <li> images.md - Fixed rating hotkeys (R prefix), added 2s slideshow option</li> <li> watch-history.md - Fixed seek duration, added J/L keys</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#also-completed","title":"Also Completed","text":"<ul> <li> technical-overview.md - Rewrote service architecture section with current services and query builders</li> <li> regression-testing.md - Updated version number (1.6.0 \u2192 3.2)</li> </ul>"},{"location":"audits/2026-01-17-documentation-audit/#reference-section-fixes-2026-01-17","title":"Reference Section Fixes (2026-01-17)","text":"<ul> <li> faq.md - Added \"How does Peek sync with Stash?\" section for general users</li> <li> faq.md - Added \"What about TV Mode?\" section with work-in-progress warning</li> <li> keyboard-navigation.md - Added TV Mode work-in-progress warning at top</li> <li> keyboard-navigation.md - Rewrote TV Mode section with current limitations</li> </ul>"},{"location":"development/api-reference/","title":"API Reference","text":"<p>Auto-generated from TypeScript source files. Last updated: 2026-02-24</p>"},{"location":"development/api-reference/#contents","title":"Contents","text":"<ul> <li>Auth</li> <li>Setup</li> <li>Sync</li> <li>Exclusions</li> <li>User</li> <li>Playlists</li> <li>Carousels</li> <li>Watch History</li> <li>Image View History</li> <li>Ratings</li> <li>Custom Themes</li> <li>Library</li> <li>Clips</li> <li>Admin</li> <li>Downloads</li> <li>Groups</li> <li>Timeline</li> <li>User Stats</li> </ul>"},{"location":"development/api-reference/#auth","title":"Auth","text":"<p>Authentication endpoints for login, logout, and session management.</p>"},{"location":"development/api-reference/#setup","title":"Setup","text":"<p>Setup wizard endpoints for initial configuration.</p>"},{"location":"development/api-reference/#get-apisetupstatus","title":"GET /api/setup/status","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface GetSetupStatusResponse {\n  setupComplete: boolean;\n  hasUsers: boolean;\n  hasStashInstance: boolean;\n  userCount: number;\n  stashInstanceCount: number;\n}\n</code></pre> <p>Controller: <code>getSetupStatus</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#post-apisetupcreate-admin","title":"POST /api/setup/create-admin","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface CreateFirstAdminRequest {\n  username: string;\n  password: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateFirstAdminResponse {\n  success: true;\n  user: {\n  id: number;\n  username: string;\n  role: string;\n  createdAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>createFirstAdmin</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#post-apisetuptest-stash-connection","title":"POST /api/setup/test-stash-connection","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface TestStashConnectionRequest {\n  url: string;\n  apiKey: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface TestStashConnectionResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n  details?: string;\n  version?: string;\n}\n</code></pre> <p>Controller: <code>testStashConnection</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#post-apisetupcreate-stash-instance","title":"POST /api/setup/create-stash-instance","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface CreateFirstStashInstanceRequest {\n  name?: string;\n  url: string;\n  apiKey: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateFirstStashInstanceResponse {\n  success: true;\n  instance: {\n  id: string;\n  name: string;\n  url: string;\n  enabled: boolean;\n  createdAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>createFirstStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#post-apisetupreset","title":"POST /api/setup/reset","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface ResetSetupRequest {\n  confirm: \"RESET_SETUP\";\n}\n</code></pre> <p>Response:</p> <pre><code>interface ResetSetupResponse {\n  success: true;\n  message: string;\n  deleted: {\n  users: number;\n  stashInstances: number;\n};\n}\n</code></pre> <p>Controller: <code>resetSetup</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#get-apisetupstash-instance","title":"GET /api/setup/stash-instance","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface GetStashInstanceResponse {\n  instance: {\n  id: string;\n  name: string;\n  url: string;\n  enabled: boolean;\n  priority: number;\n  createdAt: Date;\n  updatedAt: Date;\n} | null;\n  instanceCount: number;\n}\n</code></pre> <p>Controller: <code>getStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#get-apisetupstash-instances","title":"GET /api/setup/stash-instances","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface GetAllStashInstancesResponse {\n  instances: StashInstanceData[];\n}\n</code></pre> <p>Controller: <code>getAllStashInstances</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#post-apisetupstash-instance","title":"POST /api/setup/stash-instance","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface CreateStashInstanceRequest {\n  name: string;\n  description?: string;\n  url: string;\n  apiKey: string;\n  enabled?: boolean;\n  priority?: number;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateStashInstanceResponse {\n  success: true;\n  instance: StashInstanceData;\n}\n</code></pre> <p>Controller: <code>createStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#put-apisetupstash-instanceid","title":"PUT /api/setup/stash-instance/:id","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface UpdateStashInstanceRequest {\n  name?: string;\n  description?: string;\n  url?: string;\n  apiKey?: string;\n  enabled?: boolean;\n  priority?: number;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdateStashInstanceParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdateStashInstanceResponse {\n  success: true;\n  instance: StashInstanceData;\n}\n</code></pre> <p>Controller: <code>updateStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#delete-apisetupstash-instanceid","title":"DELETE /api/setup/stash-instance/:id","text":"<p>Authentication: None</p> <p>URL Parameters:</p> <pre><code>interface DeleteStashInstanceParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeleteStashInstanceResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>deleteStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"development/api-reference/#sync","title":"Sync","text":"<p>Cache synchronization endpoints for refreshing Stash data.</p>"},{"location":"development/api-reference/#exclusions","title":"Exclusions","text":"<p>Content exclusion management endpoints.</p>"},{"location":"development/api-reference/#user","title":"User","text":"<p>User settings and preference endpoints.</p>"},{"location":"development/api-reference/#get-apiusersettings","title":"GET /api/user/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiusersettings","title":"PUT /api/user/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuserchange-password","title":"POST /api/user/change-password","text":"<p>Authentication: Required</p> <p>Controller: <code>changePassword</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserrecovery-key","title":"GET /api/user/recovery-key","text":"<p>Authentication: Required</p> <p>Controller: <code>getRecoveryKey</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuserrecovery-keyregenerate","title":"POST /api/user/recovery-key/regenerate","text":"<p>Authentication: Required</p> <p>Controller: <code>regenerateRecoveryKey</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiusersetup-status","title":"GET /api/user/setup-status","text":"<p>Authentication: Required</p> <p>Controller: <code>getSetupStatus</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiusercomplete-setup","title":"POST /api/user/complete-setup","text":"<p>Authentication: Required</p> <p>Controller: <code>completeSetup</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserfilter-presets","title":"GET /api/user/filter-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>getFilterPresets</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuserfilter-presets","title":"POST /api/user/filter-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>saveFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#delete-apiuserfilter-presetsartifacttypepresetid","title":"DELETE /api/user/filter-presets/:artifactType/:presetId","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserdefault-presets","title":"GET /api/user/default-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>getDefaultFilterPresets</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuserdefault-preset","title":"PUT /api/user/default-preset","text":"<p>Authentication: Required</p> <p>Controller: <code>setDefaultFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserpermissions","title":"GET /api/user/permissions","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserPermissions</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserall","title":"GET /api/user/all","text":"<p>Authentication: Required</p> <p>Controller: <code>getAllUsers</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiusercreate","title":"POST /api/user/create","text":"<p>Authentication: Required</p> <p>Controller: <code>createUser</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#delete-apiuseruserid","title":"DELETE /api/user/:userId","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteUser</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuseruseridrole","title":"PUT /api/user/:userId/role","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserRole</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuseruseridsettings","title":"PUT /api/user/:userId/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuseruseridsync-from-stash","title":"POST /api/user/:userId/sync-from-stash","text":"<p>Authentication: Required</p> <p>Controller: <code>syncFromStash</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuseruseridpermissions","title":"GET /api/user/:userId/permissions","text":"<p>Authentication: Required</p> <p>Controller: <code>getAnyUserPermissions</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuseruseridpermissions","title":"PUT /api/user/:userId/permissions","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserPermissionOverrides</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuseruseridgroups","title":"GET /api/user/:userId/groups","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserGroupMemberships</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuseruseridreset-password","title":"POST /api/user/:userId/reset-password","text":"<p>Authentication: Required</p> <p>Controller: <code>adminResetPassword</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuseruseridregenerate-recovery-key","title":"POST /api/user/:userId/regenerate-recovery-key","text":"<p>Authentication: Required</p> <p>Controller: <code>adminRegenerateRecoveryKey</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuseruseridrestrictions","title":"GET /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuseruseridrestrictions","title":"PUT /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#delete-apiuseruseridrestrictions","title":"DELETE /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuserhidden-entities","title":"POST /api/user/hidden-entities","text":"<p>Authentication: Required</p> <p>Controller: <code>hideEntity</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#post-apiuserhidden-entitiesbulk","title":"POST /api/user/hidden-entities/bulk","text":"<p>Authentication: Required</p> <p>Controller: <code>hideEntities</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#delete-apiuserhidden-entitiesall","title":"DELETE /api/user/hidden-entities/all","text":"<p>Authentication: Required</p> <p>Controller: <code>unhideAllEntities</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#delete-apiuserhidden-entitiesentitytypeentityid","title":"DELETE /api/user/hidden-entities/:entityType/:entityId","text":"<p>Authentication: Required</p> <p>Controller: <code>unhideEntity</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserhidden-entities","title":"GET /api/user/hidden-entities","text":"<p>Authentication: Required</p> <p>Controller: <code>getHiddenEntities</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserhidden-entitiesids","title":"GET /api/user/hidden-entities/ids","text":"<p>Authentication: Required</p> <p>Controller: <code>getHiddenEntityIds</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuserhide-confirmation","title":"PUT /api/user/hide-confirmation","text":"<p>Authentication: Required</p> <p>Controller: <code>updateHideConfirmation</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#get-apiuserstash-instances","title":"GET /api/user/stash-instances","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserStashInstances</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#put-apiuserstash-instances","title":"PUT /api/user/stash-instances","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserStashInstances</code> in <code>../controllers/user.ts</code></p>"},{"location":"development/api-reference/#playlists","title":"Playlists","text":"<p>Playlist management endpoints for creating and organizing scene collections.</p>"},{"location":"development/api-reference/#get-apiplaylistsshared","title":"GET /api/playlists/shared","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetSharedPlaylistsResponse {\n  playlists: SharedPlaylistData[];\n}\n</code></pre> <p>Controller: <code>getSharedPlaylists</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#get-apiplaylists","title":"GET /api/playlists/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserPlaylistsResponse {\n  playlists: PlaylistData[];\n}\n</code></pre> <p>Controller: <code>getUserPlaylists</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#get-apiplaylistsid","title":"GET /api/playlists/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetPlaylistResponse {\n  playlist: PlaylistData;\n  isOwner?: boolean;\n  accessLevel?: \"owner\" | \"shared\";\n  sharedViaGroups?: string[];\n}\n</code></pre> <p>Controller: <code>getPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#post-apiplaylists","title":"POST /api/playlists/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreatePlaylistRequest {\n  name: string;\n  description?: string;\n  isPublic?: boolean;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreatePlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>createPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#put-apiplaylistsid","title":"PUT /api/playlists/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdatePlaylistRequest {\n  name?: string;\n  description?: string;\n  isPublic?: boolean;\n  shuffle?: boolean;\n  repeat?: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdatePlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdatePlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>updatePlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#delete-apiplaylistsid","title":"DELETE /api/playlists/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeletePlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeletePlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>deletePlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#post-apiplaylistsiditems","title":"POST /api/playlists/:id/items","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface AddSceneToPlaylistRequest {\n  instanceId?: string;\n  sceneId: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface AddSceneToPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface AddSceneToPlaylistResponse {\n  item: {\n  id: number;\n  playlistId: number;\n  instanceId: string | null;\n  sceneId: string;\n  position: number;\n  addedAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>addSceneToPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#delete-apiplaylistsiditemssceneid","title":"DELETE /api/playlists/:id/items/:sceneId","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface RemoveSceneFromPlaylistParams {\n  id: string;\n  sceneId: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface RemoveSceneFromPlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>removeSceneFromPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#put-apiplaylistsidreorder","title":"PUT /api/playlists/:id/reorder","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface ReorderPlaylistRequest {\n  items: Array&lt;{\n  instanceId?: string;\n  sceneId: string;\n  position: number;\n}&gt;;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface ReorderPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface ReorderPlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>reorderPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#get-apiplaylistsidshares","title":"GET /api/playlists/:id/shares","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetPlaylistSharesResponse {\n  shares: PlaylistShareInfo[];\n}\n</code></pre> <p>Controller: <code>getPlaylistShares</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#put-apiplaylistsidshares","title":"PUT /api/playlists/:id/shares","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdatePlaylistSharesRequest {\n  groupIds: number[];\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface GetPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdatePlaylistSharesResponse {\n  shares: PlaylistShareInfo[];\n}\n</code></pre> <p>Controller: <code>updatePlaylistShares</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#post-apiplaylistsidduplicate","title":"POST /api/playlists/:id/duplicate","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DuplicatePlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>duplicatePlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"development/api-reference/#carousels","title":"Carousels","text":"<p>Custom carousel configuration endpoints.</p>"},{"location":"development/api-reference/#get-apicarousels","title":"GET /api/carousels/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserCarouselsResponse {\n  carousels: CarouselData[];\n}\n</code></pre> <p>Controller: <code>getUserCarousels</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#post-apicarouselspreview","title":"POST /api/carousels/preview","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface PreviewCarouselRequest {\n  rules: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface PreviewCarouselResponse {\n  scenes: NormalizedScene[];\n}\n</code></pre> <p>Controller: <code>previewCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#get-apicarouselsid","title":"GET /api/carousels/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>getCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#get-apicarouselsidexecute","title":"GET /api/carousels/:id/execute","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface ExecuteCarouselByIdParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface ExecuteCarouselByIdResponse {\n  carousel: {\n  id: string;\n  title: string;\n  icon: string;\n};\n  scenes: NormalizedScene[];\n}\n</code></pre> <p>Controller: <code>executeCarouselById</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#post-apicarousels","title":"POST /api/carousels/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreateCarouselRequest {\n  title: string;\n  icon?: string;\n  rules: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>createCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#put-apicarouselsid","title":"PUT /api/carousels/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdateCarouselRequest {\n  title?: string;\n  icon?: string;\n  rules?: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdateCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdateCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>updateCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#delete-apicarouselsid","title":"DELETE /api/carousels/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeleteCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeleteCarouselResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>deleteCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"development/api-reference/#watch-history","title":"Watch History","text":"<p>Watch history tracking endpoints.</p>"},{"location":"development/api-reference/#post-apiwatch-historyping","title":"POST /api/watch-history/ping","text":"<p>Authentication: Required</p> <p>Controller: <code>pingWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#post-apiwatch-historysave-activity","title":"POST /api/watch-history/save-activity","text":"<p>Authentication: Required</p> <p>Controller: <code>saveActivity</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#post-apiwatch-historyincrement-play-count","title":"POST /api/watch-history/increment-play-count","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementPlayCount</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#post-apiwatch-historyincrement-o","title":"POST /api/watch-history/increment-o","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementOCounter</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#get-apiwatch-history","title":"GET /api/watch-history/","text":"<p>Authentication: Required</p> <p>Controller: <code>getAllWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#delete-apiwatch-history","title":"DELETE /api/watch-history/","text":"<p>Authentication: Required</p> <p>Controller: <code>clearAllWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#get-apiwatch-historysceneid","title":"GET /api/watch-history/:sceneId","text":"<p>Authentication: Required</p> <p>Controller: <code>getWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"development/api-reference/#image-view-history","title":"Image View History","text":"<p>Image view history tracking endpoints.</p>"},{"location":"development/api-reference/#post-apiimage-view-historyincrement-o","title":"POST /api/image-view-history/increment-o","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementImageOCounter</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"development/api-reference/#post-apiimage-view-historyview","title":"POST /api/image-view-history/view","text":"<p>Authentication: Required</p> <p>Controller: <code>recordImageView</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"development/api-reference/#get-apiimage-view-historyimageid","title":"GET /api/image-view-history/:imageId","text":"<p>Authentication: Required</p> <p>Controller: <code>getImageViewHistory</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"development/api-reference/#ratings","title":"Ratings","text":"<p>Rating and favorite management endpoints.</p>"},{"location":"development/api-reference/#put-apiratingsscenesceneid","title":"PUT /api/ratings/scene/:sceneId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateSceneRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingsperformerperformerid","title":"PUT /api/ratings/performer/:performerId","text":"<p>Authentication: Required</p> <p>Controller: <code>updatePerformerRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingsstudiostudioid","title":"PUT /api/ratings/studio/:studioId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateStudioRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingstagtagid","title":"PUT /api/ratings/tag/:tagId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateTagRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingsgallerygalleryid","title":"PUT /api/ratings/gallery/:galleryId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateGalleryRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingsgroupgroupid","title":"PUT /api/ratings/group/:groupId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateGroupRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#put-apiratingsimageimageid","title":"PUT /api/ratings/image/:imageId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateImageRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"development/api-reference/#custom-themes","title":"Custom Themes","text":"<p>Custom theme management endpoints.</p>"},{"location":"development/api-reference/#get-apithemescustom","title":"GET /api/themes/custom/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserCustomThemesResponse {\n  themes: CustomThemeData[];\n}\n</code></pre> <p>Controller: <code>getUserCustomThemes</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#get-apithemescustomid","title":"GET /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>getCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#post-apithemescustom","title":"POST /api/themes/custom/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreateCustomThemeRequest {\n  name: string;\n  config: ThemeConfig;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>createCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#put-apithemescustomid","title":"PUT /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdateCustomThemeRequest {\n  name?: string;\n  config?: ThemeConfig;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdateCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>updateCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#delete-apithemescustomid","title":"DELETE /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeleteCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeleteCustomThemeResponse {\n  success: true;\n}\n</code></pre> <p>Controller: <code>deleteCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#post-apithemescustomidduplicate","title":"POST /api/themes/custom/:id/duplicate","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DuplicateCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DuplicateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>duplicateCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"development/api-reference/#library","title":"Library","text":"<p>Library browsing endpoints for scenes, performers, studios, tags, groups, galleries, and images.</p>"},{"location":"development/api-reference/#post-apilibrarygalleries","title":"POST /api/library/galleries","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleries</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarygalleriesminimal","title":"POST /api/library/galleries/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleriesMinimal</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"development/api-reference/#get-apilibrarygalleriesid","title":"GET /api/library/galleries/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleryById</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"development/api-reference/#get-apilibrarygalleriesgalleryidimages","title":"GET /api/library/galleries/:galleryId/images","text":"<p>Authentication: Required</p> <p>Controller: <code>getGalleryImages</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarygroups","title":"POST /api/library/groups","text":"<p>Authentication: Required</p> <p>Controller: <code>findGroups</code> in <code>../../controllers/library/groups.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarygroupsminimal","title":"POST /api/library/groups/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findGroupsMinimal</code> in <code>../../controllers/library/groups.ts</code></p>"},{"location":"development/api-reference/#post-apilibraryimages","title":"POST /api/library/images","text":"<p>Authentication: Required</p> <p>Controller: <code>findImages</code> in <code>../../controllers/library/images.ts</code></p>"},{"location":"development/api-reference/#get-apilibraryimagesid","title":"GET /api/library/images/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>findImageById</code> in <code>../../controllers/library/images.ts</code></p>"},{"location":"development/api-reference/#post-apilibraryperformers","title":"POST /api/library/performers","text":"<p>Authentication: Required</p> <p>Controller: <code>findPerformers</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"development/api-reference/#post-apilibraryperformersminimal","title":"POST /api/library/performers/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findPerformersMinimal</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"development/api-reference/#put-apilibraryperformersid","title":"PUT /api/library/performers/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updatePerformer</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"development/api-reference/#post-apilibraryscenes","title":"POST /api/library/scenes","text":"<p>Authentication: Required</p> <p>Controller: <code>findScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"development/api-reference/#get-apilibraryscenesidsimilar","title":"GET /api/library/scenes/:id/similar","text":"<p>Authentication: Required</p> <p>Controller: <code>findSimilarScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"development/api-reference/#get-apilibraryscenesrecommended","title":"GET /api/library/scenes/recommended","text":"<p>Authentication: Required</p> <p>Controller: <code>getRecommendedScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"development/api-reference/#put-apilibraryscenesid","title":"PUT /api/library/scenes/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateScene</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarystudios","title":"POST /api/library/studios","text":"<p>Authentication: Required</p> <p>Controller: <code>findStudios</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarystudiosminimal","title":"POST /api/library/studios/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findStudiosMinimal</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"development/api-reference/#put-apilibrarystudiosid","title":"PUT /api/library/studios/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateStudio</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarytags","title":"POST /api/library/tags","text":"<p>Authentication: Required</p> <p>Controller: <code>findTags</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarytagsminimal","title":"POST /api/library/tags/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findTagsMinimal</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"development/api-reference/#post-apilibrarytagsfor-scenes","title":"POST /api/library/tags/for-scenes","text":"<p>Authentication: Required</p> <p>Controller: <code>findTagsForScenes</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"development/api-reference/#put-apilibrarytagsid","title":"PUT /api/library/tags/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateTag</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"development/api-reference/#clips","title":"Clips","text":""},{"location":"development/api-reference/#get-apiclips","title":"GET /api/clips/","text":"<p>Authentication: Required</p> <p>Controller: <code>getClips</code> in <code>../controllers/clips.ts</code></p>"},{"location":"development/api-reference/#get-apiclipsid","title":"GET /api/clips/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>getClipById</code> in <code>../controllers/clips.ts</code></p>"},{"location":"development/api-reference/#admin","title":"Admin","text":""},{"location":"development/api-reference/#downloads","title":"Downloads","text":""},{"location":"development/api-reference/#get-apidownloads","title":"GET /api/downloads/","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserDownloads</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#get-apidownloadsid","title":"GET /api/downloads/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>getDownloadStatus</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#get-apidownloadsidfile","title":"GET /api/downloads/:id/file","text":"<p>Authentication: Required</p> <p>Controller: <code>getDownloadFile</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#post-apidownloadsscenesceneid","title":"POST /api/downloads/scene/:sceneId","text":"<p>Authentication: Required</p> <p>Controller: <code>startSceneDownload</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#post-apidownloadsimageimageid","title":"POST /api/downloads/image/:imageId","text":"<p>Authentication: Required</p> <p>Controller: <code>startImageDownload</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#post-apidownloadsplaylistplaylistid","title":"POST /api/downloads/playlist/:playlistId","text":"<p>Authentication: Required</p> <p>Controller: <code>startPlaylistDownload</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#delete-apidownloadsid","title":"DELETE /api/downloads/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteDownload</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#post-apidownloadsidretry","title":"POST /api/downloads/:id/retry","text":"<p>Authentication: Required</p> <p>Controller: <code>retryDownload</code> in <code>../controllers/download.ts</code></p>"},{"location":"development/api-reference/#groups","title":"Groups","text":""},{"location":"development/api-reference/#get-apigroupsusermine","title":"GET /api/groups/user/mine","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserGroups</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#get-apigroups","title":"GET /api/groups/","text":"<p>Authentication: Required</p> <p>Controller: <code>getAllGroups</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#get-apigroupsid","title":"GET /api/groups/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>getGroup</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#post-apigroups","title":"POST /api/groups/","text":"<p>Authentication: Required</p> <p>Controller: <code>createGroup</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#put-apigroupsid","title":"PUT /api/groups/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateGroup</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#delete-apigroupsid","title":"DELETE /api/groups/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteGroup</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#post-apigroupsidmembers","title":"POST /api/groups/:id/members","text":"<p>Authentication: Required</p> <p>Controller: <code>addMember</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#delete-apigroupsidmembersuserid","title":"DELETE /api/groups/:id/members/:userId","text":"<p>Authentication: Required</p> <p>Controller: <code>removeMember</code> in <code>../controllers/groups.ts</code></p>"},{"location":"development/api-reference/#timeline","title":"Timeline","text":""},{"location":"development/api-reference/#get-apitimelineentitytypedistribution","title":"GET /api/timeline/:entityType/distribution","text":"<p>Authentication: Required</p> <p>Controller: <code>getDateDistribution</code> in <code>../controllers/timelineController.ts</code></p>"},{"location":"development/api-reference/#user-stats","title":"User Stats","text":""},{"location":"development/api-reference/#get-apiuser-stats","title":"GET /api/user-stats/","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserStats</code> in <code>../controllers/userStats.ts</code></p>"},{"location":"development/local-setup/","title":"Local Development Setup","text":"<p>This guide covers setting up Peek for local development with hot reloading and debugging capabilities.</p>"},{"location":"development/local-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ (20+ recommended)</li> <li>Docker and Docker Compose</li> <li>Git</li> <li>A running Stash server with GraphQL API enabled</li> </ul>"},{"location":"development/local-setup/#quick-start-docker-compose","title":"Quick Start (Docker Compose)","text":"<p>The fastest way to get a development environment running:</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\n</code></pre> </li> <li> <p>Set up environment:</p> <pre><code>cp .env.example .env\n</code></pre> </li> <li> <p>Configure <code>.env</code>:</p> <pre><code>JWT_SECRET=your-dev-secret-here\nDATABASE_URL=file:./data/peek-stash-browser.db\n</code></pre> </li> <li> <p>Start the development stack:</p> <pre><code>docker-compose up -d\n</code></pre> </li> <li> <p>Access the app: Open <code>http://localhost:6969</code></p> </li> <li> <p>Complete the Setup Wizard to connect to your Stash server</p> </li> </ol>"},{"location":"development/local-setup/#development-ports","title":"Development Ports","text":"Port Service Description <code>6969</code> Frontend UI Vite dev server with hot reloading <code>8000</code> Backend API Express server (internal Docker network)"},{"location":"development/local-setup/#native-development-without-docker","title":"Native Development (Without Docker)","text":"<p>For faster iteration and debugging, you can run the frontend and backend natively.</p>"},{"location":"development/local-setup/#backend-setup","title":"Backend Setup","text":"<pre><code>cd server\nnpm install\nnpx prisma generate\nnpx prisma migrate dev\nnpm run dev\n</code></pre> <p>The backend runs on <code>http://localhost:8000</code>.</p>"},{"location":"development/local-setup/#frontend-setup","title":"Frontend Setup","text":"<pre><code>cd client\nnpm install\nnpm run dev\n</code></pre> <p>The frontend runs on <code>http://localhost:6969</code> with hot module replacement (HMR).</p>"},{"location":"development/local-setup/#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in the <code>server/</code> directory:</p> <pre><code># Required\nJWT_SECRET=dev-secret-change-in-production\nDATABASE_URL=file:./data/peek-db.db\n\n# Optional\nNODE_ENV=development\nLOG_LEVEL=debug\n</code></pre>"},{"location":"development/local-setup/#database-management","title":"Database Management","text":"<p>Peek uses SQLite with Prisma ORM.</p>"},{"location":"development/local-setup/#view-database","title":"View Database","text":"<pre><code>cd server\nnpx prisma studio\n</code></pre> <p>Opens a web UI at <code>http://localhost:5555</code> to browse and edit data.</p>"},{"location":"development/local-setup/#reset-database","title":"Reset Database","text":"<pre><code>cd server\nrm -rf data/peek-db.db\nnpx prisma migrate dev\n</code></pre>"},{"location":"development/local-setup/#generate-prisma-client","title":"Generate Prisma Client","text":"<p>After schema changes:</p> <pre><code>cd server\nnpx prisma generate\n</code></pre>"},{"location":"development/local-setup/#create-migration","title":"Create Migration","text":"<p>After modifying <code>prisma/schema.prisma</code>:</p> <pre><code>cd server\nnpx prisma migrate dev --name your_migration_name\n</code></pre>"},{"location":"development/local-setup/#testing","title":"Testing","text":""},{"location":"development/local-setup/#run-backend-tests","title":"Run Backend Tests","text":"<pre><code>cd server\nnpm test\n</code></pre>"},{"location":"development/local-setup/#run-frontend-tests","title":"Run Frontend Tests","text":"<pre><code>cd client\nnpm test\n</code></pre>"},{"location":"development/local-setup/#integration-tests","title":"Integration Tests","text":"<p>Integration tests require a running Stash server. See the Regression Testing Guide for details.</p>"},{"location":"development/local-setup/#debugging","title":"Debugging","text":""},{"location":"development/local-setup/#backend-debugging-vs-code","title":"Backend Debugging (VS Code)","text":"<p>Add to <code>.vscode/launch.json</code>:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Backend\",\n      \"skipFiles\": [\"&lt;node_internals&gt;/**\"],\n      \"cwd\": \"${workspaceFolder}/server\",\n      \"runtimeExecutable\": \"npm\",\n      \"runtimeArgs\": [\"run\", \"dev\"],\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n</code></pre>"},{"location":"development/local-setup/#frontend-debugging","title":"Frontend Debugging","text":"<p>Use browser DevTools (F12). The Vite dev server provides source maps for debugging TypeScript/React code.</p>"},{"location":"development/local-setup/#view-logs","title":"View Logs","text":"<pre><code># Docker Compose logs\ndocker-compose logs -f\n\n# Backend only\ndocker-compose logs -f peek-server\n\n# Frontend only\ndocker-compose logs -f peek-client\n</code></pre>"},{"location":"development/local-setup/#code-style","title":"Code Style","text":"<p>The project uses ESLint and Prettier for code formatting.</p>"},{"location":"development/local-setup/#format-code","title":"Format Code","text":"<pre><code># Root (runs on all packages)\nnpm run format\n\n# Or in specific directory\ncd client &amp;&amp; npm run format\ncd server &amp;&amp; npm run format\n</code></pre>"},{"location":"development/local-setup/#lint-check","title":"Lint Check","text":"<pre><code>npm run lint\n</code></pre>"},{"location":"development/local-setup/#building-for-production","title":"Building for Production","text":""},{"location":"development/local-setup/#build-docker-image","title":"Build Docker Image","text":"<pre><code>docker build -t peek-stash-browser:local .\n</code></pre>"},{"location":"development/local-setup/#test-production-build-locally","title":"Test Production Build Locally","text":"<pre><code>docker run -d \\\n  --name peek-local-test \\\n  -p 6969:80 \\\n  -v peek-test-data:/app/data \\\n  -e JWT_SECRET=test-secret \\\n  peek-stash-browser:local\n</code></pre>"},{"location":"development/local-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/local-setup/#port-already-in-use","title":"Port Already in Use","text":"<pre><code># Find process using port 6969\nlsof -i :6969\n\n# Kill it\nkill -9 &lt;PID&gt;\n</code></pre>"},{"location":"development/local-setup/#prisma-client-out-of-sync","title":"Prisma Client Out of Sync","text":"<pre><code>cd server\nnpx prisma generate\n</code></pre>"},{"location":"development/local-setup/#docker-compose-issues","title":"Docker Compose Issues","text":"<pre><code># Rebuild containers\ndocker-compose down\ndocker-compose build --no-cache\ndocker-compose up -d\n</code></pre>"},{"location":"development/local-setup/#clear-node-modules","title":"Clear Node Modules","text":"<pre><code>rm -rf node_modules client/node_modules server/node_modules\nnpm install\ncd client &amp;&amp; npm install\ncd ../server &amp;&amp; npm install\n</code></pre>"},{"location":"development/local-setup/#next-steps","title":"Next Steps","text":"<ul> <li>Technical Overview - Understand the architecture</li> <li>Sync Architecture - How Stash sync works</li> <li>API Reference - Backend API documentation</li> </ul>"},{"location":"development/regression-testing/","title":"Regression Testing Guide","text":"<p>This guide provides comprehensive regression testing procedures for Peek Stash Browser. Use this checklist before releasing new versions to ensure core functionality remains stable.</p> <p>Report Inaccuracies</p> <p>If you find any errors, outdated information, or inaccurate testing steps in this document, please report them via GitHub Issues with the label <code>documentation</code>. This helps keep the testing guide accurate and useful for everyone.</p>"},{"location":"development/regression-testing/#testing-environment-setup","title":"Testing Environment Setup","text":"<p>Before beginning regression testing:</p> <ol> <li>Test Data: Ensure your Stash library has:</li> <li>Multiple scenes with various file formats (MP4, MKV, etc.)</li> <li>Scenes with different durations (short &lt;5min, medium 5-30min, long &gt;30min)</li> <li>Multiple performers, studios, tags</li> <li>At least one gallery and one group/movie</li> <li>Network Conditions: Test on stable network connection</li> <li>Browsers: Test on at least two browsers (Chrome/Edge and Firefox recommended)</li> <li>Clean State: Clear browser cache and cookies before testing critical flows</li> </ol>"},{"location":"development/regression-testing/#test-execution-guidelines","title":"Test Execution Guidelines","text":"<ul> <li>Mark Pass/Fail: Check off tests as you complete them</li> <li>Document Failures: Note version, browser, and steps to reproduce any failures</li> <li>Severity Levels:</li> <li>Critical: Blocks core functionality (video playback, login, etc.)</li> <li>High: Major feature broken (search, playlists, filtering)</li> <li>Medium: Feature degraded but usable</li> <li>Low: Minor UI/UX issue</li> </ul>"},{"location":"development/regression-testing/#core-feature-tests","title":"Core Feature Tests","text":""},{"location":"development/regression-testing/#1-authentication-user-management","title":"1. Authentication &amp; User Management","text":""},{"location":"development/regression-testing/#11-first-time-setup","title":"1.1 First-Time Setup","text":"<p>Precondition: Fresh installation with no existing database</p> <ul> <li> Setup wizard appears on first access</li> <li> Can configure path mappings successfully</li> <li> Path mappings are validated (invalid paths show error)</li> <li> Default admin user is created</li> <li> After setup, redirects to login page</li> </ul>"},{"location":"development/regression-testing/#12-login-flow","title":"1.2 Login Flow","text":"<ul> <li> Can log in with valid credentials</li> <li> Invalid credentials show error message</li> <li> Session persists after page refresh</li> <li> JWT token expires after 24 hours (requires waiting or manual token expiry)</li> <li> Expired token redirects to login page</li> </ul>"},{"location":"development/regression-testing/#13-user-preferences","title":"1.3 User Preferences","text":"<p>Precondition: Logged in as any user</p> <ul> <li> Settings page loads without errors</li> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Preferences persist after logout/login</li> <li> Preferences apply immediately (theme change, etc.)</li> </ul>"},{"location":"development/regression-testing/#14-user-management-admin-only","title":"1.4 User Management (Admin Only)","text":"<p>Precondition: Logged in as admin user</p> <ul> <li> Can view list of all users</li> <li> Can create new user (Admin or User role)</li> <li> Can delete non-admin users</li> <li> Cannot delete own admin account</li> <li> Can change user passwords</li> <li> Can toggle user roles (Admin \u2194 User)</li> </ul>"},{"location":"development/regression-testing/#2-video-playback","title":"2. Video Playback","text":""},{"location":"development/regression-testing/#21-direct-playback-no-transcoding","title":"2.1 Direct Playback (No Transcoding)","text":"<p>Precondition: Select quality \"Direct\" in video player</p> <ul> <li> Video starts playing within 3 seconds</li> <li> Playback is smooth (no stuttering)</li> <li> Audio syncs with video</li> <li> Can pause and resume</li> <li> Can seek to different timestamps (beginning, middle, end)</li> <li> Volume control works</li> <li> Fullscreen toggle works</li> <li> Player shows correct duration</li> <li> Timeline/scrubber reflects current position</li> </ul>"},{"location":"development/regression-testing/#22-transcoded-playback-hls","title":"2.2 Transcoded Playback (HLS)","text":"<p>Precondition: Select quality \"720p\" or lower in video player</p> <ul> <li> HLS stream starts within 5 seconds</li> <li> Quality selector shows available qualities (360p, 480p, 720p, 1080p)</li> <li> Can switch between qualities mid-playback</li> <li> Playback resumes at same position after quality change</li> <li> Seeking works correctly (forward and backward)</li> <li> Far seeks (&gt;2 minutes ahead) restart transcoding session properly</li> <li> Segments load progressively (check Network tab)</li> <li> No missing segments or 404 errors</li> <li> Transcoding session cleans up after 90 seconds of inactivity</li> </ul> <p>Test Scenarios:</p> <ul> <li> Short video (&lt;5min): Plays from start to finish without errors</li> <li> Long video (&gt;30min): Can seek to middle and end without issues</li> <li> Multiple quality switches: Switch between 360p \u2192 720p \u2192 480p during playback</li> <li> Rapid seeking: Seek multiple times in quick succession (shouldn't crash)</li> </ul>"},{"location":"development/regression-testing/#23-resume-playback","title":"2.3 Resume Playback","text":"<p>Precondition: Previously watched a scene partially (not to completion)</p> <ul> <li> Scene shows resume position indicator (progress bar on thumbnail)</li> <li> Clicking scene shows \"Resume\" and \"Restart\" options</li> <li> \"Resume\" starts playback at last position (within 5 seconds accuracy)</li> <li> \"Restart\" starts playback at 0:00</li> <li> Resume position updates as video plays</li> <li> Watching to completion clears resume position</li> </ul>"},{"location":"development/regression-testing/#24-watch-history-tracking","title":"2.4 Watch History Tracking","text":"<ul> <li> Play count increments after watching</li> <li> Play duration accumulates correctly</li> <li> O-counter increments when marking scenes</li> <li> Last played timestamp updates</li> <li> Watch history appears in \"Recently Watched\" carousel (if implemented)</li> <li> Watch history persists across sessions</li> </ul>"},{"location":"development/regression-testing/#3-scene-search-filtering-and-sorting","title":"3. Scene Search, Filtering, and Sorting","text":""},{"location":"development/regression-testing/#31-search-functionality","title":"3.1 Search Functionality","text":"<p>Location: Scenes page, search bar at top</p> <ul> <li> Typing in search bar shows results in real-time</li> <li> Search matches scene titles</li> <li> Search matches performer names</li> <li> Search matches studio names</li> <li> Search matches tag names</li> <li> Empty search shows all scenes</li> <li> Search results update immediately (&lt;500ms)</li> <li> Clearing search resets to full library</li> </ul>"},{"location":"development/regression-testing/#32-filtering","title":"3.2 Filtering","text":"<p>Location: Scenes page, filter panel (sidebar or modal)</p>"},{"location":"development/regression-testing/#basic-filters","title":"Basic Filters","text":"<ul> <li> Filter by performer (single selection)</li> <li> Filter by multiple performers (AND logic)</li> <li> Filter by studio (single selection)</li> <li> Filter by tag (single selection)</li> <li> Filter by multiple tags (AND/OR logic based on settings)</li> <li> Filter by rating (min/max range)</li> <li> Filter by organized status (Yes/No/All)</li> <li> Filter by O-counter value (min/max range)</li> </ul>"},{"location":"development/regression-testing/#advanced-filters","title":"Advanced Filters","text":"<ul> <li> Filter by duration (min/max range in minutes)</li> <li> Filter by resolution (SD/HD/4K/etc.)</li> <li> Filter by interactive (Yes/No if applicable)</li> <li> Combining multiple filters applies AND logic correctly</li> <li> Clearing filters resets to full library</li> </ul>"},{"location":"development/regression-testing/#filter-presets","title":"Filter Presets","text":"<ul> <li> Can save current filter state as preset</li> <li> Can load saved filter preset</li> <li> Can delete saved filter preset</li> <li> Presets persist across sessions</li> <li> Default presets load on page visit (if configured)</li> </ul>"},{"location":"development/regression-testing/#hidden-items-filter","title":"Hidden Items Filter","text":"<ul> <li> Filter shows \"Show Hidden Items\" toggle</li> <li> Hidden scenes are excluded by default</li> <li> Toggling \"Show Hidden Items\" reveals hidden scenes</li> <li> Hidden scenes display with visual indicator (dimmed, badge, etc.)</li> </ul>"},{"location":"development/regression-testing/#33-sorting","title":"3.3 Sorting","text":"<p>Location: Scenes page, sort dropdown</p> <ul> <li> Sort by Date Added (newest first)</li> <li> Sort by Date Added (oldest first)</li> <li> Sort by Title (A-Z)</li> <li> Sort by Title (Z-A)</li> <li> Sort by Duration (longest first)</li> <li> Sort by Duration (shortest first)</li> <li> Sort by Rating (highest first)</li> <li> Sort by Rating (lowest first)</li> <li> Sort by Play Count (most played first)</li> <li> Sort by Random (different order on each load)</li> <li> Sort order persists when navigating away and back</li> <li> Sort works correctly with active filters</li> </ul>"},{"location":"development/regression-testing/#34-paginationinfinite-scroll","title":"3.4 Pagination/Infinite Scroll","text":"<p>Precondition: Library has &gt;40 scenes (default page size)</p> <ul> <li> Initial page loads first 40 scenes</li> <li> Scrolling to bottom loads next page automatically</li> <li> Loading indicator appears while fetching</li> <li> No duplicate scenes appear</li> <li> Can scroll through entire library without errors</li> <li> Scroll position maintained when navigating back from scene details</li> </ul>"},{"location":"development/regression-testing/#4-scene-grid-and-preview-playback","title":"4. Scene Grid and Preview Playback","text":""},{"location":"development/regression-testing/#41-scene-cards-display","title":"4.1 Scene Cards Display","text":"<ul> <li> Scene thumbnails load correctly</li> <li> Scene titles display correctly</li> <li> Scene metadata visible (duration, rating, date, etc.)</li> <li> Performer names display (truncated if too many)</li> <li> Studio name displays (if applicable)</li> <li> Watch history indicators show (resume bar, play count, O-counter)</li> <li> Cards have hover effects (preview, actions, etc.)</li> </ul>"},{"location":"development/regression-testing/#42-preview-playback-on-hover","title":"4.2 Preview Playback on Hover","text":"<p>Precondition: Preview feature enabled in settings</p> <ul> <li> Hovering over scene card for 2 seconds starts preview</li> <li> Preview plays short clip from scene</li> <li> Preview has no audio (or low volume)</li> <li> Preview loops continuously while hovering</li> <li> Moving mouse away stops preview immediately</li> <li> Preview quality matches user preference (Low/Medium/High)</li> <li> Preview doesn't interfere with clicking/navigation</li> <li> Multiple rapid hovers don't cause errors</li> </ul>"},{"location":"development/regression-testing/#43-scene-card-actions","title":"4.3 Scene Card Actions","text":"<p>Location: Hover over scene card or three-dot menu</p> <ul> <li> Can play scene directly (navigates to player page)</li> <li> Can add scene to playlist (opens playlist selector)</li> <li> Can mark scene as watched</li> <li> Can mark O-counter increment</li> <li> Can rate scene (opens rating modal or inline rating)</li> <li> Can hide scene (requires confirmation, scene disappears)</li> <li> Can view scene details (navigates to details page)</li> <li> Can download original file (triggers download)</li> </ul>"},{"location":"development/regression-testing/#5-playlists","title":"5. Playlists","text":""},{"location":"development/regression-testing/#51-playlist-creation","title":"5.1 Playlist Creation","text":"<p>Location: Playlists page or scene card menu</p> <ul> <li> Can create new playlist with name</li> <li> Can create new playlist with description (optional)</li> <li> Empty playlists are allowed</li> <li> Duplicate playlist names are allowed (or prevented based on requirements)</li> <li> New playlist appears in playlists list immediately</li> </ul>"},{"location":"development/regression-testing/#52-addingremoving-scenes","title":"5.2 Adding/Removing Scenes","text":"<ul> <li> Can add scene to playlist from scene card menu</li> <li> Can add multiple scenes to playlist in batch</li> <li> Can remove scene from playlist (via playlist view)</li> <li> Can reorder scenes in playlist (drag-and-drop or up/down buttons)</li> <li> Playlist item count updates immediately</li> <li> Playlist thumbnail updates to first scene</li> </ul>"},{"location":"development/regression-testing/#53-playlist-playback","title":"5.3 Playlist Playback","text":"<p>Precondition: Playlist has at least 3 scenes</p> <ul> <li> Clicking playlist plays first scene</li> <li> Auto-advances to next scene after current finishes</li> <li> \"Previous\" button goes to previous scene</li> <li> \"Next\" button goes to next scene</li> <li> Playlist progress indicator shows (e.g., \"2 of 5\")</li> <li> Can exit playlist playback and return later (resumes at last scene)</li> <li> Shuffle mode randomizes playback order</li> <li> Repeat mode restarts playlist after last scene</li> <li> Shuffle + Repeat combination works correctly</li> </ul>"},{"location":"development/regression-testing/#54-playlist-management","title":"5.4 Playlist Management","text":"<ul> <li> Can rename playlist</li> <li> Can edit playlist description</li> <li> Can delete playlist (requires confirmation)</li> <li> Deleting playlist doesn't delete scenes</li> <li> Can duplicate playlist</li> <li> Can export playlist as M3U (downloads file with relative paths)</li> <li> Can clear all scenes from playlist</li> </ul>"},{"location":"development/regression-testing/#6-performers-studios-tags-galleries-groups","title":"6. Performers, Studios, Tags, Galleries, Groups","text":""},{"location":"development/regression-testing/#61-performers-page","title":"6.1 Performers Page","text":"<ul> <li> Performers grid loads with thumbnails</li> <li> Can search performers by name</li> <li> Can filter performers by tag (if applicable)</li> <li> Can sort performers (name, scene count, etc.)</li> <li> Clicking performer navigates to performer details</li> <li> Performer details show bio, image, scene count</li> <li> Performer details show list of scenes</li> <li> Can filter scenes on performer page (same filters as main scenes page)</li> <li> Can rate performer (if rating feature exists)</li> <li> Can mark performer as favorite</li> </ul>"},{"location":"development/regression-testing/#62-studios-page","title":"6.2 Studios Page","text":"<ul> <li> Studios grid loads with logos/thumbnails</li> <li> Can search studios by name</li> <li> Can sort studios (name, scene count, etc.)</li> <li> Clicking studio navigates to studio details</li> <li> Studio details show scene count and scene list</li> <li> Can filter scenes on studio page</li> <li> Can rate studio (if rating feature exists)</li> <li> Can mark studio as favorite</li> </ul>"},{"location":"development/regression-testing/#63-tags-page","title":"6.3 Tags Page","text":"<ul> <li> Tags list loads (grid or list view)</li> <li> Can search tags by name</li> <li> Can sort tags (name, scene count, etc.)</li> <li> Clicking tag navigates to tag details or filters scenes</li> <li> Tag details show scene count and scene list</li> <li> Can filter scenes by tag combinations (multiple tags)</li> <li> Can hide/show tag categories (if hierarchical)</li> </ul>"},{"location":"development/regression-testing/#64-galleries-page","title":"6.4 Galleries Page","text":"<ul> <li> Galleries grid loads with cover images</li> <li> Can search galleries by title</li> <li> Can filter galleries by performer/studio/tag</li> <li> Clicking gallery navigates to gallery viewer</li> <li> Gallery viewer shows all images in grid or slideshow</li> <li> Can navigate images with arrow keys or swipe</li> <li> Can zoom images</li> <li> Can download images</li> <li> Can rate gallery (if rating feature exists)</li> </ul>"},{"location":"development/regression-testing/#65-groupsmovies-page","title":"6.5 Groups/Movies Page","text":"<ul> <li> Groups grid loads with cover images</li> <li> Can search groups by name</li> <li> Can filter groups by studio/performer/tag</li> <li> Clicking group navigates to group details</li> <li> Group details show scene list in correct order</li> <li> Can play group as playlist (scenes in order)</li> <li> Can reorder scenes in group (if editing is allowed)</li> </ul>"},{"location":"development/regression-testing/#7-ratings-and-favorites","title":"7. Ratings and Favorites","text":""},{"location":"development/regression-testing/#71-rating-scenes","title":"7.1 Rating Scenes","text":"<ul> <li> Can rate scene from 0-100 (or 0-5 stars)</li> <li> Rating updates immediately on scene card</li> <li> Rating persists across sessions</li> <li> Can change rating multiple times</li> <li> Can clear rating (set to null/unrated)</li> <li> Average rating shown alongside user rating (if Stash has community ratings)</li> </ul>"},{"location":"development/regression-testing/#72-favorite-scenes","title":"7.2 Favorite Scenes","text":"<ul> <li> Can mark scene as favorite (heart icon)</li> <li> Favorite status toggles on/off</li> <li> Favorite indicator visible on scene card</li> <li> Can filter scenes to show only favorites</li> <li> Favorites persist across sessions</li> </ul>"},{"location":"development/regression-testing/#73-rating-other-entities","title":"7.3 Rating Other Entities","text":"<p>Test for Performers, Studios, Tags, Galleries, Groups:</p> <ul> <li> Can rate each entity type</li> <li> Can favorite each entity type</li> <li> Ratings and favorites persist</li> <li> Can filter by rating/favorite status</li> </ul>"},{"location":"development/regression-testing/#8-user-settings-and-preferences","title":"8. User Settings and Preferences","text":""},{"location":"development/regression-testing/#81-general-settings","title":"8.1 General Settings","text":"<p>Location: Settings page \u2192 General Settings section</p> <ul> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can toggle preview autoplay on hover (On/Off)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Can change default sort order for scenes</li> <li> Can change scenes per page (if configurable)</li> <li> Settings save immediately or on \"Save\" button click</li> <li> Settings apply immediately (no page refresh required for most)</li> </ul>"},{"location":"development/regression-testing/#82-carousel-preferences","title":"8.2 Carousel Preferences","text":"<p>Location: Settings page \u2192 Homepage Carousels section</p> <ul> <li> Can toggle hardcoded carousels on/off (Continue Watching, High Rated, etc.)</li> <li> Can reorder carousels with up/down buttons</li> <li> Changes reflect on home page after save</li> </ul>"},{"location":"development/regression-testing/#83-custom-carousels","title":"8.3 Custom Carousels","text":"<p>Location: Settings page \u2192 Homepage Carousels \u2192 Create Carousel</p> <ul> <li> Can create custom carousel with title and icon</li> <li> Can add filter rules (performers, tags, rating, etc.)</li> <li> Preview shows matching scenes before save</li> <li> Save is disabled until preview succeeds</li> <li> Can edit existing custom carousel</li> <li> Can delete custom carousel</li> <li> Custom carousel appears on homepage</li> <li> Maximum 15 custom carousels enforced</li> <li> Filter options are sorted alphabetically</li> <li> Scene titles use basename fallback when no title</li> </ul>"},{"location":"development/regression-testing/#84-navigation-preferences","title":"8.4 Navigation Preferences","text":"<p>Location: Settings page \u2192 Navigation Settings section</p> <ul> <li> Can toggle sidebar visibility (always visible, collapsible, hidden)</li> <li> Can toggle top bar elements (show/hide search, user menu, etc.)</li> <li> Can configure keyboard shortcuts (if customizable)</li> </ul>"},{"location":"development/regression-testing/#85-filter-presets","title":"8.5 Filter Presets","text":"<p>Location: Settings page \u2192 Filter Presets section</p> <ul> <li> Can view saved filter presets</li> <li> Can edit filter preset name/description</li> <li> Can delete filter preset</li> <li> Can set default filter preset (auto-loads on scenes page)</li> <li> Can export/import filter presets (JSON file)</li> </ul>"},{"location":"development/regression-testing/#86-hidden-items-user-feature","title":"8.6 Hidden Items (User Feature)","text":"<p>Location: Settings page \u2192 link to Hidden Items page</p> <ul> <li> Can hide individual scenes, performers, studios, tags, galleries, groups</li> <li> Hidden items link in Settings navigates to Hidden Items page</li> <li> Hidden Items page shows all hidden entities grouped by type</li> <li> Can unhide items from Hidden Items page</li> <li> \"Show Hidden Items\" toggle on filter panels reveals hidden content</li> <li> Hidden items persist across sessions</li> </ul>"},{"location":"development/regression-testing/#86-content-restrictions-admin-feature","title":"8.6 Content Restrictions (Admin Feature)","text":"<p>Location: User Management page \u2192 Content Restrictions modal (admin only)</p> <p>Note: This is an admin-only feature for managing per-user content restrictions, separate from user-level hidden items.</p> <ul> <li> Admin can access Content Restrictions modal from User Management</li> <li> Can set INCLUDE mode (user sees only specified groups/tags/studios/galleries)</li> <li> Can set EXCLUDE mode (user doesn't see specified groups/tags/studios/galleries)</li> <li> Can select multiple groups, tags, studios, galleries for restriction</li> <li> Restrictions apply only to the selected user</li> <li> Restrictions apply immediately across all pages for that user</li> <li> Restrictions persist across sessions</li> <li> Can clear all restrictions for a user</li> </ul>"},{"location":"development/regression-testing/#9-keyboard-navigation-and-shortcuts","title":"9. Keyboard Navigation and Shortcuts","text":""},{"location":"development/regression-testing/#91-global-shortcuts","title":"9.1 Global Shortcuts","text":"<p>Precondition: Focus on main application (not in text input)</p> <ul> <li> <code>Space</code> or <code>K</code> pauses/plays video (in player)</li> <li> <code>F</code> toggles fullscreen (in player)</li> <li> <code>M</code> toggles mute (in player)</li> <li> <code>Left/Right</code> arrow keys seek video (\u00b15 seconds)</li> <li> <code>Up/Down</code> arrow keys adjust volume (\u00b15%)</li> <li> <code>J/L</code> keys seek video (\u00b110 seconds)</li> <li> <code>Home/End</code> keys jump to start/end of video</li> <li> <code>Shift+&gt;/Shift+&lt;</code> adjust playback speed</li> <li> <code>Shift+N/Shift+P</code> next/previous scene in playlist</li> <li> Media hardware keys (Play/Pause, FastForward, Rewind, TrackNext, TrackPrevious)</li> <li> <code>0-9</code> seek to percentage (1 = 10%, 5 = 50%, etc.)</li> <li> <code>Esc</code> exits fullscreen or closes modals</li> <li> <code>/</code> focuses search bar</li> <li> <code>?</code> opens keyboard shortcuts help modal (if implemented)</li> </ul>"},{"location":"development/regression-testing/#92-scene-grid-navigation","title":"9.2 Scene Grid Navigation","text":"<p>Precondition: Focus on scenes grid (not in search/filter)</p> <ul> <li> Arrow keys navigate between scene cards</li> <li> <code>Enter</code> plays selected scene</li> <li> <code>A</code> adds selected scene to playlist</li> <li> <code>H</code> hides selected scene</li> <li> <code>R</code> opens rating modal for selected scene</li> <li> Tab/Shift+Tab navigates focusable elements</li> </ul>"},{"location":"development/regression-testing/#93-tv-mode-navigation","title":"9.3 TV Mode Navigation","text":"<p>Precondition: TV Mode enabled (if applicable)</p> <ul> <li> D-pad navigation works (arrow keys simulate remote)</li> <li> Enter/Select button activates items</li> <li> Back button exits player or modals</li> <li> Focus indicators are clearly visible</li> <li> No keyboard traps (can always navigate out)</li> </ul>"},{"location":"development/regression-testing/#10-server-settings-and-admin-features","title":"10. Server Settings and Admin Features","text":""},{"location":"development/regression-testing/#101-server-information","title":"10.1 Server Information","text":"<p>Precondition: Logged in as admin</p> <p>Location: Settings page \u2192 Server tab</p> <ul> <li> Server version displayed correctly (matches package.json)</li> <li> Stash server URL displayed</li> <li> Stash server version displayed (fetched from Stash API)</li> <li> Database location displayed</li> <li> Cache directory location displayed</li> <li> Uptime displayed (time since server start)</li> </ul>"},{"location":"development/regression-testing/#102-cache-management","title":"10.2 Cache Management","text":"<p>Location: Settings page \u2192 Server tab \u2192 Cache section</p> <ul> <li> Can view cache status (last refresh time, entity counts)</li> <li> Can manually refresh cache (button triggers refresh)</li> <li> Cache refresh shows progress indicator</li> <li> Cache refresh completes without errors</li> <li> Scene count updates after cache refresh</li> <li> New scenes from Stash appear after cache refresh</li> </ul>"},{"location":"development/regression-testing/#103-path-mappings","title":"10.3 Path Mappings","text":"<p>Location: Settings page \u2192 Server tab \u2192 Path Mappings section</p> <ul> <li> Can view existing path mappings (Stash path \u2192 Peek path)</li> <li> Can add new path mapping</li> <li> Can edit existing path mapping</li> <li> Can delete path mapping (requires confirmation)</li> <li> Invalid paths show validation error</li> <li> Path mappings apply immediately (no restart required)</li> <li> Test path translation feature works (if exists)</li> </ul>"},{"location":"development/regression-testing/#104-update-checker","title":"10.4 Update Checker","text":"<p>Location: Settings page \u2192 Server tab \u2192 Updates section</p> <ul> <li> Current version displayed</li> <li> \"Check for updates\" button queries GitHub API</li> <li> If update available, shows banner with version number and changelog link</li> <li> If no update, shows \"Up to date\" message</li> <li> Clicking changelog link opens GitHub release page in new tab</li> </ul>"},{"location":"development/regression-testing/#11-error-handling-and-edge-cases","title":"11. Error Handling and Edge Cases","text":""},{"location":"development/regression-testing/#111-network-errors","title":"11.1 Network Errors","text":"<p>Test Scenarios:</p> <ul> <li> Stash server offline: App shows error message, doesn't crash</li> <li> Stash server slow: Loading indicators appear, requests timeout gracefully</li> <li> Invalid Stash API key: Setup wizard or settings page shows authentication error</li> <li> Network interruption during playback: Video pauses, shows buffering indicator, resumes when network recovers</li> </ul>"},{"location":"development/regression-testing/#112-invalid-data-handling","title":"11.2 Invalid Data Handling","text":"<p>Test Scenarios:</p> <ul> <li> Scene with missing file: Shows error message instead of playing, doesn't crash app</li> <li> Scene with invalid path mapping: Shows error message, allows user to update path mappings</li> <li> Corrupted video file: FFmpeg fails gracefully, shows error message</li> <li> Scene with no duration: Displays \"Unknown duration\" or defaults to 0, doesn't crash</li> <li> Scene with no title: Displays filename or \"Untitled\" instead of crashing</li> </ul>"},{"location":"development/regression-testing/#113-permission-errors","title":"11.3 Permission Errors","text":"<p>Test Scenarios:</p> <ul> <li> Non-admin tries to access admin features: Redirected or shown \"Access Denied\" message</li> <li> Expired JWT token: Redirected to login page with message \"Session expired\"</li> <li> Invalid JWT token: Redirected to login page, doesn't crash</li> </ul>"},{"location":"development/regression-testing/#114-database-errors","title":"11.4 Database Errors","text":"<p>Test Scenarios (requires simulating DB issues):</p> <ul> <li> Database locked: Shows error message, retries operation</li> <li> Database migration fails: Server logs error, shows setup wizard or maintenance page</li> <li> Database corruption: Server detects and shows recovery instructions</li> </ul>"},{"location":"development/regression-testing/#115-browser-compatibility","title":"11.5 Browser Compatibility","text":"<p>Test on Multiple Browsers:</p> <ul> <li> Chrome/Edge: All features work</li> <li> Firefox: All features work</li> <li> Safari: All features work (if targeting macOS/iOS)</li> <li> Mobile browsers: Responsive layout, touch controls work</li> </ul>"},{"location":"development/regression-testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/regression-testing/#121-load-times","title":"12.1 Load Times","text":"<ul> <li> Initial page load: &lt;3 seconds on broadband connection</li> <li> Scene grid load: &lt;2 seconds for first 40 scenes</li> <li> Video player load: &lt;3 seconds to first frame (direct playback)</li> <li> HLS stream start: &lt;5 seconds to first frame (transcoded playback)</li> <li> Search/filter response: &lt;500ms for typical library (&lt;10,000 scenes)</li> </ul>"},{"location":"development/regression-testing/#122-resource-usage","title":"12.2 Resource Usage","text":"<p>Precondition: Monitor browser DevTools Performance tab</p> <ul> <li> Memory usage: No memory leaks during 30-minute session</li> <li> CPU usage: &lt;20% CPU during idle browsing (not playing video)</li> <li> Network usage: Only necessary requests (no redundant API calls)</li> </ul>"},{"location":"development/regression-testing/#123-concurrent-sessions","title":"12.3 Concurrent Sessions","text":"<p>Test Scenarios:</p> <ul> <li> Multiple browser tabs: Can play different videos in 2+ tabs simultaneously</li> <li> Multiple users: 2+ users can log in and use app concurrently without interference</li> <li> Transcoding sessions: Multiple concurrent HLS streams don't exhaust server resources</li> </ul>"},{"location":"development/regression-testing/#mobile-and-responsive-testing","title":"Mobile and Responsive Testing","text":""},{"location":"development/regression-testing/#131-mobile-layout","title":"13.1 Mobile Layout","text":"<p>Precondition: Test on mobile device or browser DevTools mobile emulation</p> <ul> <li> Scenes grid adapts to narrow viewport (1-2 columns)</li> <li> Navigation menu becomes hamburger or bottom nav</li> <li> Scene cards remain readable and tappable (no tiny text/buttons)</li> <li> Video player controls are touch-friendly (large buttons)</li> <li> Search bar and filters accessible on mobile</li> <li> Settings page scrollable and functional</li> </ul>"},{"location":"development/regression-testing/#132-touch-controls","title":"13.2 Touch Controls","text":"<ul> <li> Tap scene card to play</li> <li> Swipe to scroll scene grid</li> <li> Pinch to zoom images (in galleries)</li> <li> Tap player controls to pause/play/seek</li> <li> Double-tap player to toggle fullscreen</li> <li> Swipe to navigate between scenes in playlist (if applicable)</li> </ul>"},{"location":"development/regression-testing/#post-release-monitoring","title":"Post-Release Monitoring","text":"<p>After deploying a new version to production:</p> <ol> <li>Check server logs: Look for errors or warnings in first 24 hours</li> <li>Monitor user reports: Track GitHub issues for bug reports</li> <li>Check update notifications: Verify users see update banner if applicable</li> <li>Database migrations: Confirm migrations ran successfully on user instances</li> <li>Performance: Monitor server resource usage (CPU, memory, disk) for anomalies</li> </ol>"},{"location":"development/regression-testing/#test-report-template","title":"Test Report Template","text":"<p>After completing regression testing, document results:</p> <pre><code>**Peek Stash Browser - Regression Test Report**\n\n**Version Tested**: 1.X.X\n**Test Date**: YYYY-MM-DD\n**Tester**: [Your Name]\n**Environment**:\n- Docker Version: X.X.X\n- Browser(s): Chrome X.X, Firefox X.X\n- Stash Version: X.X.X\n- Test Library Size: X scenes, Y performers, Z studios\n\n**Test Results Summary**:\n- Total Tests: X\n- Passed: X\n- Failed: X\n- Skipped: X (with reason)\n\n**Critical Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**High Priority Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**Medium/Low Priority Issues**:\n- [Brief list]\n\n**Recommendation**: \u2705 Ready for release / \u26a0\ufe0f Release with known issues / \u274c Do not release\n\n**Additional Notes**:\n[Any observations, performance notes, or suggestions]\n</code></pre>"},{"location":"development/regression-testing/#automation-recommendations","title":"Automation Recommendations","text":"<p>For future improvements, consider automating these tests:</p> <ul> <li>Unit tests: Core utility functions (path mapping, filter logic, etc.)</li> <li>Integration tests: API endpoints with mock data</li> <li>End-to-end tests: Playwright or Cypress for critical user flows (login, playback, search)</li> <li>Visual regression tests: Screenshot comparison for UI changes</li> <li>Performance tests: Lighthouse CI for page load metrics</li> </ul>"},{"location":"development/regression-testing/#updating-this-document","title":"Updating This Document","text":"<p>As new features are added, update this regression testing guide:</p> <ol> <li>Add new test sections for new features (e.g., \"14. Social Features\")</li> <li>Update existing tests if feature behavior changes</li> <li>Archive obsolete tests (mark as \"Deprecated\" if removed)</li> <li>Keep test steps concise and actionable</li> <li>Include preconditions and expected results for clarity</li> </ol> <p>Last Updated: 2026-01-17 (Version 3.2)</p>"},{"location":"development/sync-architecture/","title":"Sync Architecture","text":"<p>Peek maintains a local SQLite cache of Stash data to enable performant queries, per-user features, and offline resilience. This document describes the sync mechanisms that keep the cache in sync with Stash.</p>"},{"location":"development/sync-architecture/#overview","title":"Overview","text":"<p>Peek provides three sync strategies, each optimized for different use cases:</p> Sync Type When Used Performance Data Freshness Full Sync Initial setup, manual trigger Slowest Complete Incremental Sync Manual trigger with \"since\" parameter Medium Partial Smart Incremental Sync Automatic on startup Fastest Optimal"},{"location":"development/sync-architecture/#sync-types","title":"Sync Types","text":""},{"location":"development/sync-architecture/#full-sync","title":"Full Sync","text":"<p>Purpose: Complete refresh of all data from Stash.</p> <p>Triggered by: - Initial setup (first sync) - Manual \"Full Sync\" button in UI - Recovery from corrupted state - Database schema migrations (automatic on startup when upgrading versions)</p> <p>Process: 1. Sync all entity types in dependency order: studios, tags, performers, groups, galleries, scenes, images 2. Apply gallery inheritance (performers, tags, studio, date, etc. propagate from galleries to images) 3. Compute scene tag inheritance 4. Rebuild inherited image counts 5. Rebuild user stats 6. Recompute user exclusions</p> <p>Characteristics: - Always runs gallery inheritance regardless of what changed - Slowest option but guarantees complete data consistency - Safe recovery mechanism for any sync issues</p>"},{"location":"development/sync-architecture/#incremental-sync","title":"Incremental Sync","text":"<p>Purpose: Sync only entities that changed since a given timestamp.</p> <p>Triggered by: - Manual \"Incremental Sync\" button with date/time parameter</p> <p>Process: 1. Sync all entity types, but only fetch entities with <code>updated_at &gt; since</code> 2. Clean up deleted entities (detect deletions/merges in Stash) 3. Conditionally apply gallery inheritance (if images OR galleries synced) 4. Conditionally compute scene tag inheritance (if scenes synced) 5. Rebuild inherited image counts 6. Rebuild user stats 7. Recompute user exclusions</p> <p>Characteristics: - Faster than full sync for small changesets - Gallery inheritance runs if either images or galleries were updated - Useful for syncing recent changes without full resync</p>"},{"location":"development/sync-architecture/#smart-incremental-sync","title":"Smart Incremental Sync","text":"<p>Purpose: Efficiently sync only what's needed, per-entity-type.</p> <p>Triggered by: - Automatic on server startup - Scheduled sync intervals - Manual \"Smart Sync\" button</p> <p>Process: 1. For each entity type independently:    - Check last sync timestamp for that specific entity type    - Query Stash for change count since that timestamp    - If changes: sync that entity type    - If no changes: skip entirely 2. Clean up deleted entities 3. Conditionally apply gallery inheritance (if images OR galleries synced) 4. Conditionally compute scene tag inheritance (if scenes synced) 5. Rebuild inherited image counts 6. Rebuild user stats 7. Recompute user exclusions</p> <p>Characteristics: - Fastest for typical usage (many entity types unchanged) - Per-entity-type tracking prevents unnecessary work - Gallery inheritance runs if either images or galleries were updated</p>"},{"location":"development/sync-architecture/#entity-sync-order","title":"Entity Sync Order","text":"<p>All sync types process entities in dependency order:</p> <pre><code>1. studios     (no dependencies)\n2. tags        (no dependencies)\n3. performers  (no dependencies)\n4. groups      (depends on studios, tags)\n5. galleries   (depends on studios, performers, tags)\n6. scenes      (depends on studios, performers, tags, groups, galleries)\n7. images      (depends on studios, performers, tags, galleries)\n</code></pre> <p>This order ensures foreign key relationships are satisfied.</p>"},{"location":"development/sync-architecture/#post-sync-processing","title":"Post-Sync Processing","text":""},{"location":"development/sync-architecture/#gallery-inheritance","title":"Gallery Inheritance","text":"<p>Images can inherit metadata from their parent galleries:</p> <p>Inherited fields: - <code>studioId</code> (if image has none) - <code>date</code> (if image has none) - <code>photographer</code> (if image has none) - <code>details</code> (if image has none) - Performers (via <code>ImagePerformer</code> junction table) - Tags (via <code>ImageTag</code> junction table)</p> <p>Rules: - Only copies metadata if the image field is NULL/empty - Never overwrites existing image metadata - Uses first gallery if image is in multiple galleries</p> <p>Trigger conditions: - Full sync: Always runs - Incremental sync: Runs if images OR galleries were synced - Smart incremental: Runs if images OR galleries were synced</p>"},{"location":"development/sync-architecture/#scene-tag-inheritance","title":"Scene Tag Inheritance","text":"<p>Scenes inherit tags from their performers and studios:</p> <ul> <li>Performer tags propagate to scenes featuring that performer</li> <li>Studio tags propagate to scenes from that studio</li> <li>Stored in <code>SceneInheritedTag</code> for efficient querying</li> </ul> <p>Trigger conditions: - Full sync: Always runs - Incremental sync: Runs if scenes were synced - Smart incremental: Runs if scenes were synced</p>"},{"location":"development/sync-architecture/#image-count-rebuild","title":"Image Count Rebuild","text":"<p>Maintains denormalized image counts on entities:</p> <ul> <li>Performers: Count of images featuring them</li> <li>Tags: Count of images with that tag</li> <li>Studios: Count of images from that studio</li> <li>Galleries: Count of images in that gallery</li> </ul> <p>Always runs after any sync to ensure consistency.</p>"},{"location":"development/sync-architecture/#sync-state-tracking","title":"Sync State Tracking","text":"<p>Each entity type maintains its own sync state:</p> <pre><code>CREATE TABLE SyncState (\n  id TEXT PRIMARY KEY,\n  stashInstanceId TEXT,\n  entityType TEXT,              -- 'scene', 'performer', 'studio', etc.\n  lastFullSyncTimestamp TEXT,   -- RFC3339 timestamp from Stash\n  lastIncrementalSyncTimestamp TEXT\n);\n</code></pre> <p>Smart incremental sync uses the more recent of <code>lastFullSyncTimestamp</code> or <code>lastIncrementalSyncTimestamp</code> for each entity type independently.</p>"},{"location":"development/sync-architecture/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/sync-architecture/#images-not-showing-expected-performerstags","title":"Images not showing expected performers/tags","text":"<p>Symptom: Filtering images by performer returns 0 results, but the performer is associated with the gallery.</p> <p>Cause: Gallery inheritance didn't run after galleries were updated.</p> <p>Solution: Run a full sync to ensure inheritance is applied.</p>"},{"location":"development/sync-architecture/#stale-data-after-stash-changes","title":"Stale data after Stash changes","text":"<p>Symptom: Changes made in Stash don't appear in Peek.</p> <p>Cause: Smart incremental sync may have missed changes if Stash's <code>updated_at</code> timestamps weren't updated.</p> <p>Solution: Run a full sync, or incremental sync with an earlier timestamp.</p>"},{"location":"development/sync-architecture/#sync-appears-stuck","title":"Sync appears stuck","text":"<p>Symptom: Sync progress stops or takes unusually long.</p> <p>Cause: Large datasets or network issues with Stash.</p> <p>Solution: Check Peek logs for errors. Consider syncing entity types individually.</p>"},{"location":"development/sync-architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"development/sync-architecture/#how-to-catch-sync-parity-bugs","title":"How to catch sync parity bugs","text":"<p>The bug fixed in v3.1.0-beta.13 was that <code>smartIncrementalSync</code> was missing gallery inheritance. To catch this type of bug:</p> <p>1. Integration tests for end-to-end behavior:</p> <p>Add a test entity <code>galleryWithPerformerNoDirectImagePerformer</code> - a gallery that has a performer, containing images that do NOT have that performer directly assigned. Then test:</p> <pre><code>it(\"filters images by performer inherited from gallery\", async () =&gt; {\n  const response = await adminClient.post(\"/api/library/images\", {\n    filter: { per_page: 50 },\n    image_filter: {\n      performers: {\n        value: [TEST_ENTITIES.galleryPerformerNotOnImages],\n        modifier: \"INCLUDES\",\n      },\n    },\n  });\n\n  expect(response.ok).toBe(true);\n  expect(response.data.findImages.count).toBeGreaterThan(0);\n});\n</code></pre> <p>This test will fail if gallery inheritance doesn't run.</p> <p>2. Behavioral parity checks:</p> <p>When adding post-sync processing to one sync method, verify all three methods have equivalent processing. The three sync methods should have the same set of post-processing steps:</p> <ul> <li>Gallery inheritance (conditional on images/galleries synced)</li> <li>Scene tag inheritance (conditional on scenes synced)</li> <li>Image count rebuild</li> <li>User stats rebuild</li> <li>Exclusion recomputation</li> </ul>"},{"location":"development/sync-architecture/#implementation-reference","title":"Implementation Reference","text":"<p>The sync logic is implemented in:</p> <ul> <li><code>server/services/StashSyncService.ts</code> - Main sync orchestration</li> <li><code>server/services/ImageGalleryInheritanceService.ts</code> - Gallery-to-image inheritance</li> <li><code>server/services/SceneTagInheritanceService.ts</code> - Scene tag inheritance</li> <li><code>server/services/EntityImageCountService.ts</code> - Image count denormalization</li> </ul>"},{"location":"development/technical-overview/","title":"Peek Technical Overview","text":"<p>This document covers Peek's architecture, content filtering system, and implementation details. For entity relationships and the data model, see Entity Relationships.</p>"},{"location":"development/technical-overview/#stash-communication-patterns","title":"Stash Communication Patterns","text":"<p>Peek communicates with Stash in several ways. Understanding these patterns is important for performance and consistency.</p>"},{"location":"development/technical-overview/#expected-patterns","title":"Expected Patterns","text":"Pattern Purpose Examples Sync Fetch entities to cache locally <code>StashSyncService</code> fetching scenes, performers, etc. Write-back Sync user data to Stash Ratings, favorites, watch history, O-counter Media proxy Stream video/captions through Peek <code>video.ts</code> proxying HLS streams Metadata edit User edits entity metadata Scene/performer/studio/tag updates"},{"location":"development/technical-overview/#known-issues-direct-stash-queries","title":"Known Issues: Direct Stash Queries","text":"<p>These locations query Stash directly for UI display, bypassing the cache. This causes bugs and performance issues.</p> Location Issue Impact Fix <code>playlist.ts:76,165</code> Fetches scene data from Stash for playlist display Shows Stash's O-counter/favorite instead of user's Peek values Query from <code>StashScene</code> cache <code>watchHistory.ts:61</code> Fetches scene duration from Stash on every 10-second ping Unnecessary network calls during playback Store duration in cache (available in <code>files[0].duration</code>) <p>Principle: All UI data should come from Peek's cache. Stash should only be queried for sync operations and media streaming.</p>"},{"location":"development/technical-overview/#content-visibility-system","title":"Content Visibility System","text":"<p>Peek has two mechanisms for hiding content from users. Both cascade (hiding a Tag hides all content with that Tag), but they differ in who controls them and whether they can be undone.</p>"},{"location":"development/technical-overview/#restricted-content-admin-controlled","title":"Restricted Content (Admin-Controlled)","text":"<p>Purpose: Admins restrict content that specific users should never see (e.g., age-inappropriate content, legal restrictions).</p> <p>Storage: <code>UserContentRestriction</code> table</p> Column Type Description <code>userId</code> Int Target user <code>entityType</code> String <code>'groups'</code>, <code>'tags'</code>, <code>'studios'</code>, <code>'galleries'</code> <code>mode</code> String <code>'INCLUDE'</code> (whitelist) or <code>'EXCLUDE'</code> (blacklist) <code>entityIds</code> String JSON array of entity IDs <code>restrictEmpty</code> Boolean Also hide items with no entities of this type <p>Key behaviors: - Only admins can set restrictions (via Server Settings) - Users cannot see or modify their restrictions - Users cannot bypass restrictions - Supports both whitelist (INCLUDE) and blacklist (EXCLUDE) modes - Can restrict by: Tags, Groups, Studios, Galleries</p> <p>Cascading: - Tag restriction \u2192 Hides Scenes/Performers/Studios with that Tag (including inherited tags) - Group restriction \u2192 Hides Scenes in that Group - Studio restriction \u2192 Hides Scenes from that Studio - Gallery restriction \u2192 Hides Scenes linked to that Gallery</p>"},{"location":"development/technical-overview/#hidden-content-user-controlled","title":"Hidden Content (User-Controlled)","text":"<p>Purpose: Users hide content they personally don't want to see. They can undo this at any time.</p> <p>Storage: <code>UserHiddenEntity</code> table</p> Column Type Description <code>userId</code> Int User who hid the entity <code>entityType</code> String Any entity type <code>entityId</code> String Stash entity ID <code>hiddenAt</code> DateTime When it was hidden <p>Key behaviors: - Users control their own hidden items - Users can view and unhide items via Settings - Supports all entity types: Scene, Performer, Studio, Tag, Group, Gallery, Image - Admins still see their own hidden items (they can hide content for personal preference)</p> <p>Cascading: - Hidden Performer \u2192 Hides Scenes with that Performer - Hidden Studio \u2192 Hides Scenes from that Studio - Hidden Tag \u2192 Hides Scenes/Performers/Studios with that Tag (including inherited) - Hidden Group \u2192 Hides Scenes in that Group - Hidden Gallery \u2192 Hides Scenes linked to that Gallery, Images in Gallery</p>"},{"location":"development/technical-overview/#processing-order","title":"Processing Order","text":"<p>Content filtering happens in this order: 1. INCLUDE restrictions (intersection) \u2014 must match ALL includes 2. EXCLUDE restrictions (difference) \u2014 must not match ANY excludes 3. Hidden entity filtering (cascade) 4. Empty entity filtering \u2014 remove organizational entities with no visible content</p>"},{"location":"development/technical-overview/#empty-entity-filtering","title":"Empty Entity Filtering","text":"<p>After restrictions/hiding are applied, organizational entities with no remaining content are removed. Order matters due to dependencies:</p> <ol> <li>Galleries \u2014 Keep if <code>image_count &gt; 0</code></li> <li>Groups \u2014 Keep if has scenes OR has sub-groups with content (tree traversal)</li> <li>Studios \u2014 Keep if appears in visible scenes OR has visible groups/galleries OR has child studios with content</li> <li>Performers \u2014 Keep if appears in visible scenes OR has images OR in visible groups/galleries</li> <li>Tags \u2014 Keep if attached to any visible entity OR has children with content (DAG traversal)</li> </ol> <p>Current limitation: Empty filtering uses scene/image counts from Stash metadata, not restriction-aware counts. A workaround passes <code>visibleScenes</code> to the filter methods.</p>"},{"location":"development/technical-overview/#current-architecture-issues","title":"Current Architecture Issues","text":""},{"location":"development/technical-overview/#problem-in-memory-filtering-doesnt-scale","title":"Problem: In-Memory Filtering Doesn't Scale","text":"<p>The current implementation loads all entities into memory then filters:</p> <pre><code>1. Load ALL scenes from cache\n2. Filter in JavaScript (UserRestrictionService)\n3. Filter empty entities (EmptyEntityFilterService)\n4. Paginate\n</code></pre> <p>This works for small collections but becomes problematic with: - 10k+ scenes - Multiple concurrent users - Complex restriction rules</p>"},{"location":"development/technical-overview/#problem-redundant-computation","title":"Problem: Redundant Computation","text":"<p>Every request recomputes: - Which entities are hidden for this user - Which scenes match restriction rules - Which organizational entities are now empty</p> <p><code>FilteredEntityCacheService</code> helps but is invalidated frequently.</p>"},{"location":"development/technical-overview/#problem-pagination-breaks","title":"Problem: Pagination Breaks","text":"<p>To paginate correctly, we need to know the total count of visible items. Currently: 1. Load ALL items 2. Filter ALL items 3. Get count 4. Return page slice</p> <p>This defeats the purpose of pagination for large collections.</p>"},{"location":"development/technical-overview/#proposed-architecture-pre-computed-exclusions","title":"Proposed Architecture: Pre-Computed Exclusions","text":""},{"location":"development/technical-overview/#core-concept","title":"Core Concept","text":"<p>Instead of filtering at query time, pre-compute and store excluded entity IDs per user. Queries become simple JOINs:</p> <pre><code>-- Get visible scenes for user 5, page 1\nSELECT s.* FROM StashScene s\nLEFT JOIN UserExcludedEntity e\n  ON e.userId = 5\n  AND e.entityType = 'scene'\n  AND e.entityId = s.id\nWHERE e.id IS NULL  -- Not in exclusion list\n  AND s.deletedAt IS NULL\nORDER BY s.stashCreatedAt DESC\nLIMIT 25 OFFSET 0\n</code></pre>"},{"location":"development/technical-overview/#proposed-schema","title":"Proposed Schema","text":"<pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  // Why is this excluded? (for debugging, not query logic)\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  sourceType String?  // If cascade: which entity type caused it\n  sourceId   String?  // If cascade: which entity ID caused it\n\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])      // Primary query index\n  @@index([entityType, entityId])    // For cascade lookups (\"what users exclude this?\")\n}\n\n// Pre-computed visible counts per entity type (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', etc.\n  visibleCount Int      // total entities - excluded entities\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre>"},{"location":"development/technical-overview/#key-design-decisions","title":"Key Design Decisions","text":"<p>1. Single table vs separate tables?</p> <p>Single <code>UserExcludedEntity</code> table is preferred: - Simpler schema - Single JOIN pattern for all queries - <code>reason</code> column distinguishes restriction vs hidden - <code>sourceType</code>/<code>sourceId</code> enable cascade debugging</p> <p>2. How are IDs unique?</p> <p>Stash entity IDs are integers per entity type, NOT globally unique. Scene #1 and Performer #1 can coexist.</p> <p>The composite unique constraint <code>@@unique([userId, entityType, entityId])</code> handles this: - User 5 + scene + \"1\" = one record - User 5 + performer + \"1\" = different record</p> <p>3. Store exclusions vs inclusions?</p> <p>Store exclusions (what to hide): - Most users see most content (exclusions are smaller set) - Simpler query pattern (LEFT JOIN + WHERE NULL) - Easier to reason about</p> <p>4. How to distinguish restricted vs hidden?</p> <p>The <code>reason</code> column: - <code>'restricted'</code> \u2014 Admin set a restriction rule matching this entity - <code>'hidden'</code> \u2014 User explicitly hid this entity - <code>'cascade'</code> \u2014 Hidden due to a related entity being restricted/hidden - <code>'empty'</code> \u2014 Organizational entity with no visible content</p> <p>Users can query their hidden items for the unhide UI: <pre><code>SELECT * FROM UserExcludedEntity\nWHERE userId = ? AND reason = 'hidden'\n</code></pre></p> <p>5. When to recompute?</p> <p>Recompute exclusions when: - Stash sync completes (new/updated entities) - Admin changes restrictions for a user - User hides/unhides an entity - Entity relationships change (rare, usually via Stash)</p> <p>Recomputation is per-user and can be done incrementally for hide/unhide operations.</p>"},{"location":"development/technical-overview/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"development/technical-overview/#target-scale","title":"Target Scale","text":"<p>Some Stash users have 100TB+ collections with millions of images and scenes. The exclusion system must handle: - 1M+ scenes per instance - 1M+ images per instance - Multiple users with different restrictions - Worst case: 50% of content excluded per user</p>"},{"location":"development/technical-overview/#exclusion-table-size-estimates","title":"Exclusion Table Size Estimates","text":"Scenario Exclusion Records Table Size 1M scenes, 10% excluded, 1 user ~100k rows ~10MB 1M scenes, 50% excluded, 5 users ~2.5M rows ~250MB 2M entities, 30% excluded, 10 users ~6M rows ~600MB"},{"location":"development/technical-overview/#performance-characteristics","title":"Performance Characteristics","text":"<p>Query performance (with proper indexes): - Index lookup: O(log n) \u2014 ~20 comparisons for 1M rows - JOIN is efficient because all join columns are indexed - SQLite page cache keeps hot indexes in memory</p> <p>Potential bottlenecks:</p> Concern Mitigation Full recomputation time Never do full recompute except initial setup; use incremental updates COUNT queries Pre-compute visible counts in <code>UserEntityStats</code> table Index memory ~250MB for 5M rows is acceptable for modern servers Cascade complexity Track <code>sourceType</code>/<code>sourceId</code> to enable targeted updates"},{"location":"development/technical-overview/#incremental-update-strategy","title":"Incremental Update Strategy","text":"<p>Hide entity (fast, ~10-100 inserts): 1. Insert exclusion with <code>reason='hidden'</code> 2. Find cascading entities via junction tables 3. Insert cascade exclusions with <code>sourceType</code>/<code>sourceId</code> 4. Decrement <code>visibleCount</code> in <code>UserEntityStats</code></p> <p>Unhide entity (medium, may need partial recompute): 1. Delete exclusion where <code>reason='hidden'</code> AND entity matches 2. Delete cascade exclusions where <code>sourceId</code> matches 3. Re-check if any cascades should remain (other hidden entities may still exclude them) 4. Update <code>visibleCount</code> in <code>UserEntityStats</code></p> <p>Stash sync (diff-based): 1. Compare new entity list with cached list 2. For new entities: check if any restriction rules apply 3. For deleted entities: remove from exclusion table 4. For modified entities: recompute if relationships changed</p>"},{"location":"development/technical-overview/#future-optimization-table-splitting","title":"Future Optimization: Table Splitting","text":"<p>If performance issues arise at 10M+ exclusion rows, consider splitting: - <code>UserExcludedScene</code> \u2014 highest volume - <code>UserExcludedImage</code> \u2014 highest volume - <code>UserExcludedEntity</code> \u2014 for performers, studios, tags, groups, galleries (lower volume)</p> <p>Start with single table; split only if actual performance issues occur.</p>"},{"location":"development/technical-overview/#update-triggers","title":"Update Triggers","text":"<p>Pre-computed exclusions need updating when:</p> Event Scope Action Stash sync (full) All users Diff-based recompute Stash sync (incremental) All users Recompute affected entities only Admin changes restriction One user Recompute that user User hides entity One user Incremental add User unhides entity One user Incremental remove + cascade check"},{"location":"development/technical-overview/#migration-strategy","title":"Migration Strategy","text":"<ol> <li>Keep existing <code>UserContentRestriction</code> and <code>UserHiddenEntity</code> tables as source of truth</li> <li>Add new <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables</li> <li>Implement <code>ExclusionComputationService</code> with incremental update logic</li> <li>Add trigger points for recomputation (sync complete, restriction change, hide/unhide)</li> <li>Migrate query patterns to use exclusion JOINs</li> <li>Add admin endpoints for manual recomputation</li> <li>Remove in-memory filtering code once stable</li> </ol>"},{"location":"development/technical-overview/#api-changes","title":"API Changes","text":"<p>Minimal external API changes needed. Internal query implementation changes.</p> <p>New admin endpoints: <pre><code>POST /api/admin/recompute-exclusions/:userId\nPOST /api/admin/recompute-exclusions/all\nGET  /api/admin/exclusion-stats\n</code></pre></p>"},{"location":"development/technical-overview/#implementation-notes","title":"Implementation Notes","text":""},{"location":"development/technical-overview/#service-architecture","title":"Service Architecture","text":"<p>The backend uses SQL-based query builders with pre-computed exclusions for efficient filtering at scale.</p>"},{"location":"development/technical-overview/#core-services","title":"Core Services","text":"Service Purpose <code>StashEntityService.ts</code> Database queries for Stash entities (replaces in-memory cache) <code>StashSyncService.ts</code> Syncs data from Stash GraphQL API to local database <code>UserHiddenEntityService.ts</code> CRUD for user-hidden entities <code>ExclusionComputationService.ts</code> Computes and maintains <code>UserExcludedEntity</code> table <code>EntityExclusionHelper.ts</code> Helper functions for exclusion logic"},{"location":"development/technical-overview/#query-builders","title":"Query Builders","text":"<p>Each entity type has a dedicated query builder that handles filtering, sorting, pagination, and exclusion JOINs:</p> Query Builder Entity <code>SceneQueryBuilder.ts</code> Scenes <code>PerformerQueryBuilder.ts</code> Performers <code>StudioQueryBuilder.ts</code> Studios <code>TagQueryBuilder.ts</code> Tags <code>GroupQueryBuilder.ts</code> Groups <code>GalleryQueryBuilder.ts</code> Galleries <code>ImageQueryBuilder.ts</code> Images"},{"location":"development/technical-overview/#other-services","title":"Other Services","text":"Service Purpose <code>RecommendationScoringService.ts</code> Personalized scene recommendations <code>UserStatsService.ts</code> User activity statistics <code>UserStatsAggregationService.ts</code> Aggregated stats computation <code>SceneTagInheritanceService.ts</code> Computes inherited tags for scenes <code>ImageGalleryInheritanceService.ts</code> Propagates gallery metadata to images"},{"location":"development/technical-overview/#query-pattern","title":"Query Pattern","text":"<p>Library controllers use query builders for efficient SQL-based filtering:</p> <pre><code>// Query with exclusion JOIN \u2014 filtering, pagination, and count in one query\nconst result = await sceneQueryBuilder\n  .forUser(userId)\n  .withFilters(filters)\n  .withSort(sort)\n  .paginate(offset, limit)\n  .execute();\n\n// Returns { items: Scene[], total: number }\n// Already filtered by user exclusions, already paginated\n</code></pre> <p>This replaces the old pattern of loading all entities into memory and filtering in JavaScript.</p> <p>Document Version: 3.2 Last Updated: 2026-01-17</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Peek Stash Browser is configured through environment variables and the setup wizard. This page documents all available configuration options.</p>"},{"location":"getting-started/configuration/#stash-connection-setup-wizard","title":"Stash Connection (Setup Wizard)","text":"<p>As of v2.0, Stash connection details are configured via the Setup Wizard and stored in the database:</p> <ul> <li>Stash URL: Your Stash GraphQL endpoint (e.g., <code>http://192.168.1.100:9999/graphql</code>)</li> <li>Stash API Key: API key from Stash Settings \u2192 Security</li> </ul> <p>The wizard runs automatically on first access. No environment variables needed for Stash connection!</p> <p>Upgrading from v1.x? Your existing <code>STASH_URL</code> and <code>STASH_API_KEY</code> environment variables will auto-migrate to the database on first start. You can remove them from your container configuration after successful migration.</p>"},{"location":"getting-started/configuration/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>JWT_SECRET</code> JWT signing key Generate with <code>openssl rand -base64 32</code>"},{"location":"getting-started/configuration/#generating-jwt-secret","title":"Generating JWT Secret","text":"<p>Linux/macOS/unRAID: <pre><code>openssl rand -base64 32\n</code></pre></p> <p>Windows PowerShell: <pre><code>$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n[Convert]::ToBase64String($bytes)\n</code></pre></p>"},{"location":"getting-started/configuration/#optional-environment-variables","title":"Optional Environment Variables","text":"<p>These settings have sensible defaults but can be customized:</p> Variable Description Default Notes <code>DATABASE_URL</code> SQLite database file <code>file:/app/data/peek-stash-browser.db</code> Path inside container <code>CONFIG_DIR</code> App data directory <code>/app/data</code> Database location <code>NODE_ENV</code> Environment mode <code>production</code> <code>development</code> or <code>production</code> <code>PROXY_AUTH_HEADER</code> Proxy Auth Header Disabled by default"},{"location":"getting-started/configuration/#video-streaming-v20","title":"Video Streaming (v2.0+)","text":"<p>As of v2.0, Peek streams video directly through Stash - no local media access required!</p> <ul> <li>Videos are proxied through the Stash API</li> <li>No media volume mounts needed</li> <li>No path mapping configuration required</li> <li>Simpler container setup</li> </ul> <p>This is a significant simplification from v1.x which required mounting media directories and configuring path mappings.</p>"},{"location":"getting-started/configuration/#security-settings","title":"Security Settings","text":"Variable Description Default When to Use <code>SECURE_COOKIES</code> Enable secure cookie flag <code>false</code> Set to <code>true</code> when using HTTPS reverse proxy <p>Security Best Practices</p> <ul> <li>Set a strong <code>JWT_SECRET</code> during installation (required)</li> <li>Set <code>SECURE_COOKIES=true</code> when using HTTPS</li> <li>Never expose Peek directly to the internet - always use a reverse proxy</li> <li>Admin credentials are created during setup wizard (no default passwords)</li> <li>Stash API key is stored securely in the database (not in environment variables)</li> </ul>"},{"location":"getting-started/configuration/#proxy-authentication","title":"Proxy Authentication","text":"<p>Peek supports delegating authentication to your reverse proxy (e.g., Nginx, Traefik, Caddy, Authelia, Authentik). This is useful when you already have an authentication system in place and want Peek to trust the authenticated user from the proxy.</p>"},{"location":"getting-started/configuration/#how-it-works","title":"How It Works","text":"<ol> <li>Your reverse proxy handles authentication (SSO, OAuth, basic auth, etc.)</li> <li>The proxy adds a header with the authenticated username to all requests</li> <li>Peek reads this header and looks up the corresponding user in its database</li> <li>If no header is present, Peek falls back to standard JWT token authentication</li> </ol>"},{"location":"getting-started/configuration/#configuration_1","title":"Configuration","text":"<p>Set the <code>PROXY_AUTH_HEADER</code> environment variable to the name of the header your proxy uses:</p> <pre><code>PROXY_AUTH_HEADER=X-Peek-Username\n</code></pre> <p>Common header names: - <code>X-Peek-Username</code> (recommended) - <code>X-Forwarded-User</code> (common with Authelia/Traefik) - <code>Remote-User</code> (common with Nginx auth_request) - <code>X-Auth-Request-User</code> (oauth2-proxy)</p>"},{"location":"getting-started/configuration/#security-requirements","title":"Security Requirements","text":"<p>Critical Security Requirements</p> <p>When using proxy authentication, you MUST ensure:</p> <ol> <li>Peek is NOT accessible directly - Only allow access through the reverse proxy</li> <li>The proxy sanitizes the authentication header - The proxy must strip any user-supplied headers with the same name to prevent header injection attacks</li> <li>Network isolation - Peek should only listen on localhost or a private network, not on public interfaces</li> </ol> <p>Failure to follow these requirements will allow anyone to impersonate any user by setting the header in their request.</p>"},{"location":"getting-started/configuration/#example-nginx-with-auth_request","title":"Example: Nginx with auth_request","text":"<pre><code>location / {\n    # Authentication endpoint\n    auth_request /auth;\n\n    # Pass authenticated username to Peek\n    auth_request_set $user $upstream_http_x_auth_user;\n    proxy_set_header Remote-User $user;\n\n    # CRITICAL: Strip any user-provided Remote-User headers\n    proxy_set_header Remote-User \"\";  # Clear first\n    proxy_set_header Remote-User $user;  # Then set from auth\n\n    # Proxy to Peek\n    proxy_pass http://localhost:6969;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n}\n</code></pre> <pre><code># Peek configuration\nPROXY_AUTH_HEADER=Remote-User\n</code></pre>"},{"location":"getting-started/configuration/#example-traefik-with-forwardauth-authelia","title":"Example: Traefik with ForwardAuth (Authelia)","text":"<pre><code># docker-compose.yml\nservices:\n  traefik:\n    labels:\n      - \"traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://auth.example.com\"\n      - \"traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User\"\n\n  peek:\n    environment:\n      - PROXY_AUTH_HEADER=Remote-User\n    labels:\n      - \"traefik.http.routers.peek.middlewares=authelia@docker\"\n</code></pre>"},{"location":"getting-started/configuration/#user-management","title":"User Management","text":"<p>Users must exist in Peek's database for proxy authentication to work:</p> <ol> <li>Create users through Peek's admin panel (Settings \u2192 User Management)</li> <li>The username in Peek must exactly match the username passed by the proxy</li> <li>User roles and permissions are still managed within Peek</li> <li>Passwords are not used when proxy auth is enabled (but must still be set in the database)</li> </ol>"},{"location":"getting-started/configuration/#fallback-behavior","title":"Fallback Behavior","text":"<p>When <code>PROXY_AUTH_HEADER</code> is set but the header is not present in a request, Peek falls back to standard JWT cookie authentication. This allows:</p> <ul> <li>Mixed authentication (some users via proxy, others via direct login)</li> <li>API access using JWT tokens</li> <li>Testing and development without the proxy</li> </ul>"},{"location":"getting-started/configuration/#troubleshooting","title":"Troubleshooting","text":"<p>401 Unauthorized - User not found - Verify the user exists in Peek's database - Check that usernames match exactly (case-sensitive) - Verify the proxy is passing the correct header name</p> <p>Users being logged in as wrong user - CRITICAL: Your proxy is not sanitizing the header properly - Verify the proxy strips user-supplied headers before setting the authenticated value - Check that Peek is not accessible directly (bypass proxy)</p>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#minimal-production-configuration-v20","title":"Minimal Production Configuration (v2.0+)","text":"<pre><code># Required\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Stash connection configured via Setup Wizard (stored in database)\n# All other settings use defaults\n</code></pre>"},{"location":"getting-started/configuration/#complete-production-configuration","title":"Complete Production Configuration","text":"<pre><code># Authentication (Required)\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Database (Optional - defaults shown)\nDATABASE_URL=file:/app/data/peek-stash-browser.db\nCONFIG_DIR=/app/data\n\n# Security (Optional)\nSECURE_COOKIES=true\n\n# Environment (Optional)\nNODE_ENV=production\n\n# Stash connection configured via Setup Wizard (stored in database)\n</code></pre>"},{"location":"getting-started/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code># Authentication\nJWT_SECRET=dev-secret-change-in-production\n\n# Database (local SQLite file)\nDATABASE_URL=file:./data/peek-db.db\n\n# Development\nNODE_ENV=development\n\n# Stash connection configured via Setup Wizard\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-example","title":"Docker Compose Example","text":"<pre><code>services:\n  peek:\n    image: carrotwaxr/peek-stash-browser:latest\n    container_name: peek-stash-browser\n    ports:\n      - \"6969:80\"\n    volumes:\n      - peek-data:/app/data\n    environment:\n      - JWT_SECRET=${JWT_SECRET}\n      # Optional\n      - NODE_ENV=production\n      - SECURE_COOKIES=false\n    restart: unless-stopped\n\nvolumes:\n  peek-data:\n</code></pre> <p>Stash Connection</p> <p>Stash URL and API key are configured via the Setup Wizard on first access and stored in the database.</p> <p>Port Conflict with Whisparr</p> <p>Peek's default port (6969) is the same as Whisparr's default port. If you're running Whisparr, change the port mapping to <code>\"6970:80\"</code> or another available port.</p>"},{"location":"getting-started/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"getting-started/configuration/#cannot-connect-to-stash","title":"Cannot Connect to Stash","text":"<p>Check:</p> <ul> <li>Stash URL is accessible from the Peek container</li> <li>Stash API key is correct and not expired</li> <li>Stash GraphQL API is enabled</li> </ul> <p>Test connectivity:</p> <pre><code>docker exec peek-stash-browser curl http://your-stash-ip:9999/graphql\n</code></pre> <p>You can update Stash connection details in Settings \u2192 Stash Configuration.</p>"},{"location":"getting-started/configuration/#videos-wont-play","title":"Videos Won't Play","text":"<p>Check:</p> <ul> <li>Stash connection is configured correctly (Settings \u2192 Stash Configuration)</li> <li>Stash server is running and accessible</li> <li>The scene exists in Stash and has a valid video file</li> </ul>"},{"location":"getting-started/configuration/#authentication-issues","title":"Authentication Issues","text":"<p>Check:</p> <ul> <li><code>JWT_SECRET</code> is set</li> <li><code>SECURE_COOKIES</code> matches your HTTP/HTTPS setup</li> <li>Database is writable</li> </ul>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/faq/","title":"Frequently Asked Questions","text":"<p>Common questions about Peek Stash Browser.</p>"},{"location":"getting-started/faq/#general","title":"General","text":""},{"location":"getting-started/faq/#what-is-peek","title":"What is Peek?","text":"<p>Peek is a modern web application for browsing and streaming your Stash media library. It provides a mobile-friendly interface with multi-user support, playlists, recommendations, and watch history.</p>"},{"location":"getting-started/faq/#how-is-peek-different-from-stash","title":"How is Peek different from Stash?","text":"<p>Peek is a browser/player focused on video playback and discovery, while Stash is a comprehensive media organizer. Peek:</p> <ul> <li>Provides a mobile-friendly, browsing-focused interface</li> <li>Supports multiple users with separate preferences and restrictions</li> <li>Includes playlists, recommendations, and watch history</li> <li>Proxies video streams through Stash (no local media access needed)</li> <li>Complements Stash rather than replacing it</li> </ul>"},{"location":"getting-started/faq/#does-peek-modify-my-stash-library","title":"Does Peek modify my Stash library?","text":"<p>Peek can optionally sync ratings, favorites, and O-counter back to Stash (configurable). It never modifies your files or core metadata.</p>"},{"location":"getting-started/faq/#how-does-peek-sync-with-stash","title":"How does Peek sync with Stash?","text":"<p>Peek maintains a local cache of your Stash library for fast queries. Three sync mechanisms keep it updated:</p> <ul> <li>Smart Sync (automatic) - Runs on startup and periodically, only syncing what changed</li> <li>Incremental Sync - Manual option to sync recent changes since a specific time</li> <li>Full Sync - Complete refresh, runs automatically when upgrading Peek versions</li> </ul> <p>Key points:</p> <ul> <li>Syncing happens in the background - you can browse while it runs</li> <li>Large libraries (100k+ scenes) may take several minutes for full sync</li> <li>Changes made in Stash appear in Peek after the next sync</li> <li>User data (watch history, playlists, ratings) is stored separately and never affected by sync</li> </ul> <p>See Sync Architecture for technical details.</p>"},{"location":"getting-started/faq/#installation","title":"Installation","text":""},{"location":"getting-started/faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<ul> <li>unRAID: Manual Docker template installation</li> <li>Docker: Any platform supporting Docker (AMD64 and ARM64)</li> <li>Development: Node.js 18+ on Windows/Mac/Linux</li> </ul>"},{"location":"getting-started/faq/#do-i-need-a-separate-database-server","title":"Do I need a separate database server?","text":"<p>No. Peek uses embedded SQLite. No PostgreSQL, MySQL, or other database server needed.</p>"},{"location":"getting-started/faq/#can-i-run-peek-and-stash-on-the-same-server","title":"Can I run Peek and Stash on the same server?","text":"<p>Yes, and this is recommended for best performance. They run as separate containers and don't conflict.</p>"},{"location":"getting-started/faq/#video-playback","title":"Video Playback","text":""},{"location":"getting-started/faq/#how-does-video-streaming-work","title":"How does video streaming work?","text":"<p>Peek proxies video streams directly through Stash. When you play a video in Peek, it fetches the stream from Stash's API and delivers it to your browser. This means:</p> <ul> <li>No local media access or path mapping needed</li> <li>Uses Stash's transcoding capabilities</li> <li>Quality options come from Stash</li> </ul>"},{"location":"getting-started/faq/#why-are-videos-loading-slowly","title":"Why are videos loading slowly?","text":"<p>Since Peek proxies streams from Stash, performance depends on:</p> <ul> <li>Network speed between Peek and Stash (same machine/LAN is best)</li> <li>Stash server's transcoding performance</li> <li>Your browser's network connection</li> </ul> <p>If videos are slow in Peek, check if they're also slow in Stash directly.</p>"},{"location":"getting-started/faq/#configuration","title":"Configuration","text":""},{"location":"getting-started/faq/#where-are-my-settings-stored","title":"Where are my settings stored?","text":"<ul> <li>User data: SQLite database in <code>/app/data/peek-stash-browser.db</code></li> <li>Server config: Environment variables</li> <li>Stash connection: Stored in database (configured via Setup Wizard)</li> </ul>"},{"location":"getting-started/faq/#how-do-i-backup-my-data","title":"How do I backup my data?","text":"<p>See Upgrading - Backup Procedure for detailed instructions.</p>"},{"location":"getting-started/faq/#can-i-customize-the-theme","title":"Can I customize the theme?","text":"<p>Yes! Peek includes built-in themes (Light, Dark, Deep Purple, The Hub) and a custom theme editor where you can create your own color schemes.</p>"},{"location":"getting-started/faq/#features","title":"Features","text":""},{"location":"getting-started/faq/#how-do-playlists-work","title":"How do playlists work?","text":"<p>Create custom playlists of your favorite scenes:</p> <ol> <li>Click Playlists in the navigation</li> <li>Click Create Playlist</li> <li>Add scenes using the + icon on scene cards</li> </ol> <p>See the Playlists Guide for details.</p>"},{"location":"getting-started/faq/#does-peek-track-watch-history","title":"Does Peek track watch history?","text":"<p>Yes! Peek automatically tracks your viewing progress and lets you resume playback. Features include:</p> <ul> <li>Automatic progress tracking</li> <li>Resume from any device</li> <li>\"Continue Watching\" section</li> <li>Progress bars on scene cards</li> </ul> <p>See the Watch History Guide for details.</p>"},{"location":"getting-started/faq/#can-i-use-keyboard-navigation","title":"Can I use keyboard navigation?","text":"<p>Yes! Peek supports keyboard navigation including arrow keys, Enter to select, and video player shortcuts.</p> <p>See the Keyboard Navigation Guide for all shortcuts.</p>"},{"location":"getting-started/faq/#what-about-tv-mode","title":"What about TV Mode?","text":"<p>TV Mode is a work-in-progress feature for couch/remote browsing. You can enable it from the user menu, but:</p> <ul> <li>Grid navigation works on most pages (Scenes, Performers, etc.)</li> <li>Some pages don't have full TV navigation yet</li> <li>Best experience is with a wireless keyboard</li> </ul> <p>TV Mode will be improved in future updates.</p>"},{"location":"getting-started/faq/#can-i-use-peek-on-mobile","title":"Can I use Peek on mobile?","text":"<p>Yes. The web interface is responsive and works on mobile browsers.</p>"},{"location":"getting-started/faq/#can-i-use-peek-without-stash","title":"Can I use Peek without Stash?","text":"<p>No. Peek requires a Stash server for media library management and streaming.</p>"},{"location":"getting-started/faq/#security","title":"Security","text":""},{"location":"getting-started/faq/#is-peek-secure","title":"Is Peek secure?","text":"<p>Peek includes JWT authentication, bcrypt password hashing, and session management.</p> <p>Important: Change the default admin password immediately after setup!</p>"},{"location":"getting-started/faq/#should-i-expose-peek-to-the-internet","title":"Should I expose Peek to the internet?","text":"<p>Not recommended without additional protection. For remote access:</p> <ul> <li>Use a VPN</li> <li>Use a reverse proxy with authentication (see Proxy Authentication)</li> <li>Don't expose directly to the internet</li> </ul>"},{"location":"getting-started/faq/#support","title":"Support","text":""},{"location":"getting-started/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Troubleshooting Guide</li> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul>"},{"location":"getting-started/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<ol> <li>Check the Troubleshooting Guide first</li> <li>Search existing issues</li> <li>Create a new issue with: Peek version, Stash version, logs, and steps to reproduce</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Peek Stash Browser can be deployed in several ways depending on your needs and environment.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Stash server with GraphQL API enabled and an API key configured (Settings \u2192 Security)</li> <li>Docker (or Docker on unRAID)</li> <li>Network access between Peek and Stash</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#option-1-unraid","title":"Option 1: unRAID","text":""},{"location":"getting-started/installation/#template-installation","title":"Template Installation","text":"<p>Step 1: Download the template file</p> <p>Get the template from GitHub:</p> <pre><code>https://raw.githubusercontent.com/carrotwaxr/peek-stash-browser/main/unraid-template.xml\n</code></pre> <p>Step 2: Install the template</p> USB/Boot Share Exported (Easier)USB/Boot Share NOT Exported <ol> <li>Copy <code>unraid-template.xml</code> to your network share at:    <pre><code>\\\\your.server.ip.address\\flash\\config\\plugins\\dockerMan\\templates-user\n</code></pre></li> <li>The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</li> </ol> <ol> <li>Copy <code>unraid-template.xml</code> to any accessible share (e.g., <code>\\\\your.server.ip.address\\downloads</code>)</li> <li>SSH into your unRAID server</li> <li>Move the template file:    <pre><code>cp /mnt/user/downloads/unraid-template.xml /boot/config/plugins/dockerMan/templates-user/\n</code></pre></li> <li>The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</li> </ol> <p>No Restart Required</p> <p>You do NOT need to restart Docker or unRAID - the template is picked up automatically.</p> <p>Step 3: Configure the container</p> <ol> <li>Go to Docker tab \u2192 Add Container</li> <li>Select \"Peek\" from User Templates dropdown</li> <li>Configure required settings:</li> <li>JWT Secret: Generate with <code>openssl rand -hex 32</code> in unRAID terminal</li> <li>App Data Directory: Path for Peek data (e.g., <code>/mnt/user/appdata/peek-stash-browser</code>)</li> <li>Click Apply</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> <li>Complete the Setup Wizard to connect to your Stash server</li> </ol> <p>Stash URL and API Key</p> <p>Leave the \"Stash GraphQL URL\" and \"Stash API Key\" fields blank for new installs - you'll configure these in the Setup Wizard. These fields are only shown for users migrating from v1.x.</p>"},{"location":"getting-started/installation/#option-2-docker-single-container","title":"Option 2: Docker (Single Container)","text":"<p>Recommended for Production</p> <p>Single container includes everything - frontend, backend, and database. Multi-architecture images are available for both AMD64 and ARM64 (Raspberry Pi, Apple Silicon, etc.).</p> <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Volume Mounts:</p> <ul> <li><code>peek-data</code> - Database and app data (Docker named volume)</li> </ul> <p>Required Environment Variables:</p> <ul> <li><code>JWT_SECRET</code> - Secret for JWT authentication (recommended to set manually)</li> </ul> <p>Note: Stash URL and API key are configured via the Setup Wizard on first access - no environment variables needed!</p> <p>See Configuration Guide for all environment variables.</p>"},{"location":"getting-started/installation/#windows-examples","title":"Windows Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret (one-time)\n$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n$jwt = [Convert]::ToBase64String($bytes)\n\n# Run Peek\ndocker run -d `\n    --name peek-stash-browser `\n    -p 6969:80 `\n    -v peek-data:/app/data `\n    -e JWT_SECRET=$jwt `\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#linuxmacos-examples","title":"Linux/macOS Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate a secure random JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n    --name peek-stash-browser \\\n    -p 6969:80 \\\n    -v peek-data:/app/data \\\n    -e JWT_SECRET=\"${JWT_SECRET}\" \\\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Follow logs in real-time\ndocker logs -f peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#first-access-setup-wizard","title":"First Access &amp; Setup Wizard","text":"<p>After installation, access Peek in your browser for the first-time setup:</p> <ol> <li>Navigate to <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 4-step setup wizard:</li> <li>Welcome: Introduction to Peek</li> <li>Create Admin: Set your admin username and password</li> <li>Connect to Stash: Enter your Stash URL and API key</li> <li>Complete: Setup finished!</li> <li>Login with your newly created admin credentials</li> </ol>"},{"location":"getting-started/installation/#updating-peek","title":"Updating Peek","text":""},{"location":"getting-started/installation/#check-for-updates","title":"Check for Updates","text":"<p>Peek includes a built-in update checker:</p> <ol> <li>Navigate to Settings \u2192 Server Settings</li> <li>Scroll to the Version Information section</li> <li>Click Check for Updates</li> </ol> <p>The system will query GitHub for new releases and notify you if an update is available.</p>"},{"location":"getting-started/installation/#update-procedure","title":"Update Procedure","text":"<p>To update your Docker container to the latest version:</p> unRAIDLinux/macOSWindows <p>Easiest method: Click Force Update in the Docker tab to pull the latest image and restart.</p> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d `\n  --name peek-stash-browser `\n  -p 6969:80 `\n  -v peek-data:/app/data `\n  -e JWT_SECRET=$jwt `\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Your data persists across updates</p> <p>Database, user settings, Stash configuration, and playlists are stored in the <code>peek-data</code> volume and will not be lost. For backup procedures and version-specific notes, see Upgrading Peek.</p>"},{"location":"getting-started/installation/#version-pinning","title":"Version Pinning","text":"<p>To use a specific version instead of <code>:latest</code>:</p> <pre><code># Pull and use specific version\ndocker pull carrotwaxr/peek-stash-browser:1.0.0\ndocker run ... carrotwaxr/peek-stash-browser:1.0.0\n</code></pre> <p>Available versions: GitHub Releases</p>"},{"location":"getting-started/installation/#port-configuration","title":"Port Configuration","text":"<p>Peek uses a single port for production deployments:</p> Port Service Description <code>6969</code> Complete App nginx serves frontend + proxies API <p>Development Ports</p> <p>For development setup with hot reloading, see Local Development Setup.</p> <p>Port Conflict with Whisparr</p> <p>Peek's default port (6969) is the same as Whisparr's default port. If you're running Whisparr, change Peek's port mapping:</p> <pre><code>-p 6970:80   # Use 6970 instead of 6969\n</code></pre>"},{"location":"getting-started/installation/#hardware-recommendations","title":"Hardware Recommendations","text":"<p>Peek is lightweight - it proxies streams through Stash rather than transcoding locally.</p> Component Minimum Recommended CPU 1 core 2+ cores RAM 512MB 1GB+ (for large libraries) Storage 100MB SSD for database (faster queries) Network 100 Mbps Gigabit (for 4K content)"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configure environment variables</li> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get Peek up and running in 5 minutes!</p>"},{"location":"getting-started/quick-start/#step-1-install-peek","title":"Step 1: Install Peek","text":"Docker (Fastest)unRAID <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Download the unRAID template</li> <li>Copy to <code>/boot/config/plugins/dockerMan/templates-user/</code></li> <li>Go to Docker \u2192 Add Container \u2192 Select \"Peek\" from User Templates</li> <li>Generate JWT secret: <code>openssl rand -hex 32</code></li> <li>Click Apply</li> </ol> <p>For Developers</p> <p>Want to contribute or run with hot reloading? See Local Development Setup.</p>"},{"location":"getting-started/quick-start/#step-2-setup-wizard","title":"Step 2: Setup Wizard","text":"<ol> <li>Open browser: <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 4-step setup wizard:</li> <li>Welcome - Introduction to Peek</li> <li>Create Admin - Set your admin username and password</li> <li>Connect to Stash - Enter your Stash URL and API key</li> <li>Complete - Setup finished!</li> </ol>"},{"location":"getting-started/quick-start/#step-3-browse-your-library","title":"Step 3: Browse Your Library","text":"<ul> <li>Scenes: Browse all your video content</li> <li>Performers: View performers and their scenes</li> <li>Studios: Explore by production company</li> <li>Tags: Find content by tags</li> </ul>"},{"location":"getting-started/quick-start/#step-4-watch-videos","title":"Step 4: Watch Videos","text":"<ol> <li>Click any scene to view details</li> <li>Click Play to start video</li> <li>Quality automatically adjusts based on network</li> <li>Use timeline to seek through video</li> </ol>"},{"location":"getting-started/quick-start/#step-5-create-playlists","title":"Step 5: Create Playlists","text":"<p>Organize your favorite scenes into custom playlists:</p> <ol> <li>Click Playlists in the navigation menu</li> <li>Click Create Playlist</li> <li>Enter a name and optional description</li> <li>Click Create</li> </ol> <p>Adding Scenes: - Click the + icon on any scene card - Select your playlist from the menu - Scene is added instantly!</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start playback - Use Shuffle to randomize order - Use Repeat to loop your playlist</p> <p>Learn More</p> <p>See the Complete Playlists Guide for reordering scenes, editing playlists, and more!</p>"},{"location":"getting-started/quick-start/#common-tasks","title":"Common Tasks","text":""},{"location":"getting-started/quick-start/#update-admin-password","title":"Update Admin Password","text":"<ol> <li>Click user icon (top right)</li> <li>Select Settings</li> <li>Enter new password</li> <li>Click Save</li> </ol>"},{"location":"getting-started/quick-start/#create-additional-users","title":"Create Additional Users","text":"<ol> <li>Go to Users (admin only)</li> <li>Click Create User</li> <li>Enter username, email, password</li> <li>Select role (Admin or User)</li> <li>Click Create</li> </ol>"},{"location":"getting-started/quick-start/#configure-theme","title":"Configure Theme","text":"<ol> <li>Click theme toggle icon (moon/sun)</li> <li>Choose Dark or Light mode</li> <li>Theme preference is saved automatically</li> </ol>"},{"location":"getting-started/quick-start/#video-playback-tips","title":"Video Playback Tips","text":"<ul> <li>Direct Play: If browser supports the format, plays directly (no transcoding)</li> <li>Transcoded: HLS streaming with adaptive quality when needed</li> <li>Seeking: Full timeline scrubbing works in both modes</li> <li>Quality: Click quality button to manually select resolution</li> </ul>"},{"location":"getting-started/quick-start/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Space</code> Play/Pause <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>\u2191</code> Volume up <code>\u2193</code> Volume down <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>Full Keyboard Navigation</p> <p>Peek supports complete keyboard navigation including TV mode! See the Keyboard Navigation Guide for all shortcuts.</p>"},{"location":"getting-started/quick-start/#troubleshooting-first-time-issues","title":"Troubleshooting First-Time Issues","text":""},{"location":"getting-started/quick-start/#cant-login","title":"Can't Login","text":"<ul> <li>Check container logs: <code>docker logs peek-stash-browser</code></li> <li>Verify database was created in <code>/app/data</code></li> <li>Ensure <code>JWT_SECRET</code> is set (or auto-generated)</li> </ul>"},{"location":"getting-started/quick-start/#no-scenes-showing","title":"No Scenes Showing","text":"<ul> <li>Check your Stash connection in Settings \u2192 Server Settings</li> <li>Verify your Stash API key is valid in Stash \u2192 Settings \u2192 Security</li> <li>Test Stash connectivity from container:   <pre><code>docker exec peek-stash-browser curl http://your-stash:9999/graphql\n</code></pre></li> </ul>"},{"location":"getting-started/quick-start/#videos-wont-play","title":"Videos Won't Play","text":"<ul> <li>Check container logs: <code>docker logs peek-stash-browser</code></li> <li>Verify Stash is accessible and streaming is working in Stash itself</li> <li>Check browser console for errors</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Full Configuration Guide</li> <li>Complete Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting Guide</li> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul>"},{"location":"getting-started/troubleshooting/","title":"Troubleshooting","text":"<p>Quick solutions for common issues with Peek.</p>"},{"location":"getting-started/troubleshooting/#network-setup","title":"Network Setup","text":"<p>For best performance, Peek and Stash should be on the same local network (ideally the same machine or Docker network). Peek proxies all video streams through Stash, so network latency directly affects playback performance.</p> <p>Recommended setup:</p> <ul> <li>Peek and Stash on the same Docker host</li> <li>Or: Same LAN with gigabit connection</li> <li>Avoid: Peek and Stash on different networks/VPNs</li> </ul>"},{"location":"getting-started/troubleshooting/#container-wont-start","title":"Container Won't Start","text":"<p>Check logs first:</p> <pre><code>docker logs peek-stash-browser\n</code></pre> <p>Common causes:</p> <ul> <li>Missing <code>JWT_SECRET</code> environment variable</li> <li>Port 6969 already in use</li> <li>Volume mount issues for <code>/app/data</code></li> </ul> <p>Solution: Recreate the container with correct configuration. See Installation.</p>"},{"location":"getting-started/troubleshooting/#cant-connect-to-stash","title":"Can't Connect to Stash","text":"<p>Symptoms: Empty library, \"Connection failed\" errors, sync fails.</p> <p>Test connectivity from Peek container:</p> <pre><code>docker exec peek-stash-browser curl -X POST http://your-stash-ip:9999/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"ApiKey: your-api-key\" \\\n  -d '{\"query\": \"{ findTags(filter: { per_page: 1 }) { count } }\"}'\n</code></pre> <p>Checklist:</p> <ul> <li> Stash URL is correct in Settings \u2192 Server Settings</li> <li> API key is valid (Stash \u2192 Settings \u2192 Security)</li> <li> Stash is reachable from Peek container (check Docker networking)</li> <li> No firewall blocking the connection</li> </ul>"},{"location":"getting-started/troubleshooting/#videos-wont-play","title":"Videos Won't Play","text":"<p>Peek proxies streams through Stash. If videos don't play:</p> <ol> <li>Test in Stash directly - Does the video play in Stash's web UI?</li> <li>Check Peek logs - <code>docker logs peek-stash-browser</code></li> <li>Check browser console - Press F12, look for errors</li> </ol> <p>If videos work in Stash but not Peek, check the Stash connection settings.</p>"},{"location":"getting-started/troubleshooting/#viewing-logs","title":"Viewing Logs","text":"<pre><code># All logs\ndocker logs peek-stash-browser\n\n# Follow logs (live)\ndocker logs -f peek-stash-browser\n\n# Last 100 lines\ndocker logs --tail 100 peek-stash-browser\n</code></pre>"},{"location":"getting-started/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If your container starts, connects to Stash, and the web UI loads - most things should work. For other issues:</p> <p>Before reporting:</p> <ol> <li>Check container logs for errors</li> <li>Check browser console (F12 \u2192 Console)</li> <li>Note your Peek version (Settings \u2192 Server Settings)</li> </ol> <p>Report issues:</p> <ul> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul> <p>Include: Peek version, Stash version, relevant logs, and steps to reproduce.</p>"},{"location":"getting-started/upgrading/","title":"Upgrading Peek","text":"<p>Most upgrades are automatic - just pull the latest image and restart. This page covers backup procedures and version-specific notes.</p>"},{"location":"getting-started/upgrading/#standard-update-procedure","title":"Standard Update Procedure","text":"<p>See Installation - Update Procedure for step-by-step instructions on updating your container.</p>"},{"location":"getting-started/upgrading/#backup-procedure","title":"Backup Procedure","text":"<p>Before major upgrades, back up your database. Your Peek database is a single SQLite file.</p> unRAIDDocker (Named Volume)Docker (Bind Mount) <ol> <li>Navigate to your Peek appdata folder (typically <code>/mnt/user/appdata/peek-stash-browser/</code>)</li> <li>Copy <code>peek-stash-browser.db</code> to a safe location</li> <li>Also copy <code>peek-stash-browser.db-wal</code> and <code>peek-stash-browser.db-shm</code> if they exist</li> </ol> <pre><code># Stop Peek for a clean backup\ndocker stop peek-stash-browser\n\n# Copy from named volume\ndocker run --rm -v peek-data:/data -v $(pwd):/backup alpine \\\n  cp /data/peek-stash-browser.db /backup/peek-stash-browser.db.backup\n\n# Restart\ndocker start peek-stash-browser\n</code></pre> <pre><code># Stop Peek for a clean backup\ndocker stop peek-stash-browser\n\n# Copy the database file\ncp /path/to/your/data/peek-stash-browser.db ./peek-stash-browser.db.backup\n\n# Restart\ndocker start peek-stash-browser\n</code></pre> <p>Hot Backup (While Running)</p> <p>If you can't stop the container: <pre><code>docker exec peek-stash-browser sqlite3 /app/data/peek-stash-browser.db \".backup '/app/data/backup.db'\"\ndocker cp peek-stash-browser:/app/data/backup.db ./peek-stash-browser.db.backup\n</code></pre></p>"},{"location":"getting-started/upgrading/#restore-from-backup","title":"Restore from Backup","text":"<pre><code># Stop Peek\ndocker stop peek-stash-browser\n\n# Replace database with backup\n# (adjust paths for your setup)\ncp ./peek-stash-browser.db.backup /path/to/data/peek-stash-browser.db\n\n# Restart\ndocker start peek-stash-browser\n</code></pre>"},{"location":"getting-started/upgrading/#version-notes","title":"Version Notes","text":""},{"location":"getting-started/upgrading/#version-310","title":"Version 3.1.0","text":"<p>Migration: Automatic. No user action required.</p> <ul> <li>New <code>UserExcludedEntity</code> table for pre-computed exclusions</li> <li>New indexes on image junction tables</li> <li>A full sync is triggered automatically to populate inherited tags on scenes</li> </ul>"},{"location":"getting-started/upgrading/#version-300","title":"Version 3.0.0","text":"<p>Migration: Automatic. No user action required.</p> <p>Major architectural change: Stash entity data is now stored in SQLite instead of memory.</p> <ul> <li>Scalability: Support for 100k+ scenes</li> <li>Performance: Sub-100ms query times</li> <li>Persistence: Library data survives restarts</li> </ul> <p>The initial sync after upgrading may take several minutes depending on library size.</p> <p>Upgrading from 3.0.0 Beta</p> <p>If upgrading from any v3.0.0-beta.x, run a Full Sync (Settings \u2192 Server Settings \u2192 Sync from Stash) to ensure all fields are populated.</p>"},{"location":"getting-started/upgrading/#version-200","title":"Version 2.0.0","text":"<p>Migration: Automatic. No user action required.</p> <ul> <li>Removed local FFmpeg transcoding - videos now stream directly through Stash</li> <li>Removed path mapping configuration</li> <li>STASH_URL and STASH_API_KEY environment variables auto-migrate to database</li> </ul>"},{"location":"getting-started/upgrading/#version-1x-to-2x","title":"Version 1.x to 2.x","text":"<p>Migration: Automatic. Schema updates are applied automatically on first start.</p>"},{"location":"getting-started/upgrading/#troubleshooting-upgrades","title":"Troubleshooting Upgrades","text":""},{"location":"getting-started/upgrading/#library-empty-after-upgrade","title":"Library empty after upgrade","text":"<p>The sync should start automatically. If empty after several minutes: 1. Check logs: <code>docker logs peek-stash-browser</code> 2. Manually trigger sync: Settings \u2192 Server Settings \u2192 Sync from Stash</p>"},{"location":"getting-started/upgrading/#migration-failed","title":"Migration failed","text":"<p>Check logs for the specific error: <pre><code>docker logs peek-stash-browser | grep -i migration\n</code></pre></p> <p>Common causes: - Disk full: Free up space and restart - Permission denied: Check volume mount permissions</p>"},{"location":"getting-started/upgrading/#sync-is-slow","title":"Sync is slow","text":"<p>The first sync after a major upgrade fetches all data from Stash. Subsequent syncs are incremental and much faster.</p>"},{"location":"getting-started/upgrading/#reporting-issues","title":"Reporting Issues","text":"<p>Found an upgrade bug? Report it:</p> <ul> <li>GitHub Issues</li> <li>Stash Discourse</li> </ul> <p>Include: Peek version, Stash version, library size, and relevant logs.</p>"},{"location":"plans/2024-12-23-3.0-polish-design/","title":"3.0 Polish - Design Document","text":"<p>Three minor issues to address before the 3.0 release.</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-1-long-filename-overflow-on-scene-cards","title":"Issue 1: Long Filename Overflow on Scene Cards","text":"<p>Problem: Filenames like <code>OnlyTarts.25.09.12.Isabella.De.Laa.Big.Wave.In.Her.Pussy.XXX.1080p.MP4-WRB[XC]</code> are unbroken strings that overflow the card boundaries because CSS doesn't know where to break them.</p> <p>Solution: Add <code>word-break: break-all</code> to the title element in <code>CardComponents.jsx</code>. This forces breaks anywhere in long strings, allowing the existing line-clamp and ellipsis to work correctly.</p> <p>File: <code>client/src/components/ui/CardComponents.jsx</code> (CardTitle component, around line 310)</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-2-text-search-fields","title":"Issue 2: Text Search Fields","text":"<p>Problem: Peek's text search doesn't match Stash's behavior. Stash searches more fields.</p> <p>Current state: - Scenes: <code>title</code>, <code>details</code> - Performers: <code>name</code>, <code>details</code> - Studios: <code>name</code>, <code>details</code> - Tags: <code>name</code></p> <p>Stash searches: - Scenes: <code>title</code>, <code>details</code>, <code>filepath</code>, <code>fingerprint</code>, <code>marker titles</code> - Performers: <code>name</code>, <code>aliases</code> - Studios: <code>name</code>, <code>aliases</code> - Tags: <code>name</code>, <code>aliases</code>, <code>sort_name</code></p> <p>Solution: - Scenes: Add <code>filepath</code> to search (requires SQL change in SceneQueryBuilder) - Performers: Add <code>aliases</code> (keep <code>details</code>) - Studios: Add <code>aliases</code> (keep <code>details</code>) - Tags: Add <code>aliases</code></p> <p>Files: - <code>server/services/SceneQueryBuilder.ts</code> - Add filepath to SQL LIKE query - <code>server/controllers/library/performers.ts</code> - Add aliases to filter - <code>server/controllers/library/studios.ts</code> - Add aliases to filter - <code>server/controllers/library/tags.ts</code> - Add aliases to filter</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-3-last-sync-time-not-updated-for-incremental-syncs","title":"Issue 3: Last Sync Time Not Updated for Incremental Syncs","text":"<p>Problem: The Server Settings page shows \"Last synced\" time, but it only reflects full syncs, not incremental/periodic syncs.</p> <p>Root cause: In <code>StashEntityService.getLastRefreshed()</code>: <pre><code>const syncState = await prisma.syncState.findFirst({\n  where: { entityType: \"scene\" },\n  orderBy: { lastFullSync: \"desc\" },  // Only orders by full sync\n});\nreturn syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n</code></pre></p> <p>The query orders by <code>lastFullSync</code> only, so if incremental syncs happen after a full sync, they're not reflected.</p> <p>Solution: Return whichever is more recent between <code>lastFullSync</code> and <code>lastIncrementalSync</code>. Compare both timestamps and return the later one.</p> <p>File: <code>server/services/StashEntityService.ts</code> (around line 1208)</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/","title":"3.0 Polish Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix three minor issues for the Peek 3.0 release: long filename overflow, text search fields (fixes #196), and last sync time display.</p> <p>Architecture: Small, targeted changes to existing components. No new files or major refactoring needed.</p> <p>Tech Stack: React (client), TypeScript/Express (server), SQLite via Prisma (database)</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-1-fix-long-filename-overflow-in-cardtitle","title":"Task 1: Fix Long Filename Overflow in CardTitle","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:308-322</code></p> <p>Step 1: Add word-break to title element</p> <p>In the <code>CardTitle</code> component, add <code>wordBreak: \"break-all\"</code> to the title <code>&lt;h3&gt;</code> style object.</p> <pre><code>const titleElement = (\n  &lt;h3\n    className=\"font-semibold leading-tight text-center\"\n    style={{\n      color: \"var(--text-primary)\",\n      height: titleHeight,\n      display: \"-webkit-box\",\n      WebkitLineClamp: maxTitleLines,\n      WebkitBoxOrient: \"vertical\",\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      wordBreak: \"break-all\",  // ADD THIS LINE\n    }}\n  &gt;\n    {title}\n  &lt;/h3&gt;\n);\n</code></pre> <p>Step 2: Verify visually</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code></p> <p>Test by viewing a scene card with a long unbroken filename like \"OnlyTarts.25.09.12.Isabella.De.Laa.Big.Wave.In.Her.Pussy.XXX.1080p.MP4-WRB\". The title should wrap and truncate with ellipsis instead of overflowing.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx\ngit commit -m \"fix: prevent long filename overflow in scene cards\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-2-add-filepath-to-scene-text-search-fixes-196","title":"Task 2: Add Filepath to Scene Text Search (Fixes #196)","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts:1048-1065</code> (first occurrence) - Modify: <code>server/controllers/library/scenes.ts:1105-1122</code> (second occurrence)</p> <p>Step 1: Add filePath to first search filter (lines 1048-1065)</p> <p>Find the scene text search filter around line 1048 and add <code>filePath</code> to the search:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  scenes = scenes.filter((s) =&gt; {\n    const title = s.title || \"\";\n    const details = s.details || \"\";\n    const filePath = s.files?.[0]?.path || \"\";  // ADD THIS LINE\n    const performers = (s.performers || [])\n      .map((p) =&gt; p.name || \"\")\n      .join(\" \");\n    const studio = s.studio?.name || \"\";\n    const tags = (s.tags || []).map((t) =&gt; t.name || \"\").join(\" \");\n\n    return (\n      title.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      filePath.toLowerCase().includes(lowerQuery) ||  // ADD THIS LINE\n      performers.toLowerCase().includes(lowerQuery) ||\n      studio.toLowerCase().includes(lowerQuery) ||\n      tags.toLowerCase().includes(lowerQuery)\n    );\n  });\n}\n</code></pre> <p>Step 2: Add filePath to second search filter (lines 1105-1122)</p> <p>Find the second occurrence around line 1105 and make the same change:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  scenes = scenes.filter((s) =&gt; {\n    const title = s.title || \"\";\n    const details = s.details || \"\";\n    const filePath = s.files?.[0]?.path || \"\";  // ADD THIS LINE\n    const performers = (s.performers || [])\n      .map((p) =&gt; p.name || \"\")\n      .join(\" \");\n    const studio = s.studio?.name || \"\";\n    const tags = (s.tags || []).map((t) =&gt; t.name || \"\").join(\" \");\n\n    return (\n      title.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      filePath.toLowerCase().includes(lowerQuery) ||  // ADD THIS LINE\n      performers.toLowerCase().includes(lowerQuery) ||\n      studio.toLowerCase().includes(lowerQuery) ||\n      tags.toLowerCase().includes(lowerQuery)\n    );\n  });\n}\n</code></pre> <p>Step 3: Run lint to check for errors</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"fix: include filepath in scene text search\n\nCloses #196\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-3-add-aliases-to-tag-text-search","title":"Task 3: Add Aliases to Tag Text Search","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts:284-292</code> (first occurrence) - Modify: <code>server/controllers/library/tags.ts:877-885</code> (second occurrence)</p> <p>Step 1: Add aliases to first search filter (lines 284-292)</p> <p>Find the tag text search filter around line 284 and add <code>aliases</code>:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  tags = tags.filter((t) =&gt; {\n    const name = t.name || \"\";\n    const description = t.description || \"\";\n    const aliases = (t.aliases || []).join(\" \");  // ADD THIS LINE\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      description.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD THIS LINE\n    );\n  });\n}\n</code></pre> <p>Step 2: Add aliases to second search filter (lines 877-885)</p> <p>Find the second occurrence around line 877 and make the same change:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  tags = tags.filter((t) =&gt; {\n    const name = t.name || \"\";\n    const description = t.description || \"\";\n    const aliases = (t.aliases || []).join(\" \");  // ADD THIS LINE\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      description.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD THIS LINE\n    );\n  });\n}\n</code></pre> <p>Step 3: Run lint to check for errors</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/tags.ts\ngit commit -m \"fix: include aliases in tag text search\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-4-add-aliases-to-studio-text-search","title":"Task 4: Add Aliases to Studio Text Search","text":"<p>Files: - Modify: <code>server/controllers/library/studios.ts:169-178</code> (first occurrence) - Modify: <code>server/controllers/library/studios.ts:528+</code> (second occurrence - findStudiosSimple)</p> <p>Note: Studios have an <code>aliases</code> field in Stash but Peek doesn't currently sync it. Check if the field exists on NormalizedStudio before adding. If not available, skip this task.</p> <p>Step 1: Check if aliases field exists</p> <p>Search for <code>aliases</code> in the studio type or data. If NormalizedStudio doesn't have aliases, this task should be skipped - adding it would require a schema migration and sync changes which is out of scope for this polish release.</p> <p>Step 2: If aliases exists, add to first search filter (lines 169-178)</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  studios = studios.filter((s) =&gt; {\n    const name = s.name || \"\";\n    const details = s.details || \"\";\n    const aliases = (s.aliases || []).join(\" \");  // ADD IF FIELD EXISTS\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD IF FIELD EXISTS\n    );\n  });\n}\n</code></pre> <p>Step 3: If aliases exists, add to second search filter</p> <p>Apply same change to the second occurrence.</p> <p>Step 4: Run lint and commit (if changes made)</p> <pre><code>git add server/controllers/library/studios.ts\ngit commit -m \"fix: include aliases in studio text search\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-5-fix-last-sync-time-to-show-most-recent-sync","title":"Task 5: Fix Last Sync Time to Show Most Recent Sync","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:1208-1215</code></p> <p>Step 1: Update getLastRefreshed to return most recent sync</p> <p>Replace the current <code>getLastRefreshed()</code> implementation:</p> <pre><code>/**\n * Get last refresh time\n */\nasync getLastRefreshed(): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: { entityType: \"scene\" },\n  });\n\n  if (!syncState) return null;\n\n  const { lastFullSync, lastIncrementalSync } = syncState;\n\n  // Return whichever sync happened more recently\n  if (!lastFullSync) return lastIncrementalSync;\n  if (!lastIncrementalSync) return lastFullSync;\n\n  return lastFullSync &gt; lastIncrementalSync ? lastFullSync : lastIncrementalSync;\n}\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --grep \"getLastRefreshed\"</code></p> <p>If there are existing tests for this function, they may need updating.</p> <p>Step 3: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"fix: show most recent sync time (full or incremental)\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-6-run-full-test-suite-and-verify","title":"Task 6: Run Full Test Suite and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass</p> <p>Step 2: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Build both client and server</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; cd ../server &amp;&amp; npm run build</code></p> <p>Expected: Both build successfully</p> <p>Step 4: Manual verification</p> <p>Start the app and verify: 1. Long filenames on scene cards wrap and truncate properly 2. Searching for a filename substring returns matching scenes 3. Searching for tag aliases returns matching tags 4. Server Settings page shows the correct last sync time after an incremental sync</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/#summary","title":"Summary","text":"Task Description Files Modified 1 Fix filename overflow <code>client/src/components/ui/CardComponents.jsx</code> 2 Add filepath to scene search (#196) <code>server/controllers/library/scenes.ts</code> 3 Add aliases to tag search <code>server/controllers/library/tags.ts</code> 4 Add aliases to studio search <code>server/controllers/library/studios.ts</code> (if field exists) 5 Fix last sync time display <code>server/services/StashEntityService.ts</code> 6 Verify all changes N/A"},{"location":"plans/2024-12-29-lightbox-enhancements-design/","title":"Lightbox Enhancements Design","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#overview","title":"Overview","text":"<p>Transform Peek's lightbox into a modern, multi-platform image viewer with touch gestures, immersive fullscreen, and accessible metadata.</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#goals","title":"Goals","text":"<ul> <li>Mobile-first touch navigation (swipe to navigate, swipe up for info)</li> <li>True fullscreen mode using Browser Fullscreen API</li> <li>Metadata drawer showing performers, tags, studio, and image details</li> <li>Tap-to-toggle controls for immersive viewing</li> <li>Consistent experience across mobile and desktop</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#user-feedback-sources","title":"User Feedback Sources","text":"<ul> <li>Discourse thread - TikTok-style viewing requests</li> <li>GitHub Issue #193 - Images page (implemented)</li> <li>Discord feedback from honeypotfields:</li> <li>Swipe instead of tap for navigation</li> <li>Hide titlebar/chrome in fullscreen</li> <li>Prevent orientation jump issues</li> <li>Gallery-relevant tags visible without menus</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-1-touch-gesture-navigation","title":"Feature 1: Touch Gesture Navigation","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#gesture-behaviors","title":"Gesture Behaviors","text":"Gesture Action Swipe left Next image Swipe right Previous image Swipe up Open metadata drawer Swipe down Close drawer (if open) or close lightbox Tap Toggle controls visibility"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#thresholds","title":"Thresholds","text":"<ul> <li>Horizontal swipe: 50px minimum, velocity &gt; 0.3</li> <li>Swipe up (drawer): 80px minimum (prevents accidental triggers)</li> <li>Swipe down (close): 100px when drawer closed, 50px when drawer open</li> <li>Diagonal swipes: Use dominant axis (greater delta wins)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Multi-touch ignored (reserved for future pinch-to-zoom)</li> <li>Scroll within drawer: Native scroll; swipe-to-dismiss only at scroll top</li> <li>Drawer open: Swipe down closes drawer first, not lightbox</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#library","title":"Library","text":"<p>Use <code>react-swipeable</code> (~3KB gzipped) for touch handling.</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-2-metadata-drawer","title":"Feature 2: Metadata Drawer","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#layout","title":"Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  (drag handle indicator)           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  [Title]                    [Rating] [O] [\u2764]    \u2502\n\u2502  Studio Name \u2022 Jan 15, 2024 \u2022 3840\u00d72160         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  PERFORMERS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  [avatar] [avatar] [avatar] \u2192 (horizontal scroll)\u2502\n\u2502   Name     Name     Name                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TAGS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  [Tag Chip] [Tag Chip] [Tag Chip] [+3 more]     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  DETAILS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  Description text if present...                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#styling-consistent-with-existing-patterns","title":"Styling (consistent with existing patterns)","text":"<ul> <li>Container: Bottom sheet, max-height 60vh mobile / 50vh desktop</li> <li>Background: <code>var(--bg-card)</code> with <code>rounded-t-lg</code></li> <li>Section headers: <code>text-sm font-semibold uppercase tracking-wide mb-3 pb-2</code> with <code>border-b-2 border-[var(--accent-primary)]</code></li> <li>Performers: Horizontal scroll, <code>w-[120px]</code> cards, <code>aspect-[2/3]</code> thumbnails, <code>gap-4</code></li> <li>Tags: <code>TagChips</code> component (colored pills, alphabetically sorted)</li> <li>Studio link: <code>hover:underline hover:text-blue-400</code></li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#triggers","title":"Triggers","text":"<ul> <li>Swipe up on image (mobile)</li> <li><code>i</code> hotkey (all platforms)</li> <li>Info button in controls (all platforms)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#dismiss","title":"Dismiss","text":"<ul> <li>Swipe down on drawer</li> <li>Tap outside drawer</li> <li><code>i</code> key (toggle)</li> <li>Escape key</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#interactivity","title":"Interactivity","text":"<ul> <li>Performers, tags, studio are clickable links (navigates to detail page, closes lightbox)</li> <li>Rating, O-counter, favorite are interactive within drawer</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-3-controls-overlay","title":"Feature 3: Controls Overlay","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#layout_1","title":"Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  [\u2715]                            [\u26f6] [i] \u2502  \u2190 Top bar\n\u2502                                         \u2502\n\u2502   \u25c4                               \u25ba     \u2502  \u2190 Side nav (desktop)\n\u2502                                         \u2502\n\u2502                                         \u2502\n\u2502  1 / 24    Title of Image    \u2328 hints   \u2502  \u2190 Bottom bar\n\u2502        [\u25b6 5s \u25bc]  [\u2605 7.2] [\ud83d\udca7 3] [\u2764]    \u2502  \u2190 Controls row\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#visibility-states","title":"Visibility States","text":"Context Default State Behavior Desktop Visible Auto-hide after 3s of no mouse movement Mobile Hidden Tap image to toggle Slideshow Hidden Auto-hide after 2s Interacting Visible Resets auto-hide timer"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-buttons","title":"New Buttons","text":"<ul> <li>Fullscreen [\u26f6]: Top-right, toggles Browser Fullscreen API</li> <li>Info [i]: Top-right, opens metadata drawer</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#button-styling","title":"Button Styling","text":"<ul> <li>Background: <code>rgba(0, 0, 0, 0.5)</code>, <code>hover:bg-opacity-70</code></li> <li>Icons: 24px (<code>w-6 h-6</code>), white with text shadow for contrast</li> <li>Consistent with existing lightbox controls</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-4-fullscreen-mode","title":"Feature 4: Fullscreen Mode","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#behavior","title":"Behavior","text":"<ul> <li>Uses <code>document.documentElement.requestFullscreen()</code> API</li> <li>Toggle via <code>f</code> key or fullscreen button</li> <li>Icon switches between expand/compress states</li> <li>Hides browser chrome entirely (address bar, tabs)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#escape-key-cascade","title":"Escape Key Cascade","text":"<ol> <li>If drawer open \u2192 close drawer</li> <li>Else if fullscreen \u2192 exit fullscreen</li> <li>Else \u2192 close lightbox</li> </ol>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#fallback","title":"Fallback","text":"<ul> <li>Hide fullscreen button on unsupported browsers</li> <li>Log warning to console</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#platform-notes","title":"Platform Notes","text":"<ul> <li>iOS Safari: Uses <code>webkitRequestFullscreen</code>, different behavior on iPhone vs iPad</li> <li>Test on real devices before release</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#complete-list","title":"Complete List","text":"Key Action \u2190 Previous image \u2192 Next image Space Toggle slideshow Escape Close (cascading: drawer \u2192 fullscreen \u2192 lightbox) <code>i</code> Toggle info drawer <code>f</code> Toggle fullscreen <code>r</code> then <code>1-5</code> Set rating (1-5 stars mapped to 20-100) <code>r</code> then <code>0</code> Clear rating <code>r</code> then <code>f</code> Toggle favorite"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#implementation","title":"Implementation","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-dependencies","title":"New Dependencies","text":"<pre><code>{\n  \"react-swipeable\": \"^7.0.0\"\n}\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>client/src/components/ui/Lightbox.jsx</code> - Add gestures, new controls, state management</li> <li><code>client/package.json</code> - Add react-swipeable dependency</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-files","title":"New Files","text":"File Purpose <code>client/src/components/ui/MetadataDrawer.jsx</code> Bottom sheet component <code>client/src/hooks/useSwipeGestures.js</code> Custom hook wrapping react-swipeable <code>client/src/hooks/useFullscreen.js</code> Fullscreen API hook with state sync"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#component-structure","title":"Component Structure","text":"<pre><code>&lt;Lightbox&gt;\n  &lt;SwipeableContainer&gt;\n    &lt;ControlsOverlay visible={controlsVisible}&gt;\n      &lt;TopBar&gt;\n        &lt;CloseButton /&gt;\n        &lt;FullscreenButton /&gt;\n        &lt;InfoButton /&gt;\n      &lt;/TopBar&gt;\n      &lt;SideNav /&gt;           {/* Desktop only */}\n      &lt;BottomBar&gt;\n        &lt;ImageCounter /&gt;\n        &lt;ImageTitle /&gt;\n        &lt;SlideshowControls /&gt;\n        &lt;RatingBadge /&gt;\n        &lt;OCounterButton /&gt;\n        &lt;FavoriteButton /&gt;\n      &lt;/BottomBar&gt;\n    &lt;/ControlsOverlay&gt;\n    &lt;ImageContainer /&gt;\n  &lt;/SwipeableContainer&gt;\n  &lt;MetadataDrawer\n    open={drawerOpen}\n    image={currentImage}\n    onClose={() =&gt; setDrawerOpen(false)}\n  /&gt;\n&lt;/Lightbox&gt;\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#state-management","title":"State Management","text":"<pre><code>// New state\nconst [controlsVisible, setControlsVisible] = useState(true);\nconst [drawerOpen, setDrawerOpen] = useState(false);\nconst { isFullscreen, toggleFullscreen } = useFullscreen();\n\n// Existing state (preserved)\nconst [currentIndex, setCurrentIndex] = useState(initialIndex);\nconst [isPlaying, setIsPlaying] = useState(autoPlay);\nconst [intervalDuration, setIntervalDuration] = useState(5000);\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#testing-notes","title":"Testing Notes","text":"<ul> <li>Gesture thresholds need real device testing</li> <li>Fullscreen API requires user gesture (cannot auto-trigger)</li> <li>iOS Safari fullscreen behaves differently than Chrome/Firefox</li> <li>Test orientation changes don't cause layout jumps</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#future-enhancements-out-of-scope","title":"Future Enhancements (Out of Scope)","text":"<p>These were discussed but deferred for later consideration:</p> <ul> <li>Pinch-to-zoom: Multi-touch gesture for image zoom/pan</li> <li>Smart sidebar: Desktop-only side panel using pillarbox space for metadata</li> <li>Persistent defaults: User preferences for grid layout, sort order, items per page</li> <li>Tag quick-filters: Tap tag in drawer to filter gallery by that tag</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/","title":"Lightbox Enhancements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add touch gestures, metadata drawer, fullscreen mode, and tap-to-toggle controls to the Lightbox component.</p> <p>Architecture: Extend existing Lightbox.jsx with new hooks for gestures and fullscreen. Create a MetadataDrawer component for the bottom sheet. Use react-swipeable for touch handling.</p> <p>Tech Stack: React 19, react-swipeable, Tailwind CSS, lucide-react icons</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-1-add-react-swipeable-dependency","title":"Task 1: Add react-swipeable dependency","text":"<p>Files: - Modify: <code>client/package.json</code></p> <p>Step 1: Install react-swipeable</p> <p>Run: <pre><code>cd client &amp;&amp; npm install react-swipeable\n</code></pre></p> <p>Expected: Package added to dependencies</p> <p>Step 2: Verify installation</p> <p>Run: <pre><code>cd client &amp;&amp; npm ls react-swipeable\n</code></pre></p> <p>Expected: Shows react-swipeable@7.x.x</p> <p>Step 3: Commit</p> <pre><code>git add client/package.json client/package-lock.json\ngit commit -m \"chore: add react-swipeable dependency\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-2-create-usefullscreen-hook","title":"Task 2: Create useFullscreen hook","text":"<p>Files: - Create: <code>client/src/hooks/useFullscreen.js</code></p> <p>Step 1: Write the hook</p> <pre><code>import { useCallback, useEffect, useState } from \"react\";\n\n/**\n * Hook to manage browser fullscreen state\n * @returns {{ isFullscreen: boolean, toggleFullscreen: () =&gt; void, supportsFullscreen: boolean }}\n */\nexport function useFullscreen() {\n  const [isFullscreen, setIsFullscreen] = useState(false);\n\n  const supportsFullscreen = Boolean(\n    document.fullscreenEnabled ||\n      document.webkitFullscreenEnabled ||\n      document.mozFullScreenEnabled ||\n      document.msFullscreenEnabled\n  );\n\n  useEffect(() =&gt; {\n    const handleFullscreenChange = () =&gt; {\n      setIsFullscreen(Boolean(document.fullscreenElement));\n    };\n\n    document.addEventListener(\"fullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"webkitfullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"mozfullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"MSFullscreenChange\", handleFullscreenChange);\n\n    return () =&gt; {\n      document.removeEventListener(\"fullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"webkitfullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"mozfullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"MSFullscreenChange\", handleFullscreenChange);\n    };\n  }, []);\n\n  const toggleFullscreen = useCallback(async () =&gt; {\n    try {\n      if (!document.fullscreenElement) {\n        const elem = document.documentElement;\n        if (elem.requestFullscreen) {\n          await elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) {\n          await elem.webkitRequestFullscreen();\n        } else if (elem.mozRequestFullScreen) {\n          await elem.mozRequestFullScreen();\n        } else if (elem.msRequestFullscreen) {\n          await elem.msRequestFullscreen();\n        }\n      } else {\n        if (document.exitFullscreen) {\n          await document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n          await document.webkitExitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n          await document.mozCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n          await document.msExitFullscreen();\n        }\n      }\n    } catch (err) {\n      console.warn(\"Fullscreen toggle failed:\", err);\n    }\n  }, []);\n\n  return { isFullscreen, toggleFullscreen, supportsFullscreen };\n}\n</code></pre> <p>Step 2: Verify file exists</p> <p>Run: <pre><code>ls -la client/src/hooks/useFullscreen.js\n</code></pre></p> <p>Expected: File exists</p> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/useFullscreen.js\ngit commit -m \"feat: add useFullscreen hook for browser fullscreen API\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-3-create-metadatadrawer-component","title":"Task 3: Create MetadataDrawer component","text":"<p>Files: - Create: <code>client/src/components/ui/MetadataDrawer.jsx</code></p> <p>Step 1: Write the component</p> <pre><code>import { Link } from \"react-router-dom\";\nimport { X } from \"lucide-react\";\nimport TagChips from \"./TagChips.jsx\";\nimport RatingBadge from \"./RatingBadge.jsx\";\nimport OCounterButton from \"./OCounterButton.jsx\";\nimport FavoriteButton from \"./FavoriteButton.jsx\";\n\n/**\n * Bottom sheet drawer displaying image metadata\n */\nconst MetadataDrawer = ({\n  open,\n  onClose,\n  image,\n  rating,\n  isFavorite,\n  oCounter,\n  onRatingClick,\n  onFavoriteChange,\n  onOCounterChange,\n}) =&gt; {\n  if (!open || !image) return null;\n\n  const studio = image.studio;\n  const performers = image.performers || [];\n  const tags = image.tags || [];\n  const date = image.date\n    ? new Date(image.date).toLocaleDateString()\n    : null;\n  const resolution =\n    image.width &amp;&amp; image.height ? `${image.width}\u00d7${image.height}` : null;\n\n  // Build subtitle parts\n  const subtitleParts = [studio?.name, date, resolution].filter(Boolean);\n  const subtitle = subtitleParts.join(\" \u2022 \");\n\n  return (\n    &lt;&gt;\n      {/* Backdrop */}\n      &lt;div\n        className=\"fixed inset-0 z-50\"\n        onClick={onClose}\n        aria-hidden=\"true\"\n      /&gt;\n\n      {/* Drawer */}\n      &lt;div\n        className=\"fixed bottom-0 left-0 right-0 z-50 rounded-t-lg overflow-hidden\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          maxHeight: \"60vh\",\n        }}\n        onClick={(e) =&gt; e.stopPropagation()}\n      &gt;\n        {/* Drag handle */}\n        &lt;div className=\"flex justify-center py-3\"&gt;\n          &lt;div\n            className=\"w-10 h-1 rounded-full\"\n            style={{ backgroundColor: \"var(--text-muted)\" }}\n          /&gt;\n        &lt;/div&gt;\n\n        {/* Scrollable content */}\n        &lt;div\n          className=\"overflow-y-auto px-4 pb-6\"\n          style={{ maxHeight: \"calc(60vh - 40px)\" }}\n        &gt;\n          {/* Header row: Title + controls */}\n          &lt;div className=\"flex items-start justify-between gap-4 mb-2\"&gt;\n            &lt;h2\n              className=\"text-lg font-semibold line-clamp-2 flex-1\"\n              style={{ color: \"var(--text-primary)\" }}\n            &gt;\n              {image.title || \"Untitled\"}\n            &lt;/h2&gt;\n            &lt;div className=\"flex items-center gap-2 flex-shrink-0\"&gt;\n              &lt;RatingBadge\n                rating={rating}\n                onClick={onRatingClick}\n                size=\"medium\"\n              /&gt;\n              &lt;OCounterButton\n                imageId={image.id}\n                initialCount={oCounter}\n                onChange={onOCounterChange}\n                size=\"medium\"\n                variant=\"card\"\n                interactive={true}\n              /&gt;\n              &lt;FavoriteButton\n                isFavorite={isFavorite}\n                onChange={onFavoriteChange}\n                size=\"medium\"\n                variant=\"card\"\n              /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          {/* Subtitle: Studio \u2022 Date \u2022 Resolution */}\n          {subtitle &amp;&amp; (\n            &lt;p\n              className=\"text-sm mb-4\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              {studio ? (\n                &lt;Link\n                  to={`/studio/${studio.id}`}\n                  className=\"hover:underline hover:text-blue-400\"\n                  onClick={onClose}\n                &gt;\n                  {studio.name}\n                &lt;/Link&gt;\n              ) : null}\n              {studio &amp;&amp; (date || resolution) ? \" \u2022 \" : null}\n              {date}\n              {date &amp;&amp; resolution ? \" \u2022 \" : null}\n              {resolution}\n            &lt;/p&gt;\n          )}\n\n          {/* Performers section */}\n          {performers.length &gt; 0 &amp;&amp; (\n            &lt;div className=\"mb-4\"&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Performers\n              &lt;/h3&gt;\n              &lt;div\n                className=\"flex gap-4 overflow-x-auto pb-2 scroll-smooth\"\n                style={{ scrollbarWidth: \"thin\" }}\n              &gt;\n                {performers.map((performer) =&gt; (\n                  &lt;Link\n                    key={performer.id}\n                    to={`/performer/${performer.id}`}\n                    className=\"flex flex-col items-center flex-shrink-0 group w-[120px]\"\n                    onClick={onClose}\n                  &gt;\n                    &lt;div\n                      className=\"aspect-[2/3] rounded-lg overflow-hidden mb-2 w-full border-2 border-transparent group-hover:border-[var(--accent-primary)] transition-all\"\n                      style={{ backgroundColor: \"var(--border-color)\" }}\n                    &gt;\n                      {performer.image_path ? (\n                        &lt;img\n                          src={performer.image_path}\n                          alt={performer.name}\n                          className=\"w-full h-full object-cover\"\n                        /&gt;\n                      ) : (\n                        &lt;div className=\"w-full h-full flex items-center justify-center\"&gt;\n                          &lt;span\n                            className=\"text-4xl\"\n                            style={{ color: \"var(--text-secondary)\" }}\n                          &gt;\n                            {performer.gender === \"MALE\" ? \"\u2642\" : \"\u2640\"}\n                          &lt;/span&gt;\n                        &lt;/div&gt;\n                      )}\n                    &lt;/div&gt;\n                    &lt;span\n                      className=\"text-xs font-medium text-center w-full line-clamp-2 group-hover:underline\"\n                      style={{ color: \"var(--text-primary)\" }}\n                    &gt;\n                      {performer.name}\n                    &lt;/span&gt;\n                  &lt;/Link&gt;\n                ))}\n              &lt;/div&gt;\n            &lt;/div&gt;\n          )}\n\n          {/* Tags section */}\n          {tags.length &gt; 0 &amp;&amp; (\n            &lt;div className=\"mb-4\"&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Tags\n              &lt;/h3&gt;\n              &lt;TagChips tags={tags} /&gt;\n            &lt;/div&gt;\n          )}\n\n          {/* Details section (if description exists) */}\n          {image.details &amp;&amp; (\n            &lt;div&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Details\n              &lt;/h3&gt;\n              &lt;p\n                className=\"text-sm leading-relaxed\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                {image.details}\n              &lt;/p&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n};\n\nexport default MetadataDrawer;\n</code></pre> <p>Step 2: Verify file exists</p> <p>Run: <pre><code>ls -la client/src/components/ui/MetadataDrawer.jsx\n</code></pre></p> <p>Expected: File exists</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/MetadataDrawer.jsx\ngit commit -m \"feat: add MetadataDrawer component for image metadata display\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-4-add-swipe-gestures-to-lightbox","title":"Task 4: Add swipe gestures to Lightbox","text":"<p>Files: - Modify: <code>client/src/components/ui/Lightbox.jsx</code></p> <p>Step 1: Add imports at top of file</p> <p>Add after existing imports:</p> <pre><code>import { useSwipeable } from \"react-swipeable\";\nimport { Info, Maximize, Minimize } from \"lucide-react\";\nimport { useFullscreen } from \"../../hooks/useFullscreen.js\";\nimport MetadataDrawer from \"./MetadataDrawer.jsx\";\n</code></pre> <p>Step 2: Add new state variables after existing state</p> <p>Add after <code>const [isRatingPopoverOpen, setIsRatingPopoverOpen] = useState(false);</code>:</p> <pre><code>// New state for enhanced features\nconst [controlsVisible, setControlsVisible] = useState(true);\nconst [drawerOpen, setDrawerOpen] = useState(false);\nconst { isFullscreen, toggleFullscreen, supportsFullscreen } = useFullscreen();\nconst controlsTimeoutRef = useRef(null);\n</code></pre> <p>Step 3: Add controls auto-hide logic</p> <p>Add after the controlsTimeoutRef declaration:</p> <pre><code>// Auto-hide controls after inactivity\nconst showControls = useCallback(() =&gt; {\n  setControlsVisible(true);\n  if (controlsTimeoutRef.current) {\n    clearTimeout(controlsTimeoutRef.current);\n  }\n  controlsTimeoutRef.current = setTimeout(() =&gt; {\n    if (!drawerOpen &amp;&amp; !isRatingPopoverOpen) {\n      setControlsVisible(false);\n    }\n  }, 3000);\n}, [drawerOpen, isRatingPopoverOpen]);\n\n// Reset auto-hide on mouse movement (desktop)\nconst handleMouseMove = useCallback(() =&gt; {\n  showControls();\n}, [showControls]);\n\n// Toggle controls on tap (mobile)\nconst handleTap = useCallback(() =&gt; {\n  setControlsVisible((prev) =&gt; !prev);\n}, []);\n</code></pre> <p>Step 4: Add swipe handlers</p> <p>Add after handleTap:</p> <pre><code>// Swipe gesture handlers\nconst swipeHandlers = useSwipeable({\n  onSwipedLeft: () =&gt; goToNext(),\n  onSwipedRight: () =&gt; goToPrevious(),\n  onSwipedUp: () =&gt; setDrawerOpen(true),\n  onSwipedDown: () =&gt; {\n    if (drawerOpen) {\n      setDrawerOpen(false);\n    } else {\n      onClose();\n    }\n  },\n  onTap: handleTap,\n  delta: 50,\n  preventScrollOnSwipe: true,\n  trackMouse: false,\n});\n</code></pre> <p>Step 5: Update keyboard handler for new shortcuts</p> <p>Replace the existing keyboard handler <code>useEffect</code> (lines 206-231) with:</p> <pre><code>// Keyboard controls\nuseEffect(() =&gt; {\n  if (!isOpen) return;\n\n  const handleKeyDown = (e) =&gt; {\n    // Ignore if typing in an input\n    if (e.target.tagName === \"INPUT\" || e.target.tagName === \"TEXTAREA\") return;\n\n    switch (e.key) {\n      case \"Escape\":\n        if (drawerOpen) {\n          setDrawerOpen(false);\n        } else if (isFullscreen) {\n          // Browser handles fullscreen exit, but we track state\n        } else {\n          onClose();\n        }\n        break;\n      case \"ArrowLeft\":\n        goToPrevious();\n        break;\n      case \"ArrowRight\":\n        goToNext();\n        break;\n      case \" \":\n        e.preventDefault();\n        toggleSlideshow();\n        break;\n      case \"i\":\n      case \"I\":\n        setDrawerOpen((prev) =&gt; !prev);\n        break;\n      case \"f\":\n      case \"F\":\n        toggleFullscreen();\n        break;\n      default:\n        break;\n    }\n    showControls();\n  };\n\n  window.addEventListener(\"keydown\", handleKeyDown);\n  return () =&gt; window.removeEventListener(\"keydown\", handleKeyDown);\n}, [isOpen, onClose, goToPrevious, goToNext, toggleSlideshow, drawerOpen, isFullscreen, toggleFullscreen, showControls]);\n</code></pre> <p>Step 6: Clean up timeout on unmount</p> <p>Add after the keyboard useEffect:</p> <pre><code>// Cleanup controls timeout\nuseEffect(() =&gt; {\n  return () =&gt; {\n    if (controlsTimeoutRef.current) {\n      clearTimeout(controlsTimeoutRef.current);\n    }\n  };\n}, []);\n</code></pre> <p>Step 7: Wrap the main container with swipe handlers</p> <p>Replace the opening <code>&lt;div</code> (line 253-258) with:</p> <pre><code>&lt;div\n  {...swipeHandlers}\n  className=\"fixed inset-0 z-50 flex items-center justify-center\"\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.95)\",\n  }}\n  onMouseMove={handleMouseMove}\n  onClick={onClose}\n&gt;\n</code></pre> <p>Step 8: Add controls visibility wrapper and new buttons</p> <p>Replace the close button section (lines 261-271) with:</p> <pre><code>{/* Top controls bar */}\n&lt;div\n  className={`absolute top-4 left-4 right-4 z-50 flex justify-between items-center transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n&gt;\n  {/* Left side - empty for balance */}\n  &lt;div /&gt;\n\n  {/* Right side controls */}\n  &lt;div className=\"flex items-center gap-2\"&gt;\n    {/* Info button */}\n    &lt;button\n      onClick={(e) =&gt; {\n        e.stopPropagation();\n        setDrawerOpen(true);\n      }}\n      className=\"p-2 rounded-full transition-colors\"\n      style={{\n        backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n        color: \"var(--text-primary)\",\n      }}\n      aria-label=\"Show image info\"\n    &gt;\n      &lt;Info size={24} /&gt;\n    &lt;/button&gt;\n\n    {/* Fullscreen button */}\n    {supportsFullscreen &amp;&amp; (\n      &lt;button\n        onClick={(e) =&gt; {\n          e.stopPropagation();\n          toggleFullscreen();\n        }}\n        className=\"p-2 rounded-full transition-colors\"\n        style={{\n          backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n          color: \"var(--text-primary)\",\n        }}\n        aria-label={isFullscreen ? \"Exit fullscreen\" : \"Enter fullscreen\"}\n      &gt;\n        {isFullscreen ? &lt;Minimize size={24} /&gt; : &lt;Maximize size={24} /&gt;}\n      &lt;/button&gt;\n    )}\n\n    {/* Close button */}\n    &lt;button\n      onClick={onClose}\n      className=\"p-2 rounded-full transition-colors\"\n      style={{\n        backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n        color: \"var(--text-primary)\",\n      }}\n      aria-label=\"Close lightbox\"\n    &gt;\n      &lt;X size={24} /&gt;\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 9: Wrap existing bottom controls with visibility</p> <p>Wrap the image counter (lines 273-282), compact controls (lines 284-403), and keyboard hints (lines 494-505) with the visibility class.</p> <p>For the image counter, change to:</p> <pre><code>{/* Image counter - bottom left */}\n&lt;div\n  className={`absolute bottom-4 left-4 z-50 px-4 py-2 rounded-lg text-lg font-medium transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    color: \"var(--text-primary)\",\n  }}\n&gt;\n  {currentIndex + 1} / {images.length}\n&lt;/div&gt;\n</code></pre> <p>For the compact controls row (slideshow, rating, etc), wrap with:</p> <pre><code>{/* Compact controls - positioned to the right */}\n&lt;div className={`absolute top-16 right-4 z-50 flex items-center gap-3 transition-opacity duration-300 ${\n  controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n}`}&gt;\n</code></pre> <p>For the keyboard hints, change to:</p> <pre><code>{/* Keyboard hints */}\n&lt;div\n  className={`absolute bottom-4 right-4 z-50 px-3 py-2 rounded-lg text-xs transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    color: \"var(--text-muted)\",\n  }}\n&gt;\n  &lt;div&gt;\u2190 \u2192 Navigate&lt;/div&gt;\n  &lt;div&gt;Space Slideshow&lt;/div&gt;\n  &lt;div&gt;i Info \u2022 f Fullscreen&lt;/div&gt;\n  &lt;div&gt;Esc Close&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 10: Wrap navigation buttons with visibility</p> <p>For both Previous and Next buttons, add the visibility class:</p> <pre><code>{/* Previous button */}\n{images.length &gt; 1 &amp;&amp; (\n  &lt;button\n    onClick={(e) =&gt; {\n      e.stopPropagation();\n      goToPrevious();\n    }}\n    className={`absolute left-4 top-1/2 transform -translate-y-1/2 z-50 p-3 rounded-full transition-all duration-300 ${\n      controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n    }`}\n    style={{\n      backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n      color: \"var(--text-primary)\",\n    }}\n    aria-label=\"Previous image\"\n  &gt;\n    &lt;ChevronLeft size={32} /&gt;\n  &lt;/button&gt;\n)}\n</code></pre> <p>(Same pattern for Next button)</p> <p>Step 11: Add MetadataDrawer at end of component</p> <p>Before the closing <code>&lt;/div&gt;</code> of the main container, add:</p> <pre><code>{/* Metadata Drawer */}\n&lt;MetadataDrawer\n  open={drawerOpen}\n  onClose={() =&gt; setDrawerOpen(false)}\n  image={currentImage}\n  rating={rating}\n  isFavorite={isFavorite}\n  oCounter={oCounter}\n  onRatingClick={() =&gt; setIsRatingPopoverOpen(true)}\n  onFavoriteChange={handleFavoriteChange}\n  onOCounterChange={handleOCounterChange}\n/&gt;\n</code></pre> <p>Step 12: Verify lint passes</p> <p>Run: <pre><code>cd client &amp;&amp; npm run lint\n</code></pre></p> <p>Expected: No errors</p> <p>Step 13: Commit</p> <pre><code>git add client/src/components/ui/Lightbox.jsx\ngit commit -m \"feat: add swipe gestures, fullscreen, and metadata drawer to Lightbox\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-5-manual-testing-checklist","title":"Task 5: Manual Testing Checklist","text":"<p>Files: None (testing only)</p> <p>Step 1: Start dev server</p> <p>Run: <pre><code>cd client &amp;&amp; npm run dev\n</code></pre></p> <p>Step 2: Test on desktop browser</p> <ul> <li> Open any gallery and click an image to open lightbox</li> <li> Press <code>i</code> key - drawer should open</li> <li> Press <code>i</code> again - drawer should close</li> <li> Press <code>f</code> key - should go fullscreen</li> <li> Press <code>f</code> again - should exit fullscreen</li> <li> Press <code>Escape</code> with drawer open - drawer closes, lightbox stays</li> <li> Press <code>Escape</code> with drawer closed - lightbox closes</li> <li> Click Info button - drawer opens</li> <li> Click Fullscreen button - goes fullscreen</li> <li> Mouse movement resets auto-hide timer</li> <li> After 3s of no mouse movement, controls fade out</li> <li> Click on image toggles controls visibility</li> </ul> <p>Step 3: Test on mobile (or Chrome DevTools mobile emulation)</p> <ul> <li> Swipe left - next image</li> <li> Swipe right - previous image</li> <li> Swipe up - drawer opens</li> <li> Swipe down (drawer open) - drawer closes</li> <li> Swipe down (drawer closed) - lightbox closes</li> <li> Tap image - controls toggle</li> <li> Performers in drawer are horizontally scrollable</li> <li> Tags in drawer display correctly</li> <li> Clicking performer/tag link closes lightbox and navigates</li> </ul> <p>Step 4: Test edge cases</p> <ul> <li> Lightbox with single image - no nav arrows</li> <li> Image without performers - no performers section in drawer</li> <li> Image without tags - no tags section in drawer</li> <li> Image without studio - subtitle shows only date/resolution</li> <li> Rating/favorite/O-counter work in drawer</li> </ul> <p>Step 5: Commit any fixes found during testing</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during lightbox testing\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-6-final-cleanup-and-pr-preparation","title":"Task 6: Final cleanup and PR preparation","text":"<p>Files: - Modify: <code>docs/plans/2024-12-29-lightbox-enhancements-design.md</code> (add implementation notes)</p> <p>Step 1: Run full lint check</p> <p>Run: <pre><code>cd client &amp;&amp; npm run lint\n</code></pre></p> <p>Expected: No errors</p> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd client &amp;&amp; npm run test:run\n</code></pre></p> <p>Expected: All tests pass</p> <p>Step 3: Build check</p> <p>Run: <pre><code>cd client &amp;&amp; npm run build\n</code></pre></p> <p>Expected: Build succeeds</p> <p>Step 4: Commit any final fixes</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup for lightbox enhancements\"\n</code></pre> <p>Step 5: Push branch</p> <pre><code>git push -u origin feature/lightbox-enhancements-design\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#summary","title":"Summary","text":"Task Description Est. Complexity 1 Add react-swipeable dependency Low 2 Create useFullscreen hook Low 3 Create MetadataDrawer component Medium 4 Add swipe gestures to Lightbox High 5 Manual testing Medium 6 Final cleanup and PR Low <p>Total: 6 tasks with frequent commits for easy rollback if needed.</p>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/","title":"View Tracking &amp; Request Cancellation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix duplicate image view tracking in React Strict Mode and add request cancellation for search pages.</p> <p>Architecture: Two independent fixes: (1) Replace immediate view tracking with 3-second dwell timer in Lightbox; (2) Create <code>useCancellableQuery</code> hook with AbortController support, update API layer to pass signals, refactor 7 search pages to use the hook.</p> <p>Tech Stack: React hooks, AbortController, fetch API</p>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-1-fix-dwell-time-view-tracking-in-lightbox","title":"Task 1: Fix Dwell-Time View Tracking in Lightbox","text":"<p>Files: - Modify: <code>client/src/components/ui/Lightbox.jsx:21</code> (add ref) - Modify: <code>client/src/components/ui/Lightbox.jsx:209-218</code> (replace effect)</p> <p>Step 1: Add viewTimerRef</p> <p>After line 21 (<code>const intervalRef = useRef(null);</code>), add:</p> <pre><code>const viewTimerRef = useRef(null);\n</code></pre> <p>Step 2: Replace the view tracking useEffect</p> <p>Find this effect (around lines 209-218):</p> <pre><code>// Track image view when image changes in lightbox\nuseEffect(() =&gt; {\n  const currentImage = images[currentIndex];\n  if (!currentImage?.id || !isOpen) return;\n\n  // Record the view (fire and forget - don't block UI)\n  imageViewHistoryApi.recordView(currentImage.id).catch((err) =&gt; {\n    console.error(\"Failed to record image view:\", err);\n  });\n}, [currentIndex, images, isOpen]);\n</code></pre> <p>Replace with:</p> <pre><code>// Track image view with 3-second dwell time\n// Only records if user views image for 3+ seconds (filters rapid navigation)\nuseEffect(() =&gt; {\n  const currentImage = images[currentIndex];\n\n  // Clear any existing timer\n  if (viewTimerRef.current) {\n    clearTimeout(viewTimerRef.current);\n    viewTimerRef.current = null;\n  }\n\n  if (!currentImage?.id || !isOpen) return;\n\n  // Start 3-second dwell timer\n  viewTimerRef.current = setTimeout(() =&gt; {\n    imageViewHistoryApi.recordView(currentImage.id).catch((err) =&gt; {\n      console.error(\"Failed to record image view:\", err);\n    });\n    viewTimerRef.current = null;\n  }, 3000);\n\n  // Cleanup on navigation/close\n  return () =&gt; {\n    if (viewTimerRef.current) {\n      clearTimeout(viewTimerRef.current);\n      viewTimerRef.current = null;\n    }\n  };\n}, [currentIndex, images, isOpen]);\n</code></pre> <p>Step 3: Test manually</p> <ul> <li>Open lightbox, navigate quickly through images \u2192 Network tab should show no view API calls</li> <li>Open lightbox, stay on image for 4 seconds \u2192 Network tab should show exactly 1 view call</li> <li>In dev mode (Strict Mode), verify no duplicate calls</li> </ul> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/Lightbox.jsx\ngit commit -m \"fix: use 3-second dwell time for image view tracking\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-2-create-usecancellablequery-hook","title":"Task 2: Create useCancellableQuery Hook","text":"<p>Files: - Create: <code>client/src/hooks/useCancellableQuery.js</code></p> <p>Step 1: Create the hook file</p> <p>Create <code>client/src/hooks/useCancellableQuery.js</code>:</p> <pre><code>import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useAuth } from \"./useAuth.js\";\n\n/**\n * Hook for making cancellable API queries with automatic state management.\n * Aborts previous in-flight requests when a new query is executed.\n *\n * @param {Object} options\n * @param {boolean} options.initialLoading - Initial loading state (default: true)\n * @returns {Object} { data, isLoading, error, execute, setData, initMessage }\n */\nexport function useCancellableQuery({ initialLoading = true } = {}) {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(initialLoading);\n  const [error, setError] = useState(null);\n  const [initMessage, setInitMessage] = useState(null);\n  const abortControllerRef = useRef(null);\n  const retryTimeoutRef = useRef(null);\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n\n  /**\n   * Execute a query function with automatic cancellation of previous requests.\n   * @param {Function} queryFn - Async function that receives AbortSignal and returns data\n   * @param {Object} options\n   * @param {number} options.retryCount - Current retry count for initializing state (internal use)\n   */\n  const execute = useCallback(\n    async (queryFn, { retryCount = 0 } = {}) =&gt; {\n      // Don't make API calls if not authenticated or still checking auth\n      if (isAuthLoading || !isAuthenticated) {\n        setIsLoading(false);\n        return;\n      }\n\n      // Clear any pending retry\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n\n      // Abort previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      // Create new controller\n      const controller = new AbortController();\n      abortControllerRef.current = controller;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n        setInitMessage(null);\n\n        const result = await queryFn(controller.signal);\n\n        // Only update state if not aborted\n        if (!controller.signal.aborted) {\n          setData(result);\n          setIsLoading(false);\n        }\n      } catch (err) {\n        // Swallow AbortError - request was intentionally cancelled\n        if (err.name === \"AbortError\") {\n          return;\n        }\n\n        // Only update state if not aborted\n        if (!controller.signal.aborted) {\n          // Handle server initializing state with retry\n          if (err.isInitializing &amp;&amp; retryCount &lt; 60) {\n            setInitMessage(\"Server is syncing library, please wait...\");\n            retryTimeoutRef.current = setTimeout(() =&gt; {\n              execute(queryFn, { retryCount: retryCount + 1 });\n            }, 5000);\n            return;\n          }\n\n          setError(err);\n          setIsLoading(false);\n        }\n      }\n    },\n    [isAuthLoading, isAuthenticated]\n  );\n\n  /**\n   * Reset the query state\n   */\n  const reset = useCallback(() =&gt; {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n    }\n    setData(null);\n    setIsLoading(false);\n    setError(null);\n    setInitMessage(null);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    data,\n    isLoading,\n    error,\n    initMessage,\n    execute,\n    setData,\n    reset,\n  };\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/hooks/useCancellableQuery.js\ngit commit -m \"feat: add useCancellableQuery hook with AbortController support\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-3-add-signal-support-to-api-layer","title":"Task 3: Add Signal Support to API Layer","text":"<p>Files: - Modify: <code>client/src/services/api.js:11-51</code> (apiFetch function) - Modify: <code>client/src/services/api.js:101-103</code> (findScenes) - Modify: <code>client/src/services/api.js:111-113</code> (findPerformers) - Modify: <code>client/src/services/api.js:121-123</code> (findStudios) - Modify: <code>client/src/services/api.js:131-133</code> (findTags) - Modify: <code>client/src/services/api.js:214-216</code> (findGalleries) - Modify: <code>client/src/services/api.js:242-244</code> (findGroups) - Modify: <code>client/src/services/api.js:284-286</code> (findImages)</p> <p>Step 1: Update apiFetch to handle AbortError</p> <p>Find the <code>apiFetch</code> function. After line 22 (<code>const response = await fetch(url, config);</code>), wrap the response handling to catch AbortError early. Update the entire function:</p> <pre><code>async function apiFetch(endpoint, options = {}) {\n  const url = `${API_BASE_URL}${endpoint}`;\n\n  const config = {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n    ...options,\n  };\n\n  let response;\n  try {\n    response = await fetch(url, config);\n  } catch (err) {\n    // Re-throw AbortError so it can be caught by useCancellableQuery\n    if (err.name === \"AbortError\") {\n      throw err;\n    }\n    throw err;\n  }\n\n  if (!response.ok) {\n    // Try to parse error response body\n    let errorData;\n    try {\n      errorData = await response.json();\n    } catch {\n      errorData = { error: `HTTP error! status: ${response.status}` };\n    }\n\n    // Create error with additional metadata\n    const error = new Error(\n      errorData.error ||\n        errorData.message ||\n        `HTTP error! status: ${response.status}`\n    );\n    error.status = response.status;\n    error.data = errorData;\n\n    // Special handling for 503 - server initializing\n    if (response.status === 503 &amp;&amp; errorData.ready === false) {\n      error.isInitializing = true;\n    }\n\n    throw error;\n  }\n\n  return await response.json();\n}\n</code></pre> <p>Step 2: Update libraryApi methods to accept signal</p> <p>Update each find method to accept and pass the signal. Replace each method:</p> <p><code>findScenes</code>: <pre><code>findScenes: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/scenes\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findPerformers</code>: <pre><code>findPerformers: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/performers\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findStudios</code>: <pre><code>findStudios: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/studios\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findTags</code>: <pre><code>findTags: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/tags\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findGalleries</code>: <pre><code>findGalleries: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/galleries\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findGroups</code>: <pre><code>findGroups: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/groups\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findImages</code>: <pre><code>findImages: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/images\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add client/src/services/api.js\ngit commit -m \"feat: add AbortController signal support to library API methods\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-4-refactor-imagesjsx-to-use-usecancellablequery","title":"Task 4: Refactor Images.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import for the hook: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove these lines: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute, setData } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire <code>handleQueryChange</code> function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getImages(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getImages to accept signal</p> <p>Change: <pre><code>const getImages = async (query) =&gt; {\n  const response = await libraryApi.findImages(query);\n</code></pre></p> <p>To: <pre><code>const getImages = async (query, signal) =&gt; {\n  const response = await libraryApi.findImages(query, signal);\n</code></pre></p> <p>Step 5: Verify the error conditional still works</p> <p>The existing code <code>if (error &amp;&amp; !initMessage)</code> should still work since <code>initMessage</code> comes from the hook.</p> <p>Step 6: Test manually</p> <ul> <li>Go to Images page, rapidly change filters \u2192 should see cancelled requests in Network tab</li> <li>Ensure images load correctly</li> </ul> <p>Step 7: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"refactor: use useCancellableQuery in Images page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-5-refactor-performersjsx-to-use-usecancellablequery","title":"Task 5: Refactor Performers.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Performers.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getPerformers(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getPerformers to accept signal</p> <p>Change: <pre><code>const getPerformers = async (query) =&gt; {\n  const response = await libraryApi.findPerformers(query);\n</code></pre></p> <p>To: <pre><code>const getPerformers = async (query, signal) =&gt; {\n  const response = await libraryApi.findPerformers(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Performers.jsx\ngit commit -m \"refactor: use useCancellableQuery in Performers page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-6-refactor-studiosjsx-to-use-usecancellablequery","title":"Task 6: Refactor Studios.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Studios.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getStudios(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getStudios to accept signal</p> <p>Change: <pre><code>const getStudios = async (query) =&gt; {\n  const response = await libraryApi.findStudios(query);\n</code></pre></p> <p>To: <pre><code>const getStudios = async (query, signal) =&gt; {\n  const response = await libraryApi.findStudios(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Studios.jsx\ngit commit -m \"refactor: use useCancellableQuery in Studios page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-7-refactor-tagsjsx-to-use-usecancellablequery","title":"Task 7: Refactor Tags.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Tags.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getTags(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getTags to accept signal</p> <p>Change: <pre><code>const getTags = async (query) =&gt; {\n  const response = await libraryApi.findTags(query);\n</code></pre></p> <p>To: <pre><code>const getTags = async (query, signal) =&gt; {\n  const response = await libraryApi.findTags(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Tags.jsx\ngit commit -m \"refactor: use useCancellableQuery in Tags page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-8-refactor-groupsjsx-to-use-usecancellablequery","title":"Task 8: Refactor Groups.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Groups.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getGroups(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getGroups to accept signal</p> <p>Change: <pre><code>const getGroups = async (query) =&gt; {\n  const response = await libraryApi.findGroups(query);\n</code></pre></p> <p>To: <pre><code>const getGroups = async (query, signal) =&gt; {\n  const response = await libraryApi.findGroups(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Groups.jsx\ngit commit -m \"refactor: use useCancellableQuery in Groups page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-9-refactor-galleriesjsx-to-use-usecancellablequery","title":"Task 9: Refactor Galleries.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Galleries.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getGalleries(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getGalleries to accept signal</p> <p>Change: <pre><code>const getGalleries = async (query) =&gt; {\n  const response = await libraryApi.findGalleries(query);\n</code></pre></p> <p>To: <pre><code>const getGalleries = async (query, signal) =&gt; {\n  const response = await libraryApi.findGalleries(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Galleries.jsx\ngit commit -m \"refactor: use useCancellableQuery in Galleries page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-10-refactor-scenesearchjsx-to-use-usecancellablequery","title":"Task 10: Refactor SceneSearch.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute, setData } = useCancellableQuery();\n</code></pre></p> <p>Note: SceneSearch needs <code>setData</code> for <code>handleHideSuccess</code>.</p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getScenes(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getScenes to accept signal</p> <p>Change: <pre><code>const getScenes = async (query) =&gt; {\n  const response = await libraryApi.findScenes(query);\n</code></pre></p> <p>To: <pre><code>const getScenes = async (query, signal) =&gt; {\n  const response = await libraryApi.findScenes(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"refactor: use useCancellableQuery in SceneSearch\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-11-run-linting-and-fix-any-issues","title":"Task 11: Run Linting and Fix Any Issues","text":"<p>Step 1: Run linting</p> <pre><code>cd client &amp;&amp; npm run lint\n</code></pre> <p>Step 2: Fix any issues</p> <p>Address any linting errors that appear.</p> <p>Step 3: Commit fixes if any</p> <pre><code>git add -A\ngit commit -m \"fix: address linting issues\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-12-manual-testing-verification","title":"Task 12: Manual Testing Verification","text":"<p>Test View Tracking: 1. Open Images page, click an image to open lightbox 2. Navigate quickly through images (arrow keys or buttons) 3. Open Network tab, filter by \"view\" - should see NO requests for quick navigation 4. Stay on one image for 4+ seconds 5. Should see exactly 1 <code>/api/image-view-history/view</code> request 6. Navigate to new image, wait 4+ seconds \u2192 another view request 7. In React dev mode (Strict Mode), verify no duplicate requests</p> <p>Test Request Cancellation: 1. Go to any search page (Images, Performers, etc.) 2. Open Network tab 3. Type in search box rapidly (e.g., \"test\") 4. Should see previous requests cancelled (status \"cancelled\" or greyed out) 5. Only final request should complete 6. Change filters/pagination rapidly \u2192 same cancellation behavior 7. Result should show data from final query, no flicker</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/","title":"Fix Direct Stash Queries","text":"<p>Branch: <code>bugfix/direct-stash-queries</code> Status: Design Complete Complexity: Low-Medium</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#problem-statement","title":"Problem Statement","text":"<p>Two locations in the codebase bypass Peek's cache and query Stash directly for UI data:</p> <ol> <li><code>playlist.ts:76,165</code> \u2014 Fetches full scene data from Stash to display playlist items</li> <li>Bug: Shows Stash's global O-counter and favorite values instead of the user's personal Peek values</li> <li> <p>Performance: Unnecessary network round-trip on every playlist view</p> </li> <li> <p><code>watchHistory.ts:61</code> \u2014 Fetches scene duration from Stash on every 10-second playback ping</p> </li> <li>Performance: Adds latency to every ping during video playback</li> <li>Reliability: Playback tracking fails if Stash is temporarily unreachable</li> </ol> <p>Both issues violate the principle: All UI data should come from Peek's cache.</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#solution-overview","title":"Solution Overview","text":"<p>Both fixes follow the same pattern: replace Stash GraphQL queries with Prisma queries against cached <code>StashScene</code> data.</p> <p>Playlist Fix (<code>playlist.ts</code>): 1. Query <code>StashScene</code> table by IDs instead of <code>stash.findScenes()</code> 2. Merge with user's <code>WatchHistory</code> and <code>SceneRating</code> data for personal O-counter/favorite 3. Apply user restrictions via <code>userRestrictionService.filterScenesForUser()</code> \u2014 restricted scenes are excluded from playlist display 4. Transform paths using existing <code>stashUrlProxy</code> utilities</p> <p>WatchHistory Fix (<code>watchHistory.ts</code>): 1. Query <code>StashScene</code> table for <code>duration</code> field instead of <code>stash.findScenes()</code> 2. The <code>duration</code> column already exists in cache (schema line 433) 3. Fallback: if duration is null/0, continue without percentage calculation (don't fail the ping)</p> <p>Scope boundaries: - We are NOT changing how playlists are created/edited - We are NOT changing the watch history tracking logic itself - We are only changing WHERE the scene data comes from</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#file-servercontrollersplaylistts","title":"File: <code>server/controllers/playlist.ts</code>","text":"<p>Current flow (lines 76 and 165): <pre><code>const scenesResponse = await stash.findScenes({ scene_ids: sceneIds.map(id =&gt; parseInt(id)) });\n</code></pre></p> <p>New flow: <pre><code>// 1. Fetch scenes from cache\nconst scenes = await prisma.stashScene.findMany({\n  where: { id: { in: sceneIds }, deletedAt: null },\n  include: { performers: true, tags: true, groups: true, studio: true }\n});\n\n// 2. Apply user restrictions (filter out hidden/restricted scenes)\nconst visibleScenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n\n// 3. Merge with user's personal data (WatchHistory + SceneRating)\nconst scenesWithUserData = await mergeScenesWithUserData(visibleScenes, userId);\n\n// 4. Transform paths for proxy URLs\nconst transformedScenes = scenesWithUserData.map(s =&gt; transformScene(s));\n</code></pre></p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#file-servercontrollerswatchhistoryts","title":"File: <code>server/controllers/watchHistory.ts</code>","text":"<p>Current flow (line 61): <pre><code>const sceneData = await stash.findScenes({ ids: [sceneId] });\nsceneDuration = sceneData.findScenes.scenes[0]?.files?.[0]?.duration || 0;\n</code></pre></p> <p>New flow: <pre><code>const scene = await prisma.stashScene.findUnique({\n  where: { id: sceneId },\n  select: { duration: true }\n});\nconst sceneDuration = scene?.duration || 0;\n</code></pre></p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Playlist display:</li> <li>Create a playlist with several scenes</li> <li>Verify scenes display with correct screenshots, titles, durations</li> <li>Rate a scene and mark as favorite in Peek</li> <li>Verify playlist shows YOUR rating/favorite, not Stash's global values</li> <li> <p>Increment O-counter on a scene, verify playlist reflects YOUR count</p> </li> <li> <p>Restricted content in playlists:</p> </li> <li>Add a scene to a playlist</li> <li>Have admin restrict that scene (via tag/studio/group restriction)</li> <li>Verify the scene no longer appears in the playlist</li> <li> <p>Unhide/unrestrict, verify it reappears</p> </li> <li> <p>Watch history duration:</p> </li> <li>Play a video, let it ping for 30+ seconds</li> <li>Check server logs \u2014 no Stash GraphQL calls for duration</li> <li> <p>Verify play percentage calculations still work correctly</p> </li> <li> <p>Edge cases:</p> </li> <li>Playlist with scene that was deleted from Stash (should be excluded gracefully)</li> <li>Scene with null/0 duration (ping should continue without failing)</li> </ol> <p>No new automated tests required \u2014 these are simple query pattern changes covered by existing integration tests.</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/controllers/playlist.ts</code> \u2014 Replace Stash queries with Prisma + restriction filtering</li> <li><code>server/controllers/watchHistory.ts</code> \u2014 Replace Stash query with Prisma lookup</li> </ul>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents this as a known issue under \"Stash Communication Patterns\"</li> </ul>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/","title":"Fix Direct Stash Queries - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace direct Stash GraphQL queries with Prisma cache queries in playlist.ts and watchHistory.ts to fix user data display bugs and improve performance.</p> <p>Architecture: Both fixes use the same pattern: query <code>StashScene</code> table via Prisma instead of Stash GraphQL, then apply existing user data merging and restriction filtering.</p> <p>Tech Stack: Prisma, TypeScript, Express</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-1-fix-watchhistoryts-duration-lookup","title":"Task 1: Fix watchHistory.ts Duration Lookup","text":"<p>The simpler fix \u2014 replace one Stash query with a Prisma lookup.</p> <p>Files: - Modify: <code>server/controllers/watchHistory.ts:57-69</code></p> <p>Step 1: Replace Stash query with Prisma lookup</p> <p>In <code>server/controllers/watchHistory.ts</code>, find lines 57-69:</p> <pre><code>// Get scene duration from Stash\nconst stash = stashInstanceManager.getDefault();\nlet sceneDuration = 0;\ntry {\n  const sceneData = await stash.findScenes({ ids: [sceneId] });\n  sceneDuration = sceneData.findScenes.scenes[0]?.files?.[0]?.duration || 0;\n} catch (error) {\n  logger.error(\"Failed to fetch scene duration from Stash\", {\n    sceneId,\n    error,\n  });\n  // Continue without duration - won't be able to calculate percentages\n}\n</code></pre> <p>Replace with:</p> <pre><code>// Get scene duration from cache\nlet sceneDuration = 0;\ntry {\n  const scene = await prisma.stashScene.findUnique({\n    where: { id: sceneId },\n    select: { duration: true },\n  });\n  sceneDuration = scene?.duration || 0;\n} catch (error) {\n  logger.error(\"Failed to fetch scene duration from cache\", {\n    sceneId,\n    error,\n  });\n  // Continue without duration - won't be able to calculate percentages\n}\n</code></pre> <p>Step 2: Remove unused import</p> <p>At the top of the file, find line 5:</p> <pre><code>import { stashInstanceManager } from \"../services/StashInstanceManager.js\";\n</code></pre> <p>Remove this line since we no longer use <code>stashInstanceManager</code> in this file.</p> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors related to watchHistory.ts</p> <p>Step 4: Test manually</p> <ol> <li>Start the server: <code>npm run dev</code></li> <li>Play a video in Peek</li> <li>Watch server logs \u2014 should see \"Watch history ping\" logs without any Stash GraphQL errors</li> <li>Check that play percentage calculations still work (resume position updates)</li> </ol> <p>Step 5: Commit</p> <pre><code>git add server/controllers/watchHistory.ts\ngit commit -m \"fix: use cached duration in watchHistory instead of Stash query\n\nReplaces direct Stash GraphQL query with Prisma cache lookup for scene\nduration. Eliminates network call on every 10-second playback ping.\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-2-fix-getplaylist-scene-fetching","title":"Task 2: Fix getPlaylist Scene Fetching","text":"<p>This is the main fix \u2014 replace Stash query with cache query and add restriction filtering.</p> <p>Files: - Modify: <code>server/controllers/playlist.ts:123-221</code> (getPlaylist function)</p> <p>Step 1: Add required imports</p> <p>At the top of <code>server/controllers/playlist.ts</code>, add these imports after the existing ones:</p> <pre><code>import { stashEntityService } from \"../services/StashEntityService.js\";\nimport { userRestrictionService } from \"../services/UserRestrictionService.js\";\n</code></pre> <p>Step 2: Replace getPlaylist implementation</p> <p>Replace the entire <code>getPlaylist</code> function (lines 123-221) with:</p> <pre><code>/**\n * Get single playlist with items and scene details from cache\n */\nexport const getPlaylist = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const playlistId = parseInt(req.params.id);\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    if (isNaN(playlistId)) {\n      return res.status(400).json({ error: \"Invalid playlist ID\" });\n    }\n\n    const playlist = await prisma.playlist.findFirst({\n      where: {\n        id: playlistId,\n        userId, // Only allow accessing own playlists\n      },\n      include: {\n        items: {\n          orderBy: {\n            position: \"asc\",\n          },\n        },\n      },\n    });\n\n    if (!playlist) {\n      return res.status(404).json({ error: \"Playlist not found\" });\n    }\n\n    // Fetch scene details from cache for all items\n    if (playlist.items.length &gt; 0) {\n      const sceneIds = playlist.items.map((item) =&gt; item.sceneId);\n\n      try {\n        // 1. Fetch scenes from cache with relations\n        const scenes = await stashEntityService.getScenesByIdsWithRelations(sceneIds);\n\n        // 2. Apply user restrictions (filter out hidden/restricted scenes)\n        const isAdmin = req.user?.role === \"ADMIN\";\n        const visibleScenes = isAdmin\n          ? scenes\n          : await userRestrictionService.filterScenesForUser(scenes, userId);\n\n        // 3. Reset user-specific fields to defaults before merging Peek user data\n        const scenesWithDefaults = visibleScenes.map((s) =&gt; ({\n          ...s,\n          ...DEFAULT_SCENE_USER_FIELDS,\n        }));\n\n        // 4. Merge with user's personal data (WatchHistory + SceneRating)\n        const { mergeScenesWithUserData } = await import(\"./library/scenes.js\");\n        const scenesWithUserHistory = await mergeScenesWithUserData(\n          scenesWithDefaults,\n          userId\n        );\n\n        // 5. Transform paths for proxy URLs\n        const transformedScenes = scenesWithUserHistory.map((s) =&gt;\n          transformScene(s as unknown as Scene)\n        );\n\n        // Create a map of scene ID to scene data\n        const sceneMap = new Map(\n          transformedScenes.map((s) =&gt; [s.id, s])\n        );\n\n        // Attach scene data to each playlist item\n        // Note: Items with restricted/hidden scenes will have scene: null\n        const itemsWithScenes = playlist.items.map((item) =&gt; ({\n          ...item,\n          scene: sceneMap.get(item.sceneId) || null,\n        }));\n\n        res.json({\n          playlist: {\n            ...playlist,\n            items: itemsWithScenes,\n          },\n        });\n      } catch (cacheError) {\n        console.error(\"Error fetching scenes from cache:\", cacheError);\n        // Return playlist without scene details if cache fails\n        res.json({ playlist });\n      }\n    } else {\n      res.json({ playlist });\n    }\n  } catch (error) {\n    console.error(\"Error getting playlist:\", error);\n    res.status(500).json({ error: \"Failed to get playlist\" });\n  }\n};\n</code></pre> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/playlist.ts\ngit commit -m \"fix: use cache for getPlaylist scene data\n\n- Replace Stash GraphQL query with StashEntityService cache lookup\n- Apply user restrictions to filter hidden/restricted scenes\n- Fixes bug where Stash O-counter/favorite showed instead of user's values\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-3-fix-getuserplaylists-scene-fetching","title":"Task 3: Fix getUserPlaylists Scene Fetching","text":"<p>Same pattern for the playlists list endpoint (preview thumbnails).</p> <p>Files: - Modify: <code>server/controllers/playlist.ts:30-118</code> (getUserPlaylists function)</p> <p>Step 1: Replace getUserPlaylists implementation</p> <p>Replace the entire <code>getUserPlaylists</code> function (lines 30-118) with:</p> <pre><code>/**\n * Get all playlists for current user\n * Includes first 4 items with scene preview data for thumbnail display\n */\nexport const getUserPlaylists = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    const playlists = await prisma.playlist.findMany({\n      where: {\n        userId,\n      },\n      include: {\n        _count: {\n          select: { items: true },\n        },\n        items: {\n          orderBy: {\n            position: \"asc\",\n          },\n          take: 4, // Only fetch first 4 items for preview\n        },\n      },\n      orderBy: {\n        updatedAt: \"desc\",\n      },\n    });\n\n    // Fetch scene details for preview items from cache\n    const playlistsWithScenes = await Promise.all(\n      playlists.map(async (playlist) =&gt; {\n        if (playlist.items.length === 0) {\n          return playlist;\n        }\n\n        const sceneIds = playlist.items.map((item) =&gt; item.sceneId);\n\n        try {\n          // 1. Fetch scenes from cache with relations\n          const scenes = await stashEntityService.getScenesByIdsWithRelations(sceneIds);\n\n          // 2. Apply user restrictions (filter out hidden/restricted scenes)\n          const isAdmin = req.user?.role === \"ADMIN\";\n          const visibleScenes = isAdmin\n            ? scenes\n            : await userRestrictionService.filterScenesForUser(scenes, userId);\n\n          // 3. Transform scenes to add proxy URLs\n          const transformedScenes = visibleScenes.map((s) =&gt;\n            transformScene(s as unknown as Scene)\n          );\n\n          // Create a map of scene ID to scene data\n          const sceneMap = new Map(\n            transformedScenes.map((s) =&gt; [s.id, s])\n          );\n\n          // Attach scene data to each playlist item (only paths.screenshot needed for preview)\n          const itemsWithScenes = playlist.items.map((item) =&gt; ({\n            ...item,\n            scene: sceneMap.get(item.sceneId) || null,\n          }));\n\n          return {\n            ...playlist,\n            items: itemsWithScenes,\n          };\n        } catch (cacheError) {\n          console.error(\n            `Error fetching scenes for playlist ${playlist.id}:`,\n            cacheError\n          );\n          // Return playlist without scene details if cache fails\n          return playlist;\n        }\n      })\n    );\n\n    res.json({ playlists: playlistsWithScenes });\n  } catch (error) {\n    console.error(\"Error getting playlists:\", error);\n    res.status(500).json({ error: \"Failed to get playlists\" });\n  }\n};\n</code></pre> <p>Step 2: Remove unused Stash import pattern</p> <p>The dynamic import of <code>stashInstanceManager</code> is no longer used in this file. Search for any remaining references:</p> <pre><code>// These lines should no longer exist anywhere in the file:\n// const { stashInstanceManager } = await import(\"../services/StashInstanceManager.js\");\n// const stash = stashInstanceManager.getDefault();\n</code></pre> <p>Verify there are no remaining Stash imports.</p> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/playlist.ts\ngit commit -m \"fix: use cache for getUserPlaylists scene previews\n\n- Replace Stash GraphQL query with StashEntityService cache lookup\n- Apply user restrictions to filter hidden/restricted scenes from previews\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-4-manual-testing","title":"Task 4: Manual Testing","text":"<p>Step 1: Test playlist display with user data</p> <ol> <li>Start the server: <code>npm run dev</code></li> <li>Create a playlist with several scenes</li> <li>Rate one scene 5 stars in Peek</li> <li>Mark another scene as favorite in Peek</li> <li>Increment O-counter on a scene</li> <li>View the playlist</li> <li>Verify: Scenes show YOUR rating/favorite/O-counter, not Stash's global values</li> </ol> <p>Step 2: Test restricted content filtering</p> <ol> <li>As admin, add a tag restriction for a test user (e.g., exclude tag \"Test\")</li> <li>Add a scene with that tag to a playlist</li> <li>Log in as the restricted user</li> <li>View the playlist</li> <li>Verify: The restricted scene does not appear in the playlist</li> </ol> <p>Step 3: Test watch history duration</p> <ol> <li>Play a video in Peek</li> <li>Let it play for 30+ seconds</li> <li>Check server logs</li> <li>Verify: No Stash GraphQL calls for duration</li> <li>Verify: Resume time is saved correctly</li> </ol> <p>Step 4: Test edge cases</p> <ol> <li>Create a playlist with a scene, then delete that scene from Stash</li> <li>Run a sync</li> <li>View the playlist</li> <li>Verify: Deleted scene shows as <code>scene: null</code>, playlist doesn't crash</li> </ol> <p>Step 5: Final commit with test confirmation</p> <pre><code>git add -A\ngit commit -m \"test: verify direct stash query fixes work correctly\n\nManual testing confirmed:\n- Playlist scenes show user's personal O-counter/favorite/ratings\n- Restricted scenes are filtered from playlist display\n- Watch history uses cached duration (no Stash calls)\n- Deleted scenes handled gracefully\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#summary","title":"Summary","text":"Task Description Files Changed 1 Fix watchHistory duration lookup <code>server/controllers/watchHistory.ts</code> 2 Fix getPlaylist scene fetching <code>server/controllers/playlist.ts</code> 3 Fix getUserPlaylists scene previews <code>server/controllers/playlist.ts</code> 4 Manual testing (verification only) <p>Total commits: 4-5 small, focused commits</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/","title":"Image Gallery Inheritance","text":"<p>Branch: <code>feature/image-gallery-inheritance</code> Status: Design Complete Complexity: Medium</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#problem-statement","title":"Problem Statement","text":"<p>Images in Stash can exist within Galleries, and in many workflows the Gallery serves as the \"container\" with metadata that logically applies to all its images. For example: - A Gallery titled \"Beach Shoot 2024\" has performers, tags, studio, date, photographer - The individual images inside have no metadata \u2014 just filenames</p> <p>Currently, Peek stores Images with only their directly-assigned metadata. This means: - Images with no direct metadata appear \"empty\" in the UI - Filtering by performer/tag/studio misses images that should match via their Gallery - Content restrictions don't cascade properly from Gallery metadata to Images</p> <p>Goal: During sync, inherit metadata from Gallery to Image when the Image has none.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#solution-overview","title":"Solution Overview","text":"<p>Inheritance Rules:</p> <p>During sync, for each Image in a Gallery, copy these fields from Gallery \u2192 Image only if the Image has none:</p> Field Inherit? Notes Performers Yes Copy Gallery's performers if Image has no performers Tags Yes Copy Gallery's tags if Image has no tags Studio Yes Copy Gallery's studio if Image has no studio Date Yes Copy Gallery's date if Image has no date Photographer Yes Copy Gallery's photographer if Image has no photographer Details Yes Copy Gallery's details if Image has no details Title No Each image keeps its own name <p>When inheritance happens: - During initial full sync - During incremental sync when an Image or its Gallery is updated - NOT at query time \u2014 this is a denormalization at sync time</p> <p>Storage approach: - Inherited values are stored directly on the <code>StashImage</code> record - No separate \"inherited\" flag \u2014 we treat them as the image's effective values - If user later adds metadata directly in Stash, next sync overwrites with direct values</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#file-serverservicesstashsyncservicets","title":"File: <code>server/services/StashSyncService.ts</code>","text":"<p>The sync service already processes Images. We need to add a post-processing step after Images are synced but Galleries are available.</p> <pre><code>// After syncing images, apply gallery inheritance\nasync function applyGalleryInheritance(images: StashImage[], galleries: Map&lt;string, StashGallery&gt;): Promise&lt;void&gt; {\n  for (const image of images) {\n    // Get galleries this image belongs to (via ImageGallery junction)\n    const imageGalleries = await prisma.imageGallery.findMany({\n      where: { imageId: image.id },\n      include: { gallery: true }\n    });\n\n    if (imageGalleries.length === 0) continue;\n\n    // Use first gallery for inheritance (images rarely span multiple galleries)\n    const gallery = imageGalleries[0].gallery;\n\n    const updates: Partial&lt;StashImage&gt; = {};\n\n    // Inherit scalar fields if image has none\n    if (!image.studioId &amp;&amp; gallery.studioId) updates.studioId = gallery.studioId;\n    if (!image.date &amp;&amp; gallery.date) updates.date = gallery.date;\n    if (!image.photographer &amp;&amp; gallery.photographer) updates.photographer = gallery.photographer;\n    if (!image.details &amp;&amp; gallery.details) updates.details = gallery.details;\n\n    // Apply scalar updates\n    if (Object.keys(updates).length &gt; 0) {\n      await prisma.stashImage.update({ where: { id: image.id }, data: updates });\n    }\n\n    // Inherit performers if image has none\n    const imagePerformers = await prisma.imagePerformer.count({ where: { imageId: image.id } });\n    if (imagePerformers === 0) {\n      const galleryPerformers = await prisma.galleryPerformer.findMany({ where: { galleryId: gallery.id } });\n      await prisma.imagePerformer.createMany({\n        data: galleryPerformers.map(gp =&gt; ({ imageId: image.id, performerId: gp.performerId })),\n        skipDuplicates: true\n      });\n    }\n\n    // Inherit tags if image has none\n    const imageTags = await prisma.imageTag.count({ where: { imageId: image.id } });\n    if (imageTags === 0) {\n      const galleryTags = await prisma.galleryTag.findMany({ where: { galleryId: gallery.id } });\n      await prisma.imageTag.createMany({\n        data: galleryTags.map(gt =&gt; ({ imageId: image.id, tagId: gt.tagId })),\n        skipDuplicates: true\n      });\n    }\n  }\n}\n</code></pre> <p>Sync order matters: Galleries must be synced before Images, or inheritance must run as a separate pass after both are complete.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Basic inheritance:</li> <li>In Stash, create a Gallery with performers, tags, studio, date, photographer, details</li> <li>Add images to the Gallery that have no metadata</li> <li>Run Peek sync</li> <li>Verify images now show the Gallery's performers, tags, studio, date, photographer, details</li> <li> <p>Verify image titles are NOT overwritten (each keeps its filename/title)</p> </li> <li> <p>Partial inheritance:</p> </li> <li>In Stash, create an Image with its own performer but no tags</li> <li>Add it to a Gallery that has both performers and tags</li> <li>Run sync</li> <li>Verify Image keeps its own performer (not overwritten)</li> <li> <p>Verify Image inherits Gallery's tags</p> </li> <li> <p>Filtering works:</p> </li> <li>Filter images by a performer that's only on the Gallery (not directly on images)</li> <li> <p>Verify inherited images appear in results</p> </li> <li> <p>Restriction cascade:</p> </li> <li>Create a Gallery with a restricted tag</li> <li>Add images with no direct tags</li> <li> <p>Verify images inherit the tag and are properly restricted</p> </li> <li> <p>Re-sync behavior:</p> </li> <li>Add metadata directly to an Image in Stash</li> <li>Run sync</li> <li>Verify direct metadata overwrites previously inherited values</li> </ol>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Image in multiple galleries (use first gallery \u2014 rare case)</li> <li>Image not in any gallery (no inheritance, keep as-is)</li> <li>Gallery with no metadata (nothing to inherit)</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/services/StashSyncService.ts</code> \u2014 Add <code>applyGalleryInheritance()</code> function, call after image sync</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents Image Gallery Inheritance under \"Pseudo-Relationships\"</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/","title":"Image Gallery Inheritance Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Denormalize gallery metadata (studio, date, photographer, details, performers, tags) to images at sync time so images can be filtered and displayed without loading their parent gallery.</p> <p>Architecture: After images are synced and ImageGallery junction records exist, run a post-processing pass that copies gallery metadata to images that have none. Uses SQL for efficient bulk operations matching the existing EntityImageCountService pattern.</p> <p>Tech Stack: Prisma, SQLite raw queries, TypeScript</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-1-create-imagegalleryinheritanceservice","title":"Task 1: Create ImageGalleryInheritanceService","text":"<p>Create a new service to handle gallery \u2192 image inheritance logic.</p> <p>Files: - Create: <code>server/services/ImageGalleryInheritanceService.ts</code> - Test: <code>server/services/__tests__/ImageGalleryInheritanceService.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create the test file with basic tests for the inheritance logic.</p> <pre><code>// server/services/__tests__/ImageGalleryInheritanceService.test.ts\nimport { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { imageGalleryInheritanceService } from \"../ImageGalleryInheritanceService.js\";\n\ndescribe(\"ImageGalleryInheritanceService\", () =&gt; {\n  // Clean up test data\n  beforeEach(async () =&gt; {\n    await prisma.imageGallery.deleteMany({});\n    await prisma.imagePerformer.deleteMany({});\n    await prisma.imageTag.deleteMany({});\n    await prisma.galleryPerformer.deleteMany({});\n    await prisma.galleryTag.deleteMany({});\n    await prisma.stashImage.deleteMany({});\n    await prisma.stashGallery.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.imageGallery.deleteMany({});\n    await prisma.imagePerformer.deleteMany({});\n    await prisma.imageTag.deleteMany({});\n    await prisma.galleryPerformer.deleteMany({});\n    await prisma.galleryTag.deleteMany({});\n    await prisma.stashImage.deleteMany({});\n    await prisma.stashGallery.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n  });\n\n  describe(\"applyGalleryInheritance\", () =&gt; {\n    it(\"should inherit studio from gallery when image has none\", async () =&gt; {\n      // Create studio\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n\n      // Create gallery with studio\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\", studioId: \"studio-1\" },\n      });\n\n      // Create image without studio\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited studio\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-1\");\n    });\n\n    it(\"should NOT overwrite image studio when image already has one\", async () =&gt; {\n      // Create two studios\n      await prisma.stashStudio.createMany({\n        data: [\n          { id: \"studio-1\", name: \"Gallery Studio\" },\n          { id: \"studio-2\", name: \"Image Studio\" },\n        ],\n      });\n\n      // Create gallery with studio-1\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\", studioId: \"studio-1\" },\n      });\n\n      // Create image with its own studio-2\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\", studioId: \"studio-2\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image kept its own studio\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-2\");\n    });\n\n    it(\"should inherit performers from gallery when image has none\", async () =&gt; {\n      // Create performer\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n\n      // Create gallery and link performer\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryPerformer.create({\n        data: { galleryId: \"gallery-1\", performerId: \"performer-1\" },\n      });\n\n      // Create image without performers\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited performer\n      const imagePerformers = await prisma.imagePerformer.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imagePerformers).toHaveLength(1);\n      expect(imagePerformers[0].performerId).toBe(\"performer-1\");\n    });\n\n    it(\"should inherit tags from gallery when image has none\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Test Tag\" },\n      });\n\n      // Create gallery and link tag\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryTag.create({\n        data: { galleryId: \"gallery-1\", tagId: \"tag-1\" },\n      });\n\n      // Create image without tags\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited tag\n      const imageTags = await prisma.imageTag.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imageTags).toHaveLength(1);\n      expect(imageTags[0].tagId).toBe(\"tag-1\");\n    });\n\n    it(\"should NOT inherit performers when image already has performers\", async () =&gt; {\n      // Create two performers\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"performer-1\", name: \"Gallery Performer\" },\n          { id: \"performer-2\", name: \"Image Performer\" },\n        ],\n      });\n\n      // Create gallery with performer-1\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryPerformer.create({\n        data: { galleryId: \"gallery-1\", performerId: \"performer-1\" },\n      });\n\n      // Create image with performer-2\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n      await prisma.imagePerformer.create({\n        data: { imageId: \"image-1\", performerId: \"performer-2\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image kept only its own performer\n      const imagePerformers = await prisma.imagePerformer.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imagePerformers).toHaveLength(1);\n      expect(imagePerformers[0].performerId).toBe(\"performer-2\");\n    });\n\n    it(\"should handle image in multiple galleries (use first)\", async () =&gt; {\n      // Create two studios\n      await prisma.stashStudio.createMany({\n        data: [\n          { id: \"studio-1\", name: \"First Gallery Studio\" },\n          { id: \"studio-2\", name: \"Second Gallery Studio\" },\n        ],\n      });\n\n      // Create two galleries\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"First Gallery\", studioId: \"studio-1\" },\n      });\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-2\", title: \"Second Gallery\", studioId: \"studio-2\" },\n      });\n\n      // Create image without studio\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to both galleries (gallery-1 first)\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-2\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image got studio from first gallery\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-1\");\n    });\n\n    it(\"should handle image not in any gallery (no inheritance)\", async () =&gt; {\n      // Create image without gallery\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Standalone Image\" },\n      });\n\n      // Apply inheritance (should not fail)\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image unchanged\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBeNull();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run ImageGalleryInheritanceService</code></p> <p>Expected: FAIL with \"Cannot find module '../ImageGalleryInheritanceService.js'\"</p> <p>Step 3: Write the service implementation</p> <pre><code>// server/services/ImageGalleryInheritanceService.ts\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * ImageGalleryInheritanceService\n *\n * Applies gallery metadata to images that have none.\n * Called after sync completes to denormalize gallery data for efficient filtering.\n *\n * Inheritance rules:\n * - Only copies metadata if the image field is NULL/empty\n * - Never overwrites existing image metadata\n * - Uses first gallery if image is in multiple galleries\n *\n * Fields inherited:\n * - studioId, date, photographer, details (scalar fields)\n * - performers (via ImagePerformer junction)\n * - tags (via ImageTag junction)\n */\nclass ImageGalleryInheritanceService {\n  /**\n   * Apply gallery inheritance to all images.\n   * Uses SQL for efficient bulk operations.\n   */\n  async applyGalleryInheritance(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"Applying gallery inheritance to images...\");\n\n    try {\n      // Step 1: Inherit scalar fields (studioId, date, photographer, details)\n      await this.inheritScalarFields();\n\n      // Step 2: Inherit performers\n      await this.inheritPerformers();\n\n      // Step 3: Inherit tags\n      await this.inheritTags();\n\n      const duration = Date.now() - startTime;\n      logger.info(`Gallery inheritance applied in ${duration}ms`);\n    } catch (error) {\n      logger.error(\"Failed to apply gallery inheritance\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Inherit scalar fields from gallery to image where image has none.\n   * Uses a single UPDATE with subquery for efficiency.\n   */\n  private async inheritScalarFields(): Promise&lt;void&gt; {\n    // For each scalar field, update images that:\n    // 1. Have no value for that field\n    // 2. Are in a gallery that has a value\n\n    // StudioId inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET studioId = (\n        SELECT g.studioId\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.studioId IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE studioId IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.studioId IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Date inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET date = (\n        SELECT g.date\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.date IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE date IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.date IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Photographer inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET photographer = (\n        SELECT g.photographer\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.photographer IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE photographer IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.photographer IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Details inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET details = (\n        SELECT g.details\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.details IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE details IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.details IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n  }\n\n  /**\n   * Inherit performers from gallery to image where image has none.\n   * Uses INSERT OR IGNORE to handle duplicates.\n   */\n  private async inheritPerformers(): Promise&lt;void&gt; {\n    // Insert gallery performers for images that have no performers\n    await prisma.$executeRaw`\n      INSERT OR IGNORE INTO ImagePerformer (imageId, performerId)\n      SELECT DISTINCT ig.imageId, gp.performerId\n      FROM ImageGallery ig\n      JOIN GalleryPerformer gp ON gp.galleryId = ig.galleryId\n      JOIN StashImage i ON i.id = ig.imageId\n      JOIN StashGallery g ON g.id = ig.galleryId\n      WHERE i.deletedAt IS NULL\n        AND g.deletedAt IS NULL\n        AND ig.imageId NOT IN (\n          SELECT DISTINCT imageId FROM ImagePerformer\n        )\n    `;\n  }\n\n  /**\n   * Inherit tags from gallery to image where image has none.\n   * Uses INSERT OR IGNORE to handle duplicates.\n   */\n  private async inheritTags(): Promise&lt;void&gt; {\n    // Insert gallery tags for images that have no tags\n    await prisma.$executeRaw`\n      INSERT OR IGNORE INTO ImageTag (imageId, tagId)\n      SELECT DISTINCT ig.imageId, gt.tagId\n      FROM ImageGallery ig\n      JOIN GalleryTag gt ON gt.galleryId = ig.galleryId\n      JOIN StashImage i ON i.id = ig.imageId\n      JOIN StashGallery g ON g.id = ig.galleryId\n      WHERE i.deletedAt IS NULL\n        AND g.deletedAt IS NULL\n        AND ig.imageId NOT IN (\n          SELECT DISTINCT imageId FROM ImageTag\n        )\n    `;\n  }\n}\n\nexport const imageGalleryInheritanceService = new ImageGalleryInheritanceService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run ImageGalleryInheritanceService</code></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageGalleryInheritanceService.ts server/services/__tests__/ImageGalleryInheritanceService.test.ts\ngit commit -m \"feat: add ImageGalleryInheritanceService\n\nDenormalizes gallery metadata (studio, date, photographer, details,\nperformers, tags) to images at sync time. Uses efficient SQL bulk\noperations matching EntityImageCountService pattern.\"\n</code></pre>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-2-integrate-with-stashsyncservice","title":"Task 2: Integrate with StashSyncService","text":"<p>Wire up the inheritance service to run after image sync completes.</p> <p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Add import for the new service</p> <p>At the top of <code>server/services/StashSyncService.ts</code>, add the import alongside other service imports:</p> <pre><code>import { imageGalleryInheritanceService } from \"./ImageGalleryInheritanceService.js\";\n</code></pre> <p>Step 2: Call inheritance after image sync in fullSync</p> <p>In the <code>fullSync</code> method, after images are synced (around line 217), add the inheritance call before <code>rebuildAllImageCounts</code>:</p> <p>Find this section: <pre><code>      result = await this.syncImages(stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n      // Rebuild user stats to reflect current entity relationships\n      // Rebuild inherited image counts (must happen after images and galleries are synced)\n      logger.info(\"Rebuilding inherited image counts...\");\n</code></pre></p> <p>Change to: <pre><code>      result = await this.syncImages(stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n\n      // Apply gallery inheritance to images (must happen after images and galleries are synced)\n      logger.info(\"Applying gallery inheritance to images...\");\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n      logger.info(\"Gallery inheritance complete\");\n\n      // Rebuild inherited image counts (must happen after gallery inheritance)\n      logger.info(\"Rebuilding inherited image counts...\");\n</code></pre></p> <p>Step 3: Call inheritance after incremental sync</p> <p>Find the <code>smartIncrementalSync</code> method (around line 256). After the sync loop completes and before stats rebuild, add inheritance.</p> <p>Find this section (around line 340): <pre><code>      // Rebuild stats after sync\n      if (results.some((r) =&gt; r.synced &gt; 0)) {\n</code></pre></p> <p>Add before it: <pre><code>      // Apply gallery inheritance if images were synced\n      const imageResult = results.find((r) =&gt; r.entityType === \"image\");\n      if (imageResult &amp;&amp; imageResult.synced &gt; 0) {\n        logger.info(\"Applying gallery inheritance after incremental sync...\");\n        await imageGalleryInheritanceService.applyGalleryInheritance();\n        logger.info(\"Gallery inheritance complete\");\n      }\n</code></pre></p> <p>Step 4: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: integrate gallery inheritance into sync pipeline\n\nCalls ImageGalleryInheritanceService.applyGalleryInheritance() after\nimage sync completes, both in full sync and incremental sync.\nRuns before image count rebuild to ensure accurate counts.\"\n</code></pre>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-3-manual-testing","title":"Task 3: Manual Testing","text":"<p>Verify the feature works end-to-end.</p> <p>Step 1: Start the development server</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code></p> <p>Step 2: Create test data in Stash</p> <ol> <li>In Stash, create a Gallery with:</li> <li>Title: \"Test Gallery\"</li> <li>Date: Any date</li> <li>Studio: Create or select one</li> <li>Photographer: \"Test Photographer\"</li> <li>Details: \"Gallery description\"</li> <li>Add 2-3 performers</li> <li> <p>Add 2-3 tags</p> </li> <li> <p>Add 2-3 images to the Gallery (images should have no metadata)</p> </li> </ol> <p>Step 3: Run sync in Peek</p> <ol> <li>Go to Peek Admin \u2192 Sync</li> <li>Run a full sync or incremental sync</li> <li>Check server logs for:</li> <li>\"Applying gallery inheritance to images...\"</li> <li>\"Gallery inheritance applied in Xms\"</li> </ol> <p>Step 4: Verify inheritance worked</p> <ol> <li>Go to Library \u2192 Images</li> <li>Find the images from the test gallery</li> <li>Verify each image shows:</li> <li>The gallery's studio</li> <li>The gallery's date</li> <li>The gallery's performers</li> <li>The gallery's tags</li> </ol> <p>Step 5: Verify filtering works</p> <ol> <li>Filter images by the gallery's performer</li> <li>Verify inherited images appear in results</li> <li>Filter images by the gallery's tag</li> <li>Verify inherited images appear in results</li> </ol> <p>Step 6: Verify no-overwrite behavior</p> <ol> <li>In Stash, add a direct performer to one of the gallery images</li> <li>Run sync</li> <li>Verify that image kept its own performer (not replaced with gallery's)</li> </ol>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-4-run-full-test-suite","title":"Task 4: Run Full Test Suite","text":"<p>Ensure no regressions in existing tests.</p> <p>Step 1: Run all tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass</p> <p>Step 2: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Commit any fixes if needed</p> <p>If tests or lint fail, fix and commit.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-summary","title":"Task Summary","text":"Task Description Files Changed 1 Create ImageGalleryInheritanceService <code>server/services/ImageGalleryInheritanceService.ts</code>, <code>server/services/__tests__/ImageGalleryInheritanceService.test.ts</code> 2 Integrate with StashSyncService <code>server/services/StashSyncService.ts</code> 3 Manual testing (verification only) 4 Run full test suite (verification only) <p>Total commits: 2-3 focused commits</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/","title":"Pre-Computed Exclusions","text":"<p>Branch: <code>feature/pre-computed-exclusions</code> Status: Design Complete Complexity: High</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#problem-statement","title":"Problem Statement","text":"<p>Peek's content filtering (restrictions + hidden items) currently works by: 1. Loading ALL entities into memory 2. Filtering in JavaScript 3. Paginating the filtered results</p> <p>This doesn't scale. Problems include: - Memory: 1M+ scenes loaded into memory per request - CPU: Filtering logic runs on every request, for every user - Pagination: To get page 5 of 25 items, we load and filter ALL items first - Counts: Total visible count requires processing entire dataset</p> <p>Current flow (slow): <pre><code>Controller (e.g., scenes.ts)\n    \u2193\n1. userRestrictionService.getExcludedSceneIds(userId)  \u2190 6-10 DB queries per request\n    \u2193\n2. sceneQueryBuilder.execute({ excludedSceneIds, ... })  \u2190 passes exclusions as Set\n    \u2193\n3. SceneQueryBuilder uses NOT IN (excludedIds) in SQL  \u2190 parameter limits, chunking needed\n</code></pre></p> <p>Target scale: Users with 100TB+ collections containing millions of scenes and images.</p> <p>Goal: Pre-compute excluded entity IDs per user, stored in a database table. Queries become simple JOINs with proper pagination and counts at the database level.</p> <p>New flow (fast): <pre><code>Controller (e.g., scenes.ts)\n    \u2193\n1. sceneQueryBuilder.execute({ userId, ... })  \u2190 no pre-computation needed\n    \u2193\n2. SceneQueryBuilder adds LEFT JOIN UserExcludedEntity + WHERE e.id IS NULL\n</code></pre></p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#solution-overview","title":"Solution Overview","text":"<p>Core concept: Instead of filtering at query time, pre-compute and store which entities each user cannot see. Queries become:</p> <pre><code>SELECT s.* FROM StashScene s\nLEFT JOIN UserExcludedEntity e\n  ON e.userId = 5 AND e.entityType = 'scene' AND e.entityId = s.id\nWHERE e.id IS NULL  -- Not excluded\nORDER BY s.stashCreatedAt DESC\nLIMIT 25 OFFSET 100\n</code></pre> <p>Two new tables:</p> Table Purpose <code>UserExcludedEntity</code> Stores (userId, entityType, entityId, reason) for every excluded item <code>UserEntityStats</code> Stores pre-computed visible counts per entity type per user <p>Exclusion reasons tracked: - <code>restricted</code> \u2014 Admin set a restriction rule matching this entity - <code>hidden</code> \u2014 User explicitly hid this entity - <code>cascade</code> \u2014 Excluded due to a related entity (e.g., scene excluded because its performer is hidden) - <code>empty</code> \u2014 Organizational entity with no visible content</p> <p>Design simplification: We store one row per excluded entity without tracking the source of cascades (<code>sourceType</code>/<code>sourceId</code>). This simplifies the schema and queries. The tradeoff is that unhide operations trigger a targeted recompute rather than a simple DELETE, but unhide is rare and recompute is fast.</p> <p>Recomputation triggers: - Stash sync completes \u2192 <code>recomputeAllUsers()</code> - Admin changes user's restrictions \u2192 <code>recomputeForUser(userId)</code> - User hides entity \u2192 <code>addHiddenEntity()</code> (synchronous, incremental) - User unhides entity \u2192 Remove from <code>UserHiddenEntity</code>, queue <code>recomputeForUser()</code> (async)</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#schema-design","title":"Schema Design","text":"<pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])      // Primary query index\n  @@index([entityType, entityId])    // For cascade lookups\n}\n\n// Pre-computed visible counts (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  visibleCount Int      // total - excluded\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre> <p>ID uniqueness: Stash IDs are per-entity-type (Scene #1 and Performer #1 can coexist). The composite unique constraint <code>@@unique([userId, entityType, entityId])</code> handles this.</p> <p>Index strategy: - <code>[userId, entityType]</code> \u2014 Primary query pattern: \"get all excluded scenes for user 5\" - <code>[entityType, entityId]</code> \u2014 Cascade lookups: \"which users have this performer excluded?\"</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#cascade-rules","title":"Cascade Rules","text":"<p>When an entity is hidden or restricted, related entities are cascade-excluded:</p> When this is hidden/restricted... These are cascade-excluded... Performer Scenes with that performer Studio Scenes from that studio Tag Scenes with that tag (direct OR inherited via <code>inheritedTagIds</code>), Performers with that tag, Studios with that tag, Groups with that tag Group Scenes in that group Gallery Scenes linked to that gallery, Images in that gallery Scene (no cascade \u2014 scenes are leaf content) Image (no cascade \u2014 images are leaf content) <p>Empty entity cascades (organizational entities with no remaining visible content):</p> Entity type Empty when... Gallery Has 0 visible images Group Has 0 visible scenes AND no sub-groups with content (tree traversal) Studio Has 0 visible scenes AND 0 visible images AND no child studios with content (tree traversal) Performer Has 0 visible scenes AND 0 visible images Tag Not attached to any visible scene/performer/studio/group/gallery/image (DAG traversal) <p>Empty exclusions computed at sync time only \u2014 not during hide/unhide operations. This keeps incremental operations fast. Users won't notice if an empty performer briefly appears until next sync.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#new-services","title":"New Services","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#file-serverservicesexclusioncomputationservicets","title":"File: <code>server/services/ExclusionComputationService.ts</code>","text":"<p>Responsible for computing and maintaining exclusions.</p> <pre><code>class ExclusionComputationService {\n  // Full recompute for a user (initial setup, restriction change, after sync)\n  async recomputeForUser(userId: number): Promise&lt;void&gt;\n\n  // Recompute for all users (after sync)\n  async recomputeAllUsers(): Promise&lt;void&gt;\n\n  // Incremental: user hid an entity (synchronous)\n  async addHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt;\n\n  // Incremental: user unhid an entity (queues async recompute)\n  async removeHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt;\n\n  // Internal phases\n  private async computeDirectExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async computeCascadeExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async computeEmptyExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async updateEntityStats(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n}\n</code></pre> <p>Full recompute algorithm:</p> <p>The entire recompute runs in a transaction. If any phase fails, the transaction rolls back and the user keeps their previous exclusions \u2014 they never see unrestricted content due to a partial failure.</p> <pre><code>async recomputeForUser(userId: number): Promise&lt;void&gt; {\n  await prisma.$transaction(async (tx) =&gt; {\n    // Phase 1: Clear existing exclusions\n    await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n    // Phase 2: Direct exclusions (restrictions + hidden)\n    await this.computeDirectExclusions(tx, userId);\n\n    // Phase 3: Cascade exclusions\n    await this.computeCascadeExclusions(tx, userId);\n\n    // Phase 4: Empty entity exclusions (sync-time only)\n    await this.computeEmptyExclusions(tx, userId);\n\n    // Phase 5: Update stats\n    await this.updateEntityStats(tx, userId);\n  });\n}\n</code></pre> <p>Computation order in Phase 3 (cascades):</p> <ol> <li>For each hidden/restricted performer \u2192 exclude their scenes</li> <li>For each hidden/restricted studio \u2192 exclude their scenes</li> <li>For each hidden/restricted tag \u2192 exclude scenes (using <code>inheritedTagIds</code>), performers, studios, groups</li> <li>For each hidden/restricted group \u2192 exclude their scenes</li> <li>For each hidden/restricted gallery \u2192 exclude linked scenes, images in gallery</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#file-serverservicesexclusionquerybuilderts","title":"File: <code>server/services/ExclusionQueryBuilder.ts</code>","text":"<p>Provides JOIN clause utilities for filtered queries.</p> <pre><code>class ExclusionQueryBuilder {\n  /**\n   * Build the exclusion JOIN clause for raw SQL\n   */\n  buildExclusionJoin(\n    entityType: string,\n    tableAlias: string\n  ): { sql: string } {\n    return {\n      sql: `LEFT JOIN UserExcludedEntity e_${tableAlias}\n            ON e_${tableAlias}.userId = ?\n            AND e_${tableAlias}.entityType = '${entityType}'\n            AND e_${tableAlias}.entityId = ${tableAlias}.id`,\n    };\n  }\n\n  /**\n   * Build the WHERE clause for exclusion filtering\n   */\n  buildExclusionWhere(tableAlias: string): string {\n    return `e_${tableAlias}.id IS NULL`;\n  }\n}\n</code></pre> <p>This utility is used by <code>SceneQueryBuilder</code> and similar query builders for other entity types.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#query-architecture-changes","title":"Query Architecture Changes","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#scenequerybuilder-updates","title":"SceneQueryBuilder Updates","text":"<p>Interface change:</p> <pre><code>// Before\ninterface SceneQueryOptions {\n  userId: number;\n  excludedSceneIds?: Set&lt;string&gt;;  // Remove this\n  // ...\n}\n\n// After\ninterface SceneQueryOptions {\n  userId: number;\n  applyExclusions?: boolean;  // Default true, false for admin override\n  // ...\n}\n</code></pre> <p>FROM clause change:</p> <pre><code>-- Before\nFROM StashScene s\nLEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\nLEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\n\n-- After\nFROM StashScene s\nLEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\nLEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\nLEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id\n</code></pre> <p>WHERE clause addition:</p> <pre><code>WHERE s.deletedAt IS NULL\n  AND e.id IS NULL  -- Not in exclusion table\n  -- ... other filters\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#same-pattern-for-other-entities","title":"Same Pattern for Other Entities","text":"<p>The <code>UserExcludedEntity</code> table is uniform \u2014 the JOIN pattern is identical for all entity types:</p> <pre><code>LEFT JOIN UserExcludedEntity e\n  ON e.userId = ? AND e.entityType = '&lt;type&gt;' AND e.entityId = &lt;table&gt;.id\nWHERE e.id IS NULL\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#incremental-updates","title":"Incremental Updates","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#hide-operation-synchronous","title":"Hide Operation (Synchronous)","text":"<p>When a user hides an entity, we add exclusions incrementally within a transaction:</p> <pre><code>async addHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt; {\n  await prisma.$transaction(async (tx) =&gt; {\n    // 1. Add the direct exclusion\n    await tx.userExcludedEntity.upsert({\n      where: { userId_entityType_entityId: { userId, entityType, entityId } },\n      create: { userId, entityType, entityId, reason: 'hidden' },\n      update: { reason: 'hidden' },\n    });\n\n    // 2. Compute and add cascades for this entity\n    await this.addCascadesForEntity(tx, userId, entityType, entityId);\n\n    // 3. Update affected stats\n    await this.updateEntityStats(tx, userId);\n  });\n}\n</code></pre> <p>This is fast \u2014 typically a few queries and INSERTs. User sees immediate feedback.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#unhide-operation-async","title":"Unhide Operation (Async)","text":"<p>Unhide is trickier \u2014 a scene might still be excluded by another hidden performer. We use a safe approach:</p> <pre><code>async removeHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt; {\n  // 1. Remove the source of truth entry (immediate)\n  await prisma.userHiddenEntity.delete({\n    where: { userId_entityType_entityId: { userId, entityType, entityId } },\n  });\n\n  // 2. Queue async recompute\n  setImmediate(() =&gt; {\n    this.recomputeForUser(userId).catch(err =&gt; {\n      logger.error('Failed to recompute exclusions after unhide', { userId, err });\n    });\n  });\n}\n</code></pre> <p>The response returns immediately. There's a brief window where the user might see stale exclusions, but the next request after recompute completes will be correct.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#api-integration-pattern","title":"API Integration Pattern","text":"<p>The problem: Exclusion filtering must be applied consistently across ALL endpoints that return entities \u2014 including minimal endpoints for filter dropdowns.</p> <p>Approach: Centralize all entity queries through query builders that use exclusion JOINs</p> <p>No controller should directly query Prisma or cache for user-visible entities. Instead:</p> <pre><code>// OLD (scattered, inconsistent)\nconst excludedIds = await userRestrictionService.getExcludedSceneIds(userId);\nconst result = await sceneQueryBuilder.execute({ excludedSceneIds, ... });\n\n// NEW (centralized)\nconst result = await sceneQueryBuilder.execute({ userId, ... });\n// Exclusion JOIN is built-in\n</code></pre> <p>Full endpoint audit:</p> Endpoint File Purpose Library (full) GET /api/library/scenes <code>library/scenes.ts</code> Scene grid GET /api/library/performers <code>library/performers.ts</code> Performer grid GET /api/library/studios <code>library/studios.ts</code> Studio grid GET /api/library/tags <code>library/tags.ts</code> Tag grid GET /api/library/groups <code>library/groups.ts</code> Group grid GET /api/library/galleries <code>library/galleries.ts</code> Gallery grid GET /api/library/images <code>library/images.ts</code> Image grid Library (minimal for dropdowns) POST /api/library/performers/minimal <code>library/performers.ts</code> Performer filter dropdown POST /api/library/studios/minimal <code>library/studios.ts</code> Studio filter dropdown POST /api/library/tags/minimal <code>library/tags.ts</code> Tag filter dropdown POST /api/library/groups/minimal <code>library/groups.ts</code> Group filter dropdown POST /api/library/galleries/minimal <code>library/galleries.ts</code> Gallery filter dropdown Other GET /api/recommendations <code>recommendations.ts</code> Home recommendations GET /api/search <code>search.ts</code> Global search GET /api/playlists/:id <code>playlist.ts</code> Playlist items GET /api/home/carousels <code>home.ts</code> Home page carousels GET /api/carousel/* <code>carousel.ts</code> Carousel queries <p>Why this works for all exclusion types:</p> <ul> <li>Restricted items \u2192 <code>ExclusionComputationService</code> processes admin restrictions, adds entries with <code>reason='restricted'</code> or <code>reason='cascade'</code></li> <li>Hidden items \u2192 Computation processes user hidden entities, adds entries with <code>reason='hidden'</code> or <code>reason='cascade'</code></li> <li>Empty items \u2192 Computation identifies organizational entities with no visible content, adds entries with <code>reason='empty'</code></li> </ul> <p>All three end up in the same <code>UserExcludedEntity</code> table. Query builders apply the same JOIN regardless of reason. The <code>reason</code> column is for debugging and the unhide UI.</p> <p>Enforcement: 1. Delete <code>userRestrictionService.getExcludedSceneIds()</code> after migration 2. Delete <code>userRestrictionService.filter*ForUser()</code> methods after migration 3. Delete <code>emptyEntityFilterService</code> methods after migration 4. Compile errors force all callers to use new pattern</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#migration-strategy","title":"Migration Strategy","text":"<p>Phase 1: Add tables (non-breaking) - Add <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables via Prisma migration - No changes to existing query logic yet</p> <p>Phase 2: Implement computation service - Build <code>ExclusionComputationService</code> with full recompute logic - Add admin endpoint to trigger recomputation manually - Test that exclusions are computed correctly</p> <p>Phase 3: Implement query builder utility - Build <code>ExclusionQueryBuilder</code> with JOIN clause helpers - Update <code>SceneQueryBuilder</code> to use exclusion JOIN instead of <code>excludedSceneIds</code> parameter - Test scene queries work correctly</p> <p>Phase 4: Wire up triggers - After Stash sync \u2192 call <code>recomputeAllUsers()</code> - After restriction change \u2192 call <code>recomputeForUser()</code> - After hide \u2192 call <code>addHiddenEntity()</code> - After unhide \u2192 call <code>removeHiddenEntity()</code></p> <p>Phase 5: Update remaining entity queries - Add exclusion JOINs to performer, studio, tag, group, gallery, image queries - Update all endpoints in audit list</p> <p>Phase 6: Cleanup - Remove old in-memory filtering code - Remove <code>getExcludedSceneIds()</code> and <code>filter*ForUser()</code> methods - Remove <code>EmptyEntityFilterService</code> - Remove <code>FilteredEntityCacheService</code></p> <p>Rollback plan: Keep old code paths available behind feature flag during migration. If issues arise, disable new code path instantly.</p> <p>Existing tables preserved: - <code>UserContentRestriction</code> \u2014 remains source of truth for admin restrictions - <code>UserHiddenEntity</code> \u2014 remains source of truth for user hidden items - <code>UserExcludedEntity</code> is a computed/derived table, can be rebuilt anytime</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#target-scale","title":"Target Scale","text":"<ul> <li>1M+ scenes per instance</li> <li>1M+ images per instance</li> <li>Multiple users with different restrictions</li> <li>Worst case: 50% of content excluded per user</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#exclusion-table-size-estimates","title":"Exclusion Table Size Estimates","text":"Scenario Exclusion Records Table Size 1M scenes, 10% excluded, 1 user ~100k rows ~10MB 1M scenes, 50% excluded, 5 users ~2.5M rows ~250MB 2M entities, 30% excluded, 10 users ~6M rows ~600MB"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#performance-characteristics","title":"Performance Characteristics","text":"<p>Query performance (with proper indexes): - Index lookup: O(log n) \u2014 ~20 comparisons for 1M rows - JOIN is efficient because all join columns are indexed - SQLite page cache keeps hot indexes in memory</p> <p>Potential bottlenecks:</p> Concern Mitigation Full recomputation time Use transactions for atomicity; recompute is seconds not minutes COUNT queries Pre-compute visible counts in <code>UserEntityStats</code> table Index memory ~250MB for 5M rows is acceptable for modern servers Failure during recompute Transaction rollback preserves previous exclusions"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#future-optimization-table-splitting","title":"Future Optimization: Table Splitting","text":"<p>If performance issues arise at 10M+ exclusion rows, consider splitting: - <code>UserExcludedScene</code> \u2014 highest volume - <code>UserExcludedImage</code> \u2014 highest volume - <code>UserExcludedEntity</code> \u2014 for performers, studios, tags, groups, galleries (lower volume)</p> <p>Start with single table; split only if actual performance issues occur.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#unit-tests","title":"Unit Tests","text":"<ol> <li>Cascade computation:</li> <li>Hide a performer \u2192 verify all their scenes are excluded with <code>reason='cascade'</code></li> <li>Hide a tag \u2192 verify scenes/performers/studios/groups with that tag are excluded</li> <li>Hide a group \u2192 verify scenes in group are excluded</li> <li> <p>Hide a gallery \u2192 verify linked scenes and images are excluded</p> </li> <li> <p>Incremental updates:</p> </li> <li>Hide entity \u2192 verify exclusions added correctly</li> <li>Unhide entity \u2192 verify recompute removes exclusions</li> <li> <p>Unhide entity that's still excluded by another source \u2192 verify it stays excluded</p> </li> <li> <p>Transaction safety:</p> </li> <li>Simulate failure mid-recompute \u2192 verify previous exclusions preserved</li> <li>Verify user never sees unrestricted content due to partial failure</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#integration-tests","title":"Integration Tests","text":"<ol> <li>Query correctness:</li> <li>Compare old in-memory filtering results with new JOIN-based results</li> <li>Run on dataset with complex restriction rules</li> <li> <p>Verify counts match</p> </li> <li> <p>Pagination:</p> </li> <li>Get page 1, page 2, page 3 \u2192 verify no duplicates, no gaps</li> <li> <p>Verify total count is accurate</p> </li> <li> <p>Performance:</p> </li> <li>Benchmark with 100k+ scenes</li> <li>Verify query time is under 100ms for paginated results</li> <li> <p>Verify recomputation time is acceptable</p> </li> <li> <p>All endpoints covered:</p> </li> <li>Verify each endpoint in audit list uses exclusion JOINs</li> <li>Verify filter dropdowns show only visible entities</li> <li>Verify hidden performer doesn't appear in performer dropdown</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Fresh user \u2192 verify initial exclusion computation works</li> <li>Admin changes restrictions \u2192 verify recomputation triggers</li> <li>User hides/unhides \u2192 verify incremental update works</li> <li>Stash sync with new content \u2192 verify new items checked against rules</li> <li>Filter dropdown \u2192 verify restricted/hidden/empty entities don't appear</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#files-changed","title":"Files Changed","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#new-files","title":"New Files","text":"<ul> <li><code>server/services/ExclusionComputationService.ts</code> \u2014 Computes and maintains exclusions</li> <li><code>server/services/ExclusionQueryBuilder.ts</code> \u2014 JOIN clause utilities for filtered queries</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#modified-files","title":"Modified Files","text":"<ul> <li><code>server/prisma/schema.prisma</code> \u2014 Add <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables</li> <li><code>server/services/SceneQueryBuilder.ts</code> \u2014 Use exclusion JOIN instead of <code>excludedSceneIds</code></li> <li><code>server/controllers/library/scenes.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/controllers/library/performers.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/studios.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/tags.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/groups.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/galleries.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/images.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/recommendations.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/controllers/search.ts</code> \u2014 Add exclusion JOINs</li> <li><code>server/controllers/playlist.ts</code> \u2014 Add exclusion JOINs</li> <li><code>server/controllers/carousel.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/services/StashSyncService.ts</code> \u2014 Trigger <code>recomputeAllUsers()</code> after sync</li> <li><code>server/controllers/user.ts</code> \u2014 Use <code>addHiddenEntity()</code>/<code>removeHiddenEntity()</code></li> <li><code>server/controllers/admin.ts</code> \u2014 Trigger <code>recomputeForUser()</code> on restriction change</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#deleted-files-after-migration-complete","title":"Deleted Files (after migration complete)","text":"<ul> <li><code>server/services/UserRestrictionService.ts</code> \u2014 Replaced by <code>ExclusionComputationService</code> + query JOINs</li> <li><code>server/services/EmptyEntityFilterService.ts</code> \u2014 Replaced by <code>ExclusionComputationService</code></li> <li><code>server/services/FilteredEntityCacheService.ts</code> \u2014 No longer needed</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#admin-endpoints","title":"Admin Endpoints","text":"<p>New endpoints for monitoring and manual control:</p> <pre><code>POST /api/admin/recompute-exclusions/:userId  \u2014 Recompute for one user\nPOST /api/admin/recompute-exclusions/all      \u2014 Recompute for all users\nGET  /api/admin/exclusion-stats               \u2014 View exclusion table size, per-user counts\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Full architecture documentation</li> <li>Fix Direct Stash Queries \u2014 Prerequisite fix (completed)</li> <li>Image Gallery Inheritance \u2014 Similar denormalization pattern (completed)</li> <li>Scene Tag Inheritance \u2014 Similar denormalization pattern (completed)</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/","title":"Pre-Computed Exclusions Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace runtime exclusion filtering with pre-computed database JOINs for scalable content filtering.</p> <p>Architecture: Pre-compute excluded entity IDs per user into a <code>UserExcludedEntity</code> table. Query builders use LEFT JOIN + WHERE NULL to filter instead of loading exclusions into memory. Computation triggered on sync, restriction change, and hide/unhide operations.</p> <p>Tech Stack: TypeScript, Prisma, SQLite, Vitest</p> <p>Design Document: Pre-Computed Exclusions Design</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-1-add-database-schema","title":"Task 1: Add Database Schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add UserExcludedEntity model</p> <p>Add after the <code>UserHiddenEntity</code> model (around line 375):</p> <pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\n// This is a derived/cached table - can be rebuilt anytime from UserContentRestriction + UserHiddenEntity\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])\n  @@index([entityType, entityId])\n}\n\n// Pre-computed visible counts (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  visibleCount Int      // total - excluded\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre> <p>Step 2: Add relations to User model</p> <p>Find the User model (around line 10) and add these relations after <code>hiddenEntities</code>:</p> <pre><code>  // Pre-computed exclusions cache\n  excludedEntities UserExcludedEntity[]\n  entityStats      UserEntityStats[]\n</code></pre> <p>Step 3: Generate Prisma client and run migration</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma migrate dev --name add_exclusion_tables\n</code></pre></p> <p>Expected: Migration created and applied successfully.</p> <p>Step 4: Verify schema</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma db push --dry-run\n</code></pre></p> <p>Expected: \"Your database is in sync\"</p> <p>Step 5: Commit</p> <pre><code>git add server/prisma/\ngit commit -m \"feat: add UserExcludedEntity and UserEntityStats tables\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-2-create-exclusioncomputationservice-core-structure","title":"Task 2: Create ExclusionComputationService - Core Structure","text":"<p>Files: - Create: <code>server/services/ExclusionComputationService.ts</code> - Create: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for basic structure</p> <p>Create <code>server/services/__tests__/ExclusionComputationService.test.ts</code>:</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\n\n// Mock prisma before importing service\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $transaction: vi.fn(),\n    userExcludedEntity: {\n      deleteMany: vi.fn(),\n      createMany: vi.fn(),\n      findMany: vi.fn(),\n    },\n    userEntityStats: {\n      upsert: vi.fn(),\n    },\n    userContentRestriction: {\n      findMany: vi.fn(),\n    },\n    userHiddenEntity: {\n      findMany: vi.fn(),\n    },\n    user: {\n      findMany: vi.fn(),\n    },\n  },\n}));\n\nimport { exclusionComputationService } from \"../ExclusionComputationService.js\";\n\ndescribe(\"ExclusionComputationService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"recomputeForUser\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.recomputeForUser).toBe(\"function\");\n    });\n  });\n\n  describe(\"recomputeAllUsers\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.recomputeAllUsers).toBe(\"function\");\n    });\n  });\n\n  describe(\"addHiddenEntity\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.addHiddenEntity).toBe(\"function\");\n    });\n  });\n\n  describe(\"removeHiddenEntity\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.removeHiddenEntity).toBe(\"function\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL - Cannot find module '../ExclusionComputationService.js'</p> <p>Step 3: Create minimal service skeleton</p> <p>Create <code>server/services/ExclusionComputationService.ts</code>:</p> <pre><code>/**\n * ExclusionComputationService\n *\n * Computes and maintains the UserExcludedEntity table which stores\n * pre-computed exclusions for each user. This enables efficient\n * JOIN-based filtering instead of loading exclusions into memory.\n *\n * Exclusion sources:\n * - UserContentRestriction (admin restrictions) -&gt; reason='restricted'\n * - UserHiddenEntity (user hidden items) -&gt; reason='hidden'\n * - Cascades from hidden entities -&gt; reason='cascade'\n * - Empty organizational entities -&gt; reason='empty'\n */\n\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\nclass ExclusionComputationService {\n  /**\n   * Full recompute for a user.\n   * Runs in a transaction - if any phase fails, previous exclusions are preserved.\n   */\n  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n    // Implementation in next task\n  }\n\n  /**\n   * Recompute exclusions for all users.\n   * Called after Stash sync completes.\n   */\n  async recomputeAllUsers(): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.recomputeAllUsers starting\");\n    // Implementation in next task\n  }\n\n  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n}\n\nexport const exclusionComputationService = new ExclusionComputationService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: add ExclusionComputationService skeleton\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-3-implement-direct-exclusions-restrictions-hidden","title":"Task 3: Implement Direct Exclusions (Restrictions + Hidden)","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for direct exclusions</p> <p>Add to <code>ExclusionComputationService.test.ts</code>:</p> <pre><code>import prisma from \"../../prisma/singleton.js\";\n\nconst mockPrisma = prisma as any;\n\ndescribe(\"computeDirectExclusions\", () =&gt; {\n  it(\"should process UserContentRestriction EXCLUDE mode\", async () =&gt; {\n    // Setup: user has restriction excluding specific tags\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([\n      {\n        userId: 1,\n        entityType: \"tags\",\n        mode: \"EXCLUDE\",\n        entityIds: JSON.stringify([\"tag1\", \"tag2\"]),\n      },\n    ]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    // Mock transaction to execute callback\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    // Verify createMany was called with the excluded tags\n    expect(mockPrisma.userExcludedEntity.createMany).toHaveBeenCalled();\n    const createCall = mockPrisma.userExcludedEntity.createMany.mock.calls[0][0];\n    expect(createCall.data).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          userId: 1,\n          entityType: \"tag\",\n          entityId: \"tag1\",\n          reason: \"restricted\",\n        }),\n        expect.objectContaining({\n          userId: 1,\n          entityType: \"tag\",\n          entityId: \"tag2\",\n          reason: \"restricted\",\n        }),\n      ])\n    );\n  });\n\n  it(\"should process UserHiddenEntity records\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\" },\n      { userId: 1, entityType: \"scene\", entityId: \"scene1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    expect(mockPrisma.userExcludedEntity.createMany).toHaveBeenCalled();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL - createMany not called or called with wrong data</p> <p>Step 3: Implement direct exclusions</p> <p>Update <code>server/services/ExclusionComputationService.ts</code>:</p> <pre><code>/**\n * ExclusionComputationService\n *\n * Computes and maintains the UserExcludedEntity table which stores\n * pre-computed exclusions for each user. This enables efficient\n * JOIN-based filtering instead of loading exclusions into memory.\n *\n * Exclusion sources:\n * - UserContentRestriction (admin restrictions) -&gt; reason='restricted'\n * - UserHiddenEntity (user hidden items) -&gt; reason='hidden'\n * - Cascades from hidden entities -&gt; reason='cascade'\n * - Empty organizational entities -&gt; reason='empty'\n */\n\nimport type { Prisma, PrismaClient } from \"@prisma/client\";\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Type for Prisma transaction client\ntype TransactionClient = Omit&lt;\n  PrismaClient,\n  \"$connect\" | \"$disconnect\" | \"$on\" | \"$transaction\" | \"$use\" | \"$extends\"\n&gt;;\n\n// Entity type mapping from restriction entityType to exclusion entityType\nconst RESTRICTION_ENTITY_MAP: Record&lt;string, string&gt; = {\n  tags: \"tag\",\n  studios: \"studio\",\n  groups: \"group\",\n  galleries: \"gallery\",\n  performers: \"performer\",\n};\n\nclass ExclusionComputationService {\n  /**\n   * Full recompute for a user.\n   * Runs in a transaction - if any phase fails, previous exclusions are preserved.\n   */\n  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Phase 1: Clear existing exclusions\n      await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n      // Phase 2: Compute direct exclusions (restrictions + hidden)\n      await this.computeDirectExclusions(tx, userId);\n\n      // Phase 3: Compute cascade exclusions (to be implemented)\n      // await this.computeCascadeExclusions(tx, userId);\n\n      // Phase 4: Compute empty exclusions (to be implemented)\n      // await this.computeEmptyExclusions(tx, userId);\n\n      // Phase 5: Update stats (to be implemented)\n      // await this.updateEntityStats(tx, userId);\n    });\n\n    logger.info(\"ExclusionComputationService.recomputeForUser complete\", {\n      userId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Recompute exclusions for all users.\n   * Called after Stash sync completes.\n   */\n  async recomputeAllUsers(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeAllUsers starting\");\n\n    const users = await prisma.user.findMany({ select: { id: true } });\n\n    for (const user of users) {\n      await this.recomputeForUser(user.id);\n    }\n\n    logger.info(\"ExclusionComputationService.recomputeAllUsers complete\", {\n      userCount: users.length,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Phase 2: Compute direct exclusions from restrictions and hidden entities.\n   */\n  private async computeDirectExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const exclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Process UserContentRestriction rules\n    const restrictions = await tx.userContentRestriction.findMany({\n      where: { userId },\n    });\n\n    for (const restriction of restrictions) {\n      const entityType = RESTRICTION_ENTITY_MAP[restriction.entityType];\n      if (!entityType) {\n        logger.warn(\"Unknown restriction entityType\", {\n          entityType: restriction.entityType,\n        });\n        continue;\n      }\n\n      const entityIds: string[] = JSON.parse(restriction.entityIds || \"[]\");\n\n      if (restriction.mode === \"EXCLUDE\") {\n        // Direct exclusion: these entities are excluded\n        for (const entityId of entityIds) {\n          exclusions.push({\n            userId,\n            entityType,\n            entityId,\n            reason: \"restricted\",\n          });\n        }\n      } else if (restriction.mode === \"INCLUDE\") {\n        // Invert: exclude everything NOT in this list\n        // This requires fetching all entity IDs of this type\n        const allIds = await this.getAllEntityIds(tx, entityType);\n        const includedSet = new Set(entityIds);\n        for (const entityId of allIds) {\n          if (!includedSet.has(entityId)) {\n            exclusions.push({\n              userId,\n              entityType,\n              entityId,\n              reason: \"restricted\",\n            });\n          }\n        }\n      }\n    }\n\n    // Process UserHiddenEntity records\n    const hiddenEntities = await tx.userHiddenEntity.findMany({\n      where: { userId },\n    });\n\n    for (const hidden of hiddenEntities) {\n      exclusions.push({\n        userId,\n        entityType: hidden.entityType,\n        entityId: hidden.entityId,\n        reason: \"hidden\",\n      });\n    }\n\n    // Batch insert all exclusions\n    if (exclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: exclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeDirectExclusions complete\", {\n      userId,\n      restrictionCount: restrictions.length,\n      hiddenCount: hiddenEntities.length,\n      exclusionCount: exclusions.length,\n    });\n  }\n\n  /**\n   * Get all entity IDs of a given type (for INCLUDE mode inversion).\n   */\n  private async getAllEntityIds(\n    tx: TransactionClient,\n    entityType: string\n  ): Promise&lt;string[]&gt; {\n    switch (entityType) {\n      case \"scene\":\n        return (\n          await tx.stashScene.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"performer\":\n        return (\n          await tx.stashPerformer.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"studio\":\n        return (\n          await tx.stashStudio.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"tag\":\n        return (\n          await tx.stashTag.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"group\":\n        return (\n          await tx.stashGroup.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"gallery\":\n        return (\n          await tx.stashGallery.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"image\":\n        return (\n          await tx.stashImage.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      default:\n        logger.warn(\"Unknown entity type in getAllEntityIds\", { entityType });\n        return [];\n    }\n  }\n}\n\nexport const exclusionComputationService = new ExclusionComputationService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement direct exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-4-implement-cascade-exclusions","title":"Task 4: Implement Cascade Exclusions","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for cascade exclusions</p> <p>Add to the test file:</p> <pre><code>describe(\"computeCascadeExclusions\", () =&gt; {\n  it(\"should cascade performer exclusion to their scenes\", async () =&gt; {\n    // Setup: performer1 is excluded\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\", reason: \"hidden\" },\n    ]);\n    mockPrisma.scenePerformer.findMany.mockResolvedValue([\n      { sceneId: \"scene1\", performerId: \"perf1\" },\n      { sceneId: \"scene2\", performerId: \"perf1\" },\n    ]);\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 3 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    // Verify scenes were cascade-excluded\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          entityType: \"scene\",\n          entityId: \"scene1\",\n          reason: \"cascade\",\n        }),\n        expect.objectContaining({\n          entityType: \"scene\",\n          entityId: \"scene2\",\n          reason: \"cascade\",\n        }),\n      ])\n    );\n  });\n\n  it(\"should cascade tag exclusion to scenes with that tag (direct and inherited)\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"tag\", entityId: \"tag1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"tag\", entityId: \"tag1\", reason: \"hidden\" },\n    ]);\n    // Direct tag association\n    mockPrisma.sceneTag.findMany.mockResolvedValue([\n      { sceneId: \"scene1\", tagId: \"tag1\" },\n    ]);\n    // Inherited tags - raw query mock\n    mockPrisma.$queryRaw = vi.fn().mockResolvedValue([{ id: \"scene2\" }]);\n    mockPrisma.performerTag.findMany.mockResolvedValue([]);\n    mockPrisma.studioTag.findMany.mockResolvedValue([]);\n    mockPrisma.groupTag.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 3 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({ entityType: \"scene\", entityId: \"scene1\" }),\n        expect.objectContaining({ entityType: \"scene\", entityId: \"scene2\" }),\n      ])\n    );\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL</p> <p>Step 3: Implement cascade exclusions</p> <p>Add to <code>ExclusionComputationService.ts</code> after <code>computeDirectExclusions</code>:</p> <pre><code>  /**\n   * Phase 3: Compute cascade exclusions from hidden/restricted entities.\n   */\n  private async computeCascadeExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    // Get all directly excluded entities\n    const directExclusions = await tx.userExcludedEntity.findMany({\n      where: {\n        userId,\n        reason: { in: [\"restricted\", \"hidden\"] },\n      },\n    });\n\n    // Group by entity type\n    const byType = new Map&lt;string, string[]&gt;();\n    for (const exc of directExclusions) {\n      const list = byType.get(exc.entityType) || [];\n      list.push(exc.entityId);\n      byType.set(exc.entityType, list);\n    }\n\n    const cascadeExclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Cascade: excluded performers \u2192 their scenes\n    const excludedPerformers = byType.get(\"performer\") || [];\n    if (excludedPerformers.length &gt; 0) {\n      const scenePerformers = await tx.scenePerformer.findMany({\n        where: { performerId: { in: excludedPerformers } },\n        select: { sceneId: true },\n      });\n      for (const sp of scenePerformers) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sp.sceneId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded studios \u2192 their scenes\n    const excludedStudios = byType.get(\"studio\") || [];\n    if (excludedStudios.length &gt; 0) {\n      const scenes = await tx.stashScene.findMany({\n        where: { studioId: { in: excludedStudios }, deletedAt: null },\n        select: { id: true },\n      });\n      for (const s of scenes) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: s.id,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded tags \u2192 scenes (direct + inherited), performers, studios, groups\n    const excludedTags = byType.get(\"tag\") || [];\n    if (excludedTags.length &gt; 0) {\n      // Scenes with direct tag\n      const directTagScenes = await tx.sceneTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { sceneId: true },\n      });\n      for (const st of directTagScenes) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: st.sceneId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Scenes with inherited tag (using raw SQL for JSON search)\n      // Build a query that finds scenes where inheritedTagIds contains any of the excluded tags\n      for (const tagId of excludedTags) {\n        const inheritedScenes = await (tx as any).$queryRaw`\n          SELECT id FROM StashScene\n          WHERE deletedAt IS NULL\n          AND EXISTS (\n            SELECT 1 FROM json_each(inheritedTagIds)\n            WHERE json_each.value = ${tagId}\n          )\n        `;\n        for (const s of inheritedScenes as { id: string }[]) {\n          cascadeExclusions.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n      }\n\n      // Performers with excluded tag\n      const taggedPerformers = await tx.performerTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { performerId: true },\n      });\n      for (const pt of taggedPerformers) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"performer\",\n          entityId: pt.performerId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Studios with excluded tag\n      const taggedStudios = await tx.studioTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { studioId: true },\n      });\n      for (const st of taggedStudios) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"studio\",\n          entityId: st.studioId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Groups with excluded tag\n      const taggedGroups = await tx.groupTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { groupId: true },\n      });\n      for (const gt of taggedGroups) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"group\",\n          entityId: gt.groupId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded groups \u2192 their scenes\n    const excludedGroups = byType.get(\"group\") || [];\n    if (excludedGroups.length &gt; 0) {\n      const sceneGroups = await tx.sceneGroup.findMany({\n        where: { groupId: { in: excludedGroups } },\n        select: { sceneId: true },\n      });\n      for (const sg of sceneGroups) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sg.sceneId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded galleries \u2192 linked scenes, images in gallery\n    const excludedGalleries = byType.get(\"gallery\") || [];\n    if (excludedGalleries.length &gt; 0) {\n      const sceneGalleries = await tx.sceneGallery.findMany({\n        where: { galleryId: { in: excludedGalleries } },\n        select: { sceneId: true },\n      });\n      for (const sg of sceneGalleries) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sg.sceneId,\n          reason: \"cascade\",\n        });\n      }\n\n      const galleryImages = await tx.imageGallery.findMany({\n        where: { galleryId: { in: excludedGalleries } },\n        select: { imageId: true },\n      });\n      for (const gi of galleryImages) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"image\",\n          entityId: gi.imageId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Batch insert cascade exclusions\n    if (cascadeExclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: cascadeExclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeCascadeExclusions complete\", {\n      userId,\n      cascadeCount: cascadeExclusions.length,\n    });\n  }\n</code></pre> <p>Also update <code>recomputeForUser</code> to call this method:</p> <pre><code>  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Phase 1: Clear existing exclusions\n      await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n      // Phase 2: Compute direct exclusions (restrictions + hidden)\n      await this.computeDirectExclusions(tx, userId);\n\n      // Phase 3: Compute cascade exclusions\n      await this.computeCascadeExclusions(tx, userId);\n\n      // Phase 4: Compute empty exclusions (to be implemented)\n      // await this.computeEmptyExclusions(tx, userId);\n\n      // Phase 5: Update stats (to be implemented)\n      // await this.updateEntityStats(tx, userId);\n    });\n\n    logger.info(\"ExclusionComputationService.recomputeForUser complete\", {\n      userId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement cascade exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-5-implement-empty-entity-exclusions","title":"Task 5: Implement Empty Entity Exclusions","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for empty exclusions</p> <p>Add to test file:</p> <pre><code>describe(\"computeEmptyExclusions\", () =&gt; {\n  it(\"should exclude galleries with no visible images\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([]);\n\n    // Mock raw query for empty galleries\n    mockPrisma.$queryRaw = vi.fn().mockResolvedValue([\n      { id: \"gallery1\" },\n      { id: \"gallery2\" },\n    ]);\n\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data || []);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          entityType: \"gallery\",\n          reason: \"empty\",\n        }),\n      ])\n    );\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL</p> <p>Step 3: Implement empty exclusions</p> <p>Add to <code>ExclusionComputationService.ts</code>:</p> <pre><code>  /**\n   * Phase 4: Compute empty entity exclusions.\n   * Excludes organizational entities with no visible content.\n   */\n  private async computeEmptyExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const emptyExclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Empty galleries: galleries with 0 visible images\n    const emptyGalleries = await (tx as any).$queryRaw`\n      SELECT g.id FROM StashGallery g\n      WHERE g.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM ImageGallery ig\n        JOIN StashImage i ON ig.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ig.galleryId = g.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const g of emptyGalleries as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"gallery\",\n        entityId: g.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty performers: performers with 0 visible scenes AND 0 visible images\n    const emptyPerformers = await (tx as any).$queryRaw`\n      SELECT p.id FROM StashPerformer p\n      WHERE p.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM ScenePerformer sp\n        JOIN StashScene s ON sp.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE sp.performerId = p.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM ImagePerformer ip\n        JOIN StashImage i ON ip.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ip.performerId = p.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const p of emptyPerformers as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"performer\",\n        entityId: p.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty studios: studios with 0 visible scenes AND 0 visible images AND no visible child studios\n    // Note: This requires recursive CTE for hierarchy, simplified version first\n    const emptyStudios = await (tx as any).$queryRaw`\n      SELECT st.id FROM StashStudio st\n      WHERE st.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM StashScene s\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE s.studioId = st.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM ImageStudio ims\n        JOIN StashImage i ON ims.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ims.studioId = st.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const s of emptyStudios as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"studio\",\n        entityId: s.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty groups: groups with 0 visible scenes\n    const emptyGroups = await (tx as any).$queryRaw`\n      SELECT g.id FROM StashGroup g\n      WHERE g.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM SceneGroup sg\n        JOIN StashScene s ON sg.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE sg.groupId = g.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const g of emptyGroups as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"group\",\n        entityId: g.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty tags: tags not attached to any visible entity\n    const emptyTags = await (tx as any).$queryRaw`\n      SELECT t.id FROM StashTag t\n      WHERE t.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM SceneTag st\n        JOIN StashScene s ON st.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE st.tagId = t.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM PerformerTag pt\n        JOIN StashPerformer p ON pt.performerId = p.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'performer' AND e.entityId = p.id\n        WHERE pt.tagId = t.id AND p.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM StudioTag stt\n        JOIN StashStudio st ON stt.studioId = st.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'studio' AND e.entityId = st.id\n        WHERE stt.tagId = t.id AND st.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM GroupTag gt\n        JOIN StashGroup g ON gt.groupId = g.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'group' AND e.entityId = g.id\n        WHERE gt.tagId = t.id AND g.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const t of emptyTags as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"tag\",\n        entityId: t.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Batch insert empty exclusions\n    if (emptyExclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: emptyExclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeEmptyExclusions complete\", {\n      userId,\n      emptyCount: emptyExclusions.length,\n    });\n  }\n</code></pre> <p>Update <code>recomputeForUser</code> to call this method:</p> <pre><code>      // Phase 4: Compute empty exclusions\n      await this.computeEmptyExclusions(tx, userId);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement empty entity exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-6-implement-entity-stats-update","title":"Task 6: Implement Entity Stats Update","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code></p> <p>Step 1: Implement stats update</p> <p>Add to <code>ExclusionComputationService.ts</code>:</p> <pre><code>  /**\n   * Phase 5: Update visible entity counts for the user.\n   */\n  private async updateEntityStats(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const entityTypes = [\"scene\", \"performer\", \"studio\", \"tag\", \"group\", \"gallery\", \"image\"];\n\n    for (const entityType of entityTypes) {\n      const total = await this.getEntityCount(tx, entityType);\n      const excluded = await tx.userExcludedEntity.count({\n        where: { userId, entityType },\n      });\n\n      await tx.userEntityStats.upsert({\n        where: { userId_entityType: { userId, entityType } },\n        create: { userId, entityType, visibleCount: total - excluded },\n        update: { visibleCount: total - excluded },\n      });\n    }\n\n    logger.debug(\"updateEntityStats complete\", { userId });\n  }\n\n  /**\n   * Get total count of entities of a given type.\n   */\n  private async getEntityCount(\n    tx: TransactionClient,\n    entityType: string\n  ): Promise&lt;number&gt; {\n    switch (entityType) {\n      case \"scene\":\n        return tx.stashScene.count({ where: { deletedAt: null } });\n      case \"performer\":\n        return tx.stashPerformer.count({ where: { deletedAt: null } });\n      case \"studio\":\n        return tx.stashStudio.count({ where: { deletedAt: null } });\n      case \"tag\":\n        return tx.stashTag.count({ where: { deletedAt: null } });\n      case \"group\":\n        return tx.stashGroup.count({ where: { deletedAt: null } });\n      case \"gallery\":\n        return tx.stashGallery.count({ where: { deletedAt: null } });\n      case \"image\":\n        return tx.stashImage.count({ where: { deletedAt: null } });\n      default:\n        return 0;\n    }\n  }\n</code></pre> <p>Update <code>recomputeForUser</code> to call this method:</p> <pre><code>      // Phase 5: Update stats\n      await this.updateEntityStats(tx, userId);\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts\ngit commit -m \"feat: implement entity stats update\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-7-implement-incremental-hideunhide","title":"Task 7: Implement Incremental Hide/Unhide","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Implement addHiddenEntity</p> <pre><code>  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Add the direct exclusion\n      await tx.userExcludedEntity.upsert({\n        where: {\n          userId_entityType_entityId: { userId, entityType, entityId },\n        },\n        create: { userId, entityType, entityId, reason: \"hidden\" },\n        update: { reason: \"hidden\" },\n      });\n\n      // Compute cascades for this specific entity\n      await this.addCascadesForEntity(tx, userId, entityType, entityId);\n    });\n\n    logger.info(\"ExclusionComputationService.addHiddenEntity complete\", {\n      userId,\n      entityType,\n      entityId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Compute and add cascade exclusions for a single hidden entity.\n   */\n  private async addCascadesForEntity(\n    tx: TransactionClient,\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    const cascades: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    switch (entityType) {\n      case \"performer\": {\n        const scenes = await tx.scenePerformer.findMany({\n          where: { performerId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"studio\": {\n        const scenes = await tx.stashScene.findMany({\n          where: { studioId: entityId, deletedAt: null },\n          select: { id: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"tag\": {\n        // Scenes with direct tag\n        const directScenes = await tx.sceneTag.findMany({\n          where: { tagId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of directScenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n\n        // Scenes with inherited tag\n        const inheritedScenes = await (tx as any).$queryRaw`\n          SELECT id FROM StashScene\n          WHERE deletedAt IS NULL\n          AND EXISTS (\n            SELECT 1 FROM json_each(inheritedTagIds)\n            WHERE json_each.value = ${entityId}\n          )\n        `;\n        for (const s of inheritedScenes as { id: string }[]) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n\n        // Performers, studios, groups with this tag\n        const performers = await tx.performerTag.findMany({\n          where: { tagId: entityId },\n          select: { performerId: true },\n        });\n        for (const p of performers) {\n          cascades.push({\n            userId,\n            entityType: \"performer\",\n            entityId: p.performerId,\n            reason: \"cascade\",\n          });\n        }\n\n        const studios = await tx.studioTag.findMany({\n          where: { tagId: entityId },\n          select: { studioId: true },\n        });\n        for (const s of studios) {\n          cascades.push({\n            userId,\n            entityType: \"studio\",\n            entityId: s.studioId,\n            reason: \"cascade\",\n          });\n        }\n\n        const groups = await tx.groupTag.findMany({\n          where: { tagId: entityId },\n          select: { groupId: true },\n        });\n        for (const g of groups) {\n          cascades.push({\n            userId,\n            entityType: \"group\",\n            entityId: g.groupId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"group\": {\n        const scenes = await tx.sceneGroup.findMany({\n          where: { groupId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"gallery\": {\n        const scenes = await tx.sceneGallery.findMany({\n          where: { galleryId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n\n        const images = await tx.imageGallery.findMany({\n          where: { galleryId: entityId },\n          select: { imageId: true },\n        });\n        for (const i of images) {\n          cascades.push({\n            userId,\n            entityType: \"image\",\n            entityId: i.imageId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n    }\n\n    if (cascades.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: cascades,\n        skipDuplicates: true,\n      });\n    }\n  }\n</code></pre> <p>Step 2: Implement removeHiddenEntity</p> <pre><code>  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n\n    // Queue async recompute - the unhide might affect cascade exclusions\n    // that need to be recalculated based on remaining hidden entities\n    setImmediate(() =&gt; {\n      this.recomputeForUser(userId).catch((err) =&gt; {\n        logger.error(\"Failed to recompute exclusions after unhide\", {\n          userId,\n          entityType,\n          entityId,\n          error: err,\n        });\n      });\n    });\n  }\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement incremental hide/unhide operations\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-8-update-scenequerybuilder-to-use-exclusion-join","title":"Task 8: Update SceneQueryBuilder to Use Exclusion JOIN","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/SceneQueryBuilder.test.ts</code></p> <p>Step 1: Update SceneQueryOptions interface</p> <p>In <code>SceneQueryBuilder.ts</code>, change the interface:</p> <pre><code>// Query builder options\nexport interface SceneQueryOptions {\n  userId: number;\n  filters?: PeekSceneFilter;\n  applyExclusions?: boolean;  // Default true, replaces excludedSceneIds\n  sort: string;\n  sortDirection: \"ASC\" | \"DESC\";\n  page: number;\n  perPage: number;\n  randomSeed?: number;\n}\n</code></pre> <p>Step 2: Update buildFromClause to include exclusion JOIN</p> <pre><code>  // Base FROM clause with user data JOINs and exclusion filter\n  private buildFromClause(userId: number, applyExclusions: boolean = true): { sql: string; params: number[] } {\n    const baseJoins = `\n      FROM StashScene s\n      LEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\n      LEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\n    `.trim();\n\n    if (applyExclusions) {\n      return {\n        sql: `${baseJoins}\n      LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id`,\n        params: [userId, userId, userId],\n      };\n    }\n\n    return {\n      sql: baseJoins,\n      params: [userId, userId],\n    };\n  }\n</code></pre> <p>Step 3: Update buildBaseWhere to include exclusion filter</p> <pre><code>  // Base WHERE clause (always filter deleted, optionally filter excluded)\n  private buildBaseWhere(applyExclusions: boolean = true): FilterClause {\n    if (applyExclusions) {\n      return {\n        sql: \"s.deletedAt IS NULL AND e.id IS NULL\",\n        params: [],\n      };\n    }\n    return {\n      sql: \"s.deletedAt IS NULL\",\n      params: [],\n    };\n  }\n</code></pre> <p>Step 4: Remove buildExclusionFilter method</p> <p>Delete the <code>buildExclusionFilter</code> method (lines 88-125) - it's no longer needed.</p> <p>Step 5: Update execute method</p> <p>Update the <code>execute</code> method to use <code>applyExclusions</code> instead of <code>excludedSceneIds</code>:</p> <pre><code>  async execute(options: SceneQueryOptions): Promise&lt;SceneQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage, applyExclusions = true, filters } = options;\n\n    // Build FROM clause\n    const fromClause = this.buildFromClause(userId, applyExclusions);\n\n    // Build WHERE clauses\n    const whereClauses: FilterClause[] = [this.buildBaseWhere(applyExclusions)];\n\n    // Remove the exclusion filter call - it's now in the JOIN\n    // const exclusionFilter = this.buildExclusionFilter(excludedSceneIds || new Set());\n    // if (exclusionFilter.sql) {\n    //   whereClauses.push(exclusionFilter);\n    // }\n\n    // ... rest of the method stays the same\n</code></pre> <p>Step 6: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/\n</code></pre></p> <p>Expected: PASS (some tests may need updates for new interface)</p> <p>Step 7: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/services/__tests__/\ngit commit -m \"refactor: update SceneQueryBuilder to use exclusion JOIN\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-9-update-scene-controllers-to-remove-getexcludedsceneids-calls","title":"Task 9: Update Scene Controllers to Remove getExcludedSceneIds Calls","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Update scenes.ts</p> <p>Find all calls to <code>userRestrictionService.getExcludedSceneIds</code> and remove them. Update <code>sceneQueryBuilder.execute</code> calls to remove <code>excludedSceneIds</code> parameter.</p> <p>Before: <pre><code>const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\nconst result = await sceneQueryBuilder.execute({\n  userId,\n  excludedSceneIds: excludedIds,\n  // ...\n});\n</code></pre></p> <p>After: <pre><code>const result = await sceneQueryBuilder.execute({\n  userId,\n  // applyExclusions defaults to true\n  // ...\n});\n</code></pre></p> <p>Step 2: Update carousel.ts</p> <p>Same pattern - remove <code>getExcludedSceneIds</code> calls and <code>excludedSceneIds</code> parameters.</p> <p>Step 3: Run tests and verify server starts</p> <p>Run: <pre><code>cd server &amp;&amp; npm run build &amp;&amp; npm test\n</code></pre></p> <p>Expected: Build succeeds, tests pass</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/\ngit commit -m \"refactor: remove getExcludedSceneIds calls from scene controllers\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-10-wire-up-sync-trigger","title":"Task 10: Wire Up Sync Trigger","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Import ExclusionComputationService</p> <p>Add at top of file: <pre><code>import { exclusionComputationService } from \"./ExclusionComputationService.js\";\n</code></pre></p> <p>Step 2: Call recomputeAllUsers after sync completes</p> <p>Find the sync completion point (after all entity types are synced) and add:</p> <pre><code>// After sync completes, recompute exclusions for all users\nlogger.info(\"Sync complete, recomputing user exclusions...\");\nawait exclusionComputationService.recomputeAllUsers();\nlogger.info(\"User exclusions recomputed\");\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: trigger exclusion recompute after Stash sync\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-11-wire-up-hideunhide-triggers","title":"Task 11: Wire Up Hide/Unhide Triggers","text":"<p>Files: - Modify: <code>server/services/UserHiddenEntityService.ts</code></p> <p>Step 1: Import ExclusionComputationService</p> <p>Add at top of file: <pre><code>import { exclusionComputationService } from \"./ExclusionComputationService.js\";\n</code></pre></p> <p>Step 2: Update hide method</p> <p>After adding to <code>UserHiddenEntity</code> table, call: <pre><code>await exclusionComputationService.addHiddenEntity(userId, entityType, entityId);\n</code></pre></p> <p>Step 3: Update unhide method</p> <p>After removing from <code>UserHiddenEntity</code> table, call: <pre><code>await exclusionComputationService.removeHiddenEntity(userId, entityType, entityId);\n</code></pre></p> <p>Step 4: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/UserHiddenEntityService.ts\ngit commit -m \"feat: trigger exclusion updates on hide/unhide\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-12-wire-up-restriction-change-trigger","title":"Task 12: Wire Up Restriction Change Trigger","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> (or wherever restrictions are updated)</p> <p>Step 1: Find restriction update endpoint</p> <p>Look for the endpoint that handles <code>PUT /api/user/restrictions</code> or similar.</p> <p>Step 2: Add recompute call after restriction change</p> <pre><code>import { exclusionComputationService } from \"../services/ExclusionComputationService.js\";\n\n// After updating UserContentRestriction:\nawait exclusionComputationService.recomputeForUser(userId);\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/\ngit commit -m \"feat: trigger exclusion recompute on restriction change\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-13-add-admin-endpoints-for-manual-recompute","title":"Task 13: Add Admin Endpoints for Manual Recompute","text":"<p>Files: - Create or modify: <code>server/controllers/admin.ts</code> or <code>server/routes/admin.ts</code></p> <p>Step 1: Add recompute endpoints</p> <pre><code>import { exclusionComputationService } from \"../services/ExclusionComputationService.js\";\n\n// POST /api/admin/recompute-exclusions/:userId\nrouter.post(\"/recompute-exclusions/:userId\", requireAdmin, async (req, res) =&gt; {\n  const userId = parseInt(req.params.userId, 10);\n  await exclusionComputationService.recomputeForUser(userId);\n  res.json({ success: true, message: `Recomputed exclusions for user ${userId}` });\n});\n\n// POST /api/admin/recompute-exclusions/all\nrouter.post(\"/recompute-exclusions/all\", requireAdmin, async (req, res) =&gt; {\n  await exclusionComputationService.recomputeAllUsers();\n  res.json({ success: true, message: \"Recomputed exclusions for all users\" });\n});\n\n// GET /api/admin/exclusion-stats\nrouter.get(\"/exclusion-stats\", requireAdmin, async (req, res) =&gt; {\n  const stats = await prisma.userExcludedEntity.groupBy({\n    by: [\"userId\", \"entityType\"],\n    _count: true,\n  });\n  res.json(stats);\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/ server/routes/\ngit commit -m \"feat: add admin endpoints for exclusion management\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-14-update-other-entity-controllers-performers-studios-tags-groups-galleries-images","title":"Task 14: Update Other Entity Controllers (Performers, Studios, Tags, Groups, Galleries, Images)","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/studios.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/groups.ts</code> - Modify: <code>server/controllers/library/galleries.ts</code> - Modify: <code>server/controllers/library/images.ts</code></p> <p>For each controller, add exclusion JOIN to queries. The pattern is:</p> <pre><code>LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = '&lt;type&gt;' AND e.entityId = &lt;table&gt;.id\nWHERE ... AND e.id IS NULL\n</code></pre> <p>This is a large task - break into sub-tasks per controller.</p> <p>Commit after each controller is updated:</p> <pre><code>git add server/controllers/library/&lt;entity&gt;.ts\ngit commit -m \"refactor: add exclusion JOIN to &lt;entity&gt; queries\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-15-remove-old-filtering-services","title":"Task 15: Remove Old Filtering Services","text":"<p>Files: - Delete: <code>server/services/UserRestrictionService.ts</code> - Delete: <code>server/services/EmptyEntityFilterService.ts</code> - Delete: <code>server/services/FilteredEntityCacheService.ts</code></p> <p>Step 1: Search for imports</p> <p>Run: <pre><code>cd server &amp;&amp; grep -r \"UserRestrictionService\\|EmptyEntityFilterService\\|FilteredEntityCacheService\" --include=\"*.ts\"\n</code></pre></p> <p>Update any remaining imports to use the new services.</p> <p>Step 2: Delete old files</p> <pre><code>rm server/services/UserRestrictionService.ts\nrm server/services/EmptyEntityFilterService.ts\nrm server/services/FilteredEntityCacheService.ts\n</code></pre> <p>Step 3: Run build and tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm run build &amp;&amp; npm test\n</code></pre></p> <p>Expected: Build succeeds, tests pass</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: remove deprecated filtering services\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-16-final-integration-test","title":"Task 16: Final Integration Test","text":"<p>Step 1: Start the server</p> <pre><code>cd server &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Manual testing checklist</p> <ol> <li>Fresh user login \u2192 verify initial exclusion computation works</li> <li>Admin changes restrictions \u2192 verify recomputation triggers</li> <li>User hides entity \u2192 verify it disappears immediately</li> <li>User unhides entity \u2192 verify it reappears after brief delay</li> <li>Stash sync \u2192 verify new items are checked against rules</li> <li>Filter dropdowns \u2192 verify hidden entities don't appear</li> </ol> <p>Step 3: Final commit</p> <pre><code>git add -A\ngit commit -m \"feat: complete pre-computed exclusions implementation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#summary","title":"Summary","text":"<p>This implementation plan covers:</p> <ol> <li>Database schema - New tables for exclusions and stats</li> <li>Computation service - Full recompute algorithm with phases</li> <li>Cascade logic - Performer\u2192scene, tag\u2192everything, etc.</li> <li>Empty entity detection - Galleries, performers, studios, groups, tags</li> <li>Incremental updates - Sync hide, async unhide</li> <li>Query changes - JOIN-based filtering in SceneQueryBuilder</li> <li>Controller updates - Remove old filtering calls</li> <li>Triggers - Sync, hide/unhide, restriction changes</li> <li>Admin endpoints - Manual recompute, stats</li> <li>Cleanup - Remove deprecated services</li> </ol> <p>Plan complete and saved to <code>docs/plans/2025-01-02-pre-computed-exclusions-implementation.md</code>. Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/","title":"Scene Tag Inheritance","text":"<p>Branch: <code>feature/scene-tag-inheritance</code> Status: Design Complete Complexity: Medium</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#problem-statement","title":"Problem Statement","text":"<p>Scenes display and filter by \"inherited\" tags from related entities. Currently: - Direct Scene Tags \u2014 works - Performer Tags \u2014 works (tags on performers in the scene) - Studio Tags \u2014 works (tags on the scene's studio) - Group Tags \u2014 MISSING (tags on groups the scene belongs to)</p> <p>Additionally, this inheritance is computed at render time on the client, causing: 1. Duplicated logic in multiple components (<code>SceneCard.jsx</code>, <code>SceneMetadata.jsx</code>) 2. Inefficient re-computation on every render 3. Inconsistency between UI display and server-side restriction filtering</p> <p>Goal: Denormalize inherited tags at sync time, storing them directly on the Scene. This matches the pattern proposed for Image Gallery Inheritance.</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#solution-overview","title":"Solution Overview","text":"<p>Approach: Store inherited tags on the Scene at sync time, similar to Image Gallery Inheritance.</p> <p>New field on <code>StashScene</code>: <pre><code>inheritedTagIds String? // JSON array of tag IDs inherited from performers, studio, groups\n</code></pre></p> <p>Why a separate field instead of adding to SceneTag junction? - Keeps direct tags distinct from inherited (important for editing in Stash) - Easy to recompute on sync without touching user's direct assignments - Client can merge for display: <code>[...scene.tags, ...inheritedTags]</code></p> <p>Inheritance sources (collected at sync):</p> Source When Performer Tags For each performer in scene, collect their tags Studio Tags If scene has a studio, collect its tags Group Tags For each group the scene belongs to, collect their tags <p>Deduplication: Store as a Set of tag IDs, converted to JSON array. Tags already directly on the scene are excluded from <code>inheritedTagIds</code> to avoid duplicates.</p> <p>Client changes: - Remove runtime tag merging logic from <code>SceneCard.jsx</code> and <code>SceneMetadata.jsx</code> - Scene response includes both <code>tags</code> (direct) and <code>inheritedTags</code> (denormalized) - Components display combined list</p> <p>Server changes: - <code>UserRestrictionService.getSceneEntityIds()</code> \u2014 simplify to use <code>inheritedTagIds</code> instead of runtime collection - Restriction filtering becomes a simple array check</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#schema-change","title":"Schema Change","text":"<pre><code>model StashScene {\n  // ... existing fields ...\n\n  // Inherited tags (denormalized at sync time)\n  // JSON array of tag IDs from performers, studio, and groups\n  inheritedTagIds String? // e.g., '[\"1\",\"5\",\"12\"]'\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesstashsyncservicets","title":"File: <code>server/services/StashSyncService.ts</code>","text":"<p>After syncing scenes with their relationships, compute inherited tags:</p> <pre><code>async function computeInheritedTags(sceneId: string): Promise&lt;string[]&gt; {\n  const tagIds = new Set&lt;string&gt;();\n\n  // Get scene's direct tag IDs (to exclude from inherited)\n  const directTags = await prisma.sceneTag.findMany({\n    where: { sceneId },\n    select: { tagId: true }\n  });\n  const directTagIds = new Set(directTags.map(t =&gt; t.tagId));\n\n  // Collect performer tags\n  const scenePerformers = await prisma.scenePerformer.findMany({\n    where: { sceneId },\n    select: { performerId: true }\n  });\n  for (const sp of scenePerformers) {\n    const performerTags = await prisma.performerTag.findMany({\n      where: { performerId: sp.performerId },\n      select: { tagId: true }\n    });\n    performerTags.forEach(pt =&gt; {\n      if (!directTagIds.has(pt.tagId)) tagIds.add(pt.tagId);\n    });\n  }\n\n  // Collect studio tags\n  const scene = await prisma.stashScene.findUnique({\n    where: { id: sceneId },\n    select: { studioId: true }\n  });\n  if (scene?.studioId) {\n    const studioTags = await prisma.studioTag.findMany({\n      where: { studioId: scene.studioId },\n      select: { tagId: true }\n    });\n    studioTags.forEach(st =&gt; {\n      if (!directTagIds.has(st.tagId)) tagIds.add(st.tagId);\n    });\n  }\n\n  // Collect group tags\n  const sceneGroups = await prisma.sceneGroup.findMany({\n    where: { sceneId },\n    select: { groupId: true }\n  });\n  for (const sg of sceneGroups) {\n    const groupTags = await prisma.groupTag.findMany({\n      where: { groupId: sg.groupId },\n      select: { tagId: true }\n    });\n    groupTags.forEach(gt =&gt; {\n      if (!directTagIds.has(gt.tagId)) tagIds.add(gt.tagId);\n    });\n  }\n\n  return Array.from(tagIds);\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesstashentityservicets","title":"File: <code>server/services/StashEntityService.ts</code>","text":"<p>Update <code>transformScene</code> to include inherited tags:</p> <pre><code>private transformScene(scene: any): NormalizedScene {\n  // ... existing transform ...\n\n  // Parse inherited tag IDs and hydrate with tag data\n  const inheritedTagIds = scene.inheritedTagIds\n    ? JSON.parse(scene.inheritedTagIds)\n    : [];\n\n  return {\n    ...base,\n    inheritedTagIds, // Raw IDs for filtering\n    // inheritedTags will be hydrated in controller if needed for display\n  };\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesuserrestrictionservicets","title":"File: <code>server/services/UserRestrictionService.ts</code>","text":"<p>Simplify <code>getSceneEntityIds()</code>:</p> <pre><code>// Before: complex runtime collection from nested objects\n// After: simple array concat\ncase \"tags\": {\n  const directTagIds = (scene.tags || []).map(t =&gt; String(t.id));\n  const inheritedTagIds = scene.inheritedTagIds || [];\n  return [...new Set([...directTagIds, ...inheritedTagIds])];\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#client-changes","title":"Client Changes","text":"<p>Remove <code>getAllTags()</code> / <code>mergeAllTags()</code> functions from: - <code>client/src/components/ui/SceneCard.jsx</code> (lines 82-98) - <code>client/src/components/scene/SceneMetadata.jsx</code> (lines 7-30)</p> <p>Replace with: <pre><code>const allTags = [...(scene.tags || []), ...(scene.inheritedTags || [])];\n</code></pre></p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Basic inheritance display:</li> <li>Create a Scene with no direct tags</li> <li>Add it to a Performer with tags, a Studio with tags, and a Group with tags</li> <li>Run sync</li> <li>Verify Scene cards show all inherited tags</li> <li> <p>Verify Scene detail page shows all inherited tags</p> </li> <li> <p>Deduplication:</p> </li> <li>Create a Scene with tag \"Action\" directly assigned</li> <li>Add a Performer to the scene who also has tag \"Action\"</li> <li>Run sync</li> <li> <p>Verify \"Action\" appears only once (not duplicated)</p> </li> <li> <p>Group tags now work:</p> </li> <li>Create a Group with tag \"Series A\"</li> <li>Add scenes to the Group (scenes have no direct tags)</li> <li>Run sync</li> <li> <p>Verify scenes display \"Series A\" tag</p> </li> <li> <p>Restriction filtering:</p> </li> <li>Restrict tag \"Explicit\" for a user</li> <li>Create a Group with tag \"Explicit\"</li> <li>Add scenes to the Group</li> <li>Verify those scenes are hidden for the restricted user</li> <li> <p>Verify same works for Performer tags and Studio tags</p> </li> <li> <p>Tag filtering in library:</p> </li> <li>Filter scenes by a tag that only exists on a Performer (not directly on scenes)</li> <li> <p>Verify scenes with that performer appear in results</p> </li> <li> <p>Re-sync behavior:</p> </li> <li>Change a Performer's tags in Stash</li> <li>Run sync</li> <li>Verify scenes with that performer update their inherited tags</li> </ol>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Scene with no performers, no studio, no groups (inheritedTagIds = [])</li> <li>Scene removed from a group (inherited tags from that group should disappear on next sync)</li> <li>Performer removed from scene (inherited tags from that performer should disappear)</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/prisma/schema.prisma</code> \u2014 Add <code>inheritedTagIds</code> field to <code>StashScene</code></li> <li><code>server/services/StashSyncService.ts</code> \u2014 Add <code>computeInheritedTags()</code>, call after scene sync</li> <li><code>server/services/StashEntityService.ts</code> \u2014 Parse and include <code>inheritedTagIds</code> in transform</li> <li><code>server/services/UserRestrictionService.ts</code> \u2014 Simplify <code>getSceneEntityIds()</code> for tags</li> <li><code>client/src/components/ui/SceneCard.jsx</code> \u2014 Remove <code>getAllTags()</code>, use <code>inheritedTags</code> from response</li> <li><code>client/src/components/scene/SceneMetadata.jsx</code> \u2014 Remove <code>mergeAllTags()</code>, use <code>inheritedTags</code> from response</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents Scene Tag Inheritance under \"Pseudo-Relationships\"</li> <li>Image Gallery Inheritance \u2014 Same pattern for Images</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/","title":"Scene Tag Inheritance Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Denormalize inherited tags at sync time, storing them on the Scene for efficient filtering and display.</p> <p>Architecture: Add <code>inheritedTagIds</code> field to StashScene schema, create SceneTagInheritanceService to compute inherited tags from performers, studio, and groups at sync time. Update client to use server-provided inherited tags instead of computing at render time.</p> <p>Tech Stack: Prisma/SQLite, TypeScript, React</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-1-add-inheritedtagids-field-to-schema","title":"Task 1: Add inheritedTagIds Field to Schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code> (StashScene model, lines 423-495)</p> <p>Step 1: Add the field to StashScene model</p> <p>Add after line 471 (<code>syncedAt</code> field):</p> <pre><code>  inheritedTagIds String? // JSON array of tag IDs from performers, studio, groups\n</code></pre> <p>Step 2: Generate migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add-scene-inherited-tag-ids</code> Expected: Migration created successfully</p> <p>Step 3: Verify schema</p> <p>Run: <code>cd server &amp;&amp; npx prisma generate</code> Expected: Prisma Client generated successfully</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/schema.prisma server/prisma/migrations/\ngit commit -m \"feat: add inheritedTagIds field to StashScene schema\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-2-create-scenetaginheritanceservice","title":"Task 2: Create SceneTagInheritanceService","text":"<p>Files: - Create: <code>server/services/SceneTagInheritanceService.ts</code> - Create: <code>server/services/__tests__/SceneTagInheritanceService.test.ts</code></p> <p>Step 1: Write the test file</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { sceneTagInheritanceService } from \"../SceneTagInheritanceService.js\";\n\ndescribe(\"SceneTagInheritanceService\", () =&gt; {\n  // Clean up test data\n  beforeEach(async () =&gt; {\n    await prisma.sceneTag.deleteMany({});\n    await prisma.scenePerformer.deleteMany({});\n    await prisma.sceneGroup.deleteMany({});\n    await prisma.performerTag.deleteMany({});\n    await prisma.studioTag.deleteMany({});\n    await prisma.groupTag.deleteMany({});\n    await prisma.stashScene.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n    await prisma.stashGroup.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.sceneTag.deleteMany({});\n    await prisma.scenePerformer.deleteMany({});\n    await prisma.sceneGroup.deleteMany({});\n    await prisma.performerTag.deleteMany({});\n    await prisma.studioTag.deleteMany({});\n    await prisma.groupTag.deleteMany({});\n    await prisma.stashScene.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n    await prisma.stashGroup.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n  });\n\n  describe(\"computeInheritedTags\", () =&gt; {\n    it(\"should inherit tags from performer\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Performer Tag\" },\n      });\n\n      // Create performer with tag\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with performer\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.scenePerformer.create({\n        data: { sceneId: \"scene-1\", performerId: \"performer-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should inherit tags from studio\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Studio Tag\" },\n      });\n\n      // Create studio with tag\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n      await prisma.studioTag.create({\n        data: { studioId: \"studio-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with studio\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\", studioId: \"studio-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should inherit tags from group\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Group Tag\" },\n      });\n\n      // Create group with tag\n      await prisma.stashGroup.create({\n        data: { id: \"group-1\", name: \"Test Group\" },\n      });\n      await prisma.groupTag.create({\n        data: { groupId: \"group-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene in group\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.sceneGroup.create({\n        data: { sceneId: \"scene-1\", groupId: \"group-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should NOT include direct scene tags in inheritedTagIds\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Direct Tag\" },\n      });\n\n      // Create scene with direct tag\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.sceneTag.create({\n        data: { sceneId: \"scene-1\", tagId: \"tag-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify direct tag is NOT in inheritedTagIds\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).not.toContain(\"tag-1\");\n    });\n\n    it(\"should deduplicate tags from multiple sources\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Shared Tag\" },\n      });\n\n      // Create performer with tag\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n\n      // Create studio with same tag\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n      await prisma.studioTag.create({\n        data: { studioId: \"studio-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with both performer and studio\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\", studioId: \"studio-1\" },\n      });\n      await prisma.scenePerformer.create({\n        data: { sceneId: \"scene-1\", performerId: \"performer-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify tag appears only once\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      const tagCount = inheritedTagIds.filter((id: string) =&gt; id === \"tag-1\").length;\n      expect(tagCount).toBe(1);\n    });\n\n    it(\"should handle scene with no related entities\", async () =&gt; {\n      // Create scene with nothing\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Standalone Scene\" },\n      });\n\n      // Apply inheritance (should not fail)\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify empty inherited tags\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toEqual([]);\n    });\n\n    it(\"should collect tags from multiple performers\", async () =&gt; {\n      // Create tags\n      await prisma.stashTag.createMany({\n        data: [\n          { id: \"tag-1\", name: \"Performer 1 Tag\" },\n          { id: \"tag-2\", name: \"Performer 2 Tag\" },\n        ],\n      });\n\n      // Create two performers with different tags\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"performer-1\", name: \"Performer 1\" },\n          { id: \"performer-2\", name: \"Performer 2\" },\n        ],\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-2\", tagId: \"tag-2\" },\n      });\n\n      // Create scene with both performers\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.scenePerformer.createMany({\n        data: [\n          { sceneId: \"scene-1\", performerId: \"performer-1\" },\n          { sceneId: \"scene-1\", performerId: \"performer-2\" },\n        ],\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited both tags\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n      expect(inheritedTagIds).toContain(\"tag-2\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneTagInheritanceService</code> Expected: FAIL - module not found</p> <p>Step 3: Write the service</p> <pre><code>import prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * SceneTagInheritanceService\n *\n * Computes inherited tags for scenes from related entities.\n * Called after sync completes to denormalize tag data for efficient filtering.\n *\n * Inheritance sources:\n * - Performer tags (from performers in the scene)\n * - Studio tags (from the scene's studio)\n * - Group tags (from groups the scene belongs to)\n *\n * Rules:\n * - Direct scene tags are NOT included in inheritedTagIds (they're already in SceneTag)\n * - Tags are deduplicated across all sources\n * - Stored as JSON array for efficient querying\n */\nclass SceneTagInheritanceService {\n  /**\n   * Compute and store inherited tags for all scenes.\n   * Uses SQL for efficient bulk operations.\n   */\n  async computeInheritedTags(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"Computing inherited tags for scenes...\");\n\n    try {\n      // Get all scenes that need processing\n      const scenes = await prisma.stashScene.findMany({\n        where: { deletedAt: null },\n        select: { id: true, studioId: true },\n      });\n\n      // Process in batches for memory efficiency\n      const BATCH_SIZE = 500;\n      let processedCount = 0;\n\n      for (let i = 0; i &lt; scenes.length; i += BATCH_SIZE) {\n        const batch = scenes.slice(i, i + BATCH_SIZE);\n        await this.processBatch(batch);\n        processedCount += batch.length;\n\n        if (processedCount % 1000 === 0) {\n          logger.info(`Processed ${processedCount}/${scenes.length} scenes`);\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      logger.info(`Scene tag inheritance computed in ${duration}ms for ${scenes.length} scenes`);\n    } catch (error) {\n      logger.error(\"Failed to compute scene tag inheritance\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Process a batch of scenes\n   */\n  private async processBatch(\n    scenes: { id: string; studioId: string | null }[]\n  ): Promise&lt;void&gt; {\n    const sceneIds = scenes.map((s) =&gt; s.id);\n\n    // Get direct tags for all scenes in batch\n    const directTags = await prisma.sceneTag.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, tagId: true },\n    });\n    const directTagsByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const dt of directTags) {\n      if (!directTagsByScene.has(dt.sceneId)) {\n        directTagsByScene.set(dt.sceneId, new Set());\n      }\n      directTagsByScene.get(dt.sceneId)!.add(dt.tagId);\n    }\n\n    // Get performer tags for all scenes in batch\n    const scenePerformers = await prisma.scenePerformer.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, performerId: true },\n    });\n    const performerIds = [...new Set(scenePerformers.map((sp) =&gt; sp.performerId))];\n    const performerTags = await prisma.performerTag.findMany({\n      where: { performerId: { in: performerIds } },\n      select: { performerId: true, tagId: true },\n    });\n    const tagsByPerformer = new Map&lt;string, string[]&gt;();\n    for (const pt of performerTags) {\n      if (!tagsByPerformer.has(pt.performerId)) {\n        tagsByPerformer.set(pt.performerId, []);\n      }\n      tagsByPerformer.get(pt.performerId)!.push(pt.tagId);\n    }\n\n    // Get studio tags\n    const studioIds = [...new Set(scenes.filter((s) =&gt; s.studioId).map((s) =&gt; s.studioId!))] ;\n    const studioTags = await prisma.studioTag.findMany({\n      where: { studioId: { in: studioIds } },\n      select: { studioId: true, tagId: true },\n    });\n    const tagsByStudio = new Map&lt;string, string[]&gt;();\n    for (const st of studioTags) {\n      if (!tagsByStudio.has(st.studioId)) {\n        tagsByStudio.set(st.studioId, []);\n      }\n      tagsByStudio.get(st.studioId)!.push(st.tagId);\n    }\n\n    // Get group tags for all scenes in batch\n    const sceneGroups = await prisma.sceneGroup.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, groupId: true },\n    });\n    const groupIds = [...new Set(sceneGroups.map((sg) =&gt; sg.groupId))];\n    const groupTags = await prisma.groupTag.findMany({\n      where: { groupId: { in: groupIds } },\n      select: { groupId: true, tagId: true },\n    });\n    const tagsByGroup = new Map&lt;string, string[]&gt;();\n    for (const gt of groupTags) {\n      if (!tagsByGroup.has(gt.groupId)) {\n        tagsByGroup.set(gt.groupId, []);\n      }\n      tagsByGroup.get(gt.groupId)!.push(gt.tagId);\n    }\n\n    // Build scene -&gt; performer mapping\n    const performersByScene = new Map&lt;string, string[]&gt;();\n    for (const sp of scenePerformers) {\n      if (!performersByScene.has(sp.sceneId)) {\n        performersByScene.set(sp.sceneId, []);\n      }\n      performersByScene.get(sp.sceneId)!.push(sp.performerId);\n    }\n\n    // Build scene -&gt; group mapping\n    const groupsByScene = new Map&lt;string, string[]&gt;();\n    for (const sg of sceneGroups) {\n      if (!groupsByScene.has(sg.sceneId)) {\n        groupsByScene.set(sg.sceneId, []);\n      }\n      groupsByScene.get(sg.sceneId)!.push(sg.groupId);\n    }\n\n    // Compute inherited tags for each scene\n    const updates: { id: string; inheritedTagIds: string }[] = [];\n\n    for (const scene of scenes) {\n      const inheritedTags = new Set&lt;string&gt;();\n      const directTagsForScene = directTagsByScene.get(scene.id) || new Set();\n\n      // Collect performer tags\n      const performers = performersByScene.get(scene.id) || [];\n      for (const performerId of performers) {\n        const tags = tagsByPerformer.get(performerId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      // Collect studio tags\n      if (scene.studioId) {\n        const tags = tagsByStudio.get(scene.studioId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      // Collect group tags\n      const groups = groupsByScene.get(scene.id) || [];\n      for (const groupId of groups) {\n        const tags = tagsByGroup.get(groupId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      updates.push({\n        id: scene.id,\n        inheritedTagIds: JSON.stringify(Array.from(inheritedTags)),\n      });\n    }\n\n    // Batch update using raw SQL for efficiency\n    // SQLite doesn't support UPDATE ... FROM with VALUES, so we use CASE WHEN\n    if (updates.length &gt; 0) {\n      // Split into smaller batches for the SQL update\n      const SQL_BATCH_SIZE = 100;\n      for (let i = 0; i &lt; updates.length; i += SQL_BATCH_SIZE) {\n        const sqlBatch = updates.slice(i, i + SQL_BATCH_SIZE);\n        const ids = sqlBatch.map((u) =&gt; u.id);\n\n        // Use individual updates - more compatible with SQLite\n        await Promise.all(\n          sqlBatch.map((u) =&gt;\n            prisma.stashScene.update({\n              where: { id: u.id },\n              data: { inheritedTagIds: u.inheritedTagIds },\n            })\n          )\n        );\n      }\n    }\n  }\n}\n\nexport const sceneTagInheritanceService = new SceneTagInheritanceService();\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneTagInheritanceService</code> Expected: All tests PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/SceneTagInheritanceService.ts server/services/__tests__/SceneTagInheritanceService.test.ts\ngit commit -m \"feat: add SceneTagInheritanceService for denormalizing inherited tags\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-3-integrate-with-stashsyncservice","title":"Task 3: Integrate with StashSyncService","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Add import at top of file</p> <p>Add after other service imports (around line 20):</p> <pre><code>import { sceneTagInheritanceService } from \"./SceneTagInheritanceService.js\";\n</code></pre> <p>Step 2: Add call after full sync (after line 222)</p> <p>Find the section where <code>imageGalleryInheritanceService.applyGalleryInheritance()</code> is called in <code>syncFromStash()</code> method. Add scene tag inheritance right before it:</p> <pre><code>      // Compute inherited tags for scenes (must happen after scenes, performers, studios, groups are synced)\n      logger.info(\"Computing inherited tags for scenes...\");\n      await sceneTagInheritanceService.computeInheritedTags();\n      logger.info(\"Scene tag inheritance complete\");\n</code></pre> <p>Step 3: Add call after incremental sync (around line 547)</p> <p>Find the section in <code>incrementalSync()</code> after gallery inheritance. Add scene tag inheritance when scenes were synced:</p> <pre><code>      // Compute inherited tags for scenes if scenes were updated\n      const sceneResult = results.find((r) =&gt; r.entityType === \"scene\");\n      if (sceneResult &amp;&amp; sceneResult.synced &gt; 0) {\n        logger.info(\"Computing inherited tags for scenes after incremental sync...\");\n        await sceneTagInheritanceService.computeInheritedTags();\n        logger.info(\"Scene tag inheritance complete\");\n      }\n</code></pre> <p>Step 4: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: integrate SceneTagInheritanceService with sync pipeline\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-4-update-userrestrictionservice-to-use-inheritedtagids","title":"Task 4: Update UserRestrictionService to Use inheritedTagIds","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code> (lines 837-876)</p> <p>Step 1: Simplify getSceneEntityIds for tags case</p> <p>Replace the current \"tags\" case (lines 848-876) with:</p> <pre><code>      case \"tags\": {\n        // Direct scene tags\n        const directTagIds = (scene.tags || []).map((t: EntityWithId) =&gt; String(t.id));\n\n        // Inherited tags (pre-computed at sync time)\n        const inheritedTagIds = (scene as any).inheritedTagIds || [];\n\n        // Combine and deduplicate\n        return [...new Set([...directTagIds, ...inheritedTagIds])];\n      }\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"refactor: simplify UserRestrictionService to use pre-computed inheritedTagIds\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-5-update-stashentityservice-to-include-inheritedtagids","title":"Task 5: Update StashEntityService to Include inheritedTagIds","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Update transformScene method (around line 1414)</p> <p>Add inheritedTagIds parsing after the existing fields:</p> <pre><code>      // Inherited tag IDs (pre-computed at sync time)\n      inheritedTagIds: scene.inheritedTagIds ? JSON.parse(scene.inheritedTagIds) : [],\n</code></pre> <p>Step 2: Update transformSceneForBrowse method (around line 1478)</p> <p>Add the same inheritedTagIds parsing:</p> <pre><code>      // Inherited tag IDs (pre-computed at sync time)\n      inheritedTagIds: scene.inheritedTagIds ? JSON.parse(scene.inheritedTagIds) : [],\n</code></pre> <p>Step 3: Update NormalizedScene type if needed</p> <p>Check <code>server/types/stash.ts</code> for NormalizedScene type. Add inheritedTagIds field if not present:</p> <pre><code>inheritedTagIds?: string[];\n</code></pre> <p>Step 4: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/stash.ts\ngit commit -m \"feat: include inheritedTagIds in scene transforms\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-6-update-client-components","title":"Task 6: Update Client Components","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code> (lines 82-100) - Modify: <code>client/src/components/scene/SceneMetadata.jsx</code> (lines 7-37)</p> <p>Step 1: Update SceneCard.jsx</p> <p>Replace the <code>getAllTags</code> function and its usage (lines 82-100) with:</p> <pre><code>    // Combine direct tags with server-computed inherited tags\n    const allTags = useMemo(() =&gt; {\n      const tagMap = new Map();\n      // Direct scene tags\n      if (scene.tags) {\n        scene.tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n      }\n      // Inherited tags (pre-computed on server)\n      if (scene.inheritedTags) {\n        scene.inheritedTags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n      }\n      return Array.from(tagMap.values());\n    }, [scene.tags, scene.inheritedTags]);\n</code></pre> <p>Note: Add <code>useMemo</code> to imports if not already present.</p> <p>Step 2: Update SceneMetadata.jsx</p> <p>Replace <code>mergeAllTags</code> function (lines 7-30) and its usage with:</p> <pre><code>/**\n * Combine direct tags with inherited tags from server\n */\nconst getAllTags = (scene) =&gt; {\n  const tagMap = new Map();\n  // Direct scene tags\n  if (scene.tags) {\n    scene.tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  }\n  // Inherited tags (pre-computed on server)\n  if (scene.inheritedTags) {\n    scene.inheritedTags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  }\n  return Array.from(tagMap.values());\n};\n</code></pre> <p>Update the component to use this:</p> <pre><code>  const allTags = getAllTags(scene);\n</code></pre> <p>Step 3: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/SceneCard.jsx client/src/components/scene/SceneMetadata.jsx\ngit commit -m \"refactor: use server-provided inheritedTags instead of client-side computation\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-7-add-inheritedtags-hydration-to-api-response","title":"Task 7: Add inheritedTags Hydration to API Response","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Update transformSceneWithRelations to hydrate inheritedTags</p> <p>In <code>transformSceneWithRelations</code> method (around line 1555), after parsing inheritedTagIds, add hydration:</p> <pre><code>    // Hydrate inherited tags with full tag objects\n    if (scene.inheritedTagIds) {\n      const inheritedTagIds = JSON.parse(scene.inheritedTagIds);\n      if (inheritedTagIds.length &gt; 0) {\n        // Look up tags in the tags array we already have, or query if needed\n        base.inheritedTags = inheritedTagIds.map((tagId: string) =&gt; {\n          // Find in existing tags or create minimal stub\n          const existingTag = base.tags?.find((t: any) =&gt; t.id === tagId);\n          return existingTag || { id: tagId, name: \"Unknown\" };\n        });\n      }\n    }\n</code></pre> <p>Step 2: Add inheritedTags to NormalizedScene type</p> <p>Update <code>server/types/stash.ts</code>:</p> <pre><code>inheritedTags?: { id: string; name: string }[];\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/stash.ts\ngit commit -m \"feat: hydrate inheritedTags with full tag objects in API response\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-8-run-full-test-suite-and-verify","title":"Task 8: Run Full Test Suite and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Run TypeScript check</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No type errors</p> <p>Step 4: Commit any remaining fixes</p> <p>If any fixes were needed, commit them.</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-9-create-pull-request","title":"Task 9: Create Pull Request","text":"<p>Step 1: Push branch</p> <pre><code>git push -u origin feature/scene-tag-inheritance\n</code></pre> <p>Step 2: Create PR</p> <pre><code>gh pr create --title \"feat: denormalize scene inherited tags at sync time\" --body \"$(cat &lt;&lt;'EOF'\n## Summary\n- Adds `inheritedTagIds` field to StashScene schema to store tags inherited from performers, studio, and groups\n- Creates SceneTagInheritanceService to compute inherited tags at sync time\n- Simplifies UserRestrictionService to use pre-computed inherited tags\n- Updates client components to use server-provided inheritedTags instead of client-side computation\n- **Fixes group tag inheritance** which was previously missing\n\n## Changes\n- Schema migration adding `inheritedTagIds` to StashScene\n- New `SceneTagInheritanceService` with comprehensive tests\n- Integration with sync pipeline (full and incremental)\n- Updated `StashEntityService` transforms to include inheritedTagIds\n- Refactored `UserRestrictionService.getSceneEntityIds()` to use pre-computed tags\n- Updated `SceneCard.jsx` and `SceneMetadata.jsx` to use server-provided tags\n\n## Test Plan\n- [x] Unit tests for SceneTagInheritanceService\n- [ ] Manual test: Scene with no direct tags shows inherited tags from performer\n- [ ] Manual test: Scene with no direct tags shows inherited tags from studio\n- [ ] Manual test: Scene with no direct tags shows inherited tags from group (NEW!)\n- [ ] Manual test: Tags inherited from multiple sources are deduplicated\n- [ ] Manual test: Direct tags are NOT duplicated in inheritedTagIds\n- [ ] Manual test: Restriction filtering works with inherited tags\nEOF\n)\"\n</code></pre> <p>Step 3: Return PR URL</p>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/","title":"View Mode Options Brainstorm","text":"<p>Date: 2025-01-11 Status: Ideation Goal: Research and brainstorm alternative display modes for search results and detail page tabs beyond the current card-based view.</p>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#context","title":"Context","text":"<p>Currently, peek uses a card-based grid layout for all search results and entity listings. Users have filter/sort controls but no way to change how results are displayed. This document captures ideas for additional view modes to give users more customization options.</p> <p>Design principles: - User customizability is the primary goal - Keep implementation DRY across entity types - Support both video and image content</p>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#core-view-types-high-value","title":"Core View Types (High Value)","text":""},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#1-grid-current-cards","title":"1. Grid (Current Cards)","text":"<p>What peek has now - visual-first with thumbnails, ratings, indicators. Good baseline that works for all entity types.</p>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#2-listtable-view","title":"2. List/Table View","text":"<ul> <li>Compact rows with columns: thumbnail (small), title, studio, date, duration, rating, tags</li> <li>Sortable columns by clicking headers</li> <li>High density - 20-50+ items visible at once</li> <li>Great for scanning metadata quickly, bulk operations</li> <li>Reference: Spotify's compact library view, file manager details view</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#3-compactdense-grid","title":"3. Compact/Dense Grid","text":"<ul> <li>Same grid layout but smaller cards - maybe 50-60% size</li> <li>Fewer details shown (title + thumbnail only, no description/indicators)</li> <li>Middle ground between full cards and list view</li> <li>Reference: iOS Photos pinch-to-zoom, Spotify grid sizing</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#4-wallmosaic-view","title":"4. Wall/Mosaic View","text":"<ul> <li>Edge-to-edge thumbnails with no gaps or minimal gaps</li> <li>Title/info appears on hover only</li> <li>Maximum visual density for browsing by \"vibe\"</li> <li>Stash already has this - familiar to users</li> <li>Reference: Pinterest masonry, Unsplash, Stash wall view</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#comparison-curation-views","title":"Comparison &amp; Curation Views","text":""},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#5-filmstrip-detail","title":"5. Filmstrip + Detail","text":"<ul> <li>Horizontal strip of thumbnails at bottom</li> <li>Large preview/detail of selected item above</li> <li>Good for sequential browsing through results</li> <li>Reference: Lightroom loupe + filmstrip</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#6-compare-view","title":"6. Compare View","text":"<ul> <li>Side-by-side view of 2-4 selected items</li> <li>Synchronized zoom/pan for images</li> <li>Useful for: \"which performer photo is better?\", \"which scene version?\"</li> <li>Reference: Lightroom compare view</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#7-survey-view","title":"7. Survey View","text":"<ul> <li>Show only currently selected items in a focused grid</li> <li>Remove items from survey with X button to narrow down</li> <li>Good for curation workflows: \"pick the best 3 from these 20\"</li> <li>Reference: Lightroom survey view</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#information-dense-views","title":"Information-Dense Views","text":""},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#8-metadata-table","title":"8. Metadata Table","text":"<ul> <li>Full spreadsheet-style view</li> <li>All available metadata as columns (user picks which to show)</li> <li>Inline editing potential</li> <li>Best for: bulk tagging, data cleanup, finding missing metadata</li> <li>Reference: Excel, Airtable, database admin tools</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#9-timelinecalendar-view","title":"9. Timeline/Calendar View","text":"<ul> <li>Items plotted on a date axis (release date, date added, etc.)</li> <li>Visual clustering shows activity patterns</li> <li>Reference: Google Photos, macOS Photos memories</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#10-statisticsanalytics-view","title":"10. Statistics/Analytics View","text":"<ul> <li>Not a browse view per se, but aggregate view</li> <li>Charts: ratings distribution, tags frequency, studios breakdown</li> <li>Could be a dashboard or a \"view mode\" for search results</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#specialized-views","title":"Specialized Views","text":""},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#11-previewtheater-mode","title":"11. Preview/Theater Mode","text":"<ul> <li>One large item at a time, full-width</li> <li>Arrow keys or swipe to navigate</li> <li>Minimal chrome, maximum content</li> <li>Good for: \"watching\" through search results like a slideshow</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#12-split-pane","title":"12. Split Pane","text":"<ul> <li>Two independent browse panels side by side</li> <li>Drag items between them</li> <li>Useful for: comparing folders, organizing into collections</li> <li>Reference: file managers, Total Commander</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#13-hierarchytree-view-for-tags","title":"13. Hierarchy/Tree View (for Tags)","text":"<ul> <li>Tree structure showing parent/child relationships</li> <li>Expandable nodes</li> <li>Could also work for Studios (parent studio -&gt; sub-studios)</li> <li>Note: This is somewhat separate from general search result display</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#thumbnail-variants-modifiers","title":"Thumbnail Variants (Modifiers)","text":"<p>These could be toggles that apply to Grid/Wall modes rather than separate view modes:</p>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#14-aspect-ratio-options","title":"14. Aspect Ratio Options","text":"<ul> <li>Square crops (uniform grid, Instagram-style)</li> <li>Original aspect (masonry/variable height)</li> <li>Fixed 16:9 (current default for scenes)</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#15-preview-behavior-options","title":"15. Preview Behavior Options","text":"<ul> <li>Static thumbnail</li> <li>Sprite animation on hover</li> <li>Video preview on hover</li> <li>Animated WebP</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#16-info-overlay-options","title":"16. Info Overlay Options","text":"<ul> <li>Clean (no overlays)</li> <li>Minimal (duration/resolution badges only)</li> <li>Full (title, studio, indicators)</li> </ul>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#implementation-considerations","title":"Implementation Considerations","text":"<p>To keep things DRY:</p> Concept Approach View mode component Single <code>&lt;ResultsView mode={mode} items={items} /&gt;</code> that switches renderer Item renderer Each mode has a renderer, but they share the same data shape Column/field config Entity-type-specific field definitions, views pick which to display User preference storage Per-entity-type makes most sense (e.g., List for scenes, Grid for performers) View switcher UI Icon buttons in the existing filter/sort toolbar area"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#questions-to-answer","title":"Questions to Answer","text":"<ol> <li>Which 3-4 views for v1? Recommendation: Grid (current), List/Table, Compact Grid, Wall</li> <li>Should view preference be global or per-entity-type?</li> <li>Which views don't fit peek's use case? (Timeline might be overkill)</li> <li>How do modifiers (aspect ratio, preview behavior) interact with view modes?</li> </ol>"},{"location":"plans/2025-01-11-view-mode-options-brainstorm/#research-sources","title":"Research Sources","text":"<ul> <li>Lightroom view modes</li> <li>Cards vs Tables UX patterns</li> <li>Gallery UI patterns</li> <li>Adobe Lightroom Classic documentation</li> <li>NN/g List Thumbnails</li> </ul>"},{"location":"plans/2025-01-12-card-grid-followup/","title":"Card/Grid Refactor Follow-up Tasks","text":"<p>Created: 2025-01-12 Status: Pending Priority: Low</p> <p>Follow-up items identified during code review of the card/grid refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#background","title":"Background","text":"<p>The card/grid refactor (completed 2025-01-12) introduced: - Three-layer card architecture: Primitives -&gt; BaseCard -&gt; Entity Cards - Two-layer grid architecture: BaseGrid -&gt; SearchableGrid/Entity Grids</p> <p>Code review identified minor improvements that were not blockers for the initial refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#tasks","title":"Tasks","text":""},{"location":"plans/2025-01-12-card-grid-followup/#1-complete-search-page-migration-important","title":"1. Complete Search Page Migration (Important)","text":"<p>Current state: Search pages (Galleries, Groups, Studios, Tags) still have inline grid implementations instead of using entity grids.</p> <p>Blocker: TV navigation (<code>useGridPageTVNavigation</code>) needs to be integrated into SearchableGrid first.</p> <p>Files to migrate: - <code>client/src/components/pages/Galleries.jsx</code> - <code>client/src/components/pages/Groups.jsx</code> - <code>client/src/components/pages/Studios.jsx</code> - <code>client/src/components/pages/Tags.jsx</code></p> <p>Benefit: Removes ~250 lines of duplicated code across 4 search pages.</p> <p>Steps: 1. Add TV navigation support to SearchableGrid or entity grids 2. Add <code>isInitializing</code> state support to SearchableGrid for SyncProgressBanner 3. Migrate each search page to use its corresponding entity grid</p>"},{"location":"plans/2025-01-12-card-grid-followup/#2-add-entitytitle-to-rating-controls-nice-to-have","title":"2. Add entityTitle to Rating Controls (Nice to Have)","text":"<p>Issue: Entity cards don't pass <code>entityTitle</code> to ratingControlsProps, so rating dialogs show generic \"Rate this [entity]\" instead of \"Rate Studio Name\".</p> <p>Files to update: - <code>client/src/components/cards/PerformerCard.jsx</code> - add <code>entityTitle: performer.name</code> - <code>client/src/components/cards/GalleryCard.jsx</code> - add <code>entityTitle: gallery.title</code> - <code>client/src/components/cards/GroupCard.jsx</code> - add <code>entityTitle: group.name</code> - <code>client/src/components/cards/StudioCard.jsx</code> - add <code>entityTitle: studio.name</code> - <code>client/src/components/cards/TagCard.jsx</code> - add <code>entityTitle: tag.name</code> - <code>client/src/components/cards/ImageCard.jsx</code> - add <code>entityTitle: image.title</code></p>"},{"location":"plans/2025-01-12-card-grid-followup/#3-add-defensive-rating-fallback-nice-to-have","title":"3. Add Defensive Rating Fallback (Nice to Have)","text":"<p>Issue: GalleryCard uses only <code>gallery.rating100</code> but old implementation had fallback to <code>gallery.rating</code>.</p> <p>File: <code>client/src/components/cards/GalleryCard.jsx</code></p> <p>Change: <pre><code>// From\ninitialRating: gallery.rating100,\n\n// To\ninitialRating: gallery.rating100 ?? gallery.rating,\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#4-document-filter-merge-behavior-nice-to-have","title":"4. Document Filter Merge Behavior (Nice to Have)","text":"<p>Issue: SearchableGrid uses shallow merge for filters which could cause issues if both <code>newQuery</code> and <code>lockedFilters</code> have nested filter objects.</p> <p>File: <code>client/src/components/ui/SearchableGrid.jsx</code></p> <p>Change: Add explanatory comment: <pre><code>// Merge locked filters into query\n// Note: Uses shallow merge. Assumes lockedFilters and newQuery\n// use different filter keys (e.g., gallery_filter vs filter)\nconst mergedQuery = {\n  ...newQuery,\n  ...lockedFilters,\n};\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#5-verify-conditional-rating-controls-design-question","title":"5. Verify Conditional Rating Controls (Design Question)","text":"<p>Issue: TagCard and ImageCard conditionally render rating controls based on <code>rating100 !== undefined</code>. This may cause height inconsistency if some cards show rating row and others don't.</p> <p>Question: Should all entities always show rating controls (even when undefined/0)?</p> <p>Files: - <code>client/src/components/cards/TagCard.jsx</code> - <code>client/src/components/cards/ImageCard.jsx</code></p> <p>Action: Verify with product requirements whether all entities should show rating controls consistently.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/","title":"Card &amp; Grid Component Refactor Design","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#overview","title":"Overview","text":"<p>Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#goals","title":"Goals","text":"<ul> <li>Reduce duplication/drift risk across all card types</li> <li>Improve developer velocity for adding new entity types</li> <li>Maintain visual consistency with type-specific variants</li> <li>Keep SceneCard's full feature set (selection, sprites, TV mode, progress)</li> <li>Nested grids = full search pages with locked parent filter</li> <li>Design for future list item compatibility (don't implement yet)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#architecture","title":"Architecture","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#three-layer-card-system","title":"Three-Layer Card System","text":"<pre><code>Primitives (ui/CardComponents.jsx)\n    \u2514\u2500\u2500 CardContainer, CardImage, CardTitle, CardDescription,\n        CardIndicators, CardRatingRow, CardOverlay, useLazyLoad\n\nBaseCard (ui/BaseCard.jsx)\n    \u2514\u2500\u2500 Composes primitives, provides render slots for customization\n\nEntity Cards (components/cards/)\n    \u2514\u2500\u2500 SceneCard, PerformerCard, GalleryCard, GroupCard,\n        StudioCard, TagCard, ImageCard\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#two-layer-grid-system","title":"Two-Layer Grid System","text":"<pre><code>BaseGrid (ui/BaseGrid.jsx)\n    \u2514\u2500\u2500 Layout, responsive columns, pagination, loading/empty states\n\nSearchableGrid (ui/SearchableGrid.jsx)\n    \u2514\u2500\u2500 BaseGrid + search controls + data fetching + locked filters\n\nEntity Grids (components/grids/)\n    \u2514\u2500\u2500 SceneGrid, PerformerGrid, GalleryGrid, GroupGrid,\n        StudioGrid, TagGrid, ImageGrid\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#component-specifications","title":"Component Specifications","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#primitives-uicardcomponentsjsx","title":"Primitives (ui/CardComponents.jsx)","text":"<p>Existing components to keep: - <code>CardContainer</code> - Wrapper (Link or div) - <code>CardImage</code> - Image with aspect ratio, unified lazy loading - <code>CardTitle</code> - Title + optional subtitle - <code>CardDescription</code> - Clamped description text - <code>CardIndicators</code> - Row of icon+count badges - <code>CardRatingRow</code> - Rating, O-counter, favorite, menu</p> <p>New component: - <code>CardOverlay</code> - Positioned overlay for progress bars, selection checkboxes</p> <p>Remove: - <code>LazyImage</code> - fold into CardImage - <code>CardDefaultImage</code> - fold into CardImage</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basecard-uibasecardjsx","title":"BaseCard (ui/BaseCard.jsx)","text":"<pre><code>interface BaseCardProps {\n  // Data\n  entityType: EntityType;\n  imagePath: string;\n  title: ReactNode;\n  subtitle?: ReactNode;\n  description?: ReactNode;\n  linkTo?: string;\n\n  // Indicators &amp; Rating\n  indicators?: IndicatorConfig[];\n  ratingControlsProps?: RatingControlsProps;\n\n  // Display options\n  hideDescription?: boolean;\n  hideSubtitle?: boolean;\n  maxTitleLines?: number;\n  maxDescriptionLines?: number;\n\n  // Customization slots\n  renderOverlay?: () =&gt; ReactNode;\n  renderImageContent?: () =&gt; ReactNode;\n  renderAfterTitle?: () =&gt; ReactNode;\n\n  // Events &amp; behavior\n  onClick?: (e) =&gt; void;\n  onLongPress?: () =&gt; void;\n  className?: string;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-cards-componentscards","title":"Entity Cards (components/cards/)","text":"Component Complexity Type-Specific Behavior SceneCard Complex Selection mode, sprite preview, progress bar, TV mode, long-press PerformerCard Thin Gender icon after title, performer indicators GalleryCard Thin Image count indicator GroupCard Thin Scene count, performer count StudioCard Thin Scene count, child studio indicators TagCard Thin Scene/performer/gallery counts ImageCard Thin Resolution indicator, gallery link"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basegrid-uibasegridjsx","title":"BaseGrid (ui/BaseGrid.jsx)","text":"<pre><code>interface BaseGridProps {\n  items: any[];\n  renderItem: (item, index) =&gt; ReactNode;\n  gridType: 'scene' | 'standard';\n  loading?: boolean;\n  error?: Error;\n  emptyMessage?: string;\n  emptyDescription?: string;\n  currentPage?: number;\n  totalPages?: number;\n  onPageChange?: (page: number) =&gt; void;\n  skeletonCount?: number;\n  renderSkeleton?: () =&gt; ReactNode;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#searchablegrid-uisearchablegridjsx","title":"SearchableGrid (ui/SearchableGrid.jsx)","text":"<pre><code>interface SearchableGridProps {\n  entityType: EntityType;\n  lockedFilters?: FilterObject;\n  hideLockedFilters?: boolean;\n  gridType?: 'scene' | 'standard';\n  renderItem: (item) =&gt; ReactNode;\n  defaultSort?: SortConfig;\n  defaultFilters?: FilterObject;\n  onResultsChange?: (results) =&gt; void;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-grids-componentsgrids","title":"Entity Grids (components/grids/)","text":"<p>SceneGrid includes selection mode and bulk actions. All others are thin wrappers around SearchableGrid.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#usage-examples","title":"Usage Examples","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#main-search-page","title":"Main search page","text":"<pre><code>&lt;SceneGrid /&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#nested-grid-on-detail-page","title":"Nested grid on detail page","text":"<pre><code>&lt;SceneGrid\n  lockedFilters={{ performer_id: performer.id }}\n  hideLockedFilters\n/&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#multiple-nested-grids","title":"Multiple nested grids","text":"<pre><code>// PerformerDetail.jsx\n&lt;Tabs&gt;\n  &lt;Tab label=\"Scenes\"&gt;\n    &lt;SceneGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Groups\"&gt;\n    &lt;GroupGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Galleries\"&gt;\n    &lt;GalleryGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n&lt;/Tabs&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#file-structure","title":"File Structure","text":"<pre><code>client/src/\n  components/\n    cards/\n      SceneCard.jsx\n      PerformerCard.jsx\n      GalleryCard.jsx\n      GroupCard.jsx\n      StudioCard.jsx\n      TagCard.jsx\n      ImageCard.jsx\n      index.js\n\n    grids/\n      SceneGrid.jsx\n      PerformerGrid.jsx\n      GalleryGrid.jsx\n      GroupGrid.jsx\n      StudioGrid.jsx\n      TagGrid.jsx\n      ImageGrid.jsx\n      index.js\n\n    ui/\n      CardComponents.jsx\n      BaseCard.jsx\n      BaseGrid.jsx\n      SearchableGrid.jsx\n      useEntityImageAspectRatio.js\n\n  constants/\n    grids.js\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#migration-plan","title":"Migration Plan","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-delete","title":"Files to DELETE","text":"<ul> <li><code>ui/GridCard.jsx</code> - Replaced by BaseCard</li> <li><code>ui/EntityGrid.jsx</code> - Replaced by components/grids/*</li> <li><code>scene-search/SceneGrid.jsx</code> - Moved to components/grids/</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-move","title":"Files to MOVE","text":"<ul> <li><code>ui/SceneCard.jsx</code> \u2192 <code>components/cards/SceneCard.jsx</code></li> <li><code>ui/PerformerCard.jsx</code> \u2192 <code>components/cards/PerformerCard.jsx</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-create","title":"Files to CREATE","text":"<ul> <li><code>ui/BaseCard.jsx</code></li> <li><code>ui/BaseGrid.jsx</code></li> <li><code>ui/SearchableGrid.jsx</code></li> <li><code>components/cards/GalleryCard.jsx</code></li> <li><code>components/cards/GroupCard.jsx</code></li> <li><code>components/cards/StudioCard.jsx</code></li> <li><code>components/cards/TagCard.jsx</code></li> <li><code>components/cards/ImageCard.jsx</code></li> <li><code>components/cards/index.js</code></li> <li><code>components/grids/SceneGrid.jsx</code></li> <li><code>components/grids/PerformerGrid.jsx</code></li> <li><code>components/grids/GalleryGrid.jsx</code></li> <li><code>components/grids/GroupGrid.jsx</code></li> <li><code>components/grids/StudioGrid.jsx</code></li> <li><code>components/grids/TagGrid.jsx</code></li> <li><code>components/grids/ImageGrid.jsx</code></li> <li><code>components/grids/index.js</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-refactor","title":"Files to REFACTOR","text":"<ul> <li><code>ui/CardComponents.jsx</code> - Remove LazyImage/CardDefaultImage, add CardOverlay</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#pages-to-update","title":"Pages to UPDATE","text":"<ul> <li>Scenes, Performers, Galleries, Groups, Studios, Tags, Images (search pages)</li> <li>PerformerDetail, StudioDetail, TagDetail, GroupDetail, GalleryDetail (detail pages)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/","title":"Card &amp; Grid Component Refactor Implementation Plan","text":"<p>Status: COMPLETED - All 25 tasks implemented successfully on 2025-01-12.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#implementation-summary","title":"Implementation Summary","text":"<p>The card and grid refactor has been fully implemented with the following results:</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#new-architecture","title":"New Architecture","text":"<ul> <li>Card Layer 1 (Primitives): <code>CardComponents.jsx</code> - CardImage, CardTitle, CardOverlay, etc.</li> <li>Card Layer 2: <code>BaseCard.jsx</code> - Composable card with render slots</li> <li>Card Layer 3: Entity cards in <code>components/cards/</code> - PerformerCard, GalleryCard, GroupCard, StudioCard, TagCard, ImageCard</li> <li>Grid Layer 1: <code>BaseGrid.jsx</code> - Layout, pagination, loading/empty states</li> <li>Grid Layer 2: <code>SearchableGrid.jsx</code> - Integrated search controls and data fetching</li> <li>Grid Layer 3: Entity grids in <code>components/grids/</code> - PerformerGrid, GalleryGrid, GroupGrid, StudioGrid, TagGrid, ImageGrid</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#files-deleted","title":"Files Deleted","text":"<ul> <li><code>GridCard.jsx</code> - Replaced by BaseCard + entity cards</li> <li><code>EntityGrid.jsx</code> - Replaced by SearchableGrid + entity grids</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#additional-migrations","title":"Additional Migrations","text":"<p>During implementation, 4 main search pages (Galleries, Groups, Studios, Tags) were discovered to still use the deprecated GridCard. These were migrated to use the new shared entity cards.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#test-results","title":"Test Results","text":"<ul> <li>All 346 tests pass</li> <li>No lint errors (only pre-existing warnings in unrelated files)</li> </ul> <p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids with locked filters.</p> <p>Architecture: Three-layer card system (Primitives \u2192 BaseCard \u2192 Entity Cards) + Two-layer grid system (BaseGrid \u2192 SearchableGrid \u2192 Entity Grids). This eliminates the current duplication between SceneCard, PerformerCard, GridCard, and EntityGrid while preserving SceneCard's full feature set.</p> <p>Tech Stack: React 18, React Router 6, Tailwind CSS, CSS variables for theming, Lucide React icons</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-1-card-primitives-cleanup","title":"Phase 1: Card Primitives Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-1-add-cardoverlay-to-cardcomponentsjsx","title":"Task 1: Add CardOverlay to CardComponents.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:155-171</code> (after CardDefaultImage) - Modify: <code>client/src/components/ui/index.js:9-19</code> (add export)</p> <p>Step 1: Write the failing test</p> <p>Create test file first:</p> <pre><code>// client/src/components/ui/__tests__/CardComponents.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { CardOverlay } from \"../CardComponents\";\n\ndescribe(\"CardOverlay\", () =&gt; {\n  it(\"renders children in positioned overlay\", () =&gt; {\n    render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Test Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(screen.getByText(\"Test Content\")).toBeInTheDocument();\n  });\n\n  it(\"applies correct position classes for bottom-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for top-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"top-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"top-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for bottom-right\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-right\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"right-0\");\n  });\n\n  it(\"applies correct position classes for full\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"full\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"inset-0\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL with \"Cannot find module '../CardComponents'\" or similar</p> <p>Step 3: Write CardOverlay implementation</p> <p>Add to <code>client/src/components/ui/CardComponents.jsx</code> after line 171 (after CardDefaultImage):</p> <pre><code>/**\n * CardOverlay - Positioned overlay container for progress bars, selection checkboxes, etc.\n * @param {Object} props\n * @param {'top-left'|'top-right'|'bottom-left'|'bottom-right'|'full'} props.position - Position of overlay\n * @param {React.ReactNode} props.children - Content to render in overlay\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const CardOverlay = ({ position = \"bottom-left\", children, className = \"\" }) =&gt; {\n  const positionClasses = {\n    \"top-left\": \"absolute top-0 left-0\",\n    \"top-right\": \"absolute top-0 right-0\",\n    \"bottom-left\": \"absolute bottom-0 left-0\",\n    \"bottom-right\": \"absolute bottom-0 right-0\",\n    \"full\": \"absolute inset-0\",\n  };\n\n  return (\n    &lt;div className={`${positionClasses[position]} ${className}`}&gt;\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Update barrel export</p> <p>In <code>client/src/components/ui/index.js</code>, update the CardComponents export:</p> <pre><code>export {\n  CardContainer,\n  CardDefaultImage,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardOverlay,  // Add this\n  CardRatingRow,\n  CardTitle,\n  LazyImage,\n  useLazyLoad,\n} from \"./CardComponents.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/index.js client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"feat(cards): add CardOverlay primitive for positioned overlays\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-2-fold-lazyimage-into-cardimage","title":"Task 2: Fold LazyImage into CardImage","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:76-148</code> (CardImage and LazyImage sections)</p> <p>Step 1: Write the failing test</p> <p>Add to <code>client/src/components/ui/__tests__/CardComponents.test.jsx</code>:</p> <pre><code>import { CardImage } from \"../CardComponents\";\n\ndescribe(\"CardImage\", () =&gt; {\n  it(\"renders image with lazy loading when src provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\" /&gt;\n    );\n    expect(screen.getByRole(\"img\")).toHaveAttribute(\"src\", \"/test.jpg\");\n  });\n\n  it(\"renders placeholder when no src provided\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage aspectRatio=\"16/9\" entityType=\"scene\" /&gt;\n    );\n    // Should render default icon, not an img tag\n    expect(container.querySelector(\"img\")).toBeNull();\n    expect(container.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"applies aspect ratio style\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"2/3\" /&gt;\n    );\n    expect(container.firstChild).toHaveStyle({ aspectRatio: \"2/3\" });\n  });\n\n  it(\"renders children overlay when provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\"&gt;\n        &lt;span&gt;Overlay Content&lt;/span&gt;\n      &lt;/CardImage&gt;\n    );\n    expect(screen.getByText(\"Overlay Content\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL (CardImage doesn't accept src prop yet)</p> <p>Step 3: Refactor CardImage to include lazy loading</p> <p>Replace CardImage in <code>client/src/components/ui/CardComponents.jsx</code>:</p> <pre><code>/**\n * CardImage - Image container with aspect ratio and built-in lazy loading\n * @param {Object} props\n * @param {string} [props.src] - Image source URL\n * @param {string} [props.alt] - Alt text for image\n * @param {string} [props.aspectRatio] - CSS aspect ratio (e.g., \"16/9\", \"2/3\")\n * @param {string} [props.entityType] - Entity type for placeholder icon\n * @param {React.ReactNode} [props.children] - Overlay content\n * @param {string} [props.className] - Additional CSS classes\n * @param {Object} [props.style] - Additional inline styles\n * @param {Function} [props.onClick] - Click handler\n */\nexport const CardImage = ({\n  src,\n  alt = \"\",\n  aspectRatio = \"16/9\",\n  entityType,\n  children,\n  className = \"\",\n  style = {},\n  onClick,\n}) =&gt; {\n  const [ref, isVisible] = useLazyLoad();\n  const [hasError, setHasError] = useState(false);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  const showPlaceholder = !src || hasError;\n\n  const getPlaceholderIcon = () =&gt; {\n    const icons = {\n      performer: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      scene: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm3 2h6v4H7V5zm8 8v2h1v-2h-1zm-2-2H7v4h6v-4zm2 0h1V9h-1v2zm1-4V5h-1v2h1zM5 5v2H4V5h1zm0 4H4v2h1V9zm-1 4h1v2H4v-2z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      gallery: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      default: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n    };\n    return icons[entityType] || icons.default;\n  };\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`relative overflow-hidden ${className}`}\n      style={{\n        aspectRatio,\n        backgroundColor: \"var(--bg-secondary)\",\n        ...style,\n      }}\n      onClick={onClick}\n    &gt;\n      {showPlaceholder ? (\n        &lt;div\n          className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ color: \"var(--text-muted)\" }}\n        &gt;\n          {getPlaceholderIcon()}\n        &lt;/div&gt;\n      ) : (\n        &lt;&gt;\n          {/* Placeholder shown while loading */}\n          {!isLoaded &amp;&amp; (\n            &lt;div\n              className=\"absolute inset-0 animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n          )}\n          {/* Actual image - only render when visible for lazy loading */}\n          {isVisible &amp;&amp; (\n            &lt;img\n              src={src}\n              alt={alt}\n              className={`absolute inset-0 w-full h-full object-cover transition-opacity duration-200 ${\n                isLoaded ? \"opacity-100\" : \"opacity-0\"\n              }`}\n              onLoad={() =&gt; setIsLoaded(true)}\n              onError={() =&gt; setHasError(true)}\n            /&gt;\n          )}\n        &lt;/&gt;\n      )}\n      {/* Children rendered as overlay */}\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"refactor(cards): fold LazyImage into CardImage with built-in lazy loading\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-2-basecard-implementation","title":"Phase 2: BaseCard Implementation","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-3-create-basecard-component","title":"Task 3: Create BaseCard Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseCard.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseCard.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (add export)</p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseCard } from \"../BaseCard\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseCard\", () =&gt; {\n  const defaultProps = {\n    entityType: \"scene\",\n    imagePath: \"/test.jpg\",\n    title: \"Test Title\",\n  };\n\n  it(\"renders title\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} /&gt;);\n    expect(screen.getByText(\"Test Title\")).toBeInTheDocument();\n  });\n\n  it(\"renders subtitle when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" /&gt;);\n    expect(screen.getByText(\"Test Subtitle\")).toBeInTheDocument();\n  });\n\n  it(\"hides subtitle when hideSubtitle is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" hideSubtitle /&gt;\n    );\n    expect(screen.queryByText(\"Test Subtitle\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders description when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} description=\"Test Description\" /&gt;);\n    expect(screen.getByText(\"Test Description\")).toBeInTheDocument();\n  });\n\n  it(\"hides description when hideDescription is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} description=\"Test Description\" hideDescription /&gt;\n    );\n    expect(screen.queryByText(\"Test Description\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders as link when linkTo provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} linkTo=\"/test\" /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/test\");\n  });\n\n  it(\"renders indicators when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        indicators={[{ type: \"SCENES\", count: 5 }]}\n      /&gt;\n    );\n    expect(screen.getByText(\"5\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderOverlay slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderOverlay={() =&gt; &lt;span&gt;Custom Overlay&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"Custom Overlay\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderAfterTitle slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderAfterTitle={() =&gt; &lt;span&gt;After Title&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"After Title\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write BaseCard implementation</p> <pre><code>// client/src/components/ui/BaseCard.jsx\nimport { forwardRef } from \"react\";\nimport { useEntityImageAspectRatio } from \"../../hooks/useEntityImageAspectRatio.js\";\nimport {\n  CardContainer,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardRatingRow,\n  CardTitle,\n} from \"./CardComponents.jsx\";\n\n/**\n * BaseCard - Composable card component that assembles primitives\n * Provides render slots for entity-specific customization\n */\nexport const BaseCard = forwardRef(\n  (\n    {\n      // Data\n      entityType,\n      imagePath,\n      title,\n      subtitle,\n      description,\n      linkTo,\n\n      // Indicators &amp; Rating\n      indicators = [],\n      ratingControlsProps,\n\n      // Display options\n      hideDescription = false,\n      hideSubtitle = false,\n      maxTitleLines = 2,\n      maxDescriptionLines = 3,\n\n      // Customization slots\n      renderOverlay,\n      renderImageContent,\n      renderAfterTitle,\n\n      // Events &amp; behavior\n      onClick,\n      onLongPress,\n      className = \"\",\n      referrerUrl,\n      tabIndex,\n      style,\n      ...rest\n    },\n    ref\n  ) =&gt; {\n    const aspectRatio = useEntityImageAspectRatio(entityType);\n\n    return (\n      &lt;CardContainer\n        ref={ref}\n        entityType={entityType}\n        linkTo={linkTo}\n        onClick={onClick}\n        referrerUrl={referrerUrl}\n        className={className}\n        tabIndex={tabIndex}\n        style={style}\n        {...rest}\n      &gt;\n        {/* Image Section */}\n        &lt;CardImage\n          src={imagePath}\n          alt={typeof title === \"string\" ? title : \"\"}\n          aspectRatio={aspectRatio}\n          entityType={entityType}\n        &gt;\n          {/* Custom image content (e.g., sprite preview) */}\n          {renderImageContent?.()}\n          {/* Custom overlay (e.g., progress bar, selection checkbox) */}\n          {renderOverlay?.()}\n        &lt;/CardImage&gt;\n\n        {/* Title Section */}\n        &lt;CardTitle\n          title={title}\n          subtitle={hideSubtitle ? null : subtitle}\n          maxTitleLines={maxTitleLines}\n        /&gt;\n\n        {/* After Title Slot (e.g., gender icon) */}\n        {renderAfterTitle?.()}\n\n        {/* Description */}\n        {!hideDescription &amp;&amp; description &amp;&amp; (\n          &lt;CardDescription\n            description={description}\n            maxLines={maxDescriptionLines}\n          /&gt;\n        )}\n\n        {/* Indicators */}\n        {indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators indicators={indicators} /&gt;}\n\n        {/* Rating Controls */}\n        {ratingControlsProps &amp;&amp; (\n          &lt;CardRatingRow entityType={entityType} {...ratingControlsProps} /&gt;\n        )}\n      &lt;/CardContainer&gt;\n    );\n  }\n);\n\nBaseCard.displayName = \"BaseCard\";\n\nexport default BaseCard;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseCard } from \"./BaseCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseCard.jsx client/src/components/ui/__tests__/BaseCard.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(cards): add BaseCard component with render slots\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-3-entity-cards-directory-structure","title":"Phase 3: Entity Cards Directory Structure","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-4-create-cards-directory-and-move-performercard","title":"Task 4: Create cards directory and move PerformerCard","text":"<p>Files: - Create: <code>client/src/components/cards/</code> - Move: <code>client/src/components/ui/PerformerCard.jsx</code> \u2192 <code>client/src/components/cards/PerformerCard.jsx</code> - Create: <code>client/src/components/cards/index.js</code> - Modify: <code>client/src/components/ui/index.js</code> (re-export from new location)</p> <p>Step 1: Create directory and index file</p> <pre><code>// client/src/components/cards/index.js\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 2: Move PerformerCard</p> <p>Move file from <code>client/src/components/ui/PerformerCard.jsx</code> to <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Update imports in the moved file:</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { GenderIcon, GridCard } from \"../ui/index.js\";\n// ... rest of imports unchanged\n</code></pre> <p>Step 3: Update ui/index.js to re-export</p> <p>Replace the PerformerCard export in <code>client/src/components/ui/index.js</code>:</p> <pre><code>// Replace:\n// export { default as PerformerCard } from \"./PerformerCard.jsx\";\n// With:\nexport { PerformerCard } from \"../cards/index.js\";\n</code></pre> <p>Step 4: Run existing app to verify no breaking changes</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS with no errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/cards/ client/src/components/ui/index.js\ngit rm client/src/components/ui/PerformerCard.jsx\ngit commit -m \"refactor(cards): move PerformerCard to components/cards/\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-5-migrate-performercard-to-use-basecard","title":"Task 5: Migrate PerformerCard to use BaseCard","text":"<p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/PerformerCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerCard\", () =&gt; {\n  const mockPerformer = {\n    id: \"1\",\n    name: \"Test Performer\",\n    gender: \"FEMALE\",\n    image_path: \"/test.jpg\",\n    scene_count: 10,\n    o_counter: 5,\n    rating100: 80,\n    favorite: true,\n  };\n\n  it(\"renders performer name\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n  });\n\n  it(\"renders gender icon\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    // GenderIcon should be present\n    expect(document.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"links to performer detail page\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/performer/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"10\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify current implementation passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS (existing implementation should pass)</p> <p>Step 3: Refactor to use BaseCard</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { GenderIcon } from \"../ui/GenderIcon.jsx\";\n\n/**\n * PerformerCard - Card for displaying performer entities\n * Uses BaseCard with performer-specific configuration\n */\nconst PerformerCard = forwardRef(\n  ({ performer, referrerUrl, isTVMode, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const indicators = [\n      { type: \"PLAY_COUNT\", count: performer.play_count },\n      { type: \"SCENES\", count: performer.scene_count },\n      { type: \"GROUPS\", count: performer.group_count },\n      { type: \"IMAGES\", count: performer.image_count },\n      { type: \"GALLERIES\", count: performer.gallery_count },\n      { type: \"TAGS\", count: performer.tags?.length || 0 },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"performer\"\n        imagePath={performer.image_path}\n        title={performer.name}\n        linkTo={`/performer/${performer.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={indicators}\n        ratingControlsProps={{\n          entityId: performer.id,\n          initialRating: performer.rating100,\n          initialFavorite: performer.favorite || false,\n          initialOCounter: performer.o_counter,\n          onHideSuccess,\n        }}\n        renderAfterTitle={() =&gt; (\n          &lt;div className=\"flex items-center gap-1 mt-1\"&gt;\n            &lt;GenderIcon gender={performer.gender} size={16} /&gt;\n          &lt;/div&gt;\n        )}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nPerformerCard.displayName = \"PerformerCard\";\n\nexport default PerformerCard;\n</code></pre> <p>Step 4: Run test to verify it still passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Run full build to verify no regressions</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/PerformerCard.jsx client/src/components/cards/__tests__/PerformerCard.test.jsx\ngit commit -m \"refactor(cards): migrate PerformerCard to use BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-6-create-gallerycard","title":"Task 6: Create GalleryCard","text":"<p>Files: - Create: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GalleryCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryCard\", () =&gt; {\n  const mockGallery = {\n    id: \"1\",\n    title: \"Test Gallery\",\n    paths: { cover: \"/cover.jpg\" },\n    image_count: 25,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    performers: [{ id: \"1\", name: \"Performer 1\" }],\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 70,\n    favorite: false,\n  };\n\n  it(\"renders gallery title\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n  });\n\n  it(\"renders studio and date subtitle\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(/Test Studio/)).toBeInTheDocument();\n  });\n\n  it(\"links to gallery detail page\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/gallery/1\");\n  });\n\n  it(\"renders image count indicator\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"25\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write GalleryCard implementation</p> <pre><code>// client/src/components/cards/GalleryCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { TooltipEntityGrid } from \"../ui/TooltipEntityGrid.jsx\";\nimport { galleryTitle } from \"../../utils/gallery.js\";\n\n/**\n * GalleryCard - Card for displaying gallery entities\n */\nconst GalleryCard = forwardRef(\n  ({ gallery, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const galleryDate = gallery.date\n      ? new Date(gallery.date).toLocaleDateString()\n      : null;\n    const subtitle = (() =&gt; {\n      if (gallery.studio &amp;&amp; galleryDate) {\n        return `${gallery.studio.name} \u2022 ${galleryDate}`;\n      } else if (gallery.studio) {\n        return gallery.studio.name;\n      } else if (galleryDate) {\n        return galleryDate;\n      }\n      return null;\n    })();\n\n    // Build rich tooltip content for performers and tags\n    const performersTooltip =\n      gallery.performers &amp;&amp;\n      gallery.performers.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"performer\"\n          entities={gallery.performers}\n          title=\"Performers\"\n        /&gt;\n      );\n\n    const tagsTooltip =\n      gallery.tags &amp;&amp;\n      gallery.tags.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"tag\"\n          entities={gallery.tags}\n          title=\"Tags\"\n        /&gt;\n      );\n\n    const indicators = [\n      {\n        type: \"IMAGES\",\n        count: gallery.image_count,\n        tooltipContent:\n          gallery.image_count === 1 ? \"1 Image\" : `${gallery.image_count} Images`,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: gallery.performers?.length || 0,\n        tooltipContent: performersTooltip,\n        onClick:\n          gallery.performers?.length &gt; 0\n            ? () =&gt; navigate(`/performers?galleryId=${gallery.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: gallery.tags?.length || 0,\n        tooltipContent: tagsTooltip,\n        onClick:\n          gallery.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?galleryId=${gallery.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"gallery\"\n        imagePath={gallery.paths?.cover}\n        title={galleryTitle(gallery)}\n        subtitle={subtitle}\n        description={gallery.description}\n        linkTo={`/gallery/${gallery.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: gallery.id,\n          initialRating: gallery.rating100,\n          initialFavorite: gallery.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGalleryCard.displayName = \"GalleryCard\";\n\nexport default GalleryCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>// client/src/components/cards/index.js\nexport { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GalleryCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GalleryCard.test.jsx\ngit commit -m \"feat(cards): add GalleryCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-7-create-groupcard","title":"Task 7: Create GroupCard","text":"<p>Files: - Create: <code>client/src/components/cards/GroupCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GroupCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GroupCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GroupCard\", () =&gt; {\n  const mockGroup = {\n    id: \"1\",\n    name: \"Test Collection\",\n    front_image_path: \"/front.jpg\",\n    scene_count: 15,\n    sub_group_count: 3,\n    performer_count: 5,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 85,\n    favorite: true,\n  };\n\n  it(\"renders group name\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"Test Collection\")).toBeInTheDocument();\n  });\n\n  it(\"links to collection detail page\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/collection/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"15\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write GroupCard implementation</p> <pre><code>// client/src/components/cards/GroupCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * GroupCard - Card for displaying group/collection entities\n */\nconst GroupCard = forwardRef(\n  ({ group, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const subtitle = (() =&gt; {\n      if (group.studio &amp;&amp; group.date) {\n        return `${group.studio.name} \u2022 ${group.date}`;\n      } else if (group.studio) {\n        return group.studio.name;\n      } else if (group.date) {\n        return group.date;\n      }\n      return null;\n    })();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: group.scene_count,\n        onClick:\n          group.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"GROUPS\",\n        count: group.sub_group_count,\n        onClick:\n          group.sub_group_count &gt; 0\n            ? () =&gt; navigate(`/collections?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: group.performer_count,\n        onClick:\n          group.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: group.tags?.length || 0,\n        onClick:\n          group.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?groupIds=${group.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"group\"\n        imagePath={group.front_image_path || group.back_image_path}\n        title={group.name}\n        subtitle={subtitle}\n        description={group.description}\n        linkTo={`/collection/${group.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: group.id,\n          initialRating: group.rating100,\n          initialFavorite: group.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGroupCard.displayName = \"GroupCard\";\n\nexport default GroupCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GroupCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GroupCard.test.jsx\ngit commit -m \"feat(cards): add GroupCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-8-create-studiocard","title":"Task 8: Create StudioCard","text":"<p>Files: - Create: <code>client/src/components/cards/StudioCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/StudioCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { StudioCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"StudioCard\", () =&gt; {\n  const mockStudio = {\n    id: \"1\",\n    name: \"Test Studio\",\n    image_path: \"/studio.jpg\",\n    scene_count: 50,\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    details: \"Studio description\",\n    rating100: 90,\n    favorite: false,\n  };\n\n  it(\"renders studio name\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"Test Studio\")).toBeInTheDocument();\n  });\n\n  it(\"links to studio detail page\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/studio/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"50\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write StudioCard implementation</p> <pre><code>// client/src/components/cards/StudioCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * StudioCard - Card for displaying studio entities\n */\nconst StudioCard = forwardRef(\n  ({ studio, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: studio.scene_count,\n        onClick:\n          studio.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?studioId=${studio.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: studio.tags?.length || 0,\n        onClick:\n          studio.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?studioId=${studio.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"studio\"\n        imagePath={studio.image_path}\n        title={studio.name}\n        description={studio.details}\n        linkTo={`/studio/${studio.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: studio.id,\n          initialRating: studio.rating100,\n          initialFavorite: studio.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nStudioCard.displayName = \"StudioCard\";\n\nexport default StudioCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/StudioCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/StudioCard.test.jsx\ngit commit -m \"feat(cards): add StudioCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-9-create-tagcard","title":"Task 9: Create TagCard","text":"<p>Files: - Create: <code>client/src/components/cards/TagCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/TagCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { TagCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"TagCard\", () =&gt; {\n  const mockTag = {\n    id: \"1\",\n    name: \"Test Tag\",\n    image_path: \"/tag.jpg\",\n    scene_count: 30,\n    studio_count: 5,\n    performer_count: 10,\n    gallery_count: 8,\n    description: \"Tag description\",\n  };\n\n  it(\"renders tag name\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"Test Tag\")).toBeInTheDocument();\n  });\n\n  it(\"links to tag detail page\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/tags/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"30\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write TagCard implementation</p> <pre><code>// client/src/components/cards/TagCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * TagCard - Card for displaying tag entities\n */\nconst TagCard = forwardRef(\n  ({ tag, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: tag.scene_count,\n        onClick:\n          tag.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"STUDIOS\",\n        count: tag.studio_count,\n        onClick:\n          tag.studio_count &gt; 0\n            ? () =&gt; navigate(`/studios?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: tag.performer_count,\n        onClick:\n          tag.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"GALLERIES\",\n        count: tag.gallery_count,\n        onClick:\n          tag.gallery_count &gt; 0\n            ? () =&gt; navigate(`/galleries?tagIds=${tag.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"tag\"\n        imagePath={tag.image_path}\n        title={tag.name}\n        description={tag.description}\n        linkTo={`/tags/${tag.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={\n          tag.rating100 !== undefined\n            ? {\n                entityId: tag.id,\n                initialRating: tag.rating100,\n                initialFavorite: tag.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nTagCard.displayName = \"TagCard\";\n\nexport default TagCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/TagCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/TagCard.test.jsx\ngit commit -m \"feat(cards): add TagCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-10-create-imagecard","title":"Task 10: Create ImageCard","text":"<p>Files: - Create: <code>client/src/components/cards/ImageCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/ImageCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { ImageCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"ImageCard\", () =&gt; {\n  const mockImage = {\n    id: \"1\",\n    title: \"Test Image\",\n    paths: { thumbnail: \"/thumb.jpg\", image: \"/full.jpg\" },\n  };\n\n  it(\"renders image title\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByText(\"Test Image\")).toBeInTheDocument();\n  });\n\n  it(\"links to image detail page\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/image/1\");\n  });\n\n  it(\"uses fallback title when no title provided\", () =&gt; {\n    const imageNoTitle = { ...mockImage, title: null };\n    renderWithRouter(&lt;ImageCard image={imageNoTitle} /&gt;);\n    expect(screen.getByText(\"Image 1\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write ImageCard implementation</p> <pre><code>// client/src/components/cards/ImageCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * ImageCard - Card for displaying image entities\n */\nconst ImageCard = forwardRef(\n  ({ image, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"image\"\n        imagePath={image.paths?.thumbnail || image.paths?.image}\n        title={image.title || `Image ${image.id}`}\n        linkTo={`/image/${image.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={[]}\n        ratingControlsProps={\n          image.rating100 !== undefined\n            ? {\n                entityId: image.id,\n                initialRating: image.rating100,\n                initialFavorite: image.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nImageCard.displayName = \"ImageCard\";\n\nexport default ImageCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as ImageCard } from \"./ImageCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/ImageCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/ImageCard.test.jsx\ngit commit -m \"feat(cards): add ImageCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-4-grid-components","title":"Phase 4: Grid Components","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-11-create-basegrid-component","title":"Task 11: Create BaseGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseGrid.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseGrid.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseGrid.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseGrid } from \"../BaseGrid\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseGrid\", () =&gt; {\n  const mockItems = [\n    { id: \"1\", name: \"Item 1\" },\n    { id: \"2\", name: \"Item 2\" },\n    { id: \"3\", name: \"Item 3\" },\n  ];\n\n  it(\"renders items using renderItem function\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n      /&gt;\n    );\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 3\")).toBeInTheDocument();\n  });\n\n  it(\"shows loading skeleton when loading=true\", () =&gt; {\n    const { container } = renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        loading={true}\n        skeletonCount={3}\n      /&gt;\n    );\n    expect(container.querySelectorAll(\".animate-pulse\")).toHaveLength(3);\n  });\n\n  it(\"shows empty message when items is empty\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        emptyMessage=\"No items found\"\n      /&gt;\n    );\n    expect(screen.getByText(\"No items found\")).toBeInTheDocument();\n  });\n\n  it(\"renders pagination when totalPages &gt; 1\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n        currentPage={1}\n        totalPages={5}\n        onPageChange={() =&gt; {}}\n      /&gt;\n    );\n    // Should have pagination controls\n    expect(screen.getByRole(\"navigation\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write BaseGrid implementation</p> <pre><code>// client/src/components/ui/BaseGrid.jsx\nimport { SCENE_GRID_CONTAINER_CLASSNAMES, STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport EmptyState from \"./EmptyState.jsx\";\nimport Pagination from \"./Pagination.jsx\";\n\n/**\n * BaseGrid - Base grid component for layout, responsive columns, pagination, and loading/empty states\n *\n * @param {Object} props\n * @param {any[]} props.items - Array of items to render\n * @param {Function} props.renderItem - Function to render each item (item, index) =&gt; ReactNode\n * @param {'scene'|'standard'} props.gridType - Grid type for responsive columns\n * @param {boolean} [props.loading] - Show loading skeleton\n * @param {Error} [props.error] - Error to display\n * @param {string} [props.emptyMessage] - Message when no items\n * @param {string} [props.emptyDescription] - Description for empty state\n * @param {number} [props.currentPage] - Current page number\n * @param {number} [props.totalPages] - Total number of pages\n * @param {Function} [props.onPageChange] - Page change handler (page: number) =&gt; void\n * @param {number} [props.skeletonCount] - Number of skeleton cards to show while loading\n * @param {Function} [props.renderSkeleton] - Custom skeleton renderer\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const BaseGrid = ({\n  items,\n  renderItem,\n  gridType = \"standard\",\n  loading = false,\n  error,\n  emptyMessage = \"No items found\",\n  emptyDescription,\n  currentPage,\n  totalPages,\n  onPageChange,\n  skeletonCount = 12,\n  renderSkeleton,\n  className = \"\",\n}) =&gt; {\n  const gridClasses =\n    gridType === \"scene\"\n      ? SCENE_GRID_CONTAINER_CLASSNAMES\n      : STANDARD_GRID_CONTAINER_CLASSNAMES;\n\n  // Default skeleton renderer\n  const defaultRenderSkeleton = () =&gt; (\n    &lt;div\n      className=\"rounded-lg animate-pulse\"\n      style={{\n        backgroundColor: \"var(--bg-tertiary)\",\n        height: gridType === \"scene\" ? \"20rem\" : \"24rem\",\n      }}\n    /&gt;\n  );\n\n  const skeletonRenderer = renderSkeleton || defaultRenderSkeleton;\n\n  // Loading state\n  if (loading) {\n    return (\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {[...Array(skeletonCount)].map((_, i) =&gt; (\n          &lt;div key={i}&gt;{skeletonRenderer()}&lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  // Error state\n  if (error) {\n    return (\n      &lt;EmptyState\n        title=\"Error loading items\"\n        description={error.message || \"An error occurred\"}\n      /&gt;\n    );\n  }\n\n  // Empty state\n  if (!items || items.length === 0) {\n    return &lt;EmptyState title={emptyMessage} description={emptyDescription} /&gt;;\n  }\n\n  return (\n    &lt;&gt;\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {items.map((item, index) =&gt; renderItem(item, index))}\n      &lt;/div&gt;\n\n      {/* Pagination */}\n      {totalPages &gt; 1 &amp;&amp; onPageChange &amp;&amp; (\n        &lt;nav role=\"navigation\" aria-label=\"Pagination\" className=\"mt-6\"&gt;\n          &lt;Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            onPageChange={onPageChange}\n          /&gt;\n        &lt;/nav&gt;\n      )}\n    &lt;/&gt;\n  );\n};\n\nexport default BaseGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseGrid } from \"./BaseGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseGrid.jsx client/src/components/ui/__tests__/BaseGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add BaseGrid component for grid layout and pagination\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-12-create-searchablegrid-component","title":"Task 12: Create SearchableGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/SearchableGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/SearchableGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { SearchableGrid } from \"../SearchableGrid\";\n\n// Mock the libraryApi\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"SearchableGrid\", () =&gt; {\n  it(\"renders search controls\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    // Wait for initial load\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"applies locked filters without showing them in UI\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write SearchableGrid implementation</p> <pre><code>// client/src/components/ui/SearchableGrid.jsx\nimport { useCallback, useRef, useState } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport deepEqual from \"fast-deep-equal\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport BaseGrid from \"./BaseGrid.jsx\";\nimport SearchControls from \"./SearchControls.jsx\";\n\n/**\n * SearchableGrid - BaseGrid with integrated search controls and data fetching\n *\n * @param {Object} props\n * @param {'scene'|'performer'|'gallery'|'group'|'studio'|'tag'|'image'} props.entityType\n * @param {Object} [props.lockedFilters] - Filters that cannot be changed by user\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {'scene'|'standard'} [props.gridType] - Grid layout type\n * @param {Function} props.renderItem - Function to render each item\n * @param {Object} [props.defaultSort] - Default sort configuration\n * @param {Object} [props.defaultFilters] - Default filters\n * @param {Function} [props.onResultsChange] - Callback when results change\n * @param {string} [props.emptyMessage] - Empty state message\n * @param {string} [props.emptyDescription] - Empty state description\n * @param {number} [props.skeletonCount] - Number of skeleton items during loading\n * @param {boolean} [props.syncToUrl] - Whether to sync state to URL (default: true)\n */\nexport const SearchableGrid = ({\n  entityType,\n  lockedFilters = {},\n  hideLockedFilters = false,\n  gridType = \"standard\",\n  renderItem,\n  defaultSort = \"name\",\n  defaultFilters = {},\n  onResultsChange,\n  emptyMessage,\n  emptyDescription,\n  skeletonCount = 24,\n  syncToUrl = true,\n}) =&gt; {\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n  const [searchParams] = useSearchParams();\n\n  const [lastQuery, setLastQuery] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n\n  // API method mapping\n  const apiMethods = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Response key mapping\n  const responseKeys = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Data array key mapping\n  const dataKeys = {\n    scene: \"scenes\",\n    performer: \"performers\",\n    gallery: \"galleries\",\n    group: \"groups\",\n    studio: \"studios\",\n    tag: \"tags\",\n    image: \"images\",\n  };\n\n  const handleQueryChange = useCallback(\n    async (newQuery) =&gt; {\n      if (isAuthLoading || !isAuthenticated) {\n        return;\n      }\n\n      // Merge locked filters into query\n      const mergedQuery = {\n        ...newQuery,\n        ...lockedFilters,\n      };\n\n      // Avoid duplicate queries\n      if (lastQuery &amp;&amp; deepEqual(mergedQuery, lastQuery)) {\n        return;\n      }\n\n      try {\n        setIsLoading(true);\n        setLastQuery(mergedQuery);\n        setError(null);\n\n        const apiMethod = apiMethods[entityType];\n        const responseKey = responseKeys[entityType];\n        const dataKey = dataKeys[entityType];\n\n        const result = await libraryApi[apiMethod](mergedQuery);\n        const items = result[responseKey]?.[dataKey] || [];\n        const count = result[responseKey]?.count || 0;\n\n        setData(items);\n        setTotalCount(count);\n        onResultsChange?.({ items, count });\n      } catch (err) {\n        setError(err);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [entityType, lockedFilters, lastQuery, isAuthLoading, isAuthenticated, onResultsChange]\n  );\n\n  // Handle successful hide - remove item from local state\n  const handleHideSuccess = useCallback((entityId) =&gt; {\n    setData((prevData) =&gt; prevData.filter((item) =&gt; item.id !== entityId));\n    setTotalCount((prevCount) =&gt; Math.max(0, prevCount - 1));\n  }, []);\n\n  // Calculate pagination\n  const currentPerPage = lastQuery?.filter?.per_page || 24;\n  const totalPages = Math.ceil(totalCount / currentPerPage);\n\n  // Build filter key for locked filters if we need to hide them\n  const permanentFiltersMetadata = hideLockedFilters ? {} : lockedFilters;\n\n  return (\n    &lt;SearchControls\n      artifactType={entityType}\n      initialSort={defaultSort}\n      onQueryChange={handleQueryChange}\n      permanentFilters={lockedFilters}\n      permanentFiltersMetadata={permanentFiltersMetadata}\n      totalPages={totalPages}\n      totalCount={totalCount}\n      syncToUrl={syncToUrl}\n    &gt;\n      &lt;BaseGrid\n        items={data}\n        renderItem={(item, index) =&gt;\n          renderItem(item, index, { onHideSuccess: handleHideSuccess })\n        }\n        gridType={gridType}\n        loading={isLoading}\n        error={error}\n        emptyMessage={emptyMessage || `No ${entityType}s found`}\n        emptyDescription={emptyDescription}\n        skeletonCount={skeletonCount}\n      /&gt;\n    &lt;/SearchControls&gt;\n  );\n};\n\nexport default SearchableGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { SearchableGrid } from \"./SearchableGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/SearchableGrid.jsx client/src/components/ui/__tests__/SearchableGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add SearchableGrid with integrated search controls and data fetching\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-13-create-grids-directory-structure","title":"Task 13: Create grids directory structure","text":"<p>Files: - Create: <code>client/src/components/grids/</code> - Create: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Create directory and index</p> <pre><code>// client/src/components/grids/index.js\n// Entity grid components will be exported here\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/grids/\ngit commit -m \"chore: create grids directory structure\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-14-create-performergrid","title":"Task 14: Create PerformerGrid","text":"<p>Files: - Create: <code>client/src/components/grids/PerformerGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/PerformerGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\", image_path: \"/test.jpg\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerGrid\", () =&gt; {\n  it(\"renders performers from API\", async () =&gt; {\n    renderWithRouter(&lt;PerformerGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"supports locked filters for nested grids\", async () =&gt; {\n    renderWithRouter(\n      &lt;PerformerGrid\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write PerformerGrid implementation</p> <pre><code>// client/src/components/grids/PerformerGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { PerformerCard } from \"../cards/index.js\";\n\n/**\n * PerformerGrid - Grid for displaying performers with search and filtering\n *\n * @param {Object} [props.lockedFilters] - Filters locked for nested grid use\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {string} [props.emptyMessage] - Custom empty state message\n */\nconst PerformerGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No performers found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"performer\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"o_counter\"\n      renderItem={(performer, _index, { onHideSuccess }) =&gt; (\n        &lt;PerformerCard\n          key={performer.id}\n          performer={performer}\n          onHideSuccess={() =&gt; onHideSuccess(performer.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default PerformerGrid;\n</code></pre> <p>Step 4: Update grids/index.js</p> <pre><code>export { default as PerformerGrid } from \"./PerformerGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/grids/PerformerGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/PerformerGrid.test.jsx\ngit commit -m \"feat(grids): add PerformerGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-15-create-gallerygrid","title":"Task 15: Create GalleryGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GalleryGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/GalleryGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findGalleries: jest.fn().mockResolvedValue({\n      findGalleries: {\n        galleries: [\n          { id: \"1\", title: \"Test Gallery\", paths: { cover: \"/test.jpg\" } },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryGrid\", () =&gt; {\n  it(\"renders galleries from API\", async () =&gt; {\n    renderWithRouter(&lt;GalleryGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test, write implementation, verify</p> <pre><code>// client/src/components/grids/GalleryGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { GalleryCard } from \"../cards/index.js\";\n\nconst GalleryGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No galleries found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"gallery\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"date\"\n      renderItem={(gallery, _index, { onHideSuccess }) =&gt; (\n        &lt;GalleryCard\n          key={gallery.id}\n          gallery={gallery}\n          onHideSuccess={() =&gt; onHideSuccess(gallery.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default GalleryGrid;\n</code></pre> <p>Step 3: Update index, run test, commit</p> <pre><code>git add client/src/components/grids/GalleryGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/GalleryGrid.test.jsx\ngit commit -m \"feat(grids): add GalleryGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-16-create-groupgrid","title":"Task 16: Create GroupGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GroupGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern to GalleryGrid - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add GroupGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-17-create-studiogrid","title":"Task 17: Create StudioGrid","text":"<p>Files: - Create: <code>client/src/components/grids/StudioGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add StudioGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-18-create-taggrid","title":"Task 18: Create TagGrid","text":"<p>Files: - Create: <code>client/src/components/grids/TagGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add TagGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-19-create-imagegrid","title":"Task 19: Create ImageGrid","text":"<p>Files: - Create: <code>client/src/components/grids/ImageGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add ImageGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-5-migration-cleanup","title":"Phase 5: Migration &amp; Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-20-update-performerdetail-to-use-new-grid-components","title":"Task 20: Update PerformerDetail to use new grid components","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code></p> <p>Step 1: Verify existing behavior works</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to a performer detail page and verify tabs work.</p> <p>Step 2: Update imports</p> <pre><code>// In PerformerDetail.jsx, replace:\nimport { EntityGrid } from \"../ui/index.js\";\n\n// With:\nimport { GalleryGrid, GroupGrid } from \"../grids/index.js\";\n</code></pre> <p>Step 3: Replace EntityGrid usage</p> <p>Replace galleries tab content: <pre><code>{activeTab === 'galleries' &amp;&amp; (\n  &lt;GalleryGrid\n    lockedFilters={{\n      gallery_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No galleries found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Replace groups tab content: <pre><code>{activeTab === 'groups' &amp;&amp; (\n  &lt;GroupGrid\n    lockedFilters={{\n      group_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No collections found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Step 4: Verify changes work</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to performer detail page, verify all tabs still work.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx\ngit commit -m \"refactor(pages): update PerformerDetail to use new grid components\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-21-update-remaining-detail-pages","title":"Task 21: Update remaining detail pages","text":"<p>Files: - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code></p> <p>Follow same pattern as Task 20 for each page.</p> <p>Commit after each page: <pre><code>git commit -m \"refactor(pages): update StudioDetail to use new grid components\"\ngit commit -m \"refactor(pages): update TagDetail to use new grid components\"\n# etc.\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-22-delete-deprecated-gridcardjsx","title":"Task 22: Delete deprecated GridCard.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/GridCard.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (remove export)</p> <p>Step 1: Search for GridCard usages</p> <p>Run: <code>grep -r \"GridCard\" client/src --include=\"*.jsx\" --include=\"*.js\"</code></p> <p>Step 2: Ensure no remaining usages</p> <p>All usages should have been replaced by BaseCard-based components.</p> <p>Step 3: Delete and update exports</p> <pre><code>git rm client/src/components/ui/GridCard.jsx\n</code></pre> <p>Update index.js to remove: <pre><code>// Remove this line:\nexport { GridCard } from \"./GridCard.jsx\";\n</code></pre></p> <p>Step 4: Verify build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/index.js\ngit commit -m \"refactor(cards): delete deprecated GridCard.jsx\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-23-delete-deprecated-entitygridjsx","title":"Task 23: Delete deprecated EntityGrid.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/EntityGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Follow same pattern as Task 22.</p> <p>Commit: <pre><code>git commit -m \"refactor(grids): delete deprecated EntityGrid.jsx\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-24-run-full-test-suite-and-fix-any-issues","title":"Task 24: Run full test suite and fix any issues","text":"<p>Step 1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --watchAll=false</code></p> <p>Step 2: Fix any failing tests</p> <p>Update snapshots if needed, fix any regressions.</p> <p>Step 3: Run build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Step 4: Manual testing</p> <p>Test all pages in browser: - Scenes page - Performers page + detail - Galleries page + detail - Collections page + detail - Studios page + detail - Tags page + detail</p> <p>Step 5: Commit any fixes</p> <pre><code>git commit -m \"fix: address test failures after card/grid refactor\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-25-update-documentation","title":"Task 25: Update documentation","text":"<p>Files: - Modify: <code>docs/architecture/components.md</code> (if exists) - Or create brief documentation in README</p> <p>Document the new component hierarchy: - Primitives (CardComponents.jsx) - BaseCard + BaseGrid - Entity Cards (components/cards/) - Entity Grids (components/grids/)</p> <p>Commit: <pre><code>git commit -m \"docs: update component documentation for card/grid refactor\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#final-checklist","title":"Final Checklist","text":"<ul> <li> All tests pass</li> <li> Build succeeds without warnings</li> <li> All entity types have dedicated Card components</li> <li> All entity types have dedicated Grid components</li> <li> Nested grids work with locked filters on detail pages</li> <li> No deprecated components remain (GridCard, EntityGrid)</li> <li> Visual appearance matches pre-refactor state</li> <li> TV mode still functions correctly</li> <li> Selection mode in SceneGrid still works</li> </ul> <p>Plan complete and saved to <code>docs/plans/2025-01-12-card-grid-refactor-implementation.md</code>.</p> <p>Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/","title":"Tag Hierarchy View Design","text":"<p>Date: 2025-01-12 Status: Design Complete Branch: <code>feature/tag-hierarchy-view</code></p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#overview","title":"Overview","text":"<p>Tag Hierarchy View is a new view mode for the Tags page that displays tags as an expandable tree structure based on parent/child relationships. This gives users a way to visualize and navigate the tag taxonomy, which the current grid view doesn't convey.</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#core-behavior","title":"Core Behavior","text":"<ul> <li>View toggle: Adds \"Hierarchy\" option to ViewModeToggle (Grid | Hierarchy). Wall view doesn't apply to tags.</li> <li>Tree structure: Root tags (no parents) appear at the top level. Child tags are indented under their parents.</li> <li>Multi-parent handling: Tags with multiple parents appear under each parent (duplicated in the tree).</li> <li>Initial state: Root tags visible with their immediate children expanded (first level expanded).</li> <li>Click behavior: Single click expands/collapses a node. Double-click or icon button navigates to tag detail page.</li> <li>Search/filter: Tree is filtered to only show matching tags plus their ancestors (to maintain tree structure). Non-matching tags are hidden.</li> </ul>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#tree-node-design","title":"Tree Node Design","text":"<p>Each tree node displays as a compact \"mini-card\":</p> <p>Left side: - Expand/collapse chevron (only if tag has children) - Small thumbnail (tag's <code>image_path</code>, ~40x40px, fallback to colored placeholder)</p> <p>Center: - Tag name (primary text) - Subtitle line: child count if any (e.g., \"3 subtags\"), or parent names for context</p> <p>Right side: - Inline count badges: scene count, performer count (most relevant metrics, muted style) - Favorite star (if favorited) - Navigate icon button (arrow/external-link icon, visible on hover, always visible on touch devices)</p> <p>Visual styling: - Indentation per level (~24px per depth level) - Subtle left border or connector lines to show hierarchy relationship - Hover state with background highlight - Selected/focused state for keyboard navigation - Dimmed style when tag is shown only as ancestor of a match (not a match itself)</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#data-performance","title":"Data &amp; Performance","text":"<p>Data requirements: - The existing <code>findTags</code> GraphQL query already returns <code>parents</code> and <code>children</code> arrays with <code>{id, name}</code> for each tag - No new API endpoints needed - tree is built client-side from the flat tag list</p> <p>Tree building approach: - Fetch all tags matching current filters - Build tree structure in memory: identify root tags (no parents), then nest children recursively - Handle multi-parent by inserting tag reference under each parent node</p> <p>Performance approach: - Start simple: fetch all matching tags, build tree client-side - Hierarchy view ignores per-page pagination (needs full tag set to build tree) - Add lazy loading/virtualization only if performance becomes an issue (most libraries have &lt;500 tags)</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#component-architecture","title":"Component Architecture","text":"<p>New components:</p> <ol> <li><code>TagHierarchyView.jsx</code> - Main container</li> <li>Receives tags array, builds tree structure, manages expanded state, renders the tree</li> <li>Props: <code>tags</code>, <code>isLoading</code>, <code>onTagNavigate</code>, <code>searchQuery</code></li> <li> <p>State: <code>expandedIds</code> (Set of expanded tag IDs)</p> </li> <li> <p><code>TagTreeNode.jsx</code> - Individual tree node (rich mini-card)</p> </li> <li>Props: <code>tag</code>, <code>depth</code>, <code>isExpanded</code>, <code>hasChildren</code>, <code>onToggle</code>, <code>onNavigate</code>, <code>isAncestorOnly</code></li> <li>Recursive: renders its children as nested <code>TagTreeNode</code> components</li> </ol> <p>Modified components:</p> <ol> <li><code>ViewModeToggle.jsx</code> - Add support for custom mode arrays via props</li> <li>Currently hardcoded to grid/wall</li> <li>Accept optional <code>modes</code> prop: <code>[{id, icon, label}]</code></li> <li> <p>Tags page passes <code>modes={[\"grid\", \"hierarchy\"]}</code></p> </li> <li> <p><code>Tags.jsx</code> - Add view mode support</p> </li> <li>Use render prop from SearchControls to receive <code>viewMode</code></li> <li>Conditionally render <code>TagHierarchyView</code> or existing grid</li> <li> <p>Pass view modes config to SearchControls</p> </li> <li> <p><code>SearchControls.jsx</code> - Accept configurable view modes</p> </li> <li>Replace <code>supportsWallView</code> boolean with more flexible <code>viewModes</code> prop</li> <li>Maintain backward compatibility with existing <code>supportsWallView</code> usage</li> </ol> <p>Utility function:</p> <ul> <li><code>buildTagTree(tags)</code> - Pure function in <code>utils/</code></li> <li>Takes flat tag array, returns tree structure with nested children</li> <li>Handles multi-parent duplication</li> <li>Returns array of root nodes, each with recursive <code>children</code> array</li> </ul>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#user-interaction","title":"User Interaction","text":"<p>Keyboard navigation: - Arrow Up/Down: Move focus between visible nodes - Arrow Right: Expand focused node (if collapsed) or move to first child - Arrow Left: Collapse focused node (if expanded) or move to parent - Enter: Navigate to tag detail page - Home/End: Jump to first/last visible node</p> <p>Expand/collapse: - Chevron click or single-click on node row: Toggle expand/collapse - State persists while on the page (resets on navigation away)</p> <p>Navigation to tag detail: - Double-click anywhere on the node - Single-click the navigate icon button (visible on hover, always visible on touch) - Enter key when node is focused</p> <p>Search/filter interaction: - When filters active: tree shows only matching tags + ancestors - Ancestors shown in dimmed style (structural, not matches) - Tree auto-expands to reveal all matches - Clearing search restores full tree with first-level-expanded default</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#scope","title":"Scope","text":"<p>In scope: - New <code>TagHierarchyView</code> and <code>TagTreeNode</code> components - <code>buildTagTree</code> utility function - Update <code>ViewModeToggle</code> to accept configurable modes - Update <code>Tags.jsx</code> to support view mode switching (Grid | Hierarchy) - Update <code>SearchControls.jsx</code> to handle configurable view modes - Rich tree nodes with thumbnails, counts, favorite indicator, navigate button - Keyboard navigation support - Search filtering with ancestor preservation</p> <p>Out of scope (YAGNI): - Drag-and-drop to reorganize tag hierarchy - Inline editing of tag names - Expand all / collapse all buttons - Virtualized rendering - Lazy-loading children on expand - Persisting expanded state to localStorage - Wall view for tags</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-design/#files","title":"Files","text":"<p>Create: - <code>client/src/components/tags/TagHierarchyView.jsx</code> - <code>client/src/components/tags/TagTreeNode.jsx</code> - <code>client/src/utils/buildTagTree.js</code></p> <p>Modify: - <code>client/src/components/ui/ViewModeToggle.jsx</code> - <code>client/src/components/ui/SearchControls.jsx</code> - <code>client/src/components/pages/Tags.jsx</code></p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/","title":"Tag Hierarchy View Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a Hierarchy view mode to the Tags page that displays tags as an expandable tree based on parent/child relationships.</p> <p>Architecture: Client-side tree building from existing tag data. New TagHierarchyView and TagTreeNode components render the tree. ViewModeToggle extended to support configurable modes. SearchControls updated for flexible view mode handling.</p> <p>Tech Stack: React, Tailwind CSS, Lucide icons, Vitest for testing</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-1-create-buildtagtree-utility","title":"Task 1: Create buildTagTree utility","text":"<p>Files: - Create: <code>client/src/utils/buildTagTree.js</code> - Create: <code>client/tests/utils/buildTagTree.test.js</code></p> <p>Step 1: Write the failing tests</p> <pre><code>// client/tests/utils/buildTagTree.test.js\nimport { describe, it, expect } from \"vitest\";\nimport { buildTagTree } from \"../../src/utils/buildTagTree.js\";\n\ndescribe(\"buildTagTree\", () =&gt; {\n  it(\"returns empty array for empty input\", () =&gt; {\n    expect(buildTagTree([])).toEqual([]);\n  });\n\n  it(\"returns root tags (no parents) at top level\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Root1\", parents: [], children: [] },\n      { id: \"2\", name: \"Root2\", parents: [], children: [] },\n    ];\n    const result = buildTagTree(tags);\n    expect(result).toHaveLength(2);\n    expect(result[0].id).toBe(\"1\");\n    expect(result[1].id).toBe(\"2\");\n  });\n\n  it(\"nests children under their parents\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Parent\", parents: [], children: [{ id: \"2\", name: \"Child\" }] },\n      { id: \"2\", name: \"Child\", parents: [{ id: \"1\", name: \"Parent\" }], children: [] },\n    ];\n    const result = buildTagTree(tags);\n    expect(result).toHaveLength(1);\n    expect(result[0].id).toBe(\"1\");\n    expect(result[0].children).toHaveLength(1);\n    expect(result[0].children[0].id).toBe(\"2\");\n  });\n\n  it(\"duplicates tags under multiple parents\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Parent1\", parents: [], children: [{ id: \"3\", name: \"Child\" }] },\n      { id: \"2\", name: \"Parent2\", parents: [], children: [{ id: \"3\", name: \"Child\" }] },\n      { id: \"3\", name: \"Child\", parents: [{ id: \"1\", name: \"Parent1\" }, { id: \"2\", name: \"Parent2\" }], children: [] },\n    ];\n    const result = buildTagTree(tags);\n    expect(result).toHaveLength(2);\n    // Child appears under both parents\n    expect(result[0].children).toHaveLength(1);\n    expect(result[0].children[0].id).toBe(\"3\");\n    expect(result[1].children).toHaveLength(1);\n    expect(result[1].children[0].id).toBe(\"3\");\n  });\n\n  it(\"handles deep nesting (grandchildren)\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Grandparent\", parents: [], children: [{ id: \"2\", name: \"Parent\" }] },\n      { id: \"2\", name: \"Parent\", parents: [{ id: \"1\", name: \"Grandparent\" }], children: [{ id: \"3\", name: \"Child\" }] },\n      { id: \"3\", name: \"Child\", parents: [{ id: \"2\", name: \"Parent\" }], children: [] },\n    ];\n    const result = buildTagTree(tags);\n    expect(result).toHaveLength(1);\n    expect(result[0].children[0].children[0].id).toBe(\"3\");\n  });\n\n  it(\"preserves original tag properties\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Tag\", parents: [], children: [], scene_count: 42, favorite: true },\n    ];\n    const result = buildTagTree(tags);\n    expect(result[0].scene_count).toBe(42);\n    expect(result[0].favorite).toBe(true);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run buildTagTree</code> Expected: FAIL - module not found</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/utils/buildTagTree.js\n/**\n * Builds a tree structure from a flat array of tags with parent/child relationships.\n * Tags with multiple parents will appear under each parent (duplicated in tree).\n *\n * @param {Array} tags - Flat array of tag objects with `parents` and `children` arrays\n * @returns {Array} Array of root tree nodes, each with nested `children` array\n */\nexport function buildTagTree(tags) {\n  if (!tags || tags.length === 0) {\n    return [];\n  }\n\n  // Create a map for quick lookup\n  const tagMap = new Map();\n  tags.forEach((tag) =&gt; {\n    tagMap.set(tag.id, { ...tag, children: [] });\n  });\n\n  // Build tree by nesting children under parents\n  const roots = [];\n\n  tags.forEach((tag) =&gt; {\n    const treeNode = tagMap.get(tag.id);\n\n    if (!tag.parents || tag.parents.length === 0) {\n      // No parents = root node\n      roots.push(treeNode);\n    } else {\n      // Add to each parent's children (handles multi-parent)\n      tag.parents.forEach((parentRef) =&gt; {\n        const parentNode = tagMap.get(parentRef.id);\n        if (parentNode) {\n          // Create a copy for each parent to avoid shared references\n          const childCopy = { ...treeNode, children: [] };\n          parentNode.children.push(childCopy);\n        }\n      });\n    }\n  });\n\n  // Recursively populate children for non-root nodes\n  function populateChildren(node) {\n    const originalTag = tags.find((t) =&gt; t.id === node.id);\n    if (originalTag?.children) {\n      node.children = originalTag.children\n        .map((childRef) =&gt; {\n          const childTag = tagMap.get(childRef.id);\n          if (childTag) {\n            const childCopy = { ...childTag, children: [] };\n            populateChildren(childCopy);\n            return childCopy;\n          }\n          return null;\n        })\n        .filter(Boolean);\n    }\n  }\n\n  roots.forEach(populateChildren);\n\n  return roots;\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run buildTagTree</code> Expected: All tests PASS</p> <p>Step 5: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/utils/buildTagTree.js client/tests/utils/buildTagTree.test.js\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: add buildTagTree utility for hierarchy view\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-2-update-viewmodetoggle-to-support-configurable-modes","title":"Task 2: Update ViewModeToggle to support configurable modes","text":"<p>Files: - Modify: <code>client/src/components/ui/ViewModeToggle.jsx</code> - Create: <code>client/tests/components/ui/ViewModeToggle.test.jsx</code></p> <p>Step 1: Write the failing tests</p> <pre><code>// client/tests/components/ui/ViewModeToggle.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport ViewModeToggle from \"../../../src/components/ui/ViewModeToggle.jsx\";\n\ndescribe(\"ViewModeToggle\", () =&gt; {\n  it(\"renders default grid/wall modes when no modes prop\", () =&gt; {\n    render(&lt;ViewModeToggle value=\"grid\" onChange={() =&gt; {}} /&gt;);\n    expect(screen.getByLabelText(\"Grid view\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Wall view\")).toBeInTheDocument();\n  });\n\n  it(\"renders custom modes when modes prop provided\", () =&gt; {\n    const modes = [\n      { id: \"grid\", label: \"Grid view\" },\n      { id: \"hierarchy\", label: \"Hierarchy view\" },\n    ];\n    render(&lt;ViewModeToggle modes={modes} value=\"grid\" onChange={() =&gt; {}} /&gt;);\n    expect(screen.getByLabelText(\"Grid view\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Hierarchy view\")).toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Wall view\")).not.toBeInTheDocument();\n  });\n\n  it(\"calls onChange with mode id when clicked\", () =&gt; {\n    const onChange = vi.fn();\n    const modes = [\n      { id: \"grid\", label: \"Grid view\" },\n      { id: \"hierarchy\", label: \"Hierarchy view\" },\n    ];\n    render(&lt;ViewModeToggle modes={modes} value=\"grid\" onChange={onChange} /&gt;);\n    fireEvent.click(screen.getByLabelText(\"Hierarchy view\"));\n    expect(onChange).toHaveBeenCalledWith(\"hierarchy\");\n  });\n\n  it(\"highlights the active mode\", () =&gt; {\n    const modes = [\n      { id: \"grid\", label: \"Grid view\" },\n      { id: \"hierarchy\", label: \"Hierarchy view\" },\n    ];\n    render(&lt;ViewModeToggle modes={modes} value=\"hierarchy\" onChange={() =&gt; {}} /&gt;);\n    const hierarchyBtn = screen.getByLabelText(\"Hierarchy view\");\n    expect(hierarchyBtn).toHaveAttribute(\"aria-pressed\", \"true\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run ViewModeToggle</code> Expected: FAIL - custom modes not rendered</p> <p>Step 3: Update implementation</p> <pre><code>// client/src/components/ui/ViewModeToggle.jsx\nimport { LucideGrid2X2, LucideSquare, LucideNetwork } from \"lucide-react\";\n\n// Default modes for backward compatibility\nconst DEFAULT_MODES = [\n  { id: \"grid\", icon: LucideGrid2X2, label: \"Grid view\" },\n  { id: \"wall\", icon: LucideSquare, label: \"Wall view\" },\n];\n\n// Icon mapping for custom mode definitions\nconst MODE_ICONS = {\n  grid: LucideGrid2X2,\n  wall: LucideSquare,\n  hierarchy: LucideNetwork,\n};\n\n/**\n * Toggle between view modes.\n *\n * @param {Array} modes - Optional custom modes array [{id, label, icon?}]\n *                        If not provided, defaults to grid/wall\n * @param {string} value - Currently selected mode id\n * @param {function} onChange - Called with mode id when selection changes\n */\nconst ViewModeToggle = ({ modes, value = \"grid\", onChange, className = \"\" }) =&gt; {\n  // Use custom modes or fall back to defaults\n  const effectiveModes = modes\n    ? modes.map((mode) =&gt; ({\n        ...mode,\n        icon: mode.icon || MODE_ICONS[mode.id] || LucideGrid2X2,\n      }))\n    : DEFAULT_MODES;\n\n  return (\n    &lt;div\n      className={`inline-flex rounded-lg overflow-hidden ${className}`}\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {effectiveModes.map((mode) =&gt; (\n        &lt;button\n          key={mode.id}\n          type=\"button\"\n          onClick={() =&gt; onChange(mode.id)}\n          className=\"px-3 py-1.5 transition-colors\"\n          style={{\n            backgroundColor: value === mode.id ? \"var(--accent-primary)\" : \"transparent\",\n            color: value === mode.id ? \"white\" : \"var(--text-secondary)\",\n          }}\n          title={mode.label}\n          aria-label={mode.label}\n          aria-pressed={value === mode.id}\n        &gt;\n          &lt;mode.icon size={18} /&gt;\n        &lt;/button&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default ViewModeToggle;\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run ViewModeToggle</code> Expected: All tests PASS</p> <p>Step 5: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/components/ui/ViewModeToggle.jsx client/tests/components/ui/ViewModeToggle.test.jsx\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: ViewModeToggle supports custom modes prop\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-3-update-searchcontrols-for-configurable-view-modes","title":"Task 3: Update SearchControls for configurable view modes","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Identify changes needed</p> <p>The current SearchControls uses <code>supportsWallView</code> boolean. We need to: 1. Add <code>viewModes</code> prop (array of mode configs) 2. Keep <code>supportsWallView</code> for backward compatibility (converts to viewModes internally) 3. Pass <code>modes</code> prop to ViewModeToggle</p> <p>Step 2: Update implementation</p> <p>In <code>SearchControls.jsx</code>, find the props destructuring (around line 100) and add:</p> <pre><code>// View mode props\nsupportsWallView = false,\nviewModes, // New: array of {id, label} for custom view modes\nwallPlayback = \"autoplay\",\n</code></pre> <p>Find where ViewModeToggle is rendered (around line 758) and update:</p> <pre><code>{/* View Mode Toggle - Show if supportsWallView or viewModes provided */}\n{(supportsWallView || viewModes) &amp;&amp; (\n  &lt;div\n    data-tv-search-item=\"view-mode\"\n    ref={(el) =&gt; searchZoneNav.setItemRef(5, el)}\n    className={searchZoneNav.isFocused(5) ? \"keyboard-focus\" : \"\"}\n  &gt;\n    &lt;ViewModeToggle\n      modes={viewModes}\n      value={viewMode}\n      onChange={setViewMode}\n    /&gt;\n  &lt;/div&gt;\n)}\n\n{/* Zoom Slider - Only shown in wall mode */}\n{(supportsWallView || viewModes?.some(m =&gt; m.id === \"wall\")) &amp;&amp; viewMode === \"wall\" &amp;&amp; (\n  &lt;div\n    data-tv-search-item=\"zoom-level\"\n    ref={(el) =&gt; searchZoneNav.setItemRef(6, el)}\n    className={searchZoneNav.isFocused(6) ? \"keyboard-focus\" : \"\"}\n  &gt;\n    &lt;ZoomSlider value={zoomLevel} onChange={setZoomLevel} /&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 3: Verify existing tests still pass</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run SearchControls</code> Expected: Existing tests PASS (backward compatible)</p> <p>Step 4: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/components/ui/SearchControls.jsx\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: SearchControls accepts viewModes prop for custom modes\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-4-create-tagtreenode-component","title":"Task 4: Create TagTreeNode component","text":"<p>Files: - Create: <code>client/src/components/tags/TagTreeNode.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>// client/src/components/tags/TagTreeNode.jsx\nimport { forwardRef, useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { LucideChevronRight, LucideStar, LucideExternalLink } from \"lucide-react\";\n\n/**\n * Individual tree node for tag hierarchy view.\n * Displays a compact \"mini-card\" with expand/collapse, thumbnail, and counts.\n */\nconst TagTreeNode = forwardRef(\n  (\n    {\n      tag,\n      depth = 0,\n      isExpanded = false,\n      onToggle,\n      isAncestorOnly = false,\n      focusedId,\n      onFocus,\n    },\n    ref\n  ) =&gt; {\n    const navigate = useNavigate();\n    const hasChildren = tag.children &amp;&amp; tag.children.length &gt; 0;\n    const isFocused = focusedId === tag.id;\n\n    const handleClick = useCallback(\n      (e) =&gt; {\n        e.stopPropagation();\n        if (hasChildren) {\n          onToggle(tag.id);\n        }\n        onFocus?.(tag.id);\n      },\n      [hasChildren, onToggle, onFocus, tag.id]\n    );\n\n    const handleDoubleClick = useCallback(\n      (e) =&gt; {\n        e.stopPropagation();\n        navigate(`/tag/${tag.id}`, { state: { fromPageTitle: \"Tags\" } });\n      },\n      [navigate, tag.id]\n    );\n\n    const handleNavigateClick = useCallback(\n      (e) =&gt; {\n        e.stopPropagation();\n        navigate(`/tag/${tag.id}`, { state: { fromPageTitle: \"Tags\" } });\n      },\n      [navigate, tag.id]\n    );\n\n    const handleKeyDown = useCallback(\n      (e) =&gt; {\n        if (e.key === \"Enter\") {\n          e.preventDefault();\n          navigate(`/tag/${tag.id}`, { state: { fromPageTitle: \"Tags\" } });\n        }\n      },\n      [navigate, tag.id]\n    );\n\n    // Subtitle: child count or nothing\n    const subtitle =\n      tag.children?.length &gt; 0\n        ? `${tag.children.length} subtag${tag.children.length !== 1 ? \"s\" : \"\"}`\n        : null;\n\n    // Generate placeholder color from tag id\n    const placeholderHue = (parseInt(tag.id, 10) * 137.5) % 360;\n\n    return (\n      &lt;div&gt;\n        {/* Node row */}\n        &lt;div\n          ref={ref}\n          role=\"treeitem\"\n          aria-expanded={hasChildren ? isExpanded : undefined}\n          aria-selected={isFocused}\n          tabIndex={isFocused ? 0 : -1}\n          className={`\n            flex items-center gap-3 px-3 py-2 rounded-lg cursor-pointer\n            transition-colors group\n            ${isAncestorOnly ? \"opacity-50\" : \"\"}\n          `}\n          style={{\n            marginLeft: `${depth * 24}px`,\n            backgroundColor: isFocused\n              ? \"var(--bg-tertiary)\"\n              : \"transparent\",\n          }}\n          onClick={handleClick}\n          onDoubleClick={handleDoubleClick}\n          onKeyDown={handleKeyDown}\n        &gt;\n          {/* Expand/collapse chevron */}\n          &lt;div className=\"w-5 flex-shrink-0\"&gt;\n            {hasChildren &amp;&amp; (\n              &lt;LucideChevronRight\n                size={18}\n                className={`transition-transform ${isExpanded ? \"rotate-90\" : \"\"}`}\n                style={{ color: \"var(--text-muted)\" }}\n              /&gt;\n            )}\n          &lt;/div&gt;\n\n          {/* Thumbnail */}\n          &lt;div\n            className=\"w-10 h-10 rounded flex-shrink-0 overflow-hidden\"\n            style={{\n              backgroundColor: tag.image_path\n                ? \"var(--bg-tertiary)\"\n                : `hsl(${placeholderHue}, 40%, 30%)`,\n            }}\n          &gt;\n            {tag.image_path &amp;&amp; (\n              &lt;img\n                src={tag.image_path}\n                alt=\"\"\n                className=\"w-full h-full object-cover\"\n                loading=\"lazy\"\n              /&gt;\n            )}\n          &lt;/div&gt;\n\n          {/* Name and subtitle */}\n          &lt;div className=\"flex-1 min-w-0\"&gt;\n            &lt;div\n              className=\"font-medium truncate\"\n              style={{ color: \"var(--text-primary)\" }}\n            &gt;\n              {tag.name}\n            &lt;/div&gt;\n            {subtitle &amp;&amp; (\n              &lt;div\n                className=\"text-xs truncate\"\n                style={{ color: \"var(--text-muted)\" }}\n              &gt;\n                {subtitle}\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n\n          {/* Right side: counts, favorite, navigate */}\n          &lt;div className=\"flex items-center gap-2 flex-shrink-0\"&gt;\n            {/* Scene count badge */}\n            {tag.scene_count &gt; 0 &amp;&amp; (\n              &lt;span\n                className=\"text-xs px-2 py-0.5 rounded\"\n                style={{\n                  backgroundColor: \"var(--bg-tertiary)\",\n                  color: \"var(--text-muted)\",\n                }}\n              &gt;\n                {tag.scene_count} scenes\n              &lt;/span&gt;\n            )}\n\n            {/* Performer count badge */}\n            {tag.performer_count &gt; 0 &amp;&amp; (\n              &lt;span\n                className=\"text-xs px-2 py-0.5 rounded\"\n                style={{\n                  backgroundColor: \"var(--bg-tertiary)\",\n                  color: \"var(--text-muted)\",\n                }}\n              &gt;\n                {tag.performer_count} performers\n              &lt;/span&gt;\n            )}\n\n            {/* Favorite star */}\n            {tag.favorite &amp;&amp; (\n              &lt;LucideStar\n                size={16}\n                fill=\"var(--accent-primary)\"\n                style={{ color: \"var(--accent-primary)\" }}\n              /&gt;\n            )}\n\n            {/* Navigate button - visible on hover */}\n            &lt;button\n              type=\"button\"\n              onClick={handleNavigateClick}\n              className=\"p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n              title=\"Go to tag\"\n              aria-label={`Go to ${tag.name}`}\n            &gt;\n              &lt;LucideExternalLink\n                size={14}\n                style={{ color: \"var(--text-secondary)\" }}\n              /&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        {/* Children (recursive) */}\n        {hasChildren &amp;&amp; isExpanded &amp;&amp; (\n          &lt;div role=\"group\"&gt;\n            {tag.children.map((child) =&gt; (\n              &lt;TagTreeNode\n                key={`${tag.id}-${child.id}`}\n                tag={child}\n                depth={depth + 1}\n                isExpanded={false}\n                onToggle={onToggle}\n                isAncestorOnly={isAncestorOnly}\n                focusedId={focusedId}\n                onFocus={onFocus}\n              /&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    );\n  }\n);\n\nTagTreeNode.displayName = \"TagTreeNode\";\n\nexport default TagTreeNode;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/components/tags/TagTreeNode.jsx\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: add TagTreeNode component for hierarchy view\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-5-create-taghierarchyview-component","title":"Task 5: Create TagHierarchyView component","text":"<p>Files: - Create: <code>client/src/components/tags/TagHierarchyView.jsx</code> - Create: <code>client/src/components/tags/index.js</code></p> <p>Step 1: Create the main hierarchy view component</p> <pre><code>// client/src/components/tags/TagHierarchyView.jsx\nimport { useState, useMemo, useCallback, useEffect, useRef } from \"react\";\nimport { buildTagTree } from \"../../utils/buildTagTree.js\";\nimport TagTreeNode from \"./TagTreeNode.jsx\";\n\n/**\n * Hierarchy view for tags - displays tags as an expandable tree.\n */\nconst TagHierarchyView = ({ tags, isLoading, searchQuery }) =&gt; {\n  // Track which nodes are expanded (by tag id)\n  const [expandedIds, setExpandedIds] = useState(new Set());\n  // Track focused node for keyboard navigation\n  const [focusedId, setFocusedId] = useState(null);\n  const containerRef = useRef(null);\n\n  // Build tree structure from flat tags\n  const tree = useMemo(() =&gt; buildTagTree(tags), [tags]);\n\n  // Get all visible nodes (for keyboard nav)\n  const visibleNodes = useMemo(() =&gt; {\n    const nodes = [];\n    const traverse = (node, depth = 0) =&gt; {\n      nodes.push({ ...node, depth });\n      if (expandedIds.has(node.id) &amp;&amp; node.children) {\n        node.children.forEach((child) =&gt; traverse(child, depth + 1));\n      }\n    };\n    tree.forEach((root) =&gt; traverse(root));\n    return nodes;\n  }, [tree, expandedIds]);\n\n  // Initialize: expand first level\n  useEffect(() =&gt; {\n    if (tree.length &gt; 0 &amp;&amp; expandedIds.size === 0) {\n      const rootIds = new Set(tree.map((t) =&gt; t.id));\n      setExpandedIds(rootIds);\n    }\n  }, [tree, expandedIds.size]);\n\n  // Auto-expand to show search matches\n  useEffect(() =&gt; {\n    if (searchQuery &amp;&amp; tree.length &gt; 0) {\n      // Find all ancestor IDs that need to be expanded to show matches\n      const idsToExpand = new Set();\n      const findAncestors = (node, ancestors = []) =&gt; {\n        const matches =\n          node.name?.toLowerCase().includes(searchQuery.toLowerCase());\n        if (matches) {\n          ancestors.forEach((id) =&gt; idsToExpand.add(id));\n        }\n        if (node.children) {\n          node.children.forEach((child) =&gt;\n            findAncestors(child, [...ancestors, node.id])\n          );\n        }\n      };\n      tree.forEach((root) =&gt; findAncestors(root));\n      if (idsToExpand.size &gt; 0) {\n        setExpandedIds((prev) =&gt; new Set([...prev, ...idsToExpand]));\n      }\n    }\n  }, [searchQuery, tree]);\n\n  const handleToggle = useCallback((id) =&gt; {\n    setExpandedIds((prev) =&gt; {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleFocus = useCallback((id) =&gt; {\n    setFocusedId(id);\n  }, []);\n\n  // Keyboard navigation\n  const handleKeyDown = useCallback(\n    (e) =&gt; {\n      if (!focusedId || visibleNodes.length === 0) return;\n\n      const currentIndex = visibleNodes.findIndex((n) =&gt; n.id === focusedId);\n      if (currentIndex === -1) return;\n\n      const currentNode = visibleNodes[currentIndex];\n\n      switch (e.key) {\n        case \"ArrowDown\":\n          e.preventDefault();\n          if (currentIndex &lt; visibleNodes.length - 1) {\n            setFocusedId(visibleNodes[currentIndex + 1].id);\n          }\n          break;\n\n        case \"ArrowUp\":\n          e.preventDefault();\n          if (currentIndex &gt; 0) {\n            setFocusedId(visibleNodes[currentIndex - 1].id);\n          }\n          break;\n\n        case \"ArrowRight\":\n          e.preventDefault();\n          if (currentNode.children?.length &gt; 0) {\n            if (!expandedIds.has(currentNode.id)) {\n              handleToggle(currentNode.id);\n            } else if (currentIndex &lt; visibleNodes.length - 1) {\n              // Already expanded, move to first child\n              setFocusedId(visibleNodes[currentIndex + 1].id);\n            }\n          }\n          break;\n\n        case \"ArrowLeft\":\n          e.preventDefault();\n          if (expandedIds.has(currentNode.id)) {\n            handleToggle(currentNode.id);\n          } else {\n            // Find parent and focus it\n            const parentId = tags.find((t) =&gt; t.id === currentNode.id)?.parents?.[0]?.id;\n            if (parentId) {\n              setFocusedId(parentId);\n            }\n          }\n          break;\n\n        case \"Home\":\n          e.preventDefault();\n          setFocusedId(visibleNodes[0].id);\n          break;\n\n        case \"End\":\n          e.preventDefault();\n          setFocusedId(visibleNodes[visibleNodes.length - 1].id);\n          break;\n\n        default:\n          break;\n      }\n    },\n    [focusedId, visibleNodes, expandedIds, handleToggle, tags]\n  );\n\n  // Set initial focus\n  useEffect(() =&gt; {\n    if (visibleNodes.length &gt; 0 &amp;&amp; !focusedId) {\n      setFocusedId(visibleNodes[0].id);\n    }\n  }, [visibleNodes, focusedId]);\n\n  if (isLoading) {\n    return (\n      &lt;div className=\"space-y-2\"&gt;\n        {[...Array(8)].map((_, i) =&gt; (\n          &lt;div\n            key={i}\n            className=\"h-14 rounded-lg animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              marginLeft: `${(i % 3) * 24}px`,\n            }}\n          /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  if (tree.length === 0) {\n    return (\n      &lt;div\n        className=\"text-center py-12\"\n        style={{ color: \"var(--text-muted)\" }}\n      &gt;\n        No tags found\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div\n      ref={containerRef}\n      role=\"tree\"\n      aria-label=\"Tag hierarchy\"\n      onKeyDown={handleKeyDown}\n      className=\"space-y-1\"\n    &gt;\n      {tree.map((rootTag) =&gt; (\n        &lt;TagTreeNode\n          key={rootTag.id}\n          tag={rootTag}\n          depth={0}\n          isExpanded={expandedIds.has(rootTag.id)}\n          onToggle={handleToggle}\n          focusedId={focusedId}\n          onFocus={handleFocus}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default TagHierarchyView;\n</code></pre> <p>Step 2: Create index file</p> <pre><code>// client/src/components/tags/index.js\nexport { default as TagHierarchyView } from \"./TagHierarchyView.jsx\";\nexport { default as TagTreeNode } from \"./TagTreeNode.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/components/tags/\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: add TagHierarchyView component\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-6-update-tags-page-to-support-hierarchy-view","title":"Task 6: Update Tags page to support hierarchy view","text":"<p>Files: - Modify: <code>client/src/components/pages/Tags.jsx</code></p> <p>Step 1: Update Tags.jsx</p> <p>Replace the entire file with:</p> <pre><code>// client/src/components/pages/Tags.jsx\nimport { useCallback, useRef, useState } from \"react\";\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport { useInitialFocus } from \"../../hooks/useFocusTrap.js\";\nimport { useGridColumns } from \"../../hooks/useGridColumns.js\";\nimport { usePageTitle } from \"../../hooks/usePageTitle.js\";\nimport { useGridPageTVNavigation } from \"../../hooks/useGridPageTVNavigation.js\";\nimport { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport { TagCard } from \"../cards/index.js\";\nimport { TagHierarchyView } from \"../tags/index.js\";\nimport {\n  SyncProgressBanner,\n  ErrorMessage,\n  PageHeader,\n  PageLayout,\n  SearchControls,\n} from \"../ui/index.js\";\n\n// View modes for Tags page (no wall view - doesn't make sense for tags)\nconst TAG_VIEW_MODES = [\n  { id: \"grid\", label: \"Grid view\" },\n  { id: \"hierarchy\", label: \"Hierarchy view\" },\n];\n\nconst Tags = () =&gt; {\n  usePageTitle(\"Tags\");\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const pageRef = useRef(null);\n  const gridRef = useRef(null);\n  const columns = useGridColumns(\"tags\");\n\n  const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n\n  const handleQueryChange = useCallback(\n    (newQuery) =&gt; {\n      execute((signal) =&gt; getTags(newQuery, signal));\n    },\n    [execute]\n  );\n\n  const currentTags = data?.tags || [];\n  const totalCount = data?.count || 0;\n\n  // Track effective perPage from SearchControls state (fixes stale URL param bug)\n  const [effectivePerPage, setEffectivePerPage] = useState(\n    parseInt(searchParams.get(\"per_page\")) || 24\n  );\n  const totalPages = totalCount ? Math.ceil(totalCount / effectivePerPage) : 0;\n\n  // TV Navigation - use shared hook for all grid pages\n  const {\n    isTVMode,\n    _tvNavigation,\n    searchControlsProps,\n    gridItemProps,\n  } = useGridPageTVNavigation({\n    items: currentTags,\n    columns,\n    totalPages,\n    onItemSelect: (tag) =&gt;\n      navigate(`/tag/${tag.id}`, {\n        state: { fromPageTitle: \"Tags\" },\n      }),\n  });\n\n  // Initial focus\n  useInitialFocus(\n    pageRef,\n    '[tabindex=\"0\"]',\n    !isLoading &amp;&amp; currentTags.length &gt; 0 &amp;&amp; isTVMode\n  );\n\n  // Only show error page for non-initializing errors\n  if (error &amp;&amp; !initMessage) {\n    return (\n      &lt;PageLayout&gt;\n        &lt;PageHeader title=\"Tags\" /&gt;\n        &lt;ErrorMessage error={error} /&gt;\n      &lt;/PageLayout&gt;\n    );\n  }\n\n  return (\n    &lt;PageLayout&gt;\n      &lt;div ref={pageRef}&gt;\n        &lt;PageHeader title=\"Tags\" subtitle=\"Browse tags in your library\" /&gt;\n\n        {initMessage &amp;&amp; &lt;SyncProgressBanner message={initMessage} /&gt;}\n\n        {/* Controls Section */}\n        &lt;SearchControls\n          artifactType=\"tag\"\n          initialSort=\"scenes_count\"\n          onQueryChange={handleQueryChange}\n          onPerPageStateChange={setEffectivePerPage}\n          totalPages={totalPages}\n          totalCount={totalCount}\n          viewModes={TAG_VIEW_MODES}\n          {...searchControlsProps}\n        &gt;\n          {({ viewMode }) =&gt; {\n            // Hierarchy view\n            if (viewMode === \"hierarchy\") {\n              return (\n                &lt;TagHierarchyView\n                  tags={currentTags}\n                  isLoading={isLoading}\n                  searchQuery={searchParams.get(\"q\") || \"\"}\n                /&gt;\n              );\n            }\n\n            // Grid view (default)\n            if (isLoading) {\n              return (\n                &lt;div className={STANDARD_GRID_CONTAINER_CLASSNAMES}&gt;\n                  {[...Array(12)].map((_, i) =&gt; (\n                    &lt;div\n                      key={i}\n                      className=\"rounded-lg animate-pulse\"\n                      style={{\n                        backgroundColor: \"var(--bg-tertiary)\",\n                        height: \"18rem\",\n                      }}\n                    /&gt;\n                  ))}\n                &lt;/div&gt;\n              );\n            }\n\n            return (\n              &lt;div ref={gridRef} className={STANDARD_GRID_CONTAINER_CLASSNAMES}&gt;\n                {currentTags.map((tag, index) =&gt; {\n                  const itemProps = gridItemProps(index);\n                  return (\n                    &lt;TagCard\n                      key={tag.id}\n                      tag={tag}\n                      fromPageTitle=\"Tags\"\n                      tabIndex={isTVMode ? itemProps.tabIndex : -1}\n                      {...itemProps}\n                    /&gt;\n                  );\n                })}\n              &lt;/div&gt;\n            );\n          }}\n        &lt;/SearchControls&gt;\n      &lt;/div&gt;\n    &lt;/PageLayout&gt;\n  );\n};\n\nconst getTags = async (query, signal) =&gt; {\n  const response = await libraryApi.findTags(query, signal);\n\n  // Extract tags and count from server response structure\n  const findTags = response?.findTags;\n  const result = {\n    tags: findTags?.tags || [],\n    count: findTags?.count || 0,\n  };\n  return result;\n};\n\nexport default Tags;\n</code></pre> <p>Step 2: Verify the app runs</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; docker-compose -f docker-compose.yml -f docker-compose.windows.yml up</code></p> <p>Open http://localhost:3000/tags and verify: 1. Grid/Hierarchy toggle appears 2. Grid view works as before 3. Hierarchy view shows tags in tree structure 4. Clicking expands/collapses nodes 5. Double-click navigates to tag detail</p> <p>Step 3: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/components/pages/Tags.jsx\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: Tags page supports Grid and Hierarchy view modes\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-7-add-search-filtering-for-hierarchy-view","title":"Task 7: Add search filtering for hierarchy view","text":"<p>Files: - Modify: <code>client/src/utils/buildTagTree.js</code> - Modify: <code>client/tests/utils/buildTagTree.test.js</code></p> <p>Step 1: Add tests for filtering</p> <p>Add to the existing test file:</p> <pre><code>describe(\"buildTagTree with filter\", () =&gt; {\n  it(\"returns empty array when no matches\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Action\", parents: [], children: [] },\n    ];\n    const result = buildTagTree(tags, \"xyz\");\n    expect(result).toEqual([]);\n  });\n\n  it(\"returns matching tags and their ancestors\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Genre\", parents: [], children: [{ id: \"2\", name: \"Action\" }] },\n      { id: \"2\", name: \"Action\", parents: [{ id: \"1\", name: \"Genre\" }], children: [] },\n    ];\n    const result = buildTagTree(tags, \"action\");\n    expect(result).toHaveLength(1);\n    expect(result[0].id).toBe(\"1\"); // Genre (ancestor)\n    expect(result[0].isAncestorOnly).toBe(true);\n    expect(result[0].children[0].id).toBe(\"2\"); // Action (match)\n    expect(result[0].children[0].isAncestorOnly).toBeUndefined();\n  });\n\n  it(\"marks ancestors as isAncestorOnly\", () =&gt; {\n    const tags = [\n      { id: \"1\", name: \"Root\", parents: [], children: [{ id: \"2\", name: \"Middle\" }] },\n      { id: \"2\", name: \"Middle\", parents: [{ id: \"1\", name: \"Root\" }], children: [{ id: \"3\", name: \"Leaf\" }] },\n      { id: \"3\", name: \"Leaf\", parents: [{ id: \"2\", name: \"Middle\" }], children: [] },\n    ];\n    const result = buildTagTree(tags, \"leaf\");\n    expect(result[0].isAncestorOnly).toBe(true); // Root\n    expect(result[0].children[0].isAncestorOnly).toBe(true); // Middle\n    expect(result[0].children[0].children[0].isAncestorOnly).toBeUndefined(); // Leaf (match)\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run buildTagTree</code> Expected: FAIL - filter not implemented</p> <p>Step 3: Update implementation</p> <p>Update <code>buildTagTree.js</code>:</p> <pre><code>// client/src/utils/buildTagTree.js\n/**\n * Builds a tree structure from a flat array of tags with parent/child relationships.\n * Tags with multiple parents will appear under each parent (duplicated in tree).\n *\n * @param {Array} tags - Flat array of tag objects with `parents` and `children` arrays\n * @param {string} filterQuery - Optional search query to filter tags (shows matches + ancestors)\n * @returns {Array} Array of root tree nodes, each with nested `children` array\n */\nexport function buildTagTree(tags, filterQuery = \"\") {\n  if (!tags || tags.length === 0) {\n    return [];\n  }\n\n  // Create a map for quick lookup\n  const tagMap = new Map();\n  tags.forEach((tag) =&gt; {\n    tagMap.set(tag.id, { ...tag, children: [] });\n  });\n\n  // If filtering, determine which tags match and which are ancestors of matches\n  let matchingIds = new Set();\n  let ancestorIds = new Set();\n\n  if (filterQuery) {\n    const query = filterQuery.toLowerCase();\n\n    // Find all matching tags\n    tags.forEach((tag) =&gt; {\n      if (tag.name?.toLowerCase().includes(query)) {\n        matchingIds.add(tag.id);\n      }\n    });\n\n    // If no matches, return empty\n    if (matchingIds.size === 0) {\n      return [];\n    }\n\n    // Find all ancestors of matching tags\n    const findAncestors = (tagId, visited = new Set()) =&gt; {\n      if (visited.has(tagId)) return;\n      visited.add(tagId);\n\n      const tag = tags.find((t) =&gt; t.id === tagId);\n      if (tag?.parents) {\n        tag.parents.forEach((parent) =&gt; {\n          if (!matchingIds.has(parent.id)) {\n            ancestorIds.add(parent.id);\n          }\n          findAncestors(parent.id, visited);\n        });\n      }\n    };\n\n    matchingIds.forEach((id) =&gt; findAncestors(id));\n  }\n\n  // Build tree by nesting children under parents\n  const roots = [];\n\n  // Recursive function to build tree node with children\n  const buildNode = (tagId, visitedPath = new Set()) =&gt; {\n    // Prevent infinite loops from circular references\n    if (visitedPath.has(tagId)) return null;\n\n    const tag = tagMap.get(tagId);\n    if (!tag) return null;\n\n    // When filtering, skip tags that aren't matches or ancestors\n    if (filterQuery &amp;&amp; !matchingIds.has(tagId) &amp;&amp; !ancestorIds.has(tagId)) {\n      return null;\n    }\n\n    const node = {\n      ...tag,\n      children: [],\n      isAncestorOnly: filterQuery &amp;&amp; ancestorIds.has(tagId) ? true : undefined,\n    };\n\n    // Build children\n    const originalTag = tags.find((t) =&gt; t.id === tagId);\n    if (originalTag?.children) {\n      const newPath = new Set(visitedPath);\n      newPath.add(tagId);\n\n      node.children = originalTag.children\n        .map((childRef) =&gt; buildNode(childRef.id, newPath))\n        .filter(Boolean);\n    }\n\n    return node;\n  };\n\n  // Find root tags and build tree\n  tags.forEach((tag) =&gt; {\n    if (!tag.parents || tag.parents.length === 0) {\n      const node = buildNode(tag.id);\n      if (node) {\n        roots.push(node);\n      }\n    }\n  });\n\n  return roots;\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run buildTagTree</code> Expected: All tests PASS</p> <p>Step 5: Update TagHierarchyView to use filter</p> <p>In <code>TagHierarchyView.jsx</code>, update the useMemo:</p> <pre><code>// Build tree structure from flat tags, filtered by search query\nconst tree = useMemo(\n  () =&gt; buildTagTree(tags, searchQuery),\n  [tags, searchQuery]\n);\n</code></pre> <p>Step 6: Commit</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add client/src/utils/buildTagTree.js client/tests/utils/buildTagTree.test.js client/src/components/tags/TagHierarchyView.jsx\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"feat: hierarchy view filters to matches and shows ancestors dimmed\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-8-run-linting-and-fix-issues","title":"Task 8: Run linting and fix issues","text":"<p>Step 1: Run ESLint</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm run lint</code> Expected: No errors (or fix any that appear)</p> <p>Step 2: Run all tests</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm test -- --run</code> Expected: All tests PASS</p> <p>Step 3: Commit any fixes</p> <pre><code>git -C C:/Users/carrotwaxr/code/peek-stash-browser add -A\ngit -C C:/Users/carrotwaxr/code/peek-stash-browser commit -m \"chore: lint fixes\"\n</code></pre>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#task-9-manual-verification","title":"Task 9: Manual verification","text":"<p>Step 1: Start the app</p> <p>Run: <code>cd C:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; docker-compose -f docker-compose.yml -f docker-compose.windows.yml up</code></p> <p>Step 2: Verify functionality</p> <p>Open http://localhost:3000/tags and test:</p> <ol> <li>Grid/Hierarchy toggle visible - Two-button toggle in controls bar</li> <li>Grid view unchanged - Cards display as before</li> <li>Hierarchy view shows tree - Tags organized by parent/child</li> <li>First level expanded by default - Root tags show their children</li> <li>Click expands/collapses - Single click toggles node</li> <li>Double-click navigates - Goes to tag detail page</li> <li>Navigate button on hover - Arrow icon appears on hover</li> <li>Rich nodes - Thumbnail, name, child count, scene count, favorite star</li> <li>Keyboard navigation - Arrow keys move focus, Enter navigates</li> <li>Search filters tree - Only matching tags + ancestors shown</li> <li>Ancestors dimmed - Non-matching ancestors have reduced opacity</li> <li>Multi-parent tags - Appear under each parent</li> </ol> <p>Step 3: Document any issues found</p> <p>If issues are found, create additional commits to fix them.</p>"},{"location":"plans/2025-01-12-tag-hierarchy-view-implementation/#summary","title":"Summary","text":"<p>This plan implements Tag Hierarchy View in 9 tasks:</p> <ol> <li>buildTagTree utility - Core tree-building logic with tests</li> <li>ViewModeToggle update - Support custom modes</li> <li>SearchControls update - Accept viewModes prop</li> <li>TagTreeNode - Individual tree node component</li> <li>TagHierarchyView - Main hierarchy container</li> <li>Tags page update - Wire up Grid/Hierarchy toggle</li> <li>Search filtering - Filter tree to matches + ancestors</li> <li>Lint and test - Ensure code quality</li> <li>Manual verification - Test all functionality</li> </ol>"},{"location":"plans/2025-01-12-wall-view-design/","title":"Wall View Design","text":"<p>Date: 2025-01-12 Status: Ready for implementation Branch: <code>feature/view-mode-options</code></p>"},{"location":"plans/2025-01-12-wall-view-design/#overview","title":"Overview","text":"<p>A justified gallery \"Wall\" view mode for Scenes, Galleries, and Images that mirrors Stash's SceneWallPanel behavior - preserving aspect ratios with minimal letterboxing, with all visible previews playing simultaneously.</p>"},{"location":"plans/2025-01-12-wall-view-design/#scope","title":"Scope","text":"<p>Entity types: Scenes, Galleries, Images (not Performers, Studios, Tags, Groups)</p> <p>Locations: All search pages AND all detail page tabs where these entities appear with SearchControls:</p> <ul> <li>Scene Search (<code>/scenes</code>)</li> <li>Gallery Search (<code>/galleries</code>)</li> <li>Image Search (<code>/images</code>)</li> <li>Performer detail \u2192 Scenes, Galleries, Images tabs</li> <li>Studio detail \u2192 Scenes, Galleries tabs</li> <li>Tag detail \u2192 Scenes, Galleries, Images tabs</li> <li>Group detail \u2192 Scenes tab</li> <li>Gallery detail \u2192 Images tab</li> </ul> <p>View modes: Grid (current cards) and Wall (new)</p>"},{"location":"plans/2025-01-12-wall-view-design/#key-behaviors","title":"Key Behaviors","text":"<ul> <li>Justified layout using <code>react-photo-gallery</code> or <code>react-photo-album</code></li> <li>3 zoom levels: small / medium / large (controls target row height)</li> <li>Wall-specific playback setting: autoplay all / hover only / static (global setting)</li> <li>Hover overlay: title + key metadata with gradient, 500ms fade-in delay</li> <li>View preference synced to URL and saved in filter presets</li> <li>Grid remains the default; users can set a default preset with wall view</li> </ul>"},{"location":"plans/2025-01-12-wall-view-design/#component-architecture","title":"Component Architecture","text":""},{"location":"plans/2025-01-12-wall-view-design/#new-components","title":"New Components","text":"Component Purpose <code>client/src/components/wall/WallView.jsx</code> Justified gallery container using react-photo-gallery <code>client/src/components/wall/WallItem.jsx</code> Individual item with hover overlay, preview playback <code>client/src/components/wall/wallConfig.js</code> Entity-specific configuration (scene/gallery/image) <code>client/src/components/ui/ViewModeToggle.jsx</code> Grid/Wall icon button group <code>client/src/components/ui/ZoomSlider.jsx</code> S/M/L zoom control"},{"location":"plans/2025-01-12-wall-view-design/#modified-components","title":"Modified Components","text":"Component Changes <code>SearchControls.jsx</code> Add ViewModeToggle, ZoomSlider, pass view/zoom state <code>useFilterState.js</code> Parse/sync <code>view</code> and <code>zoom</code> URL params <code>FilterPresets.jsx</code> Save/load view and zoom in presets <code>SceneSearch.jsx</code> Conditional render WallView or grid <code>GallerySearch.jsx</code> Conditional render WallView or grid <code>ImageSearch.jsx</code> Conditional render WallView or grid Detail page tab components Conditional render WallView or grid <code>Settings.jsx</code> Add wallPlayback setting <code>prisma/schema.prisma</code> Add wallPlayback to user preferences (if stored server-side)"},{"location":"plans/2025-01-12-wall-view-design/#shared-logic-dry","title":"Shared Logic (DRY)","text":"<p>WallView accepts a generic <code>items</code> array and <code>entityType</code> prop. Entity-specific rendering is configured via wallConfig:</p> <pre><code>const wallConfig = {\n  scene: {\n    getImageUrl: (item) =&gt; item.paths?.screenshot,\n    getPreviewUrl: (item) =&gt; item.paths?.preview,\n    getAspectRatio: (item) =&gt; {\n      const file = item.files?.[0];\n      return file ? file.width / file.height : 16/9;\n    },\n    getTitle: (item) =&gt; item.title || \"Untitled\",\n    getSubtitle: (item) =&gt; [item.studio?.name, formatDate(item.date)].filter(Boolean).join(\" \u2022 \"),\n    getLinkPath: (item) =&gt; `/scenes/${item.id}`,\n  },\n\n  gallery: {\n    getImageUrl: (item) =&gt; item.cover?.paths?.thumbnail,\n    getPreviewUrl: () =&gt; null,\n    getAspectRatio: (item) =&gt; {\n      const cover = item.cover;\n      return cover ? cover.width / cover.height : 4/3;\n    },\n    getTitle: (item) =&gt; item.title || \"Untitled Gallery\",\n    getSubtitle: (item) =&gt; `${item.image_count} images`,\n    getLinkPath: (item) =&gt; `/galleries/${item.id}`,\n  },\n\n  image: {\n    getImageUrl: (item) =&gt; item.paths?.thumbnail,\n    getPreviewUrl: () =&gt; null,\n    getAspectRatio: (item) =&gt; item.width &amp;&amp; item.height ? item.width / item.height : 1,\n    getTitle: (item) =&gt; item.title || item.files?.[0]?.basename || \"Untitled\",\n    getSubtitle: (item) =&gt; formatResolution(item.width, item.height),\n    getLinkPath: (item) =&gt; `/images/${item.id}`,\n  },\n}\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-design/#state-url-sync","title":"State &amp; URL Sync","text":""},{"location":"plans/2025-01-12-wall-view-design/#url-parameters","title":"URL Parameters","text":"Param Values Default <code>view</code> <code>\"grid\"</code> | <code>\"wall\"</code> <code>\"grid\"</code> <code>zoom</code> <code>\"small\"</code> | <code>\"medium\"</code> | <code>\"large\"</code> <code>\"medium\"</code> <p>Example: <code>/scenes?sort=o_counter&amp;view=wall&amp;zoom=large</code></p>"},{"location":"plans/2025-01-12-wall-view-design/#preset-integration","title":"Preset Integration","text":"<p>Filter presets already save <code>sort</code>, <code>direction</code>, and <code>filters</code>. Extend to also save <code>view</code> and <code>zoom</code>. When a preset is loaded, it applies the saved view mode and zoom along with filters/sort.</p>"},{"location":"plans/2025-01-12-wall-view-design/#global-settings-not-url-synced","title":"Global Settings (not URL-synced)","text":"Setting Values Default <code>wallPlayback</code> <code>\"autoplay\"</code> | <code>\"hover\"</code> | <code>\"static\"</code> <code>\"autoplay\"</code> <p>This lives in Settings \u2192 Display since it's about device capability, not search context.</p>"},{"location":"plans/2025-01-12-wall-view-design/#layout-styling","title":"Layout &amp; Styling","text":""},{"location":"plans/2025-01-12-wall-view-design/#target-row-heights-by-zoom","title":"Target Row Heights by Zoom","text":"Zoom Target Height Approx items/row (1920px) small 150px 6-8 items medium 220px 4-5 items large 320px 2-3 items"},{"location":"plans/2025-01-12-wall-view-design/#aspect-ratio-sources","title":"Aspect Ratio Sources","text":"<ul> <li>Scenes: video file dimensions (<code>file.width</code>/<code>file.height</code>)</li> <li>Galleries: cover image dimensions</li> <li>Images: image dimensions</li> </ul>"},{"location":"plans/2025-01-12-wall-view-design/#hover-overlay","title":"Hover Overlay","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                 \u2502\n\u2502         [video/image]           \u2502\n\u2502                                 \u2502\n\u2502  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2502  \u2190 gradient (transparent \u2192 30% black)\n\u2502  Title of Scene                 \u2502\n\u2502  Studio Name \u2022 Jan 15, 2024     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Gradient: 100px height from bottom</li> <li>Text: appears on hover after 500ms delay</li> <li>Padding: 1rem horizontal, 20px from bottom</li> <li>Title: primary text color, single line truncate</li> <li>Subtitle: secondary/muted text color</li> <li>Gap between items: 2-4px</li> </ul>"},{"location":"plans/2025-01-12-wall-view-design/#preview-playback","title":"Preview Playback","text":""},{"location":"plans/2025-01-12-wall-view-design/#playback-modes","title":"Playback Modes","text":"Mode Behavior <code>autoplay</code> All visible videos play via Intersection Observer. Hover controls sound. <code>hover</code> Static thumbnail until hover, then video plays. <code>static</code> Thumbnail only, no video playback."},{"location":"plans/2025-01-12-wall-view-design/#implementation","title":"Implementation","text":"<ul> <li>Intersection Observer triggers play/pause based on viewport visibility</li> <li>Reuse existing preview quality logic (sprite/webp/mp4 fallback chain)</li> <li>Sound: muted by default, 5% volume on hover if <code>soundOnPreview</code> enabled</li> <li>Performance: limit simultaneous video elements to visible viewport + buffer</li> </ul>"},{"location":"plans/2025-01-12-wall-view-design/#ui-integration","title":"UI Integration","text":""},{"location":"plans/2025-01-12-wall-view-design/#toolbar-layout","title":"Toolbar Layout","text":"<pre><code>[ Search input ] [ Sort \u25bc ] [\u2191\u2193] [ Filters ] [ Presets \u25bc ] [ \u229e \u25a3 ] [ S M L ]\n                                                            \u2191        \u2191\n                                                     ViewModeToggle  ZoomSlider\n                                                                    (wall only)\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-design/#viewmodetoggle","title":"ViewModeToggle","text":"<p>Two icon buttons in a button group: - Grid icon (grid-2x2 style) - Wall icon (solid square style)</p> <p>Active state uses primary color, inactive uses secondary.</p>"},{"location":"plans/2025-01-12-wall-view-design/#zoomslider","title":"ZoomSlider","text":"<p>Simple 3-position segmented control: S / M / L. Only visible when view mode is <code>wall</code>.</p>"},{"location":"plans/2025-01-12-wall-view-design/#mobile","title":"Mobile","text":"<p>View mode toggle wraps with other controls on narrow screens.</p>"},{"location":"plans/2025-01-12-wall-view-design/#new-dependency","title":"New Dependency","text":"<p><code>react-photo-gallery</code> or <code>react-photo-album</code> (newer maintained fork) for justified layout algorithm.</p>"},{"location":"plans/2025-01-12-wall-view-design/#related-documents","title":"Related Documents","text":"<ul> <li>View Mode Options Brainstorm - Original ideation document with additional view modes for future consideration</li> </ul>"},{"location":"plans/2025-01-12-wall-view-implementation/","title":"Wall View Implementation Plan","text":"<p>Status: \u2705 COMPLETE - PR #281 created 2026-01-12</p> <p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a justified gallery \"Wall\" view mode for Scenes, Galleries, and Images that mirrors Stash's SceneWallPanel behavior.</p> <p>Architecture: New WallView component using react-photo-album for justified layout. View mode (grid/wall) and zoom level synced to URL and saved in filter presets. Entity-specific rendering via wallConfig. Global wallPlayback setting in user preferences.</p> <p>Tech Stack: React, react-photo-album, Tailwind CSS, Prisma (SQLite), Express</p>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-1-add-react-photo-album-dependency","title":"Task 1: Add react-photo-album dependency","text":"<p>Files: - Modify: <code>client/package.json</code></p> <p>Step 1: Install dependency</p> <p>Run: <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm install react-photo-album\n</code></pre></p> <p>Expected: Package added to dependencies</p> <p>Step 2: Verify installation</p> <p>Run: <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm ls react-photo-album\n</code></pre></p> <p>Expected: Shows react-photo-album version</p> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/package.json client/package-lock.json &amp;&amp; git commit -m \"chore: add react-photo-album dependency for wall view\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-2-add-wallplayback-field-to-prisma-schema","title":"Task 2: Add wallPlayback field to Prisma schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma:19-28</code></p> <p>Step 1: Add wallPlayback field to User model</p> <p>Add after line 21 (<code>preferredPreviewQuality</code>):</p> <pre><code>  wallPlayback            String? @default(\"autoplay\") // \"autoplay\", \"hover\", \"static\" - Wall view preview behavior\n</code></pre> <p>Step 2: Create migration</p> <p>Run: <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/server &amp;&amp; npx prisma migrate dev --name add_wall_playback\n</code></pre></p> <p>Expected: Migration created and applied</p> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add server/prisma/ &amp;&amp; git commit -m \"feat: add wallPlayback user preference field\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-3-add-wallplayback-to-settings-api","title":"Task 3: Add wallPlayback to settings API","text":"<p>Files: - Modify: <code>server/routes/user.js</code> (find GET/PUT /settings endpoints)</p> <p>Step 1: Find the settings endpoints</p> <p>Run: <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; grep -n \"settings\" server/routes/user.js | head -20\n</code></pre></p> <p>Step 2: Add wallPlayback to GET /settings response</p> <p>In the GET /settings handler, add <code>wallPlayback</code> to the returned settings object:</p> <pre><code>wallPlayback: user.wallPlayback || \"autoplay\",\n</code></pre> <p>Step 3: Add wallPlayback to PUT /settings handler</p> <p>In the PUT /settings handler, add <code>wallPlayback</code> to the update object:</p> <pre><code>wallPlayback: body.wallPlayback,\n</code></pre> <p>Step 4: Test the endpoint</p> <p>Run the server and verify the setting is returned and can be updated.</p> <p>Step 5: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add server/routes/user.js &amp;&amp; git commit -m \"feat: add wallPlayback to user settings API\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-4-add-wallplayback-setting-to-playbacktab-ui","title":"Task 4: Add wallPlayback setting to PlaybackTab UI","text":"<p>Files: - Modify: <code>client/src/components/settings/tabs/PlaybackTab.jsx</code></p> <p>Step 1: Add state for wallPlayback</p> <p>After line 17 (<code>const [minimumPlayPercent, setMinimumPlayPercent] = useState(20);</code>), add:</p> <pre><code>const [wallPlayback, setWallPlayback] = useState(\"autoplay\");\n</code></pre> <p>Step 2: Load wallPlayback in useEffect</p> <p>In the loadSettings function, after line 32, add:</p> <pre><code>setWallPlayback(settings.wallPlayback || \"autoplay\");\n</code></pre> <p>Step 3: Add wallPlayback to saveSettings</p> <p>In the api.put call (line 48-54), add <code>wallPlayback</code> to the request body:</p> <pre><code>await api.put(\"/user/settings\", {\n  preferredQuality,\n  preferredPlaybackMode,\n  preferredPreviewQuality,\n  enableCast,\n  minimumPlayPercent,\n  wallPlayback,\n});\n</code></pre> <p>Step 4: Add UI control for wallPlayback</p> <p>After the \"Preferred Preview Quality\" section (after line 145), add:</p> <pre><code>{/* Wall View Playback */}\n&lt;div&gt;\n  &lt;label\n    htmlFor=\"wallPlayback\"\n    className=\"block text-sm font-medium mb-2\"\n    style={{ color: \"var(--text-secondary)\" }}\n  &gt;\n    Wall View Playback\n  &lt;/label&gt;\n  &lt;select\n    id=\"wallPlayback\"\n    value={wallPlayback}\n    onChange={(e) =&gt; setWallPlayback(e.target.value)}\n    className=\"w-full px-4 py-2 rounded-lg\"\n    style={{\n      backgroundColor: \"var(--bg-secondary)\",\n      border: \"1px solid var(--border-color)\",\n      color: \"var(--text-primary)\",\n    }}\n  &gt;\n    &lt;option value=\"autoplay\"&gt;Autoplay All (Default)&lt;/option&gt;\n    &lt;option value=\"hover\"&gt;Play on Hover&lt;/option&gt;\n    &lt;option value=\"static\"&gt;Static Thumbnails&lt;/option&gt;\n  &lt;/select&gt;\n  &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n    How scene previews behave in Wall view. Autoplay plays all visible\n    previews simultaneously. Hover plays on mouse over. Static shows\n    thumbnails only.\n  &lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 5: Test in browser</p> <p>Navigate to Settings \u2192 Playback and verify the new setting appears and saves.</p> <p>Step 6: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/settings/tabs/PlaybackTab.jsx &amp;&amp; git commit -m \"feat: add wallPlayback setting to PlaybackTab UI\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-5-create-wallconfigjs","title":"Task 5: Create wallConfig.js","text":"<p>Files: - Create: <code>client/src/components/wall/wallConfig.js</code></p> <p>Step 1: Create the wall directory</p> <p>Run: <pre><code>mkdir -p c:/Users/carrotwaxr/code/peek-stash-browser/client/src/components/wall\n</code></pre></p> <p>Step 2: Create wallConfig.js</p> <pre><code>/**\n * Entity-specific configuration for WallView rendering.\n * Keeps WallView and WallItem entity-agnostic.\n */\n\nimport { formatDistanceToNow } from \"date-fns\";\n\nconst formatDate = (dateStr) =&gt; {\n  if (!dateStr) return null;\n  try {\n    return formatDistanceToNow(new Date(dateStr), { addSuffix: true });\n  } catch {\n    return dateStr;\n  }\n};\n\nconst formatResolution = (width, height) =&gt; {\n  if (!width || !height) return null;\n  return `${width}\u00d7${height}`;\n};\n\nexport const wallConfig = {\n  scene: {\n    getImageUrl: (item) =&gt; item.paths?.screenshot,\n    getPreviewUrl: (item) =&gt; item.paths?.preview,\n    getAspectRatio: (item) =&gt; {\n      const file = item.files?.[0];\n      if (file?.width &amp;&amp; file?.height) {\n        return file.width / file.height;\n      }\n      return 16 / 9; // Default for scenes\n    },\n    getTitle: (item) =&gt; item.title || \"Untitled\",\n    getSubtitle: (item) =&gt; {\n      const parts = [];\n      if (item.studio?.name) parts.push(item.studio.name);\n      if (item.date) parts.push(formatDate(item.date));\n      return parts.join(\" \u2022 \");\n    },\n    getLinkPath: (item) =&gt; `/scene/${item.id}`,\n    hasPreview: true,\n  },\n\n  gallery: {\n    getImageUrl: (item) =&gt; item.cover?.paths?.thumbnail,\n    getPreviewUrl: () =&gt; null,\n    getAspectRatio: (item) =&gt; {\n      const cover = item.cover;\n      if (cover?.width &amp;&amp; cover?.height) {\n        return cover.width / cover.height;\n      }\n      return 4 / 3; // Default for galleries\n    },\n    getTitle: (item) =&gt; item.title || \"Untitled Gallery\",\n    getSubtitle: (item) =&gt; `${item.image_count || 0} images`,\n    getLinkPath: (item) =&gt; `/gallery/${item.id}`,\n    hasPreview: false,\n  },\n\n  image: {\n    getImageUrl: (item) =&gt; item.paths?.thumbnail,\n    getPreviewUrl: () =&gt; null,\n    getAspectRatio: (item) =&gt; {\n      if (item.width &amp;&amp; item.height) {\n        return item.width / item.height;\n      }\n      return 1; // Default square for images\n    },\n    getTitle: (item) =&gt; item.title || item.files?.[0]?.basename || \"Untitled\",\n    getSubtitle: (item) =&gt; formatResolution(item.width, item.height),\n    getLinkPath: (item) =&gt; `/image/${item.id}`,\n    hasPreview: false,\n  },\n};\n\n// Zoom level configurations\nexport const ZOOM_LEVELS = {\n  small: { targetRowHeight: 150, label: \"S\" },\n  medium: { targetRowHeight: 220, label: \"M\" },\n  large: { targetRowHeight: 320, label: \"L\" },\n};\n\nexport const DEFAULT_ZOOM = \"medium\";\nexport const DEFAULT_VIEW_MODE = \"grid\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/wall/wallConfig.js &amp;&amp; git commit -m \"feat: add wallConfig with entity-specific configuration\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-6-create-wallitemjsx","title":"Task 6: Create WallItem.jsx","text":"<p>Files: - Create: <code>client/src/components/wall/WallItem.jsx</code></p> <p>Step 1: Create WallItem component</p> <pre><code>import { useEffect, useRef, useState } from \"react\";\nimport { Link } from \"react-router-dom\";\n\n/**\n * Individual item in the WallView with hover overlay and optional video preview.\n */\nconst WallItem = ({\n  item,\n  config,\n  width,\n  height,\n  playbackMode = \"autoplay\", // \"autoplay\" | \"hover\" | \"static\"\n  onClick,\n}) =&gt; {\n  const containerRef = useRef(null);\n  const videoRef = useRef(null);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isInView, setIsInView] = useState(false);\n  const [showOverlay, setShowOverlay] = useState(false);\n  const overlayTimeoutRef = useRef(null);\n\n  const imageUrl = config.getImageUrl(item);\n  const previewUrl = config.getPreviewUrl(item);\n  const title = config.getTitle(item);\n  const subtitle = config.getSubtitle(item);\n  const linkPath = config.getLinkPath(item);\n  const hasPreview = config.hasPreview &amp;&amp; previewUrl;\n\n  // Intersection Observer for autoplay mode\n  useEffect(() =&gt; {\n    if (playbackMode !== \"autoplay\" || !hasPreview) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) =&gt; {\n        setIsInView(entry.isIntersecting);\n      },\n      { threshold: 0.5 }\n    );\n\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    return () =&gt; observer.disconnect();\n  }, [playbackMode, hasPreview]);\n\n  // Video playback control\n  useEffect(() =&gt; {\n    if (!videoRef.current || !hasPreview) return;\n\n    const shouldPlay =\n      playbackMode === \"autoplay\"\n        ? isInView\n        : playbackMode === \"hover\"\n          ? isHovering\n          : false;\n\n    if (shouldPlay) {\n      videoRef.current.play().catch(() =&gt; {});\n    } else {\n      videoRef.current.pause();\n    }\n  }, [playbackMode, isInView, isHovering, hasPreview]);\n\n  // Overlay show delay (500ms)\n  useEffect(() =&gt; {\n    if (isHovering) {\n      overlayTimeoutRef.current = setTimeout(() =&gt; {\n        setShowOverlay(true);\n      }, 500);\n    } else {\n      if (overlayTimeoutRef.current) {\n        clearTimeout(overlayTimeoutRef.current);\n      }\n      setShowOverlay(false);\n    }\n\n    return () =&gt; {\n      if (overlayTimeoutRef.current) {\n        clearTimeout(overlayTimeoutRef.current);\n      }\n    };\n  }, [isHovering]);\n\n  const handleClick = (e) =&gt; {\n    if (onClick) {\n      e.preventDefault();\n      onClick(item);\n    }\n  };\n\n  return (\n    &lt;Link\n      ref={containerRef}\n      to={linkPath}\n      onClick={handleClick}\n      className=\"wall-item relative block overflow-hidden\"\n      style={{ width, height }}\n      onMouseEnter={() =&gt; setIsHovering(true)}\n      onMouseLeave={() =&gt; setIsHovering(false)}\n    &gt;\n      {/* Background image */}\n      {imageUrl &amp;&amp; (\n        &lt;img\n          src={imageUrl}\n          alt={title}\n          className=\"absolute inset-0 w-full h-full object-cover\"\n          loading=\"lazy\"\n        /&gt;\n      )}\n\n      {/* Video preview (for scenes) */}\n      {hasPreview &amp;&amp; playbackMode !== \"static\" &amp;&amp; (\n        &lt;video\n          ref={videoRef}\n          src={previewUrl}\n          className=\"absolute inset-0 w-full h-full object-cover\"\n          muted\n          loop\n          playsInline\n          preload=\"none\"\n        /&gt;\n      )}\n\n      {/* Gradient overlay */}\n      &lt;div\n        className=\"absolute bottom-0 left-0 right-0 pointer-events-none transition-opacity duration-300\"\n        style={{\n          height: \"100px\",\n          background: \"linear-gradient(transparent, rgba(0, 0, 0, 0.7))\",\n          opacity: showOverlay ? 1 : 0,\n        }}\n      /&gt;\n\n      {/* Text overlay */}\n      &lt;div\n        className=\"absolute bottom-0 left-0 right-0 p-4 transition-opacity duration-300\"\n        style={{ opacity: showOverlay ? 1 : 0 }}\n      &gt;\n        &lt;h3\n          className=\"text-sm font-medium truncate\"\n          style={{ color: \"white\" }}\n        &gt;\n          {title}\n        &lt;/h3&gt;\n        {subtitle &amp;&amp; (\n          &lt;p\n            className=\"text-xs truncate mt-0.5\"\n            style={{ color: \"rgba(255, 255, 255, 0.7)\" }}\n          &gt;\n            {subtitle}\n          &lt;/p&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/Link&gt;\n  );\n};\n\nexport default WallItem;\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/wall/WallItem.jsx &amp;&amp; git commit -m \"feat: add WallItem component with hover overlay and video preview\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-7-create-wallviewjsx","title":"Task 7: Create WallView.jsx","text":"<p>Files: - Create: <code>client/src/components/wall/WallView.jsx</code></p> <p>Step 1: Create WallView component</p> <pre><code>import { useMemo } from \"react\";\nimport { RowsPhotoAlbum } from \"react-photo-album\";\nimport \"react-photo-album/rows.css\";\nimport WallItem from \"./WallItem.jsx\";\nimport { wallConfig, ZOOM_LEVELS, DEFAULT_ZOOM } from \"./wallConfig.js\";\n\n/**\n * Justified gallery view using react-photo-album.\n * Renders items in rows with preserved aspect ratios.\n */\nconst WallView = ({\n  items = [],\n  entityType = \"scene\",\n  zoomLevel = DEFAULT_ZOOM,\n  playbackMode = \"autoplay\",\n  onItemClick,\n  loading = false,\n  emptyMessage = \"No items found\",\n}) =&gt; {\n  const config = wallConfig[entityType];\n  const { targetRowHeight } = ZOOM_LEVELS[zoomLevel] || ZOOM_LEVELS[DEFAULT_ZOOM];\n\n  // Transform items to photo album format\n  const photos = useMemo(() =&gt; {\n    if (!items || !config) return [];\n\n    return items.map((item) =&gt; {\n      const aspectRatio = config.getAspectRatio(item);\n      // react-photo-album needs width/height, we use aspect ratio to derive them\n      const baseHeight = targetRowHeight;\n      const baseWidth = baseHeight * aspectRatio;\n\n      return {\n        src: config.getImageUrl(item) || \"\",\n        width: baseWidth,\n        height: baseHeight,\n        key: item.id,\n        // Pass original item for rendering\n        _item: item,\n      };\n    });\n  }, [items, config, targetRowHeight]);\n\n  if (loading) {\n    return (\n      &lt;div className=\"flex items-center justify-center py-16\"&gt;\n        &lt;div\n          className=\"animate-spin rounded-full h-8 w-8 border-b-2\"\n          style={{ borderColor: \"var(--accent-primary)\" }}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  if (!items || items.length === 0) {\n    return (\n      &lt;div className=\"flex items-center justify-center py-16\"&gt;\n        &lt;div className=\"text-center\"&gt;\n          &lt;div className=\"text-6xl mb-4\" style={{ color: \"var(--text-muted)\" }}&gt;\n            {entityType === \"scene\" ? \"\ud83c\udfac\" : entityType === \"gallery\" ? \"\ud83d\uddbc\ufe0f\" : \"\ud83d\udcf7\"}\n          &lt;/div&gt;\n          &lt;h3\n            className=\"text-xl font-medium mb-2\"\n            style={{ color: \"var(--text-primary)\" }}\n          &gt;\n            {emptyMessage}\n          &lt;/h3&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"wall-view\"&gt;\n      &lt;RowsPhotoAlbum\n        photos={photos}\n        targetRowHeight={targetRowHeight}\n        rowConstraints={{ maxPhotos: 8 }}\n        spacing={4}\n        render={{\n          photo: ({ photo, width, height }) =&gt; (\n            &lt;WallItem\n              key={photo.key}\n              item={photo._item}\n              config={config}\n              width={width}\n              height={height}\n              playbackMode={playbackMode}\n              onClick={onItemClick}\n            /&gt;\n          ),\n        }}\n      /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default WallView;\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/wall/WallView.jsx &amp;&amp; git commit -m \"feat: add WallView component with justified layout\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-8-create-viewmodetogglejsx","title":"Task 8: Create ViewModeToggle.jsx","text":"<p>Files: - Create: <code>client/src/components/ui/ViewModeToggle.jsx</code></p> <p>Step 1: Create ViewModeToggle component</p> <pre><code>import { LucideGrid2X2, LucideSquare } from \"lucide-react\";\n\n/**\n * Toggle between Grid and Wall view modes.\n */\nconst ViewModeToggle = ({ value = \"grid\", onChange, className = \"\" }) =&gt; {\n  const modes = [\n    { id: \"grid\", icon: LucideGrid2X2, label: \"Grid view\" },\n    { id: \"wall\", icon: LucideSquare, label: \"Wall view\" },\n  ];\n\n  return (\n    &lt;div\n      className={`inline-flex rounded-lg overflow-hidden ${className}`}\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {modes.map(({ id, icon: Icon, label }) =&gt; (\n        &lt;button\n          key={id}\n          type=\"button\"\n          onClick={() =&gt; onChange(id)}\n          className=\"px-3 py-1.5 transition-colors\"\n          style={{\n            backgroundColor: value === id ? \"var(--accent-primary)\" : \"transparent\",\n            color: value === id ? \"white\" : \"var(--text-secondary)\",\n          }}\n          title={label}\n          aria-label={label}\n          aria-pressed={value === id}\n        &gt;\n          &lt;Icon size={18} /&gt;\n        &lt;/button&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default ViewModeToggle;\n</code></pre> <p>Step 2: Export from ui index</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { default as ViewModeToggle } from \"./ViewModeToggle.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/ViewModeToggle.jsx client/src/components/ui/index.js &amp;&amp; git commit -m \"feat: add ViewModeToggle component\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-9-create-zoomsliderjsx","title":"Task 9: Create ZoomSlider.jsx","text":"<p>Files: - Create: <code>client/src/components/ui/ZoomSlider.jsx</code></p> <p>Step 1: Create ZoomSlider component</p> <pre><code>import { ZOOM_LEVELS } from \"../wall/wallConfig.js\";\n\n/**\n * 3-level zoom control for Wall view (S/M/L).\n */\nconst ZoomSlider = ({ value = \"medium\", onChange, className = \"\" }) =&gt; {\n  const levels = Object.entries(ZOOM_LEVELS);\n\n  return (\n    &lt;div\n      className={`inline-flex rounded-lg overflow-hidden ${className}`}\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {levels.map(([id, { label }]) =&gt; (\n        &lt;button\n          key={id}\n          type=\"button\"\n          onClick={() =&gt; onChange(id)}\n          className=\"px-2.5 py-1.5 text-xs font-medium transition-colors min-w-[28px]\"\n          style={{\n            backgroundColor: value === id ? \"var(--accent-primary)\" : \"transparent\",\n            color: value === id ? \"white\" : \"var(--text-secondary)\",\n          }}\n          title={`${label} size`}\n          aria-label={`${label} size`}\n          aria-pressed={value === id}\n        &gt;\n          {label}\n        &lt;/button&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default ZoomSlider;\n</code></pre> <p>Step 2: Export from ui index</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { default as ZoomSlider } from \"./ZoomSlider.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/ZoomSlider.jsx client/src/components/ui/index.js &amp;&amp; git commit -m \"feat: add ZoomSlider component\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-10-add-viewzoom-to-url-params-utility","title":"Task 10: Add view/zoom to URL params utility","text":"<p>Files: - Modify: <code>client/src/utils/urlParams.js</code></p> <p>Step 1: Add view and zoom to buildSearchParams</p> <p>In the <code>buildSearchParams</code> function (around line 160), add parameters for view and zoom:</p> <p>After <code>if (perPage !== 24) params.set(\"per_page\", perPage.toString());</code> add:</p> <pre><code>if (viewMode &amp;&amp; viewMode !== \"grid\") params.set(\"view\", viewMode);\nif (zoomLevel &amp;&amp; zoomLevel !== \"medium\") params.set(\"zoom\", zoomLevel);\n</code></pre> <p>Update the function signature to accept these new params:</p> <pre><code>export const buildSearchParams = ({\n  searchText,\n  sortField,\n  sortDirection,\n  currentPage,\n  perPage,\n  filters,\n  filterOptions,\n  viewMode,\n  zoomLevel,\n}) =&gt; {\n</code></pre> <p>Step 2: Add view and zoom to parseSearchParams</p> <p>In the <code>parseSearchParams</code> function (around line 188), add:</p> <pre><code>viewMode: searchParams.get(\"view\") || defaults.viewMode || \"grid\",\nzoomLevel: searchParams.get(\"zoom\") || defaults.zoomLevel || \"medium\",\n</code></pre> <p>Step 3: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/utils/urlParams.js &amp;&amp; git commit -m \"feat: add view and zoom to URL params utility\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-11-add-viewzoom-state-to-usefilterstate-hook","title":"Task 11: Add view/zoom state to useFilterState hook","text":"<p>Files: - Modify: <code>client/src/hooks/useFilterState.js</code></p> <p>Step 1: Add state for viewMode and zoomLevel</p> <p>After line 29 (<code>const [searchText, setSearchTextState] = useState(\"\");</code>), add:</p> <pre><code>const [viewMode, setViewModeState] = useState(\"grid\");\nconst [zoomLevel, setZoomLevelState] = useState(\"medium\");\n</code></pre> <p>Step 2: Parse view/zoom from URL in initialize</p> <p>In the initialize function, update the <code>urlState</code> parsing (around line 64) and set the state.</p> <p>In <code>finalState</code>, add: <pre><code>viewMode: urlState.viewMode,\nzoomLevel: urlState.zoomLevel,\n</code></pre></p> <p>After setting other state (around line 112), add: <pre><code>setViewModeState(finalState.viewMode);\nsetZoomLevelState(finalState.zoomLevel);\n</code></pre></p> <p>Step 3: Update stateRef</p> <p>Update line 146 to include viewMode and zoomLevel:</p> <pre><code>stateRef.current = { filters, sort, pagination, searchText, viewMode, zoomLevel };\n</code></pre> <p>Step 4: Update syncToUrlParams</p> <p>Update the syncToUrlParams function to include viewMode and zoomLevel in the params call:</p> <pre><code>const params = buildSearchParams({\n  searchText: state.searchText,\n  sortField: state.sort.field,\n  sortDirection: state.sort.direction,\n  currentPage: state.pagination.page,\n  perPage: state.pagination.perPage,\n  filters: state.filters,\n  filterOptions,\n  viewMode: state.viewMode,\n  zoomLevel: state.zoomLevel,\n});\n</code></pre> <p>Step 5: Add setViewMode and setZoomLevel actions</p> <p>Add new action functions:</p> <pre><code>const setViewMode = useCallback((mode) =&gt; {\n  setViewModeState(mode);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText,\n    viewMode: mode,\n    zoomLevel,\n  });\n}, [filters, sort, pagination, searchText, zoomLevel, syncToUrlParams]);\n\nconst setZoomLevel = useCallback((level) =&gt; {\n  setZoomLevelState(level);\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination,\n    searchText,\n    viewMode,\n    zoomLevel: level,\n  });\n}, [filters, sort, pagination, searchText, viewMode, syncToUrlParams]);\n</code></pre> <p>Step 6: Update loadPreset to handle view/zoom</p> <p>In the loadPreset callback, add handling for view and zoom from preset:</p> <pre><code>const loadPreset = useCallback((preset) =&gt; {\n  const newFilters = { ...permanentFilters, ...preset.filters };\n  const newViewMode = preset.viewMode || \"grid\";\n  const newZoomLevel = preset.zoomLevel || \"medium\";\n\n  setFiltersState(newFilters);\n  setSortState({ field: preset.sort, direction: preset.direction });\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  setViewModeState(newViewMode);\n  setZoomLevelState(newZoomLevel);\n\n  syncToUrlParams({\n    filters: newFilters,\n    sort: { field: preset.sort, direction: preset.direction },\n    pagination: { ...pagination, page: 1 },\n    searchText,\n    viewMode: newViewMode,\n    zoomLevel: newZoomLevel,\n  });\n}, [permanentFilters, pagination, searchText, syncToUrlParams]);\n</code></pre> <p>Step 7: Return new values and actions</p> <p>Update the return statement to include:</p> <pre><code>return {\n  filters,\n  sort,\n  pagination,\n  searchText,\n  viewMode,\n  zoomLevel,\n  isInitialized,\n  isLoadingPresets,\n  // Actions\n  setFilter,\n  setFilters,\n  removeFilter,\n  clearFilters,\n  setSort,\n  setPage,\n  setPerPage,\n  setSearchText,\n  setViewMode,\n  setZoomLevel,\n  loadPreset,\n};\n</code></pre> <p>Step 8: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/hooks/useFilterState.js &amp;&amp; git commit -m \"feat: add viewMode and zoomLevel to useFilterState hook\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-12-add-viewzoom-to-filterpresets-saveload","title":"Task 12: Add view/zoom to FilterPresets save/load","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterPresets.jsx</code></p> <p>Step 1: Update FilterPresets props</p> <p>Add <code>currentViewMode</code> and <code>currentZoomLevel</code> to the component props (around line 43):</p> <pre><code>const FilterPresets = ({\n  artifactType,\n  context,\n  currentFilters,\n  permanentFilters = {},\n  currentSort,\n  currentDirection,\n  currentViewMode = \"grid\",\n  currentZoomLevel = \"medium\",\n  onLoadPreset,\n}) =&gt; {\n</code></pre> <p>Step 2: Save viewMode and zoomLevel in handleSavePreset</p> <p>In the apiPost call (around line 109), add the new fields:</p> <pre><code>await apiPost(\"/user/filter-presets\", {\n  artifactType,\n  context: effectiveContext,\n  name: presetName,\n  filters: filtersToSave,\n  sort: currentSort,\n  direction: currentDirection,\n  viewMode: currentViewMode,\n  zoomLevel: currentZoomLevel,\n  setAsDefault,\n});\n</code></pre> <p>Step 3: Load viewMode and zoomLevel in handleLoadPreset</p> <p>In the handleLoadPreset callback (around line 136), add the new fields:</p> <pre><code>onLoadPreset({\n  filters: mergedFilters,\n  sort: preset.sort,\n  direction: preset.direction,\n  viewMode: preset.viewMode || \"grid\",\n  zoomLevel: preset.zoomLevel || \"medium\",\n});\n</code></pre> <p>Step 4: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/FilterPresets.jsx &amp;&amp; git commit -m \"feat: add viewMode and zoomLevel to filter presets\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-13-add-viewmodetoggle-and-zoomslider-to-searchcontrols","title":"Task 13: Add ViewModeToggle and ZoomSlider to SearchControls","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Import new components</p> <p>Add imports at top of file:</p> <pre><code>import ViewModeToggle from \"./ViewModeToggle.jsx\";\nimport ZoomSlider from \"./ZoomSlider.jsx\";\n</code></pre> <p>Step 2: Add props for view mode support</p> <p>Add new props to the component (around line 84):</p> <pre><code>const SearchControls = ({\n  artifactType = \"scene\",\n  context,\n  children,\n  initialSort = \"o_counter\",\n  onQueryChange,\n  onPerPageStateChange,\n  paginationHandlerRef,\n  permanentFilters = {},\n  permanentFiltersMetadata = {},\n  totalPages,\n  totalCount,\n  syncToUrl = true,\n  // View mode props\n  supportsWallView = false,\n  wallPlayback = \"autoplay\",\n  // TV Mode props\n  tvSearchZoneActive = false,\n  tvTopPaginationZoneActive = false,\n  tvBottomPaginationZoneActive = false,\n}) =&gt; {\n</code></pre> <p>Step 3: Get viewMode and zoomLevel from useFilterState</p> <p>Update the destructuring from useFilterState (around line 218):</p> <pre><code>const {\n  filters,\n  sort,\n  pagination,\n  searchText,\n  viewMode,\n  zoomLevel,\n  isInitialized,\n  isLoadingPresets,\n  setFilters: setFiltersAction,\n  removeFilter: removeFilterAction,\n  clearFilters: clearFiltersAction,\n  setSort: setSortAction,\n  setPage,\n  setPerPage: setPerPageAction,\n  setSearchText: setSearchTextAction,\n  setViewMode,\n  setZoomLevel,\n  loadPreset,\n} = useFilterState({\n  artifactType,\n  context: effectiveContext,\n  initialSort,\n  permanentFilters,\n  filterOptions,\n  syncToUrl,\n});\n</code></pre> <p>Step 4: Add handlers for view mode and zoom</p> <p>Add handler functions:</p> <pre><code>const handleViewModeChange = useCallback((mode) =&gt; {\n  setViewMode(mode);\n  // Also trigger query change to refresh with new view\n  const query = {\n    filter: {\n      direction: sortDirection,\n      page: 1,\n      per_page: perPage,\n      q: searchText,\n      sort: getSortWithSeed(sortField),\n    },\n    ...buildFilter(artifactType, filters, unitPreference),\n  };\n  onQueryChange(query);\n}, [setViewMode, sortDirection, perPage, searchText, sortField, filters, artifactType, unitPreference, onQueryChange, getSortWithSeed]);\n\nconst handleZoomChange = useCallback((level) =&gt; {\n  setZoomLevel(level);\n}, [setZoomLevel]);\n</code></pre> <p>Step 5: Pass viewMode/zoomLevel to FilterPresets</p> <p>Update the FilterPresets component usage (around line 728):</p> <pre><code>&lt;FilterPresets\n  artifactType={artifactType}\n  context={effectiveContext}\n  currentFilters={filters}\n  currentSort={sortField}\n  currentDirection={sortDirection}\n  currentViewMode={viewMode}\n  currentZoomLevel={zoomLevel}\n  permanentFilters={permanentFilters}\n  onLoadPreset={handleLoadPreset}\n/&gt;\n</code></pre> <p>Step 6: Add ViewModeToggle and ZoomSlider to toolbar</p> <p>After the FilterPresets section (around line 742), add:</p> <pre><code>{/* View Mode Toggle - Only for supported artifact types */}\n{supportsWallView &amp;&amp; (\n  &lt;ViewModeToggle\n    value={viewMode}\n    onChange={handleViewModeChange}\n  /&gt;\n)}\n\n{/* Zoom Slider - Only shown in wall mode */}\n{supportsWallView &amp;&amp; viewMode === \"wall\" &amp;&amp; (\n  &lt;ZoomSlider\n    value={zoomLevel}\n    onChange={handleZoomChange}\n  /&gt;\n)}\n</code></pre> <p>Step 7: Expose viewMode, zoomLevel, and wallPlayback via children render prop or context</p> <p>For pages to access viewMode/zoomLevel, we need to pass them down. The cleanest approach is to add a render prop pattern.</p> <p>Update the children rendering section to pass props:</p> <pre><code>{typeof children === \"function\"\n  ? children({ viewMode, zoomLevel, wallPlayback })\n  : children}\n</code></pre> <p>Step 8: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/SearchControls.jsx &amp;&amp; git commit -m \"feat: add ViewModeToggle and ZoomSlider to SearchControls\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-14-create-usewallplayback-hook","title":"Task 14: Create useWallPlayback hook","text":"<p>Files: - Create: <code>client/src/hooks/useWallPlayback.js</code></p> <p>Step 1: Create the hook</p> <pre><code>import { useEffect, useState } from \"react\";\nimport { apiGet } from \"../services/api.js\";\n\n/**\n * Hook to get the user's wallPlayback preference.\n * Returns \"autoplay\" | \"hover\" | \"static\"\n */\nexport const useWallPlayback = () =&gt; {\n  const [wallPlayback, setWallPlayback] = useState(\"autoplay\");\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    const loadSetting = async () =&gt; {\n      try {\n        const response = await apiGet(\"/user/settings\");\n        setWallPlayback(response.settings?.wallPlayback || \"autoplay\");\n      } catch {\n        // Default to autoplay on error\n        setWallPlayback(\"autoplay\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadSetting();\n  }, []);\n\n  return { wallPlayback, loading };\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/hooks/useWallPlayback.js &amp;&amp; git commit -m \"feat: add useWallPlayback hook\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-15-integrate-wallview-into-scenesearch-page","title":"Task 15: Integrate WallView into SceneSearch page","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Import WallView and useWallPlayback</p> <p>Add imports:</p> <pre><code>import WallView from \"../wall/WallView.jsx\";\nimport { useWallPlayback } from \"../../hooks/useWallPlayback.js\";\n</code></pre> <p>Step 2: Get wallPlayback setting</p> <p>Inside the component, add:</p> <pre><code>const { wallPlayback } = useWallPlayback();\n</code></pre> <p>Step 3: Update SearchControls to enable wall view</p> <p>Add <code>supportsWallView={true}</code> and <code>wallPlayback={wallPlayback}</code> to SearchControls.</p> <p>Step 4: Use render prop to get viewMode/zoomLevel</p> <p>Wrap the grid rendering in the children function:</p> <pre><code>&lt;SearchControls\n  artifactType=\"scene\"\n  // ... other props\n  supportsWallView={true}\n  wallPlayback={wallPlayback}\n&gt;\n  {({ viewMode, zoomLevel }) =&gt; (\n    viewMode === \"wall\" ? (\n      &lt;WallView\n        items={scenes}\n        entityType=\"scene\"\n        zoomLevel={zoomLevel}\n        playbackMode={wallPlayback}\n        onItemClick={handleSceneClick}\n        loading={loading}\n        emptyMessage=\"No scenes found\"\n      /&gt;\n    ) : (\n      &lt;SceneGrid\n        scenes={scenes}\n        loading={loading}\n        error={error}\n        currentPage={currentPage}\n        totalPages={totalPages}\n        onPageChange={handlePageChange}\n        onSceneClick={handleSceneClick}\n        // ... other props\n      /&gt;\n    )\n  )}\n&lt;/SearchControls&gt;\n</code></pre> <p>Step 5: Test in browser</p> <p>Navigate to /scenes and verify: - View toggle appears in toolbar - Clicking Wall shows justified layout - Zoom slider appears in wall mode - Previews autoplay based on setting</p> <p>Step 6: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/scene-search/SceneSearch.jsx &amp;&amp; git commit -m \"feat: integrate WallView into SceneSearch page\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-16-integrate-wallview-into-gallerysearch-and-imagesearch","title":"Task 16: Integrate WallView into GallerySearch and ImageSearch","text":"<p>Files: - Modify: <code>client/src/pages/GallerySearch.jsx</code> (or wherever gallery search lives) - Modify: <code>client/src/pages/ImageSearch.jsx</code> (or wherever image search lives)</p> <p>Step 1: Find the gallery and image search pages</p> <p>Run: <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; find client/src -name \"*Gallery*\" -o -name \"*Image*\" | grep -E \"\\.(jsx|tsx)$\" | head -20\n</code></pre></p> <p>Step 2: Apply same pattern as SceneSearch</p> <p>For each page: 1. Import WallView and useWallPlayback 2. Add supportsWallView={true} to SearchControls 3. Use render prop to conditionally render WallView or existing grid 4. Pass entityType=\"gallery\" or entityType=\"image\" to WallView</p> <p>Step 3: Test in browser</p> <p>Navigate to /galleries and /images and verify wall view works.</p> <p>Step 4: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src &amp;&amp; git commit -m \"feat: integrate WallView into GallerySearch and ImageSearch\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-17-integrate-wallview-into-detail-page-tabs","title":"Task 17: Integrate WallView into detail page tabs","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code></p> <p>Step 1: For each detail page, locate scene/gallery/image tabs</p> <p>Each page uses SearchControls for these tabs. Apply the same pattern: 1. Add supportsWallView={true} for scene/gallery/image tabs 2. Use render prop to conditionally render WallView</p> <p>Step 2: PerformerDetail - scenes, galleries, images tabs</p> <p>Import WallView and useWallPlayback, then update each relevant tab.</p> <p>Step 3: StudioDetail - scenes, galleries tabs</p> <p>Same pattern.</p> <p>Step 4: TagDetail - scenes, galleries, images tabs</p> <p>Same pattern.</p> <p>Step 5: GroupDetail - scenes tab</p> <p>Same pattern.</p> <p>Step 6: GalleryDetail - images view</p> <p>The image display in GalleryDetail may use a different pattern (lightbox). Check if it uses SearchControls and apply if appropriate.</p> <p>Step 7: Test all detail pages</p> <p>Navigate to each detail page type and verify wall view works on relevant tabs.</p> <p>Step 8: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/pages &amp;&amp; git commit -m \"feat: integrate WallView into detail page tabs\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-18-export-wall-components-from-index","title":"Task 18: Export wall components from index","text":"<p>Files: - Create: <code>client/src/components/wall/index.js</code></p> <p>Step 1: Create index file</p> <pre><code>export { default as WallView } from \"./WallView.jsx\";\nexport { default as WallItem } from \"./WallItem.jsx\";\nexport { wallConfig, ZOOM_LEVELS, DEFAULT_ZOOM, DEFAULT_VIEW_MODE } from \"./wallConfig.js\";\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src/components/wall/index.js &amp;&amp; git commit -m \"chore: add wall components index export\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-19-add-wall-view-css-refinements","title":"Task 19: Add wall view CSS refinements","text":"<p>Files: - Modify: <code>client/src/index.css</code> (or appropriate global CSS file)</p> <p>Step 1: Add wall view styles</p> <pre><code>/* Wall View */\n.wall-view {\n  width: 100%;\n}\n\n.wall-item {\n  cursor: pointer;\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.wall-item:hover {\n  transform: scale(1.02);\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n  z-index: 10;\n}\n\n.wall-item video {\n  transition: opacity 0.3s ease;\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add client/src &amp;&amp; git commit -m \"style: add wall view CSS refinements\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#task-20-final-testing-and-cleanup","title":"Task 20: Final testing and cleanup","text":"<p>Step 1: Run the full application</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; docker-compose -f docker-compose.yml -f docker-compose.windows.yml up\n</code></pre> <p>Step 2: Test checklist</p> <ul> <li> Scene Search: Grid/Wall toggle works, zoom slider appears in wall mode</li> <li> Gallery Search: Grid/Wall toggle works</li> <li> Image Search: Grid/Wall toggle works</li> <li> Performer Detail tabs: Wall view on scenes, galleries, images</li> <li> Studio Detail tabs: Wall view on scenes, galleries</li> <li> Tag Detail tabs: Wall view on scenes, galleries, images</li> <li> Group Detail tabs: Wall view on scenes</li> <li> Gallery Detail: Wall view on images (if applicable)</li> <li> Settings: wallPlayback setting saves and affects preview behavior</li> <li> Presets: view/zoom saved in presets, loaded correctly</li> <li> URL sync: view/zoom params in URL, back/forward navigation works</li> </ul> <p>Step 3: Run linting</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/client &amp;&amp; npm run lint\n</code></pre> <p>Fix any lint errors.</p> <p>Step 4: Final commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser &amp;&amp; git add . &amp;&amp; git commit -m \"feat: complete wall view implementation\"\n</code></pre>"},{"location":"plans/2025-01-12-wall-view-implementation/#summary","title":"Summary","text":"<p>This implementation plan adds: - Wall view with justified layout via react-photo-album - 3 zoom levels (S/M/L) - Global wallPlayback setting (autoplay/hover/static) - URL sync for view mode and zoom - Preset integration for view/zoom - Support for scenes, galleries, and images across all search pages and detail page tabs</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/","title":"Empty Entity Filtering Bug Fix Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix the bug where non-admin users see drastically reduced entity counts (Performers: 180/7000+, Studios: 941/1101) due to missing relationship data in empty entity filtering.</p> <p>Architecture: Add new scene query methods that include performer/tag junction data, update <code>filterEmptyStudios</code> with parent/child traversal and gallery lookup, update <code>filterEmptyTags</code> to accept performer data for tag lookup.</p> <p>Tech Stack: TypeScript, Prisma ORM, Express controllers</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-1-add-getallsceneswithperformers-method","title":"Task 1: Add getAllScenesWithPerformers Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:185</code> (after getAllScenesWithTags) - Test: <code>server/services/__tests__/StashEntityService.test.ts</code> (if exists, otherwise manual verification)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithTags()</code> method (around line 185):</p> <pre><code>  /**\n   * Get all scenes with performers relation included\n   * Used for empty entity filtering which needs to know which performers appear in visible scenes\n   */\n  async getAllScenesWithPerformers(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformers: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformers method for empty entity filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-2-add-getallsceneswithperformersandtags-method","title":"Task 2: Add getAllScenesWithPerformersAndTags Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code> (after the method added in Task 1)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithPerformers()</code>:</p> <pre><code>  /**\n   * Get all scenes with both performers and tags relations included\n   * Used for tags filtering which needs both performer IDs and tag IDs\n   */\n  async getAllScenesWithPerformersAndTags(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n        tags: {\n          select: { tagId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      scene.tags = (c.tags?.map((t: { tagId: string }) =&gt; ({ id: t.tagId })) || []) as typeof scene.tags;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformersAndTags: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformersAndTags method for tags filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-3-update-filteremptystudios-with-parentchild-traversal","title":"Task 3: Update filterEmptyStudios with Parent/Child Traversal","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:269-332</code> (replace filterEmptyStudios method)</p> <p>Step 1: Replace the filterEmptyStudios method</p> <p>Find <code>filterEmptyStudios</code> method (starts around line 269) and replace entirely with:</p> <pre><code>  /**\n   * Filter studios with no content\n   * Hide if ALL of:\n   * - Not in any visible scene\n   * - No visible groups\n   * - No images\n   * - No visible galleries\n   * - No child studios with content\n   */\n  filterEmptyStudios&lt;T extends FilterableStudio&gt;(\n    studios: T[],\n    visibleGroups: FilterableGroup[],\n    visibleGalleries: FilterableGallery[],\n    visibleScenes?: Array&lt;{ id: string; studio?: { id: string } | null }&gt;\n  ): T[] {\n    // Build set of studios in visible scenes\n    const studiosInVisibleScenes = new Set&lt;string&gt;();\n    if (visibleScenes) {\n      for (const scene of visibleScenes) {\n        if (scene.studio) {\n          studiosInVisibleScenes.add(scene.studio.id);\n        }\n      }\n    }\n\n    // Build sets of visible group and gallery IDs for fast lookup\n    const visibleGroupIds = new Set(visibleGroups.map((g) =&gt; g.id));\n    const visibleGalleryIds = new Set(visibleGalleries.map((g) =&gt; g.id));\n\n    // Build set of studios that have visible galleries\n    const studiosWithVisibleGalleries = new Set&lt;string&gt;();\n    for (const gallery of visibleGalleries) {\n      const studioId = (gallery as { studio?: { id: string } }).studio?.id;\n      if (studioId) {\n        studiosWithVisibleGalleries.add(studioId);\n      }\n    }\n\n    // Build parent -&gt; children map for recursive check\n    const studioMap = new Map(studios.map((s) =&gt; [s.id, s]));\n    const childrenMap = new Map&lt;string, string[]&gt;();\n    for (const studio of studios) {\n      const parentId = (studio as { parent_studio?: { id: string } }).parent_studio?.id;\n      if (parentId) {\n        if (!childrenMap.has(parentId)) {\n          childrenMap.set(parentId, []);\n        }\n        childrenMap.get(parentId)!.push(studio.id);\n      }\n    }\n\n    // Track which studios have content\n    const hasContent = new Map&lt;string, boolean&gt;();\n\n    const checkHasContent = (studioId: string, visited = new Set&lt;string&gt;()): boolean =&gt; {\n      if (visited.has(studioId)) return false;\n      visited.add(studioId);\n\n      if (hasContent.has(studioId)) {\n        return hasContent.get(studioId)!;\n      }\n\n      const studio = studioMap.get(studioId);\n      if (!studio) return false;\n\n      // Check if studio appears in visible scenes\n      if (visibleScenes &amp;&amp; studiosInVisibleScenes.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Fallback to scene_count if visibleScenes not provided\n      if (!visibleScenes &amp;&amp; studio.scene_count &amp;&amp; studio.scene_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has images? Keep\n      if (studio.image_count &amp;&amp; studio.image_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible galleries? Keep\n      if (studiosWithVisibleGalleries.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible groups? Keep\n      if (studio.groups &amp;&amp; Array.isArray(studio.groups)) {\n        if (studio.groups.some((g) =&gt; visibleGroupIds.has(g.id))) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      // Check if any child studio has content\n      const children = childrenMap.get(studioId) || [];\n      for (const childId of children) {\n        if (checkHasContent(childId, visited)) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      hasContent.set(studioId, false);\n      return false;\n    };\n\n    // Check all studios\n    for (const studio of studios) {\n      checkHasContent(studio.id);\n    }\n\n    const filtered = studios.filter((studio) =&gt; hasContent.get(studio.id) === true);\n\n    logger.debug(\"Filtered empty studios\", {\n      original: studios.length,\n      filtered: filtered.length,\n      removed: studios.length - filtered.length,\n    });\n\n    return filtered;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: add parent/child traversal and gallery lookup to filterEmptyStudios\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-4-update-filteremptytags-to-accept-allperformers-parameter","title":"Task 4: Update filterEmptyTags to Accept allPerformers Parameter","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:342-515</code> (update filterEmptyTags method)</p> <p>Step 1: Update the method signature and add performer lookup</p> <p>Find <code>filterEmptyTags</code> method (starts around line 342). Update the signature and the performer tag lookup logic:</p> <p>Change the method signature from: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;;\n      studio?: { id: string; tags?: Array&lt;{ id: string }&gt; } | null;\n    }&gt;\n  ): T[] {\n</code></pre></p> <p>To: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string }&gt;;\n      studio?: { id: string } | null;\n    }&gt;,\n    allPerformers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;\n  ): T[] {\n</code></pre></p> <p>Then, inside the method, after line <code>const tagsOnVisibleEntities = new Set&lt;string&gt;();</code> add:</p> <pre><code>    // Build performer ID -&gt; tags lookup from allPerformers\n    const performerTagsMap = new Map&lt;string, string[]&gt;();\n    if (allPerformers) {\n      for (const performer of allPerformers) {\n        if (performer.tags) {\n          performerTagsMap.set(performer.id, performer.tags.map(t =&gt; t.id));\n        }\n      }\n    }\n</code></pre> <p>Then update the performer tags section (around lines 375-384) from: <pre><code>        // Tags on performers in visible scenes\n        if (scene.performers) {\n          for (const performer of scene.performers) {\n            if (performer.tags) {\n              for (const tag of performer.tags) {\n                tagsOnVisibleEntities.add(tag.id);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Tags on performers in visible scenes (lookup from allPerformers)\n        if (scene.performers &amp;&amp; allPerformers) {\n          for (const performer of scene.performers) {\n            const performerTags = performerTagsMap.get(performer.id);\n            if (performerTags) {\n              for (const tagId of performerTags) {\n                tagsOnVisibleEntities.add(tagId);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>Also update the studio tags section (around lines 386-391) from: <pre><code>        // Tags on studio in visible scenes\n        if (scene.studio?.tags) {\n          for (const tag of scene.studio.tags) {\n            tagsOnVisibleEntities.add(tag.id);\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Note: Studio tags are not loaded via scenes - they're on the studio entities\n        // This would require passing allStudios, but studio tags are a rare use case\n        // Skip for now - can be added later if needed\n</code></pre></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: update filterEmptyTags to accept allPerformers for tag lookup\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-5-update-performersts-to-use-getallsceneswithperformers","title":"Task 5: Update performers.ts to Use getAllScenesWithPerformers","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts:122</code> (findPerformers) - Modify: <code>server/controllers/library/performers.ts:605</code> (findPerformersMinimal)</p> <p>Step 1: Update findPerformers (line 122)</p> <p>Find line 122: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 2: Update findPerformersMinimal (line 605)</p> <p>Find line 605: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/performers.ts\ngit commit -m \"fix: use getAllScenesWithPerformers for performer filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-6-update-tagsts-to-use-getallsceneswithperformersandtags","title":"Task 6: Update tags.ts to Use getAllScenesWithPerformersAndTags","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts:180</code> (findTags) - Modify: <code>server/controllers/library/tags.ts:234-238</code> (filterEmptyTags call in findTags) - Modify: <code>server/controllers/library/tags.ts:763</code> (findTagsMinimal) - Modify: <code>server/controllers/library/tags.ts:815-819</code> (filterEmptyTags call in findTagsMinimal)</p> <p>Step 1: Update findTags scene fetching (line 180)</p> <p>Find line 180: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 2: Update filterEmptyTags call in findTags (around line 234-238)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes // \u2190 NEW: Pass visible scenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 3: Update findTagsMinimal scene fetching (line 763)</p> <p>Find line 763: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 4: Update filterEmptyTags call in findTagsMinimal (around line 815-819)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 5: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/controllers/library/tags.ts\ngit commit -m \"fix: use getAllScenesWithPerformersAndTags and pass allPerformers to tag filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-7-run-tests-and-verify","title":"Task 7: Run Tests and Verify","text":"<p>Files: - Test: All existing tests</p> <p>Step 1: Run the test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Fix any failing tests</p> <p>If any tests fail due to the new method signatures, update them accordingly.</p> <p>Step 3: Commit any test fixes</p> <pre><code>git add -A\ngit commit -m \"test: fix tests for empty entity filtering changes\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-8-manual-verification","title":"Task 8: Manual Verification","text":"<p>Step 1: Start the server</p> <p>Run: <code>npm run dev</code> (or however the dev server starts)</p> <p>Step 2: Log in as non-admin user</p> <p>Step 3: Verify counts</p> <ul> <li>Navigate to Performers page - should show 7,000+ (not 180)</li> <li>Navigate to Studios page - should show 1,101 (not 941)</li> <li>Navigate to Tags page - verify count looks correct</li> <li>Check that parent studios with only child content are visible</li> <li>Check that studios with only galleries are visible</li> </ul> <p>Step 4: Log in as admin and verify counts still match</p> <p>Step 5: Final commit if any adjustments needed</p> <pre><code>git add -A\ngit commit -m \"fix: empty entity filtering - complete fix for performer/studio/tag counts\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#summary","title":"Summary","text":"Task Description Files 1 Add getAllScenesWithPerformers StashEntityService.ts 2 Add getAllScenesWithPerformersAndTags StashEntityService.ts 3 Update filterEmptyStudios with parent/child EmptyEntityFilterService.ts 4 Update filterEmptyTags to accept allPerformers EmptyEntityFilterService.ts 5 Update performers.ts call sites performers.ts 6 Update tags.ts call sites tags.ts 7 Run tests - 8 Manual verification -"},{"location":"plans/2025-01-13-table-list-view-design/","title":"Table/List View Design","text":"<p>Date: 2025-01-13 Status: Approved Branch: <code>feature/table-list-view</code></p>"},{"location":"plans/2025-01-13-table-list-view-design/#overview","title":"Overview","text":"<p>A high-density view mode for scanning and comparing metadata across many items at once. Available for all entity types. Users who want to see 20-50+ items on screen, quickly compare metadata fields, or find items based on specific attributes rather than visual browsing.</p>"},{"location":"plans/2025-01-13-table-list-view-design/#core-behavior","title":"Core Behavior","text":"<ul> <li>Rows display one item each with configurable columns</li> <li>Title/Name column is always visible and serves as the navigation link to the detail page</li> <li>Other cells can be interactive (e.g., clicking a performer navigates to them, clicking a studio navigates to it)</li> <li>Horizontal scrolling when columns exceed viewport width</li> <li>Small fixed-size thumbnails (~40-50px) to maintain compact row height</li> <li>Fixed row heights with text truncation (ellipsis) for long values</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#sort-integration","title":"Sort Integration","text":"<ul> <li>Clicking a column header sets that field as the sort and syncs with the existing sort dropdown</li> <li>Clicking the same header again reverses sort direction</li> <li>Visual indicator (arrow) shows current sort column and direction</li> <li>Both column headers and sort dropdown reflect the same state</li> <li>Non-sortable columns have no hover cursor change or click action</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#column-configuration","title":"Column Configuration","text":""},{"location":"plans/2025-01-13-table-list-view-design/#three-tier-settings","title":"Three-Tier Settings","text":"<ol> <li> <p>System defaults - Hardcoded fallback per entity type. Sensible starting columns.</p> </li> <li> <p>User defaults - Configured in Settings &gt; Customization tab. Per-entity-type settings for which columns appear and their order. Overrides system defaults.</p> </li> <li> <p>Preset-specific - When a user saves a filter preset while in table view, the current column visibility and order are saved with it. Loading that preset restores those columns. Overrides user defaults.</p> </li> </ol>"},{"location":"plans/2025-01-13-table-list-view-design/#resolution-order","title":"Resolution Order","text":"<p>When entering table view: 1. If active preset has <code>tableColumns</code> \u2192 use those 2. Else if user has configured defaults for this entity \u2192 use those 3. Else \u2192 use system defaults</p>"},{"location":"plans/2025-01-13-table-list-view-design/#configuration-ui","title":"Configuration UI","text":"<p>Toolbar button: - \"Columns\" button appears in toolbar when in table view - Opens a popover with column list</p> <p>Popover contents: - List of all available columns with checkboxes for visibility - Each row has: checkbox, column name, up/down arrows, jump-to-top/jump-to-bottom buttons - Mandatory columns (Title/Name) have checkbox disabled, always checked</p> <p>Right-click on headers: - Quick \"Hide this column\" option without opening full popover</p> <p>Settings page (Customization tab): - Same column list UI as the popover, for setting defaults - One section per entity type</p>"},{"location":"plans/2025-01-13-table-list-view-design/#column-definitions","title":"Column Definitions","text":""},{"location":"plans/2025-01-13-table-list-view-design/#scenes","title":"Scenes","text":"Column Mandatory Default Sortable Title Yes Yes Yes Thumbnail No Yes No Date No Yes Yes Duration No Yes Yes Rating No Yes Yes Studio No Yes Yes Performers No No No Tags No No No Resolution No No Yes Filesize No No Yes Play Count No No Yes O-Counter No No Yes Path No No Yes"},{"location":"plans/2025-01-13-table-list-view-design/#performers","title":"Performers","text":"Column Mandatory Default Sortable Name Yes Yes Yes Image No Yes No Aliases No No No Gender No No Yes Rating No Yes Yes Favorite No Yes Yes Age No No Yes Country No No Yes Ethnicity No No Yes Scene Count No Yes Yes O-Counter No No Yes"},{"location":"plans/2025-01-13-table-list-view-design/#studios","title":"Studios","text":"Column Mandatory Default Sortable Name Yes Yes Yes Image No Yes No Rating No Yes Yes Parent Studio No No Yes Scene Count No Yes Yes Child Count No No Yes"},{"location":"plans/2025-01-13-table-list-view-design/#tags","title":"Tags","text":"Column Mandatory Default Sortable Name Yes Yes Yes Image No Yes No Scene Count No Yes Yes Performer Count No No Yes Description No No No"},{"location":"plans/2025-01-13-table-list-view-design/#galleries","title":"Galleries","text":"Column Mandatory Default Sortable Title Yes Yes Yes Thumbnail No Yes No Date No Yes Yes Rating No Yes Yes Studio No No Yes Performers No No No Tags No No No Image Count No Yes Yes Path No No Yes"},{"location":"plans/2025-01-13-table-list-view-design/#images","title":"Images","text":"Column Mandatory Default Sortable Title Yes Yes Yes Thumbnail No Yes No Rating No Yes Yes Studio No No Yes Performers No No No Tags No No No Filesize No No Yes Resolution No No Yes Path No No Yes"},{"location":"plans/2025-01-13-table-list-view-design/#groups-movies","title":"Groups (Movies)","text":"Column Mandatory Default Sortable Name Yes Yes Yes Image No Yes No Rating No Yes Yes Studio No No Yes Date No No Yes Duration No No Yes Scene Count No Yes Yes"},{"location":"plans/2025-01-13-table-list-view-design/#interaction-details","title":"Interaction Details","text":""},{"location":"plans/2025-01-13-table-list-view-design/#row-interactions","title":"Row Interactions","text":"<ul> <li>Title/Name cell - Clickable link, navigates to detail page. Styled as a link (hover underline or color change).</li> <li>Thumbnail cell - Not clickable.</li> <li>Studio cell - Clickable, navigates to that studio's page.</li> <li>Performer cells - Each performer name clickable, navigates to their page.</li> <li>Tag cells - Same pattern as performers.</li> <li>Other cells - Not clickable (Rating, Duration, Date, etc. are display-only).</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#multi-value-cells","title":"Multi-Value Cells","text":"<ul> <li>Show first 2 items, then \"+N more\" if additional exist</li> <li>\"+N more\" opens a small popover listing all values</li> <li>Each value in the popover is clickable for navigation</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#sort-interactions","title":"Sort Interactions","text":"<ul> <li>Column header click - Sets sort to that field (if sortable), ascending. Shows up-arrow indicator.</li> <li>Second click on same header - Toggles to descending. Shows down-arrow indicator.</li> <li>Third click - Back to ascending (always a sort active).</li> <li>Non-sortable columns - No hover cursor change, no click action, slightly muted header style.</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#ui-layout","title":"UI Layout","text":""},{"location":"plans/2025-01-13-table-list-view-design/#table-structure","title":"Table Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [Toolbar: Search | Filters | Sort \u25bc | View Mode Icons | Columns]   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      \u2502 Title \u25b2        \u2502 Date   \u2502 Duration \u2502 Rating \u2502 Studio        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [img]\u2502 Scene Name     \u2502 Jan 12 \u2502 32:15    \u2502 \u2605\u2605\u2605\u2605   \u2502 Studio Name   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [img]\u2502 Another Scene  \u2502 Jan 10 \u2502 18:42    \u2502 \u2605\u2605\u2605    \u2502 Other Studio  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-design/#column-config-popover","title":"Column Config Popover","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Columns                    [x]  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u2611 Title (required)              \u2502\n\u2502 \u2611 Thumbnail      [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2502 \u2611 Date           [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2502 \u2611 Duration       [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2502 \u2611 Rating         [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2502 \u2610 Performers     [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2502 \u2610 Tags           [\u2912][\u2191][\u2193][\u2913]  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-design/#state-persistence","title":"State Persistence","text":""},{"location":"plans/2025-01-13-table-list-view-design/#storage-structure","title":"Storage Structure","text":"<p>User defaults (in user settings): <pre><code>tableColumns: {\n  scenes: { visible: [\"title\", \"thumbnail\", \"date\", ...], order: [\"title\", \"thumbnail\", ...] },\n  performers: { visible: [...], order: [...] },\n  // ...per entity type\n}\n</code></pre></p> <p>Presets (extended structure): <pre><code>{\n  name: \"My Scene Preset\",\n  filters: { ... },\n  sort: { field: \"date\", direction: \"desc\" },\n  viewMode: \"table\",\n  tableColumns: { visible: [...], order: [...] }  // only when viewMode is table\n}\n</code></pre></p>"},{"location":"plans/2025-01-13-table-list-view-design/#change-behavior","title":"Change Behavior","text":"<ul> <li>Column config changes apply immediately to current view</li> <li>If a preset is active, changes are \"unsaved\" (preset could indicate drift)</li> <li>Changes don't auto-save to user defaults - explicit save in Settings</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#v1-scope","title":"v1 Scope","text":""},{"location":"plans/2025-01-13-table-list-view-design/#included","title":"Included","text":"<ul> <li>Table view mode for all entity types</li> <li>Column visibility toggles via toolbar popover</li> <li>Column reordering via arrow buttons (up/down/top/bottom)</li> <li>Clickable headers for sorting (sync with sort dropdown)</li> <li>Multi-value truncation with \"+N more\" popovers</li> <li>Cell navigation (title \u2192 detail, studio \u2192 studio page, performer \u2192 performer page)</li> <li>Right-click header \u2192 \"Hide this column\"</li> <li>User defaults in Settings &gt; Customization</li> <li>Column config saved with presets</li> <li>Horizontal scroll for overflow</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#not-included-future","title":"Not Included (Future)","text":"<ul> <li>Column width resizing</li> <li>Inline editing of cell values</li> <li>Bulk selection / bulk actions on rows</li> <li>Keyboard navigation within the table</li> <li>Column grouping or pinning</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-design/#component-breakdown","title":"Component Breakdown","text":"<ul> <li><code>TableView</code> - Main container, handles horizontal scroll</li> <li><code>TableHeader</code> - Header row with sortable columns, sort indicators</li> <li><code>TableRow</code> - Entity-specific row renderer</li> <li><code>ColumnConfigPopover</code> - Visibility + reorder UI</li> <li><code>MultiValueCell</code> - Handles truncation + \"+N more\" popover</li> <li><code>useTableColumns</code> hook - Manages column state, persistence, resolution order</li> </ul>"},{"location":"plans/2025-01-13-table-list-view-implementation/","title":"Table/List View Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a table/list view mode to all entity list pages with configurable columns, sortable headers, and three-tier column preferences (system defaults \u2192 user defaults \u2192 preset-specific).</p> <p>Architecture: Create a generic <code>TableView</code> component that renders entity-specific columns. Column configuration is managed by a <code>useTableColumns</code> hook that handles persistence. The existing <code>ViewModeToggle</code> and <code>useFilterState</code> hooks are extended to support the new view mode. Column preferences are stored in user settings and optionally saved with filter presets.</p> <p>Tech Stack: React, Tailwind CSS, existing API patterns (axios), lucide-react icons</p>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-1-define-column-configuration-constants","title":"Task 1: Define Column Configuration Constants","text":"<p>Files: - Create: <code>client/src/config/tableColumns.js</code></p> <p>Step 1: Create the column configuration file</p> <pre><code>// client/src/config/tableColumns.js\n\n/**\n * Table column definitions for all entity types\n *\n * Each column definition includes:\n * - id: unique identifier (matches sort field where applicable)\n * - label: display name for header\n * - mandatory: if true, cannot be hidden\n * - defaultVisible: shown by default when no user preference\n * - sortable: if true, clicking header sorts by this field\n * - width: Tailwind width class (w-XX or min-w-XX)\n * - render: function to render cell content (entity) =&gt; ReactNode\n */\n\n// Scene columns\nexport const SCENE_COLUMNS = [\n  {\n    id: \"title\",\n    label: \"Title\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n    width: \"min-w-[200px]\",\n  },\n  {\n    id: \"thumbnail\",\n    label: \"Thumbnail\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"date\",\n    label: \"Date\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"duration\",\n    label: \"Duration\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[80px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"studio\",\n    label: \"Studio\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true, // sorts by studio name\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"performers\",\n    label: \"Performers\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"tags\",\n    label: \"Tags\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"resolution\",\n    label: \"Resolution\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"filesize\",\n    label: \"File Size\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"play_count\",\n    label: \"Play Count\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"o_counter\",\n    label: \"O Count\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[80px]\",\n  },\n  {\n    id: \"path\",\n    label: \"Path\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[200px]\",\n  },\n];\n\n// Performer columns\nexport const PERFORMER_COLUMNS = [\n  {\n    id: \"name\",\n    label: \"Name\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"image\",\n    label: \"Image\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"aliases\",\n    label: \"Aliases\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"gender\",\n    label: \"Gender\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"favorite\",\n    label: \"Favorite\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[80px]\",\n  },\n  {\n    id: \"age\",\n    label: \"Age\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true, // sorts by birthdate\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"country\",\n    label: \"Country\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"ethnicity\",\n    label: \"Ethnicity\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"scenes_count\",\n    label: \"Scenes\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[70px]\",\n  },\n  {\n    id: \"o_counter\",\n    label: \"O Count\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[80px]\",\n  },\n];\n\n// Studio columns\nexport const STUDIO_COLUMNS = [\n  {\n    id: \"name\",\n    label: \"Name\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"image\",\n    label: \"Image\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"parent_studio\",\n    label: \"Parent Studio\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"scenes_count\",\n    label: \"Scenes\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[70px]\",\n  },\n  {\n    id: \"child_count\",\n    label: \"Sub-Studios\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n];\n\n// Tag columns\nexport const TAG_COLUMNS = [\n  {\n    id: \"name\",\n    label: \"Name\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"image\",\n    label: \"Image\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"scenes_count\",\n    label: \"Scenes\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[70px]\",\n  },\n  {\n    id: \"performer_count\",\n    label: \"Performers\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"description\",\n    label: \"Description\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[200px]\",\n  },\n];\n\n// Gallery columns\nexport const GALLERY_COLUMNS = [\n  {\n    id: \"title\",\n    label: \"Title\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"thumbnail\",\n    label: \"Thumbnail\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"date\",\n    label: \"Date\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"studio\",\n    label: \"Studio\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"performers\",\n    label: \"Performers\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"tags\",\n    label: \"Tags\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"image_count\",\n    label: \"Images\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[70px]\",\n  },\n  {\n    id: \"path\",\n    label: \"Path\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[200px]\",\n  },\n];\n\n// Image columns\nexport const IMAGE_COLUMNS = [\n  {\n    id: \"title\",\n    label: \"Title\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"thumbnail\",\n    label: \"Thumbnail\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"studio\",\n    label: \"Studio\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"performers\",\n    label: \"Performers\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"tags\",\n    label: \"Tags\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: false,\n    width: \"min-w-[150px]\",\n  },\n  {\n    id: \"filesize\",\n    label: \"File Size\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"resolution\",\n    label: \"Resolution\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[90px]\",\n  },\n  {\n    id: \"path\",\n    label: \"Path\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[200px]\",\n  },\n];\n\n// Group columns\nexport const GROUP_COLUMNS = [\n  {\n    id: \"name\",\n    label: \"Name\",\n    mandatory: true,\n    defaultVisible: true,\n    sortable: true,\n  },\n  {\n    id: \"image\",\n    label: \"Image\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: false,\n    width: \"w-[60px]\",\n  },\n  {\n    id: \"rating\",\n    label: \"Rating\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"studio\",\n    label: \"Studio\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"min-w-[120px]\",\n  },\n  {\n    id: \"date\",\n    label: \"Date\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[100px]\",\n  },\n  {\n    id: \"duration\",\n    label: \"Duration\",\n    mandatory: false,\n    defaultVisible: false,\n    sortable: true,\n    width: \"w-[80px]\",\n  },\n  {\n    id: \"scene_count\",\n    label: \"Scenes\",\n    mandatory: false,\n    defaultVisible: true,\n    sortable: true,\n    width: \"w-[70px]\",\n  },\n];\n\n// Helper to get columns by entity type\nexport const getColumnsForEntity = (entityType) =&gt; {\n  const columnMap = {\n    scene: SCENE_COLUMNS,\n    performer: PERFORMER_COLUMNS,\n    studio: STUDIO_COLUMNS,\n    tag: TAG_COLUMNS,\n    gallery: GALLERY_COLUMNS,\n    image: IMAGE_COLUMNS,\n    group: GROUP_COLUMNS,\n  };\n  return columnMap[entityType] || [];\n};\n\n// Helper to get default visible column IDs for an entity type\nexport const getDefaultVisibleColumns = (entityType) =&gt; {\n  const columns = getColumnsForEntity(entityType);\n  return columns\n    .filter((col) =&gt; col.defaultVisible)\n    .map((col) =&gt; col.id);\n};\n\n// Helper to get default column order for an entity type\nexport const getDefaultColumnOrder = (entityType) =&gt; {\n  const columns = getColumnsForEntity(entityType);\n  return columns.map((col) =&gt; col.id);\n};\n\n// Map column ID to actual sort field (some differ)\nexport const getColumnSortField = (columnId, entityType) =&gt; {\n  // Special mappings where column ID differs from sort field\n  const sortFieldMap = {\n    age: \"birthdate\", // age column sorts by birthdate\n    scenes_count: \"scenes_count\", // same\n    scene_count: \"scene_count\", // groups use singular\n  };\n  return sortFieldMap[columnId] || columnId;\n};\n</code></pre> <p>Step 2: Verify the file was created correctly</p> <p>Run: Check file exists at <code>client/src/config/tableColumns.js</code></p> <p>Step 3: Commit</p> <pre><code>git add client/src/config/tableColumns.js\ngit commit -m \"feat: add table column configuration constants\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-2-create-usetablecolumns-hook","title":"Task 2: Create useTableColumns Hook","text":"<p>Files: - Create: <code>client/src/hooks/useTableColumns.js</code></p> <p>Step 1: Create the hook file</p> <pre><code>// client/src/hooks/useTableColumns.js\n\nimport { useState, useCallback, useMemo } from \"react\";\nimport {\n  getColumnsForEntity,\n  getDefaultVisibleColumns,\n  getDefaultColumnOrder,\n} from \"../config/tableColumns.js\";\n\n/**\n * Hook to manage table column visibility and order.\n *\n * Three-tier preference system:\n * 1. Preset-specific columns (if preset has tableColumns)\n * 2. User default columns (from settings)\n * 3. System default columns (from tableColumns.js)\n *\n * @param {string} entityType - The entity type (scene, performer, etc.)\n * @param {Object} options\n * @param {Object} options.presetColumns - Column config from active preset\n * @param {Object} options.userDefaultColumns - Column config from user settings\n * @returns {Object} Column state and actions\n */\nexport const useTableColumns = (entityType, options = {}) =&gt; {\n  const { presetColumns, userDefaultColumns } = options;\n\n  const allColumns = useMemo(\n    () =&gt; getColumnsForEntity(entityType),\n    [entityType]\n  );\n\n  // Determine initial visible columns based on priority\n  const getInitialVisible = useCallback(() =&gt; {\n    if (presetColumns?.visible?.length &gt; 0) {\n      return presetColumns.visible;\n    }\n    if (userDefaultColumns?.visible?.length &gt; 0) {\n      return userDefaultColumns.visible;\n    }\n    return getDefaultVisibleColumns(entityType);\n  }, [entityType, presetColumns, userDefaultColumns]);\n\n  // Determine initial column order based on priority\n  const getInitialOrder = useCallback(() =&gt; {\n    if (presetColumns?.order?.length &gt; 0) {\n      return presetColumns.order;\n    }\n    if (userDefaultColumns?.order?.length &gt; 0) {\n      return userDefaultColumns.order;\n    }\n    return getDefaultColumnOrder(entityType);\n  }, [entityType, presetColumns, userDefaultColumns]);\n\n  const [visibleColumnIds, setVisibleColumnIds] = useState(getInitialVisible);\n  const [columnOrder, setColumnOrder] = useState(getInitialOrder);\n\n  // Get ordered, visible columns with full metadata\n  const visibleColumns = useMemo(() =&gt; {\n    // Filter to only columns that exist in our definitions\n    const validOrder = columnOrder.filter((id) =&gt;\n      allColumns.some((col) =&gt; col.id === id)\n    );\n\n    // Add any missing columns at the end (in case new columns were added)\n    const missingColumns = allColumns\n      .filter((col) =&gt; !validOrder.includes(col.id))\n      .map((col) =&gt; col.id);\n\n    const fullOrder = [...validOrder, ...missingColumns];\n\n    return fullOrder\n      .filter((id) =&gt; {\n        const col = allColumns.find((c) =&gt; c.id === id);\n        // Always include mandatory columns, or if it's in visible list\n        return col?.mandatory || visibleColumnIds.includes(id);\n      })\n      .map((id) =&gt; allColumns.find((col) =&gt; col.id === id))\n      .filter(Boolean);\n  }, [allColumns, columnOrder, visibleColumnIds]);\n\n  // Toggle column visibility\n  const toggleColumn = useCallback((columnId) =&gt; {\n    const column = allColumns.find((col) =&gt; col.id === columnId);\n    if (column?.mandatory) return; // Can't hide mandatory columns\n\n    setVisibleColumnIds((prev) =&gt; {\n      if (prev.includes(columnId)) {\n        return prev.filter((id) =&gt; id !== columnId);\n      }\n      return [...prev, columnId];\n    });\n  }, [allColumns]);\n\n  // Hide a specific column\n  const hideColumn = useCallback((columnId) =&gt; {\n    const column = allColumns.find((col) =&gt; col.id === columnId);\n    if (column?.mandatory) return;\n\n    setVisibleColumnIds((prev) =&gt; prev.filter((id) =&gt; id !== columnId));\n  }, [allColumns]);\n\n  // Move column to a specific position\n  const moveColumn = useCallback((columnId, direction) =&gt; {\n    setColumnOrder((prev) =&gt; {\n      const currentIndex = prev.indexOf(columnId);\n      if (currentIndex === -1) return prev;\n\n      let newIndex;\n      switch (direction) {\n        case \"top\":\n          newIndex = 0;\n          break;\n        case \"up\":\n          newIndex = Math.max(0, currentIndex - 1);\n          break;\n        case \"down\":\n          newIndex = Math.min(prev.length - 1, currentIndex + 1);\n          break;\n        case \"bottom\":\n          newIndex = prev.length - 1;\n          break;\n        default:\n          return prev;\n      }\n\n      if (newIndex === currentIndex) return prev;\n\n      const newOrder = [...prev];\n      newOrder.splice(currentIndex, 1);\n      newOrder.splice(newIndex, 0, columnId);\n      return newOrder;\n    });\n  }, []);\n\n  // Get current config for saving to preset or settings\n  const getColumnConfig = useCallback(() =&gt; ({\n    visible: visibleColumnIds,\n    order: columnOrder,\n  }), [visibleColumnIds, columnOrder]);\n\n  // Reset to user defaults or system defaults\n  const resetToDefaults = useCallback((useUserDefaults = true) =&gt; {\n    if (useUserDefaults &amp;&amp; userDefaultColumns?.visible?.length &gt; 0) {\n      setVisibleColumnIds(userDefaultColumns.visible);\n      setColumnOrder(userDefaultColumns.order || getDefaultColumnOrder(entityType));\n    } else {\n      setVisibleColumnIds(getDefaultVisibleColumns(entityType));\n      setColumnOrder(getDefaultColumnOrder(entityType));\n    }\n  }, [entityType, userDefaultColumns]);\n\n  // Apply preset columns (when loading a preset)\n  const applyPresetColumns = useCallback((presetCols) =&gt; {\n    if (presetCols?.visible?.length &gt; 0) {\n      setVisibleColumnIds(presetCols.visible);\n    }\n    if (presetCols?.order?.length &gt; 0) {\n      setColumnOrder(presetCols.order);\n    }\n  }, []);\n\n  return {\n    // State\n    allColumns,\n    visibleColumns,\n    visibleColumnIds,\n    columnOrder,\n\n    // Actions\n    toggleColumn,\n    hideColumn,\n    moveColumn,\n    getColumnConfig,\n    resetToDefaults,\n    applyPresetColumns,\n  };\n};\n\nexport default useTableColumns;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/hooks/useTableColumns.js\ngit commit -m \"feat: add useTableColumns hook for column state management\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-3-create-multivaluecell-component","title":"Task 3: Create MultiValueCell Component","text":"<p>Files: - Create: <code>client/src/components/table/MultiValueCell.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>// client/src/components/table/MultiValueCell.jsx\n\nimport { useState, useRef, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\n\n/**\n * Renders a cell with multiple values (performers, tags, etc.)\n * Shows first N items and \"+X more\" that opens a popover.\n *\n * @param {Object} props\n * @param {Array} props.items - Array of { id, name, linkTo? }\n * @param {number} props.maxVisible - Max items to show before truncating (default 2)\n * @param {string} props.emptyText - Text to show when no items (default \"-\")\n */\nconst MultiValueCell = ({ items = [], maxVisible = 2, emptyText = \"-\" }) =&gt; {\n  const [showPopover, setShowPopover] = useState(false);\n  const popoverRef = useRef(null);\n  const buttonRef = useRef(null);\n\n  // Close popover when clicking outside\n  useEffect(() =&gt; {\n    if (!showPopover) return;\n\n    const handleClickOutside = (event) =&gt; {\n      if (\n        popoverRef.current &amp;&amp;\n        !popoverRef.current.contains(event.target) &amp;&amp;\n        buttonRef.current &amp;&amp;\n        !buttonRef.current.contains(event.target)\n      ) {\n        setShowPopover(false);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () =&gt; document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [showPopover]);\n\n  if (!items || items.length === 0) {\n    return &lt;span style={{ color: \"var(--text-muted)\" }}&gt;{emptyText}&lt;/span&gt;;\n  }\n\n  const visibleItems = items.slice(0, maxVisible);\n  const hiddenCount = items.length - maxVisible;\n\n  const renderItem = (item, index, isLast) =&gt; {\n    const separator = isLast ? \"\" : \", \";\n\n    if (item.linkTo) {\n      return (\n        &lt;span key={item.id}&gt;\n          &lt;Link\n            to={item.linkTo}\n            className=\"hover:underline\"\n            style={{ color: \"var(--accent-primary)\" }}\n            onClick={(e) =&gt; e.stopPropagation()}\n          &gt;\n            {item.name}\n          &lt;/Link&gt;\n          {separator}\n        &lt;/span&gt;\n      );\n    }\n\n    return (\n      &lt;span key={item.id}&gt;\n        {item.name}\n        {separator}\n      &lt;/span&gt;\n    );\n  };\n\n  return (\n    &lt;div className=\"relative flex items-center gap-1 min-w-0\"&gt;\n      &lt;span className=\"truncate\"&gt;\n        {visibleItems.map((item, index) =&gt;\n          renderItem(item, index, index === visibleItems.length - 1 &amp;&amp; hiddenCount &lt;= 0)\n        )}\n      &lt;/span&gt;\n\n      {hiddenCount &gt; 0 &amp;&amp; (\n        &lt;&gt;\n          &lt;button\n            ref={buttonRef}\n            onClick={(e) =&gt; {\n              e.stopPropagation();\n              setShowPopover(!showPopover);\n            }}\n            className=\"text-xs px-1.5 py-0.5 rounded flex-shrink-0 hover:opacity-80\"\n            style={{\n              backgroundColor: \"var(--bg-secondary)\",\n              color: \"var(--text-secondary)\",\n            }}\n          &gt;\n            +{hiddenCount} more\n          &lt;/button&gt;\n\n          {showPopover &amp;&amp; (\n            &lt;div\n              ref={popoverRef}\n              className=\"absolute left-0 top-full mt-1 z-50 p-2 rounded-md shadow-lg border min-w-[150px] max-w-[300px] max-h-[200px] overflow-y-auto\"\n              style={{\n                backgroundColor: \"var(--bg-card)\",\n                borderColor: \"var(--border-color)\",\n              }}\n            &gt;\n              &lt;div className=\"flex flex-col gap-1\"&gt;\n                {items.map((item) =&gt; (\n                  &lt;div key={item.id} className=\"py-0.5\"&gt;\n                    {item.linkTo ? (\n                      &lt;Link\n                        to={item.linkTo}\n                        className=\"hover:underline text-sm\"\n                        style={{ color: \"var(--accent-primary)\" }}\n                        onClick={() =&gt; setShowPopover(false)}\n                      &gt;\n                        {item.name}\n                      &lt;/Link&gt;\n                    ) : (\n                      &lt;span className=\"text-sm\" style={{ color: \"var(--text-primary)\" }}&gt;\n                        {item.name}\n                      &lt;/span&gt;\n                    )}\n                  &lt;/div&gt;\n                ))}\n              &lt;/div&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default MultiValueCell;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/table/MultiValueCell.jsx\ngit commit -m \"feat: add MultiValueCell component for truncated lists\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-4-create-tableheader-component","title":"Task 4: Create TableHeader Component","text":"<p>Files: - Create: <code>client/src/components/table/TableHeader.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>// client/src/components/table/TableHeader.jsx\n\nimport { LucideArrowUp, LucideArrowDown } from \"lucide-react\";\nimport { getColumnSortField } from \"../../config/tableColumns.js\";\n\n/**\n * Table header row with sortable columns.\n *\n * @param {Object} props\n * @param {Array} props.columns - Visible columns with metadata\n * @param {Object} props.sort - Current sort { field, direction }\n * @param {Function} props.onSort - Called with (field, direction) when header clicked\n * @param {Function} props.onColumnContextMenu - Called with (columnId, event) on right-click\n * @param {string} props.entityType - Entity type for sort field mapping\n */\nconst TableHeader = ({\n  columns,\n  sort,\n  onSort,\n  onColumnContextMenu,\n  entityType,\n}) =&gt; {\n  const handleHeaderClick = (column) =&gt; {\n    if (!column.sortable) return;\n\n    const sortField = getColumnSortField(column.id, entityType);\n    const isSameField = sort.field === sortField;\n    const newDirection = isSameField &amp;&amp; sort.direction === \"DESC\" ? \"ASC\" : \"DESC\";\n\n    onSort(sortField, newDirection);\n  };\n\n  const handleContextMenu = (e, column) =&gt; {\n    if (column.mandatory) return; // Can't hide mandatory columns\n    e.preventDefault();\n    onColumnContextMenu?.(column.id, e);\n  };\n\n  return (\n    &lt;thead&gt;\n      &lt;tr\n        className=\"border-b\"\n        style={{\n          backgroundColor: \"var(--bg-secondary)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        {columns.map((column) =&gt; {\n          const sortField = getColumnSortField(column.id, entityType);\n          const isCurrentSort = sort.field === sortField;\n          const isSortable = column.sortable;\n\n          return (\n            &lt;th\n              key={column.id}\n              className={`px-3 py-2 text-left text-sm font-medium ${column.width || \"\"} ${\n                isSortable ? \"cursor-pointer select-none hover:bg-opacity-80\" : \"\"\n              }`}\n              style={{\n                color: isCurrentSort ? \"var(--accent-primary)\" : \"var(--text-secondary)\",\n                backgroundColor: isSortable ? undefined : \"transparent\",\n              }}\n              onClick={() =&gt; handleHeaderClick(column)}\n              onContextMenu={(e) =&gt; handleContextMenu(e, column)}\n              title={\n                isSortable\n                  ? `Sort by ${column.label}`\n                  : column.mandatory\n                  ? \"Required column\"\n                  : \"Right-click to hide\"\n              }\n            &gt;\n              &lt;div className=\"flex items-center gap-1\"&gt;\n                &lt;span className={!isSortable ? \"opacity-70\" : \"\"}&gt;\n                  {column.label}\n                &lt;/span&gt;\n                {isCurrentSort &amp;&amp; (\n                  sort.direction === \"ASC\" ? (\n                    &lt;LucideArrowUp size={14} /&gt;\n                  ) : (\n                    &lt;LucideArrowDown size={14} /&gt;\n                  )\n                )}\n              &lt;/div&gt;\n            &lt;/th&gt;\n          );\n        })}\n      &lt;/tr&gt;\n    &lt;/thead&gt;\n  );\n};\n\nexport default TableHeader;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/table/TableHeader.jsx\ngit commit -m \"feat: add TableHeader component with sortable columns\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-5-create-entity-specific-cell-renderers","title":"Task 5: Create Entity-Specific Cell Renderers","text":"<p>Files: - Create: <code>client/src/components/table/cellRenderers.jsx</code></p> <p>Step 1: Create the cell renderers file</p> <pre><code>// client/src/components/table/cellRenderers.jsx\n\nimport { Link } from \"react-router-dom\";\nimport { LucideHeart, LucideStar } from \"lucide-react\";\nimport MultiValueCell from \"./MultiValueCell.jsx\";\n\n// Format duration from seconds to MM:SS or HH:MM:SS\nconst formatDuration = (seconds) =&gt; {\n  if (!seconds) return \"-\";\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = Math.floor(seconds % 60);\n\n  if (h &gt; 0) {\n    return `${h}:${m.toString().padStart(2, \"0\")}:${s.toString().padStart(2, \"0\")}`;\n  }\n  return `${m}:${s.toString().padStart(2, \"0\")}`;\n};\n\n// Format file size\nconst formatFileSize = (bytes) =&gt; {\n  if (!bytes) return \"-\";\n  const units = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  let size = bytes;\n  let unitIndex = 0;\n  while (size &gt;= 1024 &amp;&amp; unitIndex &lt; units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n  return `${size.toFixed(1)} ${units[unitIndex]}`;\n};\n\n// Format date\nconst formatDate = (dateStr) =&gt; {\n  if (!dateStr) return \"-\";\n  try {\n    return new Date(dateStr).toLocaleDateString();\n  } catch {\n    return dateStr;\n  }\n};\n\n// Calculate age from birthdate\nconst calculateAge = (birthdate) =&gt; {\n  if (!birthdate) return \"-\";\n  const birth = new Date(birthdate);\n  const today = new Date();\n  let age = today.getFullYear() - birth.getFullYear();\n  const monthDiff = today.getMonth() - birth.getMonth();\n  if (monthDiff &lt; 0 || (monthDiff === 0 &amp;&amp; today.getDate() &lt; birth.getDate())) {\n    age--;\n  }\n  return age;\n};\n\n// Render rating as stars or number\nconst RatingCell = ({ rating }) =&gt; {\n  if (rating == null) return &lt;span style={{ color: \"var(--text-muted)\" }}&gt;-&lt;/span&gt;;\n\n  // Convert 0-100 to 0-5 stars\n  const stars = Math.round(rating / 20);\n\n  return (\n    &lt;div className=\"flex items-center gap-0.5\"&gt;\n      {[1, 2, 3, 4, 5].map((star) =&gt; (\n        &lt;LucideStar\n          key={star}\n          size={14}\n          className={star &lt;= stars ? \"fill-yellow-400 text-yellow-400\" : \"text-gray-400\"}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\n// Render favorite indicator\nconst FavoriteCell = ({ favorite }) =&gt; {\n  if (!favorite) return &lt;span style={{ color: \"var(--text-muted)\" }}&gt;-&lt;/span&gt;;\n  return &lt;LucideHeart size={16} className=\"fill-red-500 text-red-500\" /&gt;;\n};\n\n// Render thumbnail\nconst ThumbnailCell = ({ src, alt, linkTo }) =&gt; {\n  const img = (\n    &lt;img\n      src={src}\n      alt={alt || \"\"}\n      className=\"w-10 h-10 object-cover rounded\"\n      loading=\"lazy\"\n    /&gt;\n  );\n\n  if (linkTo) {\n    return (\n      &lt;Link to={linkTo} onClick={(e) =&gt; e.stopPropagation()}&gt;\n        {img}\n      &lt;/Link&gt;\n    );\n  }\n\n  return img;\n};\n\n// Render a navigable link cell\nconst LinkCell = ({ to, children }) =&gt; {\n  if (!children) return &lt;span style={{ color: \"var(--text-muted)\" }}&gt;-&lt;/span&gt;;\n\n  return (\n    &lt;Link\n      to={to}\n      className=\"hover:underline\"\n      style={{ color: \"var(--accent-primary)\" }}\n      onClick={(e) =&gt; e.stopPropagation()}\n    &gt;\n      {children}\n    &lt;/Link&gt;\n  );\n};\n\n/**\n * Get cell renderer for a specific column and entity type.\n * Returns a function (entity) =&gt; ReactNode\n */\nexport const getCellRenderer = (columnId, entityType) =&gt; {\n  // Scene cell renderers\n  if (entityType === \"scene\") {\n    const sceneRenderers = {\n      title: (scene) =&gt; (\n        &lt;LinkCell to={`/scene/${scene.id}`}&gt;{scene.title || \"Untitled\"}&lt;/LinkCell&gt;\n      ),\n      thumbnail: (scene) =&gt; (\n        &lt;ThumbnailCell\n          src={scene.paths?.screenshot || scene.image_path}\n          alt={scene.title}\n          linkTo={`/scene/${scene.id}`}\n        /&gt;\n      ),\n      date: (scene) =&gt; formatDate(scene.date),\n      duration: (scene) =&gt; formatDuration(scene.file?.duration || scene.duration),\n      rating: (scene) =&gt; &lt;RatingCell rating={scene.rating} /&gt;,\n      studio: (scene) =&gt; scene.studio ? (\n        &lt;LinkCell to={`/studio/${scene.studio.id}`}&gt;{scene.studio.name}&lt;/LinkCell&gt;\n      ) : \"-\",\n      performers: (scene) =&gt; (\n        &lt;MultiValueCell\n          items={(scene.performers || []).map((p) =&gt; ({\n            id: p.id,\n            name: p.name,\n            linkTo: `/performer/${p.id}`,\n          }))}\n        /&gt;\n      ),\n      tags: (scene) =&gt; (\n        &lt;MultiValueCell\n          items={(scene.tags || []).map((t) =&gt; ({\n            id: t.id,\n            name: t.name,\n            linkTo: `/tag/${t.id}`,\n          }))}\n        /&gt;\n      ),\n      resolution: (scene) =&gt; {\n        const height = scene.file?.height || scene.files?.[0]?.height;\n        return height ? `${height}p` : \"-\";\n      },\n      filesize: (scene) =&gt; formatFileSize(scene.file?.size || scene.files?.[0]?.size),\n      play_count: (scene) =&gt; scene.play_count ?? \"-\",\n      o_counter: (scene) =&gt; scene.o_counter ?? \"-\",\n      path: (scene) =&gt; (\n        &lt;span className=\"truncate text-xs\" title={scene.path || scene.file?.path}&gt;\n          {scene.path || scene.file?.path || \"-\"}\n        &lt;/span&gt;\n      ),\n    };\n    return sceneRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Performer cell renderers\n  if (entityType === \"performer\") {\n    const performerRenderers = {\n      name: (performer) =&gt; (\n        &lt;LinkCell to={`/performer/${performer.id}`}&gt;{performer.name}&lt;/LinkCell&gt;\n      ),\n      image: (performer) =&gt; (\n        &lt;ThumbnailCell\n          src={performer.image_path}\n          alt={performer.name}\n          linkTo={`/performer/${performer.id}`}\n        /&gt;\n      ),\n      aliases: (performer) =&gt; performer.aliases || \"-\",\n      gender: (performer) =&gt; performer.gender || \"-\",\n      rating: (performer) =&gt; &lt;RatingCell rating={performer.rating} /&gt;,\n      favorite: (performer) =&gt; &lt;FavoriteCell favorite={performer.favorite} /&gt;,\n      age: (performer) =&gt; calculateAge(performer.birthdate),\n      country: (performer) =&gt; performer.country || \"-\",\n      ethnicity: (performer) =&gt; performer.ethnicity || \"-\",\n      scenes_count: (performer) =&gt; performer.scene_count ?? performer.scenes_count ?? \"-\",\n      o_counter: (performer) =&gt; performer.o_counter ?? \"-\",\n    };\n    return performerRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Studio cell renderers\n  if (entityType === \"studio\") {\n    const studioRenderers = {\n      name: (studio) =&gt; (\n        &lt;LinkCell to={`/studio/${studio.id}`}&gt;{studio.name}&lt;/LinkCell&gt;\n      ),\n      image: (studio) =&gt; (\n        &lt;ThumbnailCell\n          src={studio.image_path}\n          alt={studio.name}\n          linkTo={`/studio/${studio.id}`}\n        /&gt;\n      ),\n      rating: (studio) =&gt; &lt;RatingCell rating={studio.rating} /&gt;,\n      parent_studio: (studio) =&gt; studio.parent_studio ? (\n        &lt;LinkCell to={`/studio/${studio.parent_studio.id}`}&gt;\n          {studio.parent_studio.name}\n        &lt;/LinkCell&gt;\n      ) : \"-\",\n      scenes_count: (studio) =&gt; studio.scene_count ?? studio.scenes_count ?? \"-\",\n      child_count: (studio) =&gt; studio.child_studios?.length ?? \"-\",\n    };\n    return studioRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Tag cell renderers\n  if (entityType === \"tag\") {\n    const tagRenderers = {\n      name: (tag) =&gt; (\n        &lt;LinkCell to={`/tag/${tag.id}`}&gt;{tag.name}&lt;/LinkCell&gt;\n      ),\n      image: (tag) =&gt; (\n        &lt;ThumbnailCell\n          src={tag.image_path}\n          alt={tag.name}\n          linkTo={`/tag/${tag.id}`}\n        /&gt;\n      ),\n      scenes_count: (tag) =&gt; tag.scene_count ?? tag.scenes_count ?? \"-\",\n      performer_count: (tag) =&gt; tag.performer_count ?? \"-\",\n      description: (tag) =&gt; (\n        &lt;span className=\"truncate text-xs\" title={tag.description}&gt;\n          {tag.description || \"-\"}\n        &lt;/span&gt;\n      ),\n    };\n    return tagRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Gallery cell renderers\n  if (entityType === \"gallery\") {\n    const galleryRenderers = {\n      title: (gallery) =&gt; (\n        &lt;LinkCell to={`/gallery/${gallery.id}`}&gt;\n          {gallery.title || gallery.path?.split(\"/\").pop() || \"Untitled\"}\n        &lt;/LinkCell&gt;\n      ),\n      thumbnail: (gallery) =&gt; (\n        &lt;ThumbnailCell\n          src={gallery.cover?.paths?.thumbnail || gallery.image_path}\n          alt={gallery.title}\n          linkTo={`/gallery/${gallery.id}`}\n        /&gt;\n      ),\n      date: (gallery) =&gt; formatDate(gallery.date),\n      rating: (gallery) =&gt; &lt;RatingCell rating={gallery.rating} /&gt;,\n      studio: (gallery) =&gt; gallery.studio ? (\n        &lt;LinkCell to={`/studio/${gallery.studio.id}`}&gt;{gallery.studio.name}&lt;/LinkCell&gt;\n      ) : \"-\",\n      performers: (gallery) =&gt; (\n        &lt;MultiValueCell\n          items={(gallery.performers || []).map((p) =&gt; ({\n            id: p.id,\n            name: p.name,\n            linkTo: `/performer/${p.id}`,\n          }))}\n        /&gt;\n      ),\n      tags: (gallery) =&gt; (\n        &lt;MultiValueCell\n          items={(gallery.tags || []).map((t) =&gt; ({\n            id: t.id,\n            name: t.name,\n            linkTo: `/tag/${t.id}`,\n          }))}\n        /&gt;\n      ),\n      image_count: (gallery) =&gt; gallery.image_count ?? gallery.images?.length ?? \"-\",\n      path: (gallery) =&gt; (\n        &lt;span className=\"truncate text-xs\" title={gallery.path}&gt;\n          {gallery.path || \"-\"}\n        &lt;/span&gt;\n      ),\n    };\n    return galleryRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Image cell renderers\n  if (entityType === \"image\") {\n    const imageRenderers = {\n      title: (image) =&gt; (\n        &lt;LinkCell to={`/image/${image.id}`}&gt;\n          {image.title || image.path?.split(\"/\").pop() || \"Untitled\"}\n        &lt;/LinkCell&gt;\n      ),\n      thumbnail: (image) =&gt; (\n        &lt;ThumbnailCell\n          src={image.paths?.thumbnail || image.image_path}\n          alt={image.title}\n        /&gt;\n      ),\n      rating: (image) =&gt; &lt;RatingCell rating={image.rating} /&gt;,\n      studio: (image) =&gt; image.studio ? (\n        &lt;LinkCell to={`/studio/${image.studio.id}`}&gt;{image.studio.name}&lt;/LinkCell&gt;\n      ) : \"-\",\n      performers: (image) =&gt; (\n        &lt;MultiValueCell\n          items={(image.performers || []).map((p) =&gt; ({\n            id: p.id,\n            name: p.name,\n            linkTo: `/performer/${p.id}`,\n          }))}\n        /&gt;\n      ),\n      tags: (image) =&gt; (\n        &lt;MultiValueCell\n          items={(image.tags || []).map((t) =&gt; ({\n            id: t.id,\n            name: t.name,\n            linkTo: `/tag/${t.id}`,\n          }))}\n        /&gt;\n      ),\n      filesize: (image) =&gt; formatFileSize(image.file?.size),\n      resolution: (image) =&gt; {\n        const w = image.file?.width;\n        const h = image.file?.height;\n        return w &amp;&amp; h ? `${w}x${h}` : \"-\";\n      },\n      path: (image) =&gt; (\n        &lt;span className=\"truncate text-xs\" title={image.path}&gt;\n          {image.path || \"-\"}\n        &lt;/span&gt;\n      ),\n    };\n    return imageRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Group cell renderers\n  if (entityType === \"group\") {\n    const groupRenderers = {\n      name: (group) =&gt; (\n        &lt;LinkCell to={`/collection/${group.id}`}&gt;{group.name}&lt;/LinkCell&gt;\n      ),\n      image: (group) =&gt; (\n        &lt;ThumbnailCell\n          src={group.front_image_path || group.image_path}\n          alt={group.name}\n          linkTo={`/collection/${group.id}`}\n        /&gt;\n      ),\n      rating: (group) =&gt; &lt;RatingCell rating={group.rating} /&gt;,\n      studio: (group) =&gt; group.studio ? (\n        &lt;LinkCell to={`/studio/${group.studio.id}`}&gt;{group.studio.name}&lt;/LinkCell&gt;\n      ) : \"-\",\n      date: (group) =&gt; formatDate(group.date),\n      duration: (group) =&gt; formatDuration(group.duration),\n      scene_count: (group) =&gt; group.scene_count ?? group.scenes?.length ?? \"-\",\n    };\n    return groupRenderers[columnId] || (() =&gt; \"-\");\n  }\n\n  // Fallback\n  return () =&gt; \"-\";\n};\n\nexport { RatingCell, FavoriteCell, ThumbnailCell, LinkCell, MultiValueCell };\nexport { formatDuration, formatFileSize, formatDate, calculateAge };\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/table/cellRenderers.jsx\ngit commit -m \"feat: add entity-specific cell renderers for table view\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-6-create-columnconfigpopover-component","title":"Task 6: Create ColumnConfigPopover Component","text":"<p>Files: - Create: <code>client/src/components/table/ColumnConfigPopover.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>// client/src/components/table/ColumnConfigPopover.jsx\n\nimport { useState, useRef, useEffect } from \"react\";\nimport {\n  LucideColumns3,\n  LucideChevronUp,\n  LucideChevronDown,\n  LucideChevronsUp,\n  LucideChevronsDown,\n  LucideX,\n} from \"lucide-react\";\nimport Button from \"../ui/Button.jsx\";\n\n/**\n * Popover for configuring table column visibility and order.\n *\n * @param {Object} props\n * @param {Array} props.allColumns - All available columns\n * @param {Array} props.visibleColumnIds - Currently visible column IDs\n * @param {Array} props.columnOrder - Current column order\n * @param {Function} props.onToggleColumn - Called with columnId to toggle visibility\n * @param {Function} props.onMoveColumn - Called with (columnId, direction)\n */\nconst ColumnConfigPopover = ({\n  allColumns,\n  visibleColumnIds,\n  columnOrder,\n  onToggleColumn,\n  onMoveColumn,\n}) =&gt; {\n  const [isOpen, setIsOpen] = useState(false);\n  const popoverRef = useRef(null);\n  const buttonRef = useRef(null);\n\n  // Close on click outside\n  useEffect(() =&gt; {\n    if (!isOpen) return;\n\n    const handleClickOutside = (event) =&gt; {\n      if (\n        popoverRef.current &amp;&amp;\n        !popoverRef.current.contains(event.target) &amp;&amp;\n        buttonRef.current &amp;&amp;\n        !buttonRef.current.contains(event.target)\n      ) {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () =&gt; document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [isOpen]);\n\n  // Get columns in order\n  const orderedColumns = columnOrder\n    .map((id) =&gt; allColumns.find((col) =&gt; col.id === id))\n    .filter(Boolean);\n\n  // Add any columns not in order (new columns)\n  const missingColumns = allColumns.filter(\n    (col) =&gt; !columnOrder.includes(col.id)\n  );\n  const allOrderedColumns = [...orderedColumns, ...missingColumns];\n\n  return (\n    &lt;div className=\"relative\"&gt;\n      &lt;Button\n        ref={buttonRef}\n        onClick={() =&gt; setIsOpen(!isOpen)}\n        variant=\"secondary\"\n        size=\"sm\"\n        icon={&lt;LucideColumns3 size={16} /&gt;}\n        title=\"Configure columns\"\n      &gt;\n        Columns\n      &lt;/Button&gt;\n\n      {isOpen &amp;&amp; (\n        &lt;div\n          ref={popoverRef}\n          className=\"absolute right-0 top-full mt-2 z-50 rounded-lg shadow-xl border w-[320px]\"\n          style={{\n            backgroundColor: \"var(--bg-card)\",\n            borderColor: \"var(--border-color)\",\n          }}\n        &gt;\n          {/* Header */}\n          &lt;div\n            className=\"flex items-center justify-between px-4 py-3 border-b\"\n            style={{ borderColor: \"var(--border-color)\" }}\n          &gt;\n            &lt;h3 className=\"font-medium\" style={{ color: \"var(--text-primary)\" }}&gt;\n              Columns\n            &lt;/h3&gt;\n            &lt;button\n              onClick={() =&gt; setIsOpen(false)}\n              className=\"p-1 rounded hover:bg-opacity-80\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              &lt;LucideX size={16} /&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n\n          {/* Column list */}\n          &lt;div className=\"max-h-[400px] overflow-y-auto py-2\"&gt;\n            {allOrderedColumns.map((column, index) =&gt; {\n              const isVisible = column.mandatory || visibleColumnIds.includes(column.id);\n              const isFirst = index === 0;\n              const isLast = index === allOrderedColumns.length - 1;\n\n              return (\n                &lt;div\n                  key={column.id}\n                  className=\"flex items-center gap-2 px-4 py-2 hover:bg-opacity-50\"\n                  style={{\n                    backgroundColor: isVisible ? \"transparent\" : \"var(--bg-secondary)\",\n                  }}\n                &gt;\n                  {/* Checkbox */}\n                  &lt;input\n                    type=\"checkbox\"\n                    checked={isVisible}\n                    disabled={column.mandatory}\n                    onChange={() =&gt; onToggleColumn(column.id)}\n                    className=\"w-4 h-4 rounded cursor-pointer disabled:cursor-not-allowed disabled:opacity-50\"\n                    style={{ accentColor: \"var(--accent-primary)\" }}\n                  /&gt;\n\n                  {/* Label */}\n                  &lt;span\n                    className={`flex-1 text-sm ${column.mandatory ? \"font-medium\" : \"\"}`}\n                    style={{\n                      color: isVisible ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                    }}\n                  &gt;\n                    {column.label}\n                    {column.mandatory &amp;&amp; (\n                      &lt;span className=\"text-xs ml-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n                        (required)\n                      &lt;/span&gt;\n                    )}\n                  &lt;/span&gt;\n\n                  {/* Move buttons */}\n                  &lt;div className=\"flex items-center gap-0.5\"&gt;\n                    &lt;button\n                      onClick={() =&gt; onMoveColumn(column.id, \"top\")}\n                      disabled={isFirst}\n                      className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                      title=\"Move to top\"\n                    &gt;\n                      &lt;LucideChevronsUp size={14} /&gt;\n                    &lt;/button&gt;\n                    &lt;button\n                      onClick={() =&gt; onMoveColumn(column.id, \"up\")}\n                      disabled={isFirst}\n                      className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                      title=\"Move up\"\n                    &gt;\n                      &lt;LucideChevronUp size={14} /&gt;\n                    &lt;/button&gt;\n                    &lt;button\n                      onClick={() =&gt; onMoveColumn(column.id, \"down\")}\n                      disabled={isLast}\n                      className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                      title=\"Move down\"\n                    &gt;\n                      &lt;LucideChevronDown size={14} /&gt;\n                    &lt;/button&gt;\n                    &lt;button\n                      onClick={() =&gt; onMoveColumn(column.id, \"bottom\")}\n                      disabled={isLast}\n                      className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                      title=\"Move to bottom\"\n                    &gt;\n                      &lt;LucideChevronsDown size={14} /&gt;\n                    &lt;/button&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ColumnConfigPopover;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/table/ColumnConfigPopover.jsx\ngit commit -m \"feat: add ColumnConfigPopover for column visibility and ordering\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-7-create-tableview-component","title":"Task 7: Create TableView Component","text":"<p>Files: - Create: <code>client/src/components/table/TableView.jsx</code></p> <p>Step 1: Create the main TableView component</p> <pre><code>// client/src/components/table/TableView.jsx\n\nimport { useState, useCallback } from \"react\";\nimport TableHeader from \"./TableHeader.jsx\";\nimport { getCellRenderer } from \"./cellRenderers.jsx\";\n\n/**\n * Main table view component for displaying entity lists.\n *\n * @param {Object} props\n * @param {Array} props.items - Array of entities to display\n * @param {Array} props.columns - Visible columns with metadata\n * @param {Object} props.sort - Current sort { field, direction }\n * @param {Function} props.onSort - Called with (field, direction) when sort changes\n * @param {Function} props.onHideColumn - Called with columnId when hiding via context menu\n * @param {string} props.entityType - Entity type for cell rendering\n * @param {boolean} props.isLoading - Show loading state\n */\nconst TableView = ({\n  items = [],\n  columns,\n  sort,\n  onSort,\n  onHideColumn,\n  entityType,\n  isLoading = false,\n}) =&gt; {\n  const [contextMenu, setContextMenu] = useState(null);\n\n  const handleColumnContextMenu = useCallback((columnId, event) =&gt; {\n    setContextMenu({\n      columnId,\n      x: event.clientX,\n      y: event.clientY,\n    });\n  }, []);\n\n  const handleHideColumn = useCallback(() =&gt; {\n    if (contextMenu?.columnId) {\n      onHideColumn?.(contextMenu.columnId);\n    }\n    setContextMenu(null);\n  }, [contextMenu, onHideColumn]);\n\n  const closeContextMenu = useCallback(() =&gt; {\n    setContextMenu(null);\n  }, []);\n\n  // Loading skeleton\n  if (isLoading) {\n    return (\n      &lt;div className=\"overflow-x-auto\"&gt;\n        &lt;table className=\"w-full min-w-max\"&gt;\n          &lt;TableHeader\n            columns={columns}\n            sort={sort}\n            onSort={onSort}\n            entityType={entityType}\n          /&gt;\n          &lt;tbody&gt;\n            {[...Array(10)].map((_, rowIndex) =&gt; (\n              &lt;tr\n                key={rowIndex}\n                className=\"border-b\"\n                style={{ borderColor: \"var(--border-color)\" }}\n              &gt;\n                {columns.map((column) =&gt; (\n                  &lt;td key={column.id} className={`px-3 py-2 ${column.width || \"\"}`}&gt;\n                    &lt;div\n                      className=\"h-4 rounded animate-pulse\"\n                      style={{ backgroundColor: \"var(--bg-secondary)\" }}\n                    /&gt;\n                  &lt;/td&gt;\n                ))}\n              &lt;/tr&gt;\n            ))}\n          &lt;/tbody&gt;\n        &lt;/table&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  // Empty state\n  if (items.length === 0) {\n    return (\n      &lt;div className=\"overflow-x-auto\"&gt;\n        &lt;table className=\"w-full min-w-max\"&gt;\n          &lt;TableHeader\n            columns={columns}\n            sort={sort}\n            onSort={onSort}\n            entityType={entityType}\n          /&gt;\n          &lt;tbody&gt;\n            &lt;tr&gt;\n              &lt;td\n                colSpan={columns.length}\n                className=\"px-3 py-8 text-center\"\n                style={{ color: \"var(--text-muted)\" }}\n              &gt;\n                No items found\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          &lt;/tbody&gt;\n        &lt;/table&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"overflow-x-auto\" onClick={closeContextMenu}&gt;\n      &lt;table className=\"w-full min-w-max\"&gt;\n        &lt;TableHeader\n          columns={columns}\n          sort={sort}\n          onSort={onSort}\n          onColumnContextMenu={handleColumnContextMenu}\n          entityType={entityType}\n        /&gt;\n        &lt;tbody&gt;\n          {items.map((item, rowIndex) =&gt; (\n            &lt;tr\n              key={item.id || rowIndex}\n              className=\"border-b hover:bg-opacity-50 transition-colors\"\n              style={{\n                borderColor: \"var(--border-color)\",\n                backgroundColor: rowIndex % 2 === 0 ? \"transparent\" : \"var(--bg-secondary)\",\n              }}\n            &gt;\n              {columns.map((column) =&gt; {\n                const renderer = getCellRenderer(column.id, entityType);\n                return (\n                  &lt;td\n                    key={column.id}\n                    className={`px-3 py-2 text-sm ${column.width || \"\"}`}\n                    style={{ color: \"var(--text-primary)\" }}\n                  &gt;\n                    {renderer(item)}\n                  &lt;/td&gt;\n                );\n              })}\n            &lt;/tr&gt;\n          ))}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n\n      {/* Context Menu */}\n      {contextMenu &amp;&amp; (\n        &lt;&gt;\n          &lt;div\n            className=\"fixed inset-0 z-40\"\n            onClick={closeContextMenu}\n          /&gt;\n          &lt;div\n            className=\"fixed z-50 py-1 rounded-md shadow-lg border min-w-[120px]\"\n            style={{\n              left: contextMenu.x,\n              top: contextMenu.y,\n              backgroundColor: \"var(--bg-card)\",\n              borderColor: \"var(--border-color)\",\n            }}\n          &gt;\n            &lt;button\n              onClick={handleHideColumn}\n              className=\"w-full px-4 py-2 text-left text-sm hover:bg-opacity-80\"\n              style={{\n                color: \"var(--text-primary)\",\n                backgroundColor: \"transparent\",\n              }}\n              onMouseEnter={(e) =&gt; {\n                e.currentTarget.style.backgroundColor = \"var(--bg-secondary)\";\n              }}\n              onMouseLeave={(e) =&gt; {\n                e.currentTarget.style.backgroundColor = \"transparent\";\n              }}\n            &gt;\n              Hide column\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default TableView;\n</code></pre> <p>Step 2: Create index export file</p> <pre><code>// client/src/components/table/index.js\n\nexport { default as TableView } from \"./TableView.jsx\";\nexport { default as TableHeader } from \"./TableHeader.jsx\";\nexport { default as MultiValueCell } from \"./MultiValueCell.jsx\";\nexport { default as ColumnConfigPopover } from \"./ColumnConfigPopover.jsx\";\nexport * from \"./cellRenderers.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/table/TableView.jsx client/src/components/table/index.js\ngit commit -m \"feat: add TableView component\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-8-add-table-to-viewmodetoggle","title":"Task 8: Add \"table\" to ViewModeToggle","text":"<p>Files: - Modify: <code>client/src/components/ui/ViewModeToggle.jsx</code></p> <p>Step 1: Add table icon to MODE_ICONS</p> <pre><code>// In ViewModeToggle.jsx, add LucideList import and table mode\n\nimport { LucideGrid2X2, LucideSquare, LucideNetwork, LucideList } from \"lucide-react\";\n\n// Update MODE_ICONS to include table\nconst MODE_ICONS = {\n  grid: LucideGrid2X2,\n  wall: LucideSquare,\n  hierarchy: LucideNetwork,\n  table: LucideList,\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/ui/ViewModeToggle.jsx\ngit commit -m \"feat: add table icon to ViewModeToggle\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-9-extend-filterpresets-to-save-table-columns","title":"Task 9: Extend FilterPresets to Save Table Columns","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterPresets.jsx</code></p> <p>Step 1: Add tableColumns to saved preset data</p> <p>In <code>FilterPresets.jsx</code>, update the <code>handleSavePreset</code> function to include <code>tableColumns</code> prop:</p> <pre><code>// Add tableColumns prop to component\nconst FilterPresets = ({\n  artifactType,\n  context,\n  currentFilters,\n  permanentFilters = {},\n  currentSort,\n  currentDirection,\n  currentViewMode = \"grid\",\n  currentZoomLevel = \"medium\",\n  currentTableColumns = null, // NEW: { visible: [], order: [] }\n  onLoadPreset,\n}) =&gt; {\n</code></pre> <p>Update <code>handleSavePreset</code>:</p> <pre><code>await apiPost(\"/user/filter-presets\", {\n  artifactType,\n  context: effectiveContext,\n  name: presetName,\n  filters: filtersToSave,\n  sort: currentSort,\n  direction: currentDirection,\n  viewMode: currentViewMode,\n  zoomLevel: currentZoomLevel,\n  tableColumns: currentViewMode === \"table\" ? currentTableColumns : null, // NEW\n  setAsDefault,\n});\n</code></pre> <p>Update <code>handleLoadPreset</code>:</p> <pre><code>onLoadPreset({\n  filters: mergedFilters,\n  sort: preset.sort,\n  direction: preset.direction,\n  viewMode: preset.viewMode || \"grid\",\n  zoomLevel: preset.zoomLevel || \"medium\",\n  tableColumns: preset.tableColumns || null, // NEW\n});\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/ui/FilterPresets.jsx\ngit commit -m \"feat: add tableColumns support to FilterPresets\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-10-update-usefilterstate-to-handle-table-columns","title":"Task 10: Update useFilterState to Handle Table Columns","text":"<p>Files: - Modify: <code>client/src/hooks/useFilterState.js</code></p> <p>Step 1: Add tableColumns state and actions</p> <p>Add state for table columns:</p> <pre><code>const [tableColumns, setTableColumnsState] = useState(null);\n</code></pre> <p>Update <code>loadPreset</code> callback to handle table columns:</p> <pre><code>const loadPreset = useCallback((preset) =&gt; {\n  const newFilters = { ...permanentFilters, ...preset.filters };\n  const newViewMode = preset.viewMode || \"grid\";\n  const newZoomLevel = preset.zoomLevel || \"medium\";\n  const newTableColumns = preset.tableColumns || null;\n\n  setFiltersState(newFilters);\n  setSortState({ field: preset.sort, direction: preset.direction });\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  setViewModeState(newViewMode);\n  setZoomLevelState(newZoomLevel);\n  setTableColumnsState(newTableColumns);\n\n  syncToUrlParams({\n    filters: newFilters,\n    sort: { field: preset.sort, direction: preset.direction },\n    pagination: { ...pagination, page: 1 },\n    searchText,\n    viewMode: newViewMode,\n    zoomLevel: newZoomLevel,\n  });\n}, [permanentFilters, pagination, searchText, syncToUrlParams]);\n</code></pre> <p>Add <code>setTableColumns</code> action:</p> <pre><code>const setTableColumns = useCallback((columns) =&gt; {\n  setTableColumnsState(columns);\n}, []);\n</code></pre> <p>Return new state and action:</p> <pre><code>return {\n  // ... existing returns\n  tableColumns,\n  setTableColumns,\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/hooks/useFilterState.js\ngit commit -m \"feat: add tableColumns support to useFilterState\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-11-update-server-to-store-table-columns-in-presets","title":"Task 11: Update Server to Store Table Columns in Presets","text":"<p>Files: - Modify: <code>server/controllers/user/filterPresets.ts</code> - Modify: <code>server/types/api/user.ts</code> (if exists)</p> <p>Step 1: Update preset type to include tableColumns</p> <p>In the preset handler, accept and store <code>tableColumns</code>:</p> <pre><code>// In the POST handler for filter presets\nconst { tableColumns } = req.body;\n\n// Store with preset\nconst preset = {\n  // ... existing fields\n  tableColumns: tableColumns || null,\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/controllers/user/filterPresets.ts\ngit commit -m \"feat: store tableColumns in filter presets\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-12-add-table-column-defaults-to-user-settings","title":"Task 12: Add Table Column Defaults to User Settings","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code> - Create migration - Modify: <code>server/controllers/user/settings.ts</code></p> <p>Step 1: Add tableColumnDefaults field to User model</p> <pre><code>model User {\n  // ... existing fields\n  tableColumnDefaults Json? // { scene: { visible: [], order: [] }, performer: {...} }\n}\n</code></pre> <p>Step 2: Create migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add_table_column_defaults</code></p> <p>Step 3: Update settings controller</p> <p>In GET <code>/user/settings</code>:</p> <pre><code>// Return tableColumnDefaults\nreturn {\n  settings: {\n    // ... existing\n    tableColumnDefaults: user.tableColumnDefaults,\n  },\n};\n</code></pre> <p>In PUT <code>/user/settings</code>:</p> <pre><code>// Accept tableColumnDefaults\nif (req.body.tableColumnDefaults !== undefined) {\n  await prisma.user.update({\n    where: { id: userId },\n    data: { tableColumnDefaults: req.body.tableColumnDefaults },\n  });\n}\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/prisma/schema.prisma server/controllers/user/settings.ts\ngit commit -m \"feat: add tableColumnDefaults to user settings\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-13-add-table-column-settings-to-customizationtab","title":"Task 13: Add Table Column Settings to CustomizationTab","text":"<p>Files: - Create: <code>client/src/components/settings/TableColumnSettings.jsx</code> - Modify: <code>client/src/components/settings/tabs/CustomizationTab.jsx</code></p> <p>Step 1: Create TableColumnSettings component</p> <pre><code>// client/src/components/settings/TableColumnSettings.jsx\n\nimport { useState, useEffect } from \"react\";\nimport {\n  LucideChevronUp,\n  LucideChevronDown,\n  LucideChevronsUp,\n  LucideChevronsDown,\n} from \"lucide-react\";\nimport {\n  getColumnsForEntity,\n  getDefaultVisibleColumns,\n  getDefaultColumnOrder,\n} from \"../../config/tableColumns.js\";\nimport Button from \"../ui/Button.jsx\";\n\nconst ENTITY_TYPES = [\n  { id: \"scene\", label: \"Scenes\" },\n  { id: \"performer\", label: \"Performers\" },\n  { id: \"studio\", label: \"Studios\" },\n  { id: \"tag\", label: \"Tags\" },\n  { id: \"gallery\", label: \"Galleries\" },\n  { id: \"image\", label: \"Images\" },\n  { id: \"group\", label: \"Groups\" },\n];\n\n/**\n * Settings component for configuring default table columns per entity type.\n */\nconst TableColumnSettings = ({ tableColumnDefaults, onSave }) =&gt; {\n  const [activeEntity, setActiveEntity] = useState(\"scene\");\n  const [localDefaults, setLocalDefaults] = useState(tableColumnDefaults || {});\n  const [hasChanges, setHasChanges] = useState(false);\n\n  // Get current entity's columns config\n  const allColumns = getColumnsForEntity(activeEntity);\n  const currentConfig = localDefaults[activeEntity] || {\n    visible: getDefaultVisibleColumns(activeEntity),\n    order: getDefaultColumnOrder(activeEntity),\n  };\n\n  const handleToggleColumn = (columnId) =&gt; {\n    const column = allColumns.find((c) =&gt; c.id === columnId);\n    if (column?.mandatory) return;\n\n    const newVisible = currentConfig.visible.includes(columnId)\n      ? currentConfig.visible.filter((id) =&gt; id !== columnId)\n      : [...currentConfig.visible, columnId];\n\n    setLocalDefaults((prev) =&gt; ({\n      ...prev,\n      [activeEntity]: {\n        ...currentConfig,\n        visible: newVisible,\n      },\n    }));\n    setHasChanges(true);\n  };\n\n  const handleMoveColumn = (columnId, direction) =&gt; {\n    const currentIndex = currentConfig.order.indexOf(columnId);\n    if (currentIndex === -1) return;\n\n    let newIndex;\n    switch (direction) {\n      case \"top\":\n        newIndex = 0;\n        break;\n      case \"up\":\n        newIndex = Math.max(0, currentIndex - 1);\n        break;\n      case \"down\":\n        newIndex = Math.min(currentConfig.order.length - 1, currentIndex + 1);\n        break;\n      case \"bottom\":\n        newIndex = currentConfig.order.length - 1;\n        break;\n      default:\n        return;\n    }\n\n    if (newIndex === currentIndex) return;\n\n    const newOrder = [...currentConfig.order];\n    newOrder.splice(currentIndex, 1);\n    newOrder.splice(newIndex, 0, columnId);\n\n    setLocalDefaults((prev) =&gt; ({\n      ...prev,\n      [activeEntity]: {\n        ...currentConfig,\n        order: newOrder,\n      },\n    }));\n    setHasChanges(true);\n  };\n\n  const handleSave = async () =&gt; {\n    await onSave(localDefaults);\n    setHasChanges(false);\n  };\n\n  const handleReset = () =&gt; {\n    setLocalDefaults((prev) =&gt; ({\n      ...prev,\n      [activeEntity]: {\n        visible: getDefaultVisibleColumns(activeEntity),\n        order: getDefaultColumnOrder(activeEntity),\n      },\n    }));\n    setHasChanges(true);\n  };\n\n  // Get columns in current order\n  const orderedColumns = currentConfig.order\n    .map((id) =&gt; allColumns.find((col) =&gt; col.id === id))\n    .filter(Boolean);\n\n  // Add any missing columns\n  const missingColumns = allColumns.filter(\n    (col) =&gt; !currentConfig.order.includes(col.id)\n  );\n  const allOrderedColumns = [...orderedColumns, ...missingColumns];\n\n  return (\n    &lt;div&gt;\n      &lt;h3\n        className=\"text-lg font-semibold mb-4\"\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        Table View Default Columns\n      &lt;/h3&gt;\n      &lt;p className=\"text-sm mb-4\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Configure which columns are shown by default when switching to table view.\n      &lt;/p&gt;\n\n      {/* Entity type tabs */}\n      &lt;div className=\"flex flex-wrap gap-2 mb-4\"&gt;\n        {ENTITY_TYPES.map((entity) =&gt; (\n          &lt;button\n            key={entity.id}\n            onClick={() =&gt; setActiveEntity(entity.id)}\n            className={`px-3 py-1.5 text-sm rounded-md transition-colors ${\n              activeEntity === entity.id ? \"font-medium\" : \"\"\n            }`}\n            style={{\n              backgroundColor:\n                activeEntity === entity.id\n                  ? \"var(--accent-primary)\"\n                  : \"var(--bg-secondary)\",\n              color: activeEntity === entity.id ? \"white\" : \"var(--text-secondary)\",\n            }}\n          &gt;\n            {entity.label}\n          &lt;/button&gt;\n        ))}\n      &lt;/div&gt;\n\n      {/* Column list */}\n      &lt;div\n        className=\"border rounded-lg overflow-hidden mb-4\"\n        style={{ borderColor: \"var(--border-color)\" }}\n      &gt;\n        {allOrderedColumns.map((column, index) =&gt; {\n          const isVisible =\n            column.mandatory || currentConfig.visible.includes(column.id);\n          const isFirst = index === 0;\n          const isLast = index === allOrderedColumns.length - 1;\n\n          return (\n            &lt;div\n              key={column.id}\n              className=\"flex items-center gap-2 px-4 py-2 border-b last:border-b-0\"\n              style={{\n                borderColor: \"var(--border-color)\",\n                backgroundColor: isVisible ? \"transparent\" : \"var(--bg-secondary)\",\n              }}\n            &gt;\n              &lt;input\n                type=\"checkbox\"\n                checked={isVisible}\n                disabled={column.mandatory}\n                onChange={() =&gt; handleToggleColumn(column.id)}\n                className=\"w-4 h-4 rounded cursor-pointer disabled:cursor-not-allowed disabled:opacity-50\"\n                style={{ accentColor: \"var(--accent-primary)\" }}\n              /&gt;\n\n              &lt;span\n                className={`flex-1 text-sm ${column.mandatory ? \"font-medium\" : \"\"}`}\n                style={{\n                  color: isVisible ? \"var(--text-primary)\" : \"var(--text-muted)\",\n                }}\n              &gt;\n                {column.label}\n                {column.mandatory &amp;&amp; (\n                  &lt;span className=\"text-xs ml-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n                    (required)\n                  &lt;/span&gt;\n                )}\n              &lt;/span&gt;\n\n              &lt;div className=\"flex items-center gap-0.5\"&gt;\n                &lt;button\n                  onClick={() =&gt; handleMoveColumn(column.id, \"top\")}\n                  disabled={isFirst}\n                  className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                  style={{ color: \"var(--text-secondary)\" }}\n                &gt;\n                  &lt;LucideChevronsUp size={14} /&gt;\n                &lt;/button&gt;\n                &lt;button\n                  onClick={() =&gt; handleMoveColumn(column.id, \"up\")}\n                  disabled={isFirst}\n                  className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                  style={{ color: \"var(--text-secondary)\" }}\n                &gt;\n                  &lt;LucideChevronUp size={14} /&gt;\n                &lt;/button&gt;\n                &lt;button\n                  onClick={() =&gt; handleMoveColumn(column.id, \"down\")}\n                  disabled={isLast}\n                  className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                  style={{ color: \"var(--text-secondary)\" }}\n                &gt;\n                  &lt;LucideChevronDown size={14} /&gt;\n                &lt;/button&gt;\n                &lt;button\n                  onClick={() =&gt; handleMoveColumn(column.id, \"bottom\")}\n                  disabled={isLast}\n                  className=\"p-1 rounded hover:bg-opacity-80 disabled:opacity-30 disabled:cursor-not-allowed\"\n                  style={{ color: \"var(--text-secondary)\" }}\n                &gt;\n                  &lt;LucideChevronsDown size={14} /&gt;\n                &lt;/button&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          );\n        })}\n      &lt;/div&gt;\n\n      {/* Actions */}\n      &lt;div className=\"flex justify-between\"&gt;\n        &lt;Button variant=\"secondary\" size=\"sm\" onClick={handleReset}&gt;\n          Reset to Defaults\n        &lt;/Button&gt;\n        &lt;Button\n          variant=\"primary\"\n          size=\"sm\"\n          onClick={handleSave}\n          disabled={!hasChanges}\n        &gt;\n          Save Changes\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default TableColumnSettings;\n</code></pre> <p>Step 2: Add to CustomizationTab</p> <p>Import and render <code>TableColumnSettings</code> in <code>CustomizationTab.jsx</code>:</p> <pre><code>import TableColumnSettings from \"../TableColumnSettings.jsx\";\n\n// In component, add state and loader\nconst [tableColumnDefaults, setTableColumnDefaults] = useState({});\n\n// In loadSettings\nsetTableColumnDefaults(settings.tableColumnDefaults || {});\n\n// Add save handler\nconst saveTableColumnDefaults = async (newDefaults) =&gt; {\n  try {\n    await api.put(\"/user/settings\", {\n      tableColumnDefaults: newDefaults,\n    });\n    setTableColumnDefaults(newDefaults);\n    showSuccess(\"Table column defaults saved!\");\n  } catch (err) {\n    showError(err.response?.data?.error || \"Failed to save table column defaults\");\n  }\n};\n\n// In render, add section after View Preferences\n&lt;div\n  className=\"p-6 rounded-lg border\"\n  style={{\n    backgroundColor: \"var(--bg-card)\",\n    borderColor: \"var(--border-color)\",\n  }}\n&gt;\n  &lt;TableColumnSettings\n    tableColumnDefaults={tableColumnDefaults}\n    onSave={saveTableColumnDefaults}\n  /&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/TableColumnSettings.jsx client/src/components/settings/tabs/CustomizationTab.jsx\ngit commit -m \"feat: add table column settings to customization tab\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-14-integrate-tableview-into-entity-pages","title":"Task 14: Integrate TableView into Entity Pages","text":"<p>Files: - Modify: <code>client/src/components/pages/Performers.jsx</code> (example - repeat pattern for others)</p> <p>Step 1: Add table view mode option and render TableView</p> <p>This task shows the pattern for one page. Apply the same pattern to: - <code>Performers.jsx</code> - <code>Studios.jsx</code> - <code>Tags.jsx</code> - <code>Groups.jsx</code> - <code>Galleries.jsx</code> - <code>Images.jsx</code> - <code>SceneSearch.jsx</code> (for scenes)</p> <p>Example for Performers.jsx:</p> <pre><code>// Add imports\nimport { TableView, ColumnConfigPopover } from \"../table/index.js\";\nimport { useTableColumns } from \"../../hooks/useTableColumns.js\";\n\n// In component, add table modes to ViewModeToggle\nconst viewModes = [\n  { id: \"grid\", label: \"Grid view\" },\n  { id: \"table\", label: \"Table view\" },\n];\n\n// Add useTableColumns hook\nconst {\n  allColumns,\n  visibleColumns,\n  visibleColumnIds,\n  columnOrder,\n  toggleColumn,\n  hideColumn,\n  moveColumn,\n  getColumnConfig,\n  applyPresetColumns,\n} = useTableColumns(\"performer\", {\n  presetColumns: tableColumns, // from useFilterState\n  userDefaultColumns: userTableColumnDefaults?.performer,\n});\n\n// Update preset loading to apply table columns\nconst handleLoadPreset = (preset) =&gt; {\n  loadPreset(preset);\n  if (preset.tableColumns) {\n    applyPresetColumns(preset.tableColumns);\n  }\n};\n\n// In toolbar, show Columns button when in table view\n{viewMode === \"table\" &amp;&amp; (\n  &lt;ColumnConfigPopover\n    allColumns={allColumns}\n    visibleColumnIds={visibleColumnIds}\n    columnOrder={columnOrder}\n    onToggleColumn={toggleColumn}\n    onMoveColumn={moveColumn}\n  /&gt;\n)}\n\n// In render, conditionally show table or grid\n{viewMode === \"table\" ? (\n  &lt;TableView\n    items={data?.findPerformers?.performers || []}\n    columns={visibleColumns}\n    sort={sort}\n    onSort={setSort}\n    onHideColumn={hideColumn}\n    entityType=\"performer\"\n    isLoading={isLoading}\n  /&gt;\n) : (\n  // Existing grid rendering\n)}\n</code></pre> <p>Step 2: Commit after updating all pages</p> <pre><code>git add client/src/components/pages/*.jsx client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"feat: integrate TableView into all entity list pages\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-15-update-searchcontrols-to-pass-table-columns-to-presets","title":"Task 15: Update SearchControls to Pass Table Columns to Presets","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Add currentTableColumns prop and pass to FilterPresets</p> <p>In SearchControls, accept <code>currentTableColumns</code> prop and pass it to <code>FilterPresets</code>:</p> <pre><code>// Add prop\nconst SearchControls = ({\n  // ... existing props\n  currentTableColumns = null,\n}) =&gt; {\n\n// Pass to FilterPresets\n&lt;FilterPresets\n  // ... existing props\n  currentTableColumns={currentTableColumns}\n/&gt;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: pass table columns to FilterPresets from SearchControls\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-16-manual-testing-checklist","title":"Task 16: Manual Testing Checklist","text":"<p>No code changes - testing only</p> <p>Step 1: Test table view on Performers page</p> <ol> <li>Navigate to /performers</li> <li>Click table view mode button</li> <li>Verify table renders with columns</li> <li>Click column headers to sort</li> <li>Verify sort indicator appears</li> <li>Verify sort dropdown syncs</li> </ol> <p>Step 2: Test column configuration</p> <ol> <li>Click \"Columns\" button</li> <li>Toggle column visibility</li> <li>Use arrow buttons to reorder</li> <li>Right-click header to hide column</li> <li>Verify changes persist in view</li> </ol> <p>Step 3: Test multi-value cells</p> <ol> <li>Find a performer with multiple scenes/tags</li> <li>Verify \"+N more\" appears</li> <li>Click \"+N more\" to see popover</li> <li>Click item in popover to navigate</li> </ol> <p>Step 4: Test presets</p> <ol> <li>Configure columns in table view</li> <li>Save as preset</li> <li>Switch to grid view</li> <li>Load preset</li> <li>Verify table view with columns restored</li> </ol> <p>Step 5: Test settings</p> <ol> <li>Go to Settings &gt; Customization</li> <li>Configure table column defaults</li> <li>Save changes</li> <li>Navigate to entity page</li> <li>Switch to table view</li> <li>Verify default columns match settings</li> </ol> <p>Step 6: Test all entity types</p> <p>Repeat basic table view test for: - Scenes - Studios - Tags - Groups - Galleries - Images</p> <p>Step 7: Commit any fixes</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during testing\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#task-17-final-cleanup-and-documentation","title":"Task 17: Final Cleanup and Documentation","text":"<p>Files: - Update: <code>docs/plans/2025-01-13-table-list-view-design.md</code> (mark as implemented)</p> <p>Step 1: Update design doc status</p> <p>Change status from \"Approved\" to \"Implemented\"</p> <p>Step 2: Final commit</p> <pre><code>git add docs/plans/2025-01-13-table-list-view-design.md\ngit commit -m \"docs: mark table view design as implemented\"\n</code></pre>"},{"location":"plans/2025-01-13-table-list-view-implementation/#summary","title":"Summary","text":"<p>This plan implements the table/list view feature across 17 tasks:</p> <ol> <li>Tasks 1-7: Core infrastructure (column config, hook, components)</li> <li>Tasks 8-11: Integration points (ViewModeToggle, presets, filter state)</li> <li>Tasks 12-13: Settings persistence (database, customization UI)</li> <li>Task 14: Page integration (repeat pattern for all entity pages)</li> <li>Tasks 15-17: Finishing touches (SearchControls, testing, docs)</li> </ol> <p>Each task is atomic and commits independently. The TDD approach isn't strictly followed here because this is primarily UI work, but each component is built incrementally and tested as part of the integration tasks.</p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/","title":"Wall View Refinements Design","text":"<p>Status: Ready for Implementation Branch: <code>feature/wall-view-refinements</code></p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#overview","title":"Overview","text":"<p>Two issues to address with the Wall/Mosaic view:</p> <ol> <li>Toolbar button visual inconsistency - ViewModeToggle and ZoomSlider buttons have different sizing/alignment than other toolbar controls</li> <li>Missing context-aware settings - Wall preview behavior setting exists in Settings &gt; Playback but should be accessible from toolbar and moved to Customization</li> </ol>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#design-decisions","title":"Design Decisions","text":"<ul> <li>Settings cog UI: Popover/panel (not dropdown or modal)</li> <li>Cog position: After zoom slider in toolbar</li> <li>Setting persistence: Persistent (saves to user settings, same as Settings page)</li> <li>Extensibility: Config-driven popover for easy future additions</li> <li>Settings location: Move wallPlayback and preferredPreviewQuality from Playback to Customization tab</li> </ul>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#1-toolbar-button-visual-consistency","title":"1. Toolbar Button Visual Consistency","text":""},{"location":"plans/2025-01-13-wall-view-refinements-design/#problem","title":"Problem","text":"<ul> <li><code>ViewModeToggle</code> uses <code>px-3 py-1.5</code> with 18px icons</li> <li><code>ZoomSlider</code> uses <code>px-2.5 py-1.5 text-xs</code> with text labels</li> <li><code>Button</code> (sm) uses <code>px-2 py-1.5</code> with 22px icons</li> <li>Inconsistent heights and vertical alignment</li> </ul>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#solution","title":"Solution","text":"<p>Standardize both components to match Button's <code>sm</code> size: - Padding: <code>px-2 py-1.5</code> - Icon size: 16px (slightly smaller than Button's 22px to account for no text) - Add explicit height matching</p> <p>Files: <code>ViewModeToggle.jsx</code>, <code>ZoomSlider.jsx</code></p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#2-settings-page-reorganization","title":"2. Settings Page Reorganization","text":""},{"location":"plans/2025-01-13-wall-view-refinements-design/#move-to-customizationtab","title":"Move to CustomizationTab","text":"<ol> <li>Wall View Preview Behavior (wallPlayback)</li> <li>Scene Card Preview Quality (preferredPreviewQuality)</li> </ol>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#new-customizationtab-structure","title":"New CustomizationTab Structure","text":"<pre><code>\u250c\u2500 View Preferences (NEW) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Scene Card Preview Quality: [sprite \u25be]          \u2502\n\u2502  Wall View Preview Behavior: [autoplay \u25be]        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500 Measurement Units \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  (existing)                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500 Navigation Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  (existing)                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500 Carousel Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  (existing)                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#playbacktab-keeps","title":"PlaybackTab Keeps","text":"<ul> <li>Preferred Quality</li> <li>Preferred Playback Mode</li> <li>Chromecast/AirPlay toggle</li> <li>Minimum Play Percent</li> </ul> <p>Files: <code>CustomizationTab.jsx</code>, <code>PlaybackTab.jsx</code></p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#3-context-aware-settings-cog","title":"3. Context-Aware Settings Cog","text":""},{"location":"plans/2025-01-13-wall-view-refinements-design/#component-contextsettings","title":"Component: ContextSettings","text":"<p>A toolbar component that: 1. Renders a Settings cog icon 2. Opens a popover panel when clicked 3. Receives config array of settings relevant to current page/view 4. Persists changes to user settings via API 5. Disabled (grayed out) when no context-specific settings apply</p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#config-structure","title":"Config Structure","text":"<pre><code>const contextSettings = [\n  {\n    key: \"wallPlayback\",\n    label: \"Preview Behavior\",\n    type: \"select\",\n    options: [\n      { value: \"autoplay\", label: \"Autoplay All\" },\n      { value: \"hover\", label: \"Play on Hover\" },\n      { value: \"static\", label: \"Static Thumbnails\" },\n    ],\n  },\n];\n</code></pre>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#behavior","title":"Behavior","text":"<ul> <li>Settings available: Normal styling, click opens popover</li> <li>No settings: Grayed out, tooltip \"No view-specific settings available\"</li> <li>Changes: Save immediately on selection, brief toast confirms</li> </ul>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#popover-design","title":"Popover Design","text":"<ul> <li>~250px wide panel anchored to cog</li> <li>Settings rendered based on type (select, toggle, etc.)</li> <li>No save button (auto-save on change)</li> </ul> <p>Files: New <code>ContextSettings.jsx</code></p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#4-toolbar-two-row-layout","title":"4. Toolbar Two-Row Layout","text":""},{"location":"plans/2025-01-13-wall-view-refinements-design/#problem_1","title":"Problem","text":"<p>Toolbar crowded with: Search, Sort, Direction, Filters, Presets, View Mode, Zoom, Settings Cog</p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#solution_1","title":"Solution","text":"<p>Split into two rows with logical grouping:</p> <pre><code>Row 1: [Search Input........................] [Sort \u25be] [\u2193] [Filters]\nRow 2: [Filter Presets \u25be] [Grid|Wall] [S|M|L] [\u2699]\n</code></pre> <ul> <li>Row 1: \"What to show\" - search and filter controls</li> <li>Row 2: \"How to show it\" - view and display controls</li> </ul>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#responsive-behavior","title":"Responsive Behavior","text":"<ul> <li>Desktop (\u2265768px): Two rows as shown</li> <li>Mobile (&lt;768px): Stack vertically, controls wrap naturally</li> </ul> <p>Files: <code>SearchControls.jsx</code></p>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#implementation-order","title":"Implementation Order","text":"<ol> <li>Fix toolbar button consistency (ViewModeToggle, ZoomSlider)</li> <li>Move settings to CustomizationTab, remove from PlaybackTab</li> <li>Create ContextSettings component</li> <li>Reorganize SearchControls into two rows and integrate ContextSettings</li> </ol>"},{"location":"plans/2025-01-13-wall-view-refinements-design/#files-summary","title":"Files Summary","text":"<p>Modify: - <code>client/src/components/ui/ViewModeToggle.jsx</code> - <code>client/src/components/ui/ZoomSlider.jsx</code> - <code>client/src/components/ui/SearchControls.jsx</code> - <code>client/src/components/settings/tabs/CustomizationTab.jsx</code> - <code>client/src/components/settings/tabs/PlaybackTab.jsx</code></p> <p>Create: - <code>client/src/components/ui/ContextSettings.jsx</code></p> <p>No backend changes needed - wallPlayback and preferredPreviewQuality already exist in user settings schema.</p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/","title":"Filter Chip Interaction Improvements","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#overview","title":"Overview","text":"<p>Two UX improvements to filter interactions:</p> <ol> <li>Clickable filter chips - Clicking a filter chip opens the Filter Panel and highlights the corresponding filter control</li> <li>Clear All button in SearchableSelect - Add a \"Clear All\" button to multi-select dropdowns</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-1-clickable-filter-chips","title":"Feature 1: Clickable Filter Chips","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior","title":"Current Behavior","text":"<ul> <li>Filter chips display active filters with an X button to remove</li> <li>Only the X button is interactive; the chip body does nothing</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior","title":"New Behavior","text":"<ul> <li>Clicking anywhere on a chip (except X) opens the Filter Panel</li> <li>The corresponding filter control scrolls into view</li> <li>A border-pulse animation highlights the control for 1.5 seconds</li> <li>If the filter is in a collapsed section, that section expands first</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation","title":"Implementation","text":"<p>ActiveFilterChips.jsx: - Add <code>onChipClick</code> prop that receives the filter key - Make chip body clickable with <code>cursor-pointer</code> - X button uses <code>stopPropagation</code> to prevent triggering chip click</p> <p>SearchControls.jsx: - Add state: <code>highlightedFilterKey</code> (string | null) - Add handler <code>handleFilterChipClick(filterKey)</code>:   1. Open filter panel   2. Expand collapsed section if needed   3. Set <code>highlightedFilterKey</code> - Clear highlight after 1.5s via useEffect timeout - Pass <code>highlightedFilterKey</code> to FilterPanel</p> <p>FilterControls.jsx (FilterPanel): - Accept <code>highlightedFilterKey</code> prop - Store refs for each FilterControl by key - When <code>highlightedFilterKey</code> changes:   - Scroll the ref into view   - Apply <code>filter-highlight</code> CSS class</p> <p>CSS Animation: <pre><code>@keyframes filter-highlight-pulse {\n  0% {\n    border-color: var(--accent-primary);\n    box-shadow: 0 0 0 2px var(--accent-primary);\n  }\n  100% {\n    border-color: var(--border-color);\n    box-shadow: none;\n  }\n}\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n}\n</code></pre></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-2-searchableselect-clear-all-button","title":"Feature 2: SearchableSelect Clear All Button","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior_1","title":"Current Behavior","text":"<ul> <li>Multi-select shows selected items as chips inside the trigger area</li> <li>Each chip has an X to remove that individual item</li> <li>No way to clear all selections at once without opening dropdown</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior_1","title":"New Behavior","text":"<ul> <li>A \"Clear All\" X button appears next to the chevron when there are selections</li> <li>Clicking it clears all selections without opening the dropdown</li> <li>Visually distinct from individual chip X buttons (slightly larger)</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation_1","title":"Implementation","text":"<p>SearchableSelect.jsx:</p> <p>New handler: <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre></p> <p>Updated trigger layout: - From: <code>[selected chips] [chevron]</code> - To: <code>[selected chips] [clear-all X] [chevron]</code></p> <p>Clear button: - Only visible when <code>selectedItems.length &gt; 0</code> - <code>LucideX</code> icon at size 16 (vs 14 for chip X buttons) - Subtle gray color, darkens on hover - <code>aria-label=\"Clear all selections\"</code></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>client/src/components/ui/ActiveFilterChips.jsx</code> - Add click handler to chips</li> <li><code>client/src/components/ui/SearchControls.jsx</code> - Add highlight state and chip click handler</li> <li><code>client/src/components/ui/FilterControls.jsx</code> - Add highlight styling and scroll behavior</li> <li><code>client/src/components/ui/SearchableSelect.jsx</code> - Add Clear All button</li> <li><code>client/src/index.css</code> (or appropriate CSS file) - Add highlight animation</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/","title":"Filter Chip Interaction Improvements - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add clickable filter chips that highlight their corresponding filter control, and add a \"Clear All\" button to SearchableSelect dropdowns.</p> <p>Architecture: Two independent features: (1) Filter chips get click handlers that open the filter panel, expand collapsed sections, scroll to the control, and apply a pulse animation. (2) SearchableSelect gets a clear-all button in the trigger area.</p> <p>Tech Stack: React, Tailwind CSS, Lucide React icons, Vitest for testing</p>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-1-add-css-animation-for-filter-highlight","title":"Task 1: Add CSS Animation for Filter Highlight","text":"<p>Files: - Modify: <code>client/src/index.css</code></p> <p>Step 1: Add the highlight pulse animation</p> <p>Add at the end of <code>client/src/index.css</code>:</p> <pre><code>/* Filter control highlight animation - used when clicking filter chips */\n@keyframes filter-highlight-pulse {\n  0% {\n    box-shadow: 0 0 0 3px var(--accent-primary);\n  }\n  100% {\n    box-shadow: none;\n  }\n}\n\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n  border-radius: 0.375rem;\n}\n</code></pre> <p>Step 2: Verify the CSS is valid</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds without CSS errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/index.css\ngit commit -m \"feat: add filter highlight pulse animation\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-2-add-clear-all-button-to-searchableselect","title":"Task 2: Add Clear All Button to SearchableSelect","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx</code> - Create: <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code></p> <p>Step 2.1: Write the failing test for clear all functionality</p> <p>Create <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport SearchableSelect from \"../SearchableSelect\";\n\n// Mock the API\nvi.mock(\"../../../services/api.js\", () =&gt; ({\n  libraryApi: {\n    findPerformers: vi.fn().mockResolvedValue({ findPerformers: { performers: [] } }),\n    findPerformersMinimal: vi.fn().mockResolvedValue([]),\n  },\n}));\n\n// Mock the filter cache\nvi.mock(\"../../../utils/filterCache.js\", () =&gt; ({\n  getCache: vi.fn().mockReturnValue(null),\n  setCache: vi.fn(),\n}));\n\ndescribe(\"SearchableSelect\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(SearchableSelect).toBeDefined();\n    expect(typeof SearchableSelect).toBe(\"function\");\n  });\n\n  describe(\"Clear All button\", () =&gt; {\n    it(\"shows clear all button when there are selections in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      // Wait for component to load selected items\n      // The clear all button should be visible\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      expect(clearButton).toBeInTheDocument();\n    });\n\n    it(\"does not show clear all button when no selections\", () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = screen.queryByLabelText(\"Clear all selections\");\n      expect(clearButton).not.toBeInTheDocument();\n    });\n\n    it(\"calls onChange with empty array when clear all is clicked in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      expect(onChange).toHaveBeenCalledWith([]);\n    });\n\n    it(\"does not open dropdown when clear all is clicked\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      // Dropdown search input should not be visible\n      const searchInput = screen.queryByPlaceholderText(\"Search performers...\");\n      expect(searchInput).not.toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: FAIL - \"Clear all selections\" button not found</p> <p>Step 2.3: Implement the clear all button in SearchableSelect</p> <p>In <code>client/src/components/ui/SearchableSelect.jsx</code>, make these changes:</p> <ol> <li>Add the <code>handleClearAll</code> function after <code>handleRemove</code> (around line 272):</li> </ol> <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre> <ol> <li>Update the trigger area JSX (starting around line 281). Replace the existing return statement's outer div content with:</li> </ol> <p>Find this section (lines ~281-336): <pre><code>return (\n  &lt;div ref={dropdownRef} className=\"relative w-full\"&gt;\n    {/* Selected items display / Trigger button */}\n    &lt;div\n      onClick={() =&gt; setIsOpen(!isOpen)}\n      className=\"w-full pl-3 pr-[2px] py-2 rounded-md cursor-pointer border text-sm flex items-center justify-between gap-2\"\n      style={{\n        backgroundColor: \"var(--bg-card)\",\n        borderColor: \"var(--border-color)\",\n        color: \"var(--text-primary)\",\n      }}\n    &gt;\n      &lt;div className=\"flex flex-wrap gap-1 flex-1\"&gt;\n        {selectedItems.length === 0 ? (\n          &lt;span style={{ color: \"var(--text-muted)\" }}&gt;{placeholder}&lt;/span&gt;\n        ) : multi ? (\n          selectedItems.map((item) =&gt; (\n            ...\n          ))\n        ) : (\n          ...\n        )}\n      &lt;/div&gt;\n      &lt;LucideChevronDown\n        ...\n      /&gt;\n    &lt;/div&gt;\n</code></pre></p> <p>Replace the closing section (after the <code>&lt;/div&gt;</code> that wraps selected items, before <code>&lt;LucideChevronDown&gt;</code>) with:</p> <pre><code>      &lt;/div&gt;\n      &lt;div className=\"flex items-center gap-1 flex-shrink-0\"&gt;\n        {selectedItems.length &gt; 0 &amp;&amp; (\n          &lt;Button\n            onClick={handleClearAll}\n            variant=\"tertiary\"\n            className=\"hover:opacity-70 !p-1 !border-0\"\n            aria-label=\"Clear all selections\"\n            title=\"Clear all\"\n            icon={&lt;LucideX size={16} style={{ color: \"var(--text-muted)\" }} /&gt;}\n          /&gt;\n        )}\n        &lt;LucideChevronDown\n          size={14}\n          style={{\n            transform: isOpen ? \"rotate(180deg)\" : \"rotate(0deg)\",\n            transition: \"transform 0.2s\",\n            color: \"var(--text-muted)\",\n          }}\n        /&gt;\n      &lt;/div&gt;\n</code></pre> <p>Step 2.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: PASS</p> <p>Step 2.5: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx client/src/components/ui/__tests__/SearchableSelect.test.jsx\ngit commit -m \"feat: add clear all button to SearchableSelect\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-3-add-onchipclick-prop-to-activefilterchips","title":"Task 3: Add onChipClick Prop to ActiveFilterChips","text":"<p>Files: - Modify: <code>client/src/components/ui/ActiveFilterChips.jsx</code> - Create: <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code></p> <p>Step 3.1: Write failing test for chip click behavior</p> <p>Create <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport ActiveFilterChips from \"../ActiveFilterChips\";\n\nconst mockFilterOptions = [\n  { key: \"rating\", label: \"Rating\", type: \"range\" },\n  { key: \"favorite\", label: \"Favorite\", type: \"checkbox\" },\n  { key: \"performers\", label: \"Performers\", type: \"searchable-select\" },\n];\n\ndescribe(\"ActiveFilterChips\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(ActiveFilterChips).toBeDefined();\n    expect(typeof ActiveFilterChips).toBe(\"function\");\n  });\n\n  describe(\"chip click behavior\", () =&gt; {\n    it(\"calls onChipClick with filter key when chip body is clicked\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the chip body (the text part)\n      const chipText = screen.getByText(\"Favorite\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).toHaveBeenCalledWith(\"favorite\");\n      expect(onRemoveFilter).not.toHaveBeenCalled();\n    });\n\n    it(\"calls onRemoveFilter when X button is clicked, not onChipClick\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the remove button\n      const removeButton = screen.getByLabelText(\"Remove filter: Favorite\");\n      fireEvent.click(removeButton);\n\n      expect(onRemoveFilter).toHaveBeenCalledWith(\"favorite\");\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"does not call onChipClick for permanent filter chips\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{}}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n          permanentFilters={{ performers: [\"1\"] }}\n          permanentFiltersMetadata={{ performers: [{ id: \"1\", name: \"Test Performer\" }] }}\n        /&gt;\n      );\n\n      // Click the permanent chip\n      const chipText = screen.getByText(\"Performer: Test Performer\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"shows pointer cursor on clickable chips\", () =&gt; {\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={vi.fn()}\n          onChipClick={vi.fn()}\n        /&gt;\n      );\n\n      const chip = screen.getByText(\"Favorite\").closest(\"div\");\n      expect(chip).toHaveClass(\"cursor-pointer\");\n    });\n  });\n});\n</code></pre> <p>Step 3.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: FAIL - onChipClick not called / cursor-pointer class not found</p> <p>Step 3.3: Implement chip click handler in ActiveFilterChips</p> <p>In <code>client/src/components/ui/ActiveFilterChips.jsx</code>:</p> <ol> <li>Add <code>onChipClick</code> to the props (around line 14):</li> </ol> <pre><code>const ActiveFilterChips = ({\n  filters,\n  filterOptions,\n  onRemoveFilter,\n  onChipClick,\n  permanentFilters = {},\n  permanentFiltersMetadata = {},\n}) =&gt; {\n</code></pre> <ol> <li>Update the JSDoc to include the new prop (around line 4):</li> </ol> <pre><code>/**\n * Display active filters as removable chips/badges\n *\n * @param {Object} props\n * @param {Object} props.filters - Current filter values\n * @param {Array} props.filterOptions - Filter configuration from filterConfig.js\n * @param {Function} props.onRemoveFilter - Callback when a filter is removed\n * @param {Function} props.onChipClick - Callback when a chip body is clicked (receives filter key)\n * @param {Object} props.permanentFilters - Filters that can't be removed\n * @param {Object} props.permanentFiltersMetadata - Display names for permanent filters\n */\n</code></pre> <ol> <li>Update the chip rendering (around line 156-185). Replace the chip <code>&lt;div&gt;</code> with:</li> </ol> <pre><code>{allChips.map((chip) =&gt; (\n  &lt;div\n    key={chip.key}\n    onClick={() =&gt; !chip.isPermanent &amp;&amp; onChipClick?.(chip.key)}\n    className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm border transition-colors ${\n      !chip.isPermanent ? \"cursor-pointer hover:opacity-80\" : \"\"\n    }`}\n    style={{\n      backgroundColor: chip.isPermanent\n        ? \"var(--bg-tertiary)\"\n        : \"var(--bg-secondary)\",\n      borderColor: chip.isPermanent\n        ? \"var(--border-color)\"\n        : \"var(--accent-primary)\",\n      color: chip.isPermanent\n        ? \"var(--text-secondary)\"\n        : \"var(--text-primary)\",\n      opacity: chip.isPermanent ? 0.7 : 1,\n    }}\n  &gt;\n    &lt;span&gt;{chip.label}&lt;/span&gt;\n    {!chip.isPermanent &amp;&amp; (\n      &lt;Button\n        onClick={(e) =&gt; {\n          e.stopPropagation();\n          onRemoveFilter(chip.key);\n        }}\n        variant=\"tertiary\"\n        className=\"hover:opacity-70 !p-0 !border-0\"\n        aria-label={`Remove filter: ${chip.label}`}\n        title={`Remove filter: ${chip.label}`}\n        icon={&lt;LucideX className=\"w-3.5 h-3.5\" /&gt;}\n      /&gt;\n    )}\n  &lt;/div&gt;\n))}\n</code></pre> <p>Step 3.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: PASS</p> <p>Step 3.5: Commit</p> <pre><code>git add client/src/components/ui/ActiveFilterChips.jsx client/src/components/ui/__tests__/ActiveFilterChips.test.jsx\ngit commit -m \"feat: add onChipClick prop to ActiveFilterChips\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-4-add-highlight-support-to-filterpanel","title":"Task 4: Add Highlight Support to FilterPanel","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterControls.jsx</code></p> <p>Step 4.1: Update FilterPanel to accept highlight props</p> <p>In <code>client/src/components/ui/FilterControls.jsx</code>, update the <code>FilterPanel</code> component (around line 431):</p> <ol> <li>Add new props to FilterPanel:</li> </ol> <pre><code>export const FilterPanel = ({\n  children,\n  onClear,\n  hasActiveFilters,\n  isOpen,\n  onToggle,\n  onSubmit,\n  highlightedFilterKey,\n  filterRefs,\n}) =&gt; {\n</code></pre> <ol> <li>Add useEffect for scroll and highlight behavior. Add this inside FilterPanel, before the <code>if (!isOpen)</code> check:</li> </ol> <pre><code>// Scroll to highlighted filter when it changes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey &amp;&amp; filterRefs?.current?.[highlightedFilterKey]) {\n    const element = filterRefs.current[highlightedFilterKey];\n\n    // Small delay to ensure panel is rendered\n    setTimeout(() =&gt; {\n      element.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n    }, 100);\n  }\n}, [highlightedFilterKey, filterRefs]);\n</code></pre> <ol> <li>Add the useEffect import at the top of the file if not already present:</li> </ol> <pre><code>import { useEffect } from \"react\";\n</code></pre> <p>Step 4.2: Update FilterControl to accept ref and highlight class</p> <p>Update <code>FilterControl</code> component (around line 50) to forward a ref and apply highlight class:</p> <ol> <li>Import <code>forwardRef</code> at the top:</li> </ol> <pre><code>import { forwardRef, useEffect } from \"react\";\n</code></pre> <ol> <li>Wrap FilterControl with forwardRef and add highlight styling:</li> </ol> <pre><code>export const FilterControl = forwardRef(({\n  type = \"select\",\n  label,\n  value,\n  onChange,\n  options = [],\n  placeholder = \"\",\n  min,\n  max,\n  entityType,\n  multi,\n  modifierOptions,\n  modifierValue,\n  onModifierChange,\n  supportsHierarchy = false,\n  hierarchyLabel = \"Include children\",\n  hierarchyValue,\n  onHierarchyChange,\n  isHighlighted = false,\n}, ref) =&gt; {\n  // ... existing code ...\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`flex flex-col ${isHighlighted ? \"filter-highlight\" : \"\"}`}\n    &gt;\n      {/* ... rest of the component */}\n    &lt;/div&gt;\n  );\n});\n\nFilterControl.displayName = \"FilterControl\";\n</code></pre> <p>Step 4.3: Verify changes compile</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4.4: Commit</p> <pre><code>git add client/src/components/ui/FilterControls.jsx\ngit commit -m \"feat: add highlight support to FilterPanel and FilterControl\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-5-wire-up-chip-click-in-searchcontrols","title":"Task 5: Wire Up Chip Click in SearchControls","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 5.1: Add state and refs for highlighting</p> <p>In <code>client/src/components/ui/SearchControls.jsx</code>:</p> <ol> <li>Add <code>useRef</code> to the imports if not already there (line 1):</li> </ol> <pre><code>import React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n</code></pre> <ol> <li>Add state for highlighted filter key (around line 99, after other useState calls):</li> </ol> <pre><code>const [highlightedFilterKey, setHighlightedFilterKey] = useState(null);\nconst filterRefs = useRef({});\n</code></pre> <ol> <li>Add useEffect to clear highlight after animation (add after other useEffects, around line 400):</li> </ol> <pre><code>// Clear highlight after animation completes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey) {\n    const timer = setTimeout(() =&gt; {\n      setHighlightedFilterKey(null);\n    }, 1500);\n    return () =&gt; clearTimeout(timer);\n  }\n}, [highlightedFilterKey]);\n</code></pre> <p>Step 5.2: Add handler for chip clicks</p> <p>Add this handler after <code>handleRemoveFilter</code> (around line 486):</p> <pre><code>// Handle clicking on a filter chip to highlight that filter\nconst handleFilterChipClick = useCallback(\n  (filterKey) =&gt; {\n    // Open filter panel if not already open\n    setIsFilterPanelOpen(true);\n\n    // Find which section this filter belongs to\n    let sectionKey = null;\n    for (let i = 0; i &lt; filterOptions.length; i++) {\n      if (filterOptions[i].type === \"section-header\") {\n        sectionKey = filterOptions[i].key;\n      } else if (filterOptions[i].key === filterKey) {\n        break;\n      }\n    }\n\n    // Expand the section if it's collapsed\n    if (sectionKey &amp;&amp; collapsedSections[sectionKey]) {\n      setCollapsedSections((prev) =&gt; ({\n        ...prev,\n        [sectionKey]: false,\n      }));\n    }\n\n    // Set the highlighted filter key (triggers scroll and animation)\n    setHighlightedFilterKey(filterKey);\n  },\n  [filterOptions, collapsedSections]\n);\n</code></pre> <p>Step 5.3: Pass onChipClick to ActiveFilterChips</p> <p>Update the <code>ActiveFilterChips</code> component usage (around line 796):</p> <pre><code>{/* Active Filter Chips */}\n&lt;ActiveFilterChips\n  filters={filters}\n  filterOptions={filterOptions}\n  onRemoveFilter={handleRemoveFilter}\n  onChipClick={handleFilterChipClick}\n  permanentFilters={permanentFilters}\n  permanentFiltersMetadata={permanentFiltersMetadata}\n/&gt;\n</code></pre> <p>Step 5.4: Pass highlight props to FilterPanel</p> <p>Update the <code>FilterPanel</code> component usage (around line 831):</p> <pre><code>{/* Filter Panel */}\n&lt;FilterPanel\n  isOpen={isFilterPanelOpen}\n  onToggle={handleToggleFilterPanel}\n  onClear={clearFilters}\n  onSubmit={handleFilterSubmit}\n  hasActiveFilters={hasActiveFilters}\n  highlightedFilterKey={highlightedFilterKey}\n  filterRefs={filterRefs}\n&gt;\n</code></pre> <p>Step 5.5: Pass ref and isHighlighted to each FilterControl</p> <p>Update the FilterControl rendering in the map (around line 923-945):</p> <pre><code>return (\n  &lt;FilterControl\n    key={`FilterControl-${key}`}\n    ref={(el) =&gt; {\n      if (el) filterRefs.current[key] = el;\n    }}\n    isHighlighted={highlightedFilterKey === key}\n    onChange={(value) =&gt; handleFilterChange(key, value)}\n    value={filters[key] || defaultValue}\n    type={type}\n    modifierOptions={modifierOptions}\n    modifierValue={filters[modifierKey] || defaultModifier}\n    onModifierChange={(value) =&gt;\n      modifierKey &amp;&amp; handleFilterChange(modifierKey, value)\n    }\n    supportsHierarchy={supportsHierarchy}\n    hierarchyLabel={hierarchyLabel}\n    hierarchyValue={hierarchyKey ? filters[hierarchyKey] : undefined}\n    onHierarchyChange={\n      hierarchyKey\n        ? (value) =&gt; handleFilterChange(hierarchyKey, value)\n        : undefined\n    }\n    {...filterProps}\n  /&gt;\n);\n</code></pre> <p>Step 5.6: Verify changes compile and app works</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 5.7: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: wire up filter chip click to highlight filter controls\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-6-manual-testing-and-final-verification","title":"Task 6: Manual Testing and Final Verification","text":"<p>Step 6.1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm run test:run</code> Expected: All tests pass</p> <p>Step 6.2: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 6.3: Build for production</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 6.4: Manual testing checklist</p> <p>Start the dev server and verify:</p> <ol> <li>SearchableSelect Clear All:</li> <li> Clear button appears when items are selected</li> <li> Clear button disappears when no selections</li> <li> Clicking clear removes all selections</li> <li> <p> Dropdown does not open when clear is clicked</p> </li> <li> <p>Filter Chip Click:</p> </li> <li> Clicking a filter chip opens the filter panel</li> <li> The corresponding filter control scrolls into view</li> <li> A pulse animation highlights the control</li> <li> Animation fades after ~1.5 seconds</li> <li> Clicking the X still removes the filter (doesn't trigger chip click)</li> <li> <p> Permanent filter chips are not clickable</p> </li> <li> <p>Collapsed Sections:</p> </li> <li> Clicking a chip for a filter in a collapsed section expands that section</li> <li> Then scrolls to and highlights the filter</li> </ol> <p>Step 6.5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address issues from manual testing\"\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/","title":"Issues Found in v3.0.0-beta.9","text":"<p>Date: December 15, 2025 To be addressed in separate branches before or after 3.0.0 release</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-1-detail-page-tabs-not-loading-non-scenes-tabs","title":"Issue 1: Detail Page Tabs Not Loading (Non-Scenes Tabs)","text":"<p>Severity: HIGH - User-facing navigation broken</p> <p>Symptoms: - On Performer Detail, Studio Detail, Tag Detail, and Collection/Group Detail pages - Clicking non-Scenes tabs (Galleries, Images, Groups) causes a flicker - URL briefly shows <code>?tab=galleries</code> but immediately switches back to default (Scenes) - Manually typing URL with <code>?tab=galleries</code> also reverts</p> <p>Root Cause Analysis:</p> <p>The issue is NOT related to tab filtering or counts. The <code>SearchControls</code> component completely replaces URL query params when syncing state to URL, obliterating the <code>?tab=</code> parameter.</p> <p>The Problem:</p> <p>In <code>client/src/components/ui/SearchControls.jsx:384</code>: <pre><code>setSearchParams(params, { replace: true });\n</code></pre></p> <p>And in <code>client/src/utils/urlParams.js:169</code>, <code>buildSearchParams()</code> creates a brand new URLSearchParams() that only includes filter/sort/page params - it does NOT preserve unknown params like <code>tab</code>.</p> <p>The Flow: 1. User clicks \"Galleries\" tab \u2192 <code>TabNavigation</code> sets <code>?tab=galleries</code> 2. Tab content changes, <code>GalleryGrid</code> (via <code>SearchableGrid</code> \u2192 <code>SearchControls</code>) mounts 3. <code>SearchControls</code> initializes and calls <code>setSearchParams(params)</code> with only its filter params 4. <code>?tab=galleries</code> is obliterated, replaced with filter params (or empty string) 5. <code>activeTab</code> reads from URL, sees no <code>tab</code> param, defaults back to <code>scenes</code></p> <p>Files to Fix: - <code>client/src/components/ui/SearchControls.jsx</code> - URL sync logic - <code>client/src/utils/urlParams.js</code> - <code>buildSearchParams</code> function</p> <p>Fix Options: 1. Pass <code>syncToUrl={false}</code> to grids rendered inside tabs (quick fix, breaks URL bookmarking for nested grids) 2. Preserve unknown params in <code>buildSearchParams</code> - accept existing params and merge rather than replace 3. Namespace params - use prefixes like <code>scene_sort=</code>, <code>gallery_sort=</code> to avoid conflicts</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-2-tags-query-performance","title":"Issue 2: Tags Query Performance","text":"<p>Severity: MEDIUM - Usability issue, not broken</p> <p>Symptoms: - Tags list page is slow to load - Tag detail page is slow - Not unusable but noticeably slower than other entity types</p> <p>Root Cause Analysis:</p> <p>The <code>enhanceTagsWithPerformerScenes()</code> function at <code>server/controllers/library/tags.ts:19-75</code> is O(n*m) where n=scenes and m=performers. It loads ALL scenes and ALL performers to calculate counts.</p> <p>Key Finding: The real performance issue is that <code>enhanceTagsWithPerformerScenes()</code> is called at <code>tags.ts:261</code>, which is AFTER the filtered entity cache check (lines 151-254). This means:</p> <ul> <li>Tag filtering IS cached (via <code>filteredEntityCacheService</code>)</li> <li>But performer scene enhancement runs on every single request, even cache hits</li> </ul> <p>The caching only helps with content restriction filtering, not with the expensive enhancement step.</p> <p>Files to Fix: - <code>server/controllers/library/tags.ts</code> - Move enhancement inside cache block or cache separately</p> <p>Fix Options: 1. Move enhancement inside cache block - Include enhanced data in the cached result (simplest) 2. Pre-compute counts on sync - Store <code>scene_count_via_performers</code> in the StashTag table 3. Use SQL aggregation - Replace the in-memory calculation with a SQL COUNT query 4. Separate cache for enhancement - Cache the enhancement result with its own TTL 5. Lazy load - Only calculate performer scene counts when specifically requested (detail page)</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-3-o-history-stored-in-json-column","title":"Issue 3: O History Stored in JSON Column","text":"<p>Severity: LOW - Technical debt, not user-facing</p> <p>Current Implementation:</p> <p>From <code>server/prisma/schema.prisma</code> line 72: <pre><code>oHistory Json @default(\"[]\") // Array of timestamp strings when O was incremented\n</code></pre></p> <p>The O history is stored as a JSON array of timestamp strings within the WatchHistory table.</p> <p>Problems with this approach: 1. Cannot efficiently query \"all O events in the last week\" 2. Cannot aggregate O events across scenes/performers without loading all JSON 3. JSON arrays don't scale well for users with thousands of O events 4. No referential integrity</p> <p>Proposed Schema:</p> <pre><code>model OEvent {\n  id           Int       @id @default(autoincrement())\n  userId       Int\n  sceneId      String\n  timestamp    DateTime  @default(now())\n\n  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  watchHistory WatchHistory? @relation(fields: [userId, sceneId], references: [userId, sceneId])\n\n  @@index([userId])\n  @@index([sceneId])\n  @@index([timestamp])\n  @@index([userId, timestamp])\n}\n</code></pre> <p>Migration Strategy: 1. Create the new OEvent table 2. Write a data migration to move existing oHistory JSON arrays to the new table 3. Update all services that read/write oHistory to use the new table 4. Keep oHistory JSON for backward compatibility during migration period 5. Eventually deprecate and remove oHistory column</p> <p>Files to Change: - <code>server/prisma/schema.prisma</code> - Add OEvent model - <code>server/controllers/watchHistory.ts</code> - Update increment-o endpoint - <code>server/services/UserStatsService.ts</code> - Update O counter aggregation - <code>server/services/SceneQueryBuilder.ts</code> - Update any O history queries</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-4-o-counter-ui-shows-stale-value-after-playlist-navigation","title":"Issue 4: O Counter UI Shows Stale Value After Playlist Navigation","text":"<p>Severity: MEDIUM - Confusing UX</p> <p>Symptoms: 1. User increments O counter on Scene A (e.g., 0 \u2192 1) 2. User navigates to next scene (Scene B) in playlist 3. Scene B shows O counter value of 1 (from Scene A) instead of Scene B's actual value 4. This persists as user navigates through playlist 5. If user goes back to Scene A and then navigates away again, it resets correctly</p> <p>Root Cause Analysis:</p> <p>The <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> reducer actions do NOT reset <code>oCounter</code>, but <code>LOAD_SCENE_SUCCESS</code> does set it from the new scene's data at <code>client/src/contexts/scenePlayerReducer.js:108</code>:</p> <pre><code>oCounter: action.payload.oCounter || 0,\n</code></pre> <p>The <code>useEffect</code> at <code>client/src/contexts/ScenePlayerContext.jsx:126-134</code> triggers <code>loadScene()</code> when <code>currentIndex</code> changes, which dispatches <code>LOAD_SCENE_SUCCESS</code>.</p> <p>Why the stale value persists:</p> <p>The issue is a race condition or render timing issue: 1. <code>NEXT_SCENE</code> dispatches \u2192 state updates with old <code>oCounter</code> 2. Component re-renders showing stale <code>oCounter</code> 3. <code>useEffect</code> fires (async) \u2192 <code>loadScene()</code> called 4. API request completes \u2192 <code>LOAD_SCENE_SUCCESS</code> dispatches with correct <code>oCounter</code> 5. Component re-renders with correct value</p> <p>The user sees step 2 (stale) before step 5 (correct). If the API is slow or there's a render batching issue, the stale value is visible longer.</p> <p>Files to Fix: - <code>client/src/contexts/scenePlayerReducer.js</code> - Reset <code>oCounter</code> in navigation actions</p> <p>Recommended Fix: Reset <code>oCounter: 0</code> in <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> cases. This provides immediate feedback that scene is changing, and <code>LOAD_SCENE_SUCCESS</code> will set the correct value once the API responds:</p> <pre><code>// In NEXT_SCENE case (around line 244)\nreturn {\n  ...state,\n  currentIndex: nextIndex,\n  // ... existing resets\n  oCounter: 0,  // ADD THIS - immediate reset\n  // ...\n};\n\n// Same for PREV_SCENE case (around line 313)\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#summary-table","title":"Summary Table","text":"# Issue Severity Effort Recommend Fix Before Release 1 Detail page tabs not loading HIGH Medium Yes 2 Tags query slow MEDIUM High No (post-release) 3 O History JSON schema LOW High No (post-release) 4 O Counter stale UI MEDIUM Low Yes"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#recommended-branch-strategy","title":"Recommended Branch Strategy","text":"<ol> <li>Branch: <code>bugfix/detail-page-tabs</code> - Fix issue #1</li> <li>Branch: <code>bugfix/o-counter-stale-state</code> - Fix issue #4</li> <li>Branch: <code>perf/tags-query-optimization</code> - Fix issue #2 (post-release)</li> <li>Branch: <code>refactor/o-history-table</code> - Fix issue #3 (post-release)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/","title":"Peek v3.0.0 Release Announcement","text":"<p>Copy/paste-ready for Discord and Discourse</p>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discord-announcement-short","title":"Discord Announcement (short)","text":"<pre><code>**Peek v3.0.0 Released!**\n\nMajor update with SQLite-based entity storage for massive scalability improvements:\n\n- **100k+ scene support** - No more memory limits\n- **3-minute sync** for 22k scenes (was 3.6 hours)\n- **Persistent library** - Data survives restarts\n- **Comprehensive filtering** - All performer/scene filters now work correctly\n\n**Upgrading:**\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart container\n4. Wait for automatic sync\n\nAll user data (watch history, playlists, ratings) is preserved.\n\n**Beta users:** Run a full sync after upgrading to populate new fields.\n\nDocs: https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/\nIssues: https://github.com/carrotwaxr/peek-stash-browser/issues\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discourse-announcement-detailed","title":"Discourse Announcement (detailed)","text":"<pre><code># Peek v3.0.0 Released - SQLite Entity Cache\n\nAfter 13 beta versions, Peek 3.0.0 is now stable!\n\n## What's New\n\nVersion 3.0.0 is a major architectural change: your Stash library data is now stored in SQLite tables instead of in-memory. This provides:\n\n| Improvement | Before | After |\n|-------------|--------|-------|\n| Library size limit | ~50k scenes (memory) | 100k+ scenes (disk) |\n| Sync time (22k scenes) | ~3.6 hours | ~3 minutes |\n| Data persistence | Lost on restart | Survives restarts |\n| Query speed | Slow on large libs | Sub-100ms |\n\n## New Features in 3.0\n\n- **Unit Preference** - Choose metric or imperial for performer measurements\n- **Comprehensive Filters** - All performer attributes now filterable (career length, ethnicity, eye color, etc.)\n- **Filter Chip Interactions** - Click filter chips to highlight the corresponding control\n- **Improved Gallery Display** - Better fallback titles for unnamed galleries\n- **Filename Search** - Scene search now includes filepath/filename\n- **Tag Alias Search** - Tag search now includes aliases\n\n## Upgrading\n\n**From any previous version:**\n\n1. Back up your database (copy `peek.db` from your data volume)\n2. Pull the new image: `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart your container\n4. Wait for the automatic sync to complete\n\nYour user data is fully preserved:\n- User accounts\n- Watch history &amp; resume positions\n- Playlists\n- All ratings and favorites\n- Filter presets\n- Hidden entities\n\n**From 3.0.0 beta versions:**\n\nWe recommend running a **full sync** after upgrading to ensure new fields are populated:\n1. Settings &gt; Server Settings\n2. Click \"Sync from Stash\"\n3. Select \"Full Sync\"\n\nThis populates `fileBasename` (gallery display) and `fakeTits` (performer filtering) for existing data.\n\n## Breaking Changes from 2.x\n\n- Initial sync is required after upgrade (automatic)\n- Sync time depends on library size (see table in upgrade guide)\n\n## Documentation\n\n- [Upgrade Guide](https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/)\n- [Full Documentation](https://carrotwaxr.github.io/peek-stash-browser/)\n\n## Issues\n\nPlease report bugs on [GitHub Issues](https://github.com/carrotwaxr/peek-stash-browser/issues) with:\n- Your Peek version\n- Your Stash version\n- Library size\n- Steps to reproduce\n\nThanks to everyone who tested the beta versions!\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#github-release-notes","title":"GitHub Release Notes","text":"<pre><code>## What's Changed\n\n### Major Changes\n- **SQLite Entity Cache** - Library data now stored in SQLite for 100k+ scene support\n- **Persistent Storage** - Library data survives container restarts\n- **3x faster sync** - Initial sync is ~3 minutes for 22k scenes\n\n### New Features\n- Unit preference setting (metric/imperial) for performer measurements\n- Filter chip click-to-highlight interaction\n- Comprehensive performer filtering (career length, ethnicity, eye color, breast type)\n- Improved gallery title fallback display\n- Scene search now includes filepath/filename\n- Tag search now includes aliases\n\n### Bug Fixes (across beta cycle)\n- Fixed performer filter case sensitivity\n- Fixed sorting by path, last_o_at, performer_count\n- Fixed O counter aggregation for performers/studios/tags\n- Fixed watch history tracking event timing\n- Fixed gallery cards showing \"Untitled Gallery\"\n- Fixed user menu accessibility in collapsed sidebar\n- Fixed long filename overflow on scene cards\n- Fixed last sync time showing only full syncs (now shows most recent)\n\n### Breaking Changes\n- Initial sync required after upgrade (automatic)\n- Migration adds new tables only - all user data preserved\n\n### Upgrade Instructions\n\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:3.0.0`\n3. Restart container\n4. Wait for automatic sync\n\n**Beta users:** Run a full sync to populate new fields (Settings &gt; Sync from Stash &gt; Full Sync)\n\n**Full Changelog**: https://github.com/carrotwaxr/peek-stash-browser/compare/v2.1.0...v3.0.0\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/","title":"Peek v3.0.0 Release Evaluation","text":"<p>Date: December 15, 2025 Evaluator: Claude Code (AI-assisted) Version Evaluated: v3.0.0-beta.9</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#executive-summary","title":"Executive Summary","text":"<p>Peek v3.0.0 represents a major architectural change from in-memory caching to SQLite-based entity storage. After 9 beta versions, the release is conditionally ready for production with the following considerations:</p> Area Status Notes Database Migrations Ready Clean upgrade paths from 1.x and 2.x verified Core Functionality Ready Major bugs addressed across beta cycle Filtering/Sorting Stable 13 fixes in beta cycle, now comprehensive Security Review Needed Non-blocking issues identified Documentation Needs Update Outdated references to beta.2 <p>Recommendation: Proceed with 3.0.0 release after updating documentation and noting user action items.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#1-database-migration-analysis","title":"1. Database Migration Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#migration-chain-7-migrations","title":"Migration Chain (7 migrations)","text":"# Migration Description Added In 1 <code>0_baseline</code> Core user tables (User, WatchHistory, Playlist, Ratings, etc.) v2.0.0 2 <code>20251126202944_add_user_carousel</code> UserCarousel table v2.1.0 3 <code>20251211000000_stash_entities</code> StashScene, StashPerformer, junction tables (23 new tables) v3.0.0-beta.1 4 <code>20251211100000_entity_counts</code> Count columns on Stash* tables v3.0.0-beta.1 5 <code>20251214000000_add_unit_preference</code> User.unitPreference column v3.0.0-beta.5 6 <code>20251214100000_gallery_file_basename</code> StashGallery.fileBasename v3.0.0-beta.6 7 <code>20251215000000_add_performer_fake_tits</code> StashPerformer.fakeTits v3.0.0-beta.9"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#upgrade-path-verification","title":"Upgrade Path Verification","text":"Source Version Migration Handling Status v1.x (pre-migration) schemaCatchup creates missing tables, marks baseline+carousel applied Verified v2.0.x schemaCatchup handles broken states, Prisma applies remaining Verified v2.1.x Prisma applies migrations 3-7 Verified v3.0.0-beta.1-4 Prisma applies migrations 4-7 Verified v3.0.0-beta.5-8 Prisma applies migrations 5-7 Verified v3.0.0-beta.9 No migrations needed Verified Fresh install All 7 migrations applied Verified"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#data-preservation","title":"Data Preservation","text":"<p>User data is fully preserved during upgrade: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - All ratings and favorites (Scene, Performer, Studio, Tag, Gallery, Group, Image) - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#potential-migration-issues","title":"Potential Migration Issues","text":"<p>None identified. The schemaCatchup.ts module handles all legacy database scenarios correctly.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#2-breaking-changes-v2x-to-v30","title":"2. Breaking Changes (v2.x to v3.0)","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#architectural-changes","title":"Architectural Changes","text":"<ol> <li>In-Memory Cache \u2192 SQLite Tables</li> <li>Entity data now persisted in SQLite</li> <li>Initial sync required after upgrade</li> <li> <p>Subsequent syncs are incremental</p> </li> <li> <p>Environment Variables</p> </li> <li><code>STASH_URL</code> and <code>STASH_API_KEY</code> no longer needed as env vars</li> <li>Connection configured via Setup Wizard, stored in database</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#removed-features","title":"Removed Features","text":"<ol> <li>Local Transcoding (removed in v2.0)</li> <li>Peek now proxies streams directly through Stash</li> <li> <p>No more FFmpeg dependency for streaming</p> </li> <li> <p>Path Mappings (removed in v2.0)</p> </li> <li>No longer needed since streaming proxies through Stash</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#new-features-requiring-user-action","title":"New Features Requiring User Action","text":"Feature User Action Unit Preference Optional: Set metric/imperial in Settings Full Sync Post-Beta Recommended: Run full sync to populate new fields (fileBasename, fakeTits)"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#3-beta-fix-analysis","title":"3. Beta Fix Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#fix-distribution-by-beta-version","title":"Fix Distribution by Beta Version","text":"Version Fix Count Primary Focus beta.1 \u2192 beta.2 1 Permissions beta.2 \u2192 beta.3 0 - beta.3 \u2192 beta.4 5 Filter data loading beta.4 \u2192 beta.5 13 Sorting/filtering (major) beta.5 \u2192 beta.6 6 UI, watch history, settings beta.6 \u2192 beta.7 1 O counter aggregation beta.7 \u2192 beta.8 1 Performer filter parsing beta.8 \u2192 beta.9 1 Case sensitivity, new field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#recurring-issue-patterns","title":"Recurring Issue Patterns","text":"<ol> <li>Performer Filters (4 fix iterations)</li> <li>Initial data loading issues</li> <li>Career length parsing complexity</li> <li>Case sensitivity</li> <li> <p>Missing fields (fakeTits)</p> </li> <li> <p>Sorting Implementation (8 fixes in beta.5)</p> </li> <li>Missing sort options</li> <li>Wrong SQL column names</li> <li> <p>Rating field confusion (Stash vs user)</p> </li> <li> <p>Schema/Migration Mismatches (3 fixes)</p> </li> <li>unitPreference migration missing</li> <li>fakeTits field sync</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#risk-assessment","title":"Risk Assessment","text":"Area Risk Level Notes Performer Filters LOW Comprehensive overhaul completed in beta.5, edge cases addressed in beta.8-9 Sorting LOW All 8 issues fixed in beta.5 Watch History LOW Event timing fixed in beta.5-6 Gallery Display LOW fileBasename fallback added"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#4-core-system-stability","title":"4. Core System Stability","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#stashsyncservice-stable-with-notes","title":"StashSyncService - STABLE with notes","text":"<p>Strengths: - Proper abort handling for cancellable syncs - Entity ID validation for SQL injection defense - Progress events for UI feedback - Soft-delete preserves data</p> <p>Areas for Future Improvement (non-blocking): - Transaction wrapping for atomic sync operations - Consider parameterized queries for additional safety</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#scenequerybuilder-stable","title":"SceneQueryBuilder - STABLE","text":"<p>Strengths: - Parameterized SQL queries throughout - Efficient exclusion filter handling - Count query optimization - Proper hierarchy expansion</p> <p>Minor Notes: - Exclusion sets &gt;500 items are truncated with warning (documented behavior)</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#database-initialization-stable","title":"Database Initialization - STABLE","text":"<p>Strengths: - Comprehensive legacy database handling - Idempotent schema catchup - Clear migration flow</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#authentication-stable","title":"Authentication - STABLE","text":"<p>Strengths: - HTTP-only cookies prevent XSS - bcrypt password hashing - Role-based access control</p> <p>Future Improvements (non-blocking): - Rate limiting on login endpoint - Token revocation on logout</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#5-issues-categorized-by-priority","title":"5. Issues Categorized by Priority","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#blockers-must-fix-before-release","title":"BLOCKERS (must fix before release)","text":"<p>None identified.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#should-fix-recommended-before-release","title":"SHOULD-FIX (recommended before release)","text":"Issue Description Effort Documentation Outdated upgrading.md references beta.2, needs update to beta.9/3.0.0 Low docs/index.md Outdated References transcoding, default credentials Low README Beta Banner Remove beta warning for stable release Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#nice-to-have-can-be-addressed-post-release","title":"NICE-TO-HAVE (can be addressed post-release)","text":"Issue Description Priority Rate Limiting Add to login endpoint Medium Token Revocation Implement logout blacklist Medium Query Timeout Add timeout for complex queries Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#6-user-action-items-for-v300","title":"6. User Action Items for v3.0.0","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#all-users","title":"All Users","text":"<ol> <li>Back up database before upgrading</li> <li>Wait for initial sync after upgrade (varies by library size)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-300-betax","title":"Users Upgrading from 3.0.0-beta.x","text":"<ol> <li>Run full sync via Settings \u2192 Sync to populate new fields:</li> <li><code>fileBasename</code> for gallery display (beta.6+)</li> <li><code>fakeTits</code> for performer filters (beta.9+)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-2x","title":"Users Upgrading from 2.x","text":"<p>No special action needed beyond backup and sync wait.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-1x","title":"Users Upgrading from 1.x","text":"<p>No special action needed beyond backup and sync wait. schemaCatchup handles legacy databases automatically.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#7-recommended-documentation-updates","title":"7. Recommended Documentation Updates","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#files-to-update","title":"Files to Update","text":"<ol> <li>README.md</li> <li>Remove beta warning banner</li> <li> <p>Update version references</p> </li> <li> <p>docs/getting-started/upgrading.md</p> </li> <li>Update \"Latest\" from beta.2 to 3.0.0</li> <li>Add beta.x \u2192 3.0.0 upgrade notes</li> <li> <p>Add full sync recommendation for beta upgraders</p> </li> <li> <p>docs/index.md</p> </li> <li>Remove transcoding references</li> <li> <p>Remove default credentials section (Setup Wizard now handles)</p> </li> <li> <p>CLAUDE.md</p> </li> <li>Update release status if needed</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#8-release-checklist","title":"8. Release Checklist","text":"<ul> <li> Update README.md (remove beta banner)</li> <li> Update docs/getting-started/upgrading.md (comprehensive update)</li> <li> Update docs/index.md (remove outdated info)</li> <li> Verify all tests pass</li> <li> Verify lint passes</li> <li> Tag v3.0.0</li> <li> Create GitHub release with release notes</li> <li> Update Docker Hub description</li> <li> Post to Discourse/Discord</li> </ul>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#appendix-version-history","title":"Appendix: Version History","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#v300-beta-timeline","title":"v3.0.0 Beta Timeline","text":"Version Date Key Changes beta.1 Dec 10 Initial SQLite entity cache beta.2 Dec 10 Tag visibility fix beta.3 Dec 12 Video player improvements beta.4 Dec 12 Filter data loading fixes beta.5 Dec 12 Major sorting/filtering overhaul beta.6 Dec 14 UI fixes, watch history, unit preference beta.7 Dec 14 O counter aggregation fix beta.8 Dec 14 Performer filter parsing beta.9 Dec 15 Case sensitivity, fakeTits field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#breaking-changes-by-major-version","title":"Breaking Changes by Major Version","text":"Version Breaking Changes v1.x \u2192 v2.0 Removed local transcoding, removed path mappings v2.x \u2192 v3.0 Architecture change (memory \u2192 SQLite), initial sync required"},{"location":"plans/2025-12-16-query-architecture-consolidation/","title":"Query Architecture Consolidation","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#problem","title":"Problem","text":"<p>Scene queries return inconsistent objects depending on which code path is used:</p> <ul> <li><code>SceneQueryBuilder.execute()</code> returns scenes with full relations (performers, tags, studio, groups, galleries)</li> <li><code>StashEntityService.getAllScenes()</code> returns scenes with empty relation arrays</li> <li>Various <code>getAllScenesWith*()</code> variants return partial relation data (IDs only)</li> </ul> <p>This causes bugs like Similar Scenes and Recommended Scenes cards not displaying performer/tag indicators.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#goal","title":"Goal","text":"<p>Single query architecture where every scene object returned has consistent shape with populated relations. DRY principle - one path, one place for bugs.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#design","title":"Design","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-1-lightweight-scoring-query","title":"Phase 1: Lightweight Scoring Query","text":"<p>Create a new method for scoring operations that returns minimal data needed:</p> <pre><code>// New method in StashEntityService\nasync getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n  // Returns: { id, performerIds, tagIds, studioId, oCounter, date }\n  // Single efficient query joining scene + junction tables\n  // No full entity hydration - just IDs for scoring\n}\n</code></pre> <p>This supports Similar Scenes and Recommended Scenes which need to score all scenes but only need IDs for the scoring logic.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-2-consolidate-to-scenequerybuilder","title":"Phase 2: Consolidate to SceneQueryBuilder","text":"<p>All scene queries that return <code>NormalizedScene[]</code> go through <code>SceneQueryBuilder</code>, which already has <code>populateRelations()</code>.</p> <p>Methods to remove from StashEntityService: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code></p> <p>Methods to keep/modify: - <code>getScenesByIds()</code> - Keep, but have it use SceneQueryBuilder internally - <code>getScenesByIdsWithRelations()</code> - Remove, redundant after consolidation</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-3-update-all-callers","title":"Phase 3: Update All Callers","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#similar-scenes-scenests1235","title":"Similar Scenes (<code>scenes.ts:1235</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: 1. Call <code>getScenesForScoring()</code> for lightweight scoring data 2. Score and sort to get top N scene IDs 3. Call <code>SceneQueryBuilder.execute({ filters: { ids } })</code> for final results</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#recommended-scenes-scenests1472","title":"Recommended Scenes (<code>scenes.ts:1472</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: Same pattern as Similar Scenes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#standard-carousels-carouselts402","title":"Standard Carousels (<code>carousel.ts:402</code>)","text":"<p>Before: <code>getAllScenes()</code> then filter/sort in memory After: <code>SceneQueryBuilder.execute()</code> with appropriate filters</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenes-browse-fallback-scenests994","title":"Scenes Browse Fallback (<code>scenes.ts:994</code>)","text":"<p>Before: <code>getAllScenes()</code> when SQL query builder disabled After: Always use <code>SceneQueryBuilder.execute()</code></p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#entity-visibility-filtering-tagsts-performersts-studiosts","title":"Entity Visibility Filtering (<code>tags.ts</code>, <code>performers.ts</code>, <code>studios.ts</code>)","text":"<p>Before: <code>getAllScenes*()</code> to check which entities have visible scenes After: New dedicated method <code>getVisibleEntityIds(userId, entityType)</code> that queries junction tables directly - doesn't need full scene data</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-enhancements","title":"SceneQueryBuilder Enhancements","text":"<p>Add support for: - Unpaginated mode (for getting all matching IDs) - ID-only mode (returns just scene IDs, no hydration)</p> <pre><code>interface SceneQueryOptions {\n  // ... existing options\n  returnIdsOnly?: boolean;  // Skip hydration, return string[]\n  unpaginated?: boolean;    // Return all matches, no LIMIT\n}\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Scene Query Requests                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Browse  \u2502  Similar  \u2502  Recommended  \u2502  Carousels  \u2502  Details   \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502           \u2502             \u2502              \u2502            \u2502\n     \u2502           \u25bc             \u25bc              \u2502            \u2502\n     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502            \u2502\n     \u2502    \u2502 getScenesForScoring()   \u2502        \u2502            \u2502\n     \u2502    \u2502 (lightweight IDs only)  \u2502        \u2502            \u2502\n     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u2502                \u25bc                      \u2502            \u2502\n     \u2502         Score &amp; Get IDs              \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u25bc                \u25bc                      \u25bc            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SceneQueryBuilder.execute()                   \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Build WHERE  \u2502\u2192 \u2502 Execute SQL  \u2502\u2192 \u2502 populateRelations()    \u2502 \u2502\n\u2502  \u2502 clauses      \u2502  \u2502 query        \u2502  \u2502 (batch load relations) \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                    NormalizedScene[] with\n                    consistent relations\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#migration-checklist","title":"Migration Checklist","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#stashentityservice-changes","title":"StashEntityService Changes","text":"<ul> <li> Add <code>getScenesForScoring()</code> method</li> <li> Add <code>getVisibleSceneIdsByEntity()</code> for entity filtering</li> <li> Deprecate <code>getAllScenes()</code> and variants</li> <li> Update <code>getScenesByIds()</code> to use SceneQueryBuilder</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-changes","title":"SceneQueryBuilder Changes","text":"<ul> <li> Add <code>returnIdsOnly</code> option</li> <li> Add <code>unpaginated</code> option</li> <li> Ensure all relation types populated (verify galleries, groups)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#controller-updates","title":"Controller Updates","text":"<ul> <li> <code>scenes.ts</code> - findSimilarScenes</li> <li> <code>scenes.ts</code> - getRecommendedScenes</li> <li> <code>scenes.ts</code> - findScenes fallback path</li> <li> <code>carousel.ts</code> - executeCarouselQuery standard path</li> <li> <code>carousel.ts</code> - custom carousel path (verify already correct)</li> <li> <code>tags.ts</code> - enhanceTagsWithPerformerScenes</li> <li> <code>tags.ts</code> - getTagsWithFilters visibility check</li> <li> <code>tags.ts</code> - getTag scene/group counts</li> <li> <code>tags.ts</code> - related tags visibility check</li> <li> <code>performers.ts</code> - getPerformersWithFilters visibility check</li> <li> <code>performers.ts</code> - getPerformer visibility check</li> <li> <code>studios.ts</code> - getStudiosWithFilters visibility check</li> <li> <code>studios.ts</code> - getStudio visibility check</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#testing","title":"Testing","text":"<ul> <li> Similar Scenes shows performer/tag indicators on cards</li> <li> Recommended Scenes shows performer/tag indicators on cards</li> <li> Homepage carousels show indicators</li> <li> Scenes browse works with all filter combinations</li> <li> Entity pages (performers, tags, studios) filter correctly for non-admin users</li> <li> Performance acceptable (measure query times)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#risks-mitigations","title":"Risks &amp; Mitigations","text":"<p>Risk: Regression in filtering behavior Mitigation: Comprehensive manual testing of all entity pages with non-admin user</p> <p>Risk: Performance degradation from additional relation loading Mitigation: <code>getScenesForScoring()</code> keeps scoring lightweight; only final page of results gets full hydration</p> <p>Risk: Edge cases in SceneQueryBuilder not covered Mitigation: Existing integration tests + add new tests for ID-only and unpaginated modes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#ui-impact-assessment","title":"UI Impact Assessment","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenecardjsx-data-requirements","title":"SceneCard.jsx Data Requirements","text":"<p>The frontend expects these fields on every scene object:</p> Field Used For Currently Broken? <code>scene.performers</code> Count indicator + tooltip grid Yes - empty array <code>scene.performers[].tags</code> Squashed tags calculation Yes - empty <code>scene.groups</code> Count indicator + tooltip grid Yes - empty array <code>scene.galleries</code> Count indicator + tooltip grid Yes - empty array <code>scene.tags</code> Count indicator + tooltip grid Yes - empty array <code>scene.studio</code> Subtitle display Yes - null <code>scene.studio.name</code> Studio name in subtitle Yes - null <code>scene.studio.tags</code> Squashed tags calculation Yes - null <code>scene.paths.*</code> Thumbnails, previews No - works <code>scene.files[0].*</code> Duration, resolution No - works <code>scene.rating/favorite/o_counter</code> Rating row No - works <code>scene.play_count</code> Play count indicator No - works <code>scene.resumeTime</code> Progress bar No - works"},{"location":"plans/2025-12-16-query-architecture-consolidation/#affected-ui-components","title":"Affected UI Components","text":"Component Data Source Issue ScenesLikeThis.jsx <code>/api/library/scenes/:id/similar</code> Missing relation data RecommendedSidebar.jsx <code>/api/library/scenes/:id/similar</code> Missing studio data SceneCard.jsx Various endpoints Shows \"0\" for all entity counts Home.jsx carousels Standard carousel endpoints Missing relation data"},{"location":"plans/2025-12-16-query-architecture-consolidation/#verification","title":"Verification","text":"<p>No UI code changes needed. The frontend already expects full scene objects with relations. The consolidation will fix the backend to return complete data.</p> <p>After implementation, verify: - [ ] Scene cards show correct performer counts (not 0) - [ ] Scene cards show correct tag counts (not 0) - [ ] Scene cards show correct group counts (not 0) - [ ] Scene cards show correct gallery counts (not 0) - [ ] Hovering indicators shows entity tooltip grids - [ ] Studio name appears in card subtitles - [ ] Similar Scenes section displays full card data - [ ] Recommended sidebar shows studio names</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#out-of-scope-future-work","title":"Out of Scope (Future Work)","text":"<ul> <li>Tag hierarchy normalization (<code>parentIds</code> JSON \u2192 <code>TagRelation</code> table)</li> <li>Alias normalization (performer/tag aliases \u2192 separate tables)</li> <li>Studio hierarchy improvements</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-implementation/","title":"Query Architecture Consolidation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Consolidate all scene queries to use SceneQueryBuilder so every scene object has consistent relations (performers, tags, studio, groups, galleries).</p> <p>Architecture: Two-phase query for scoring operations (lightweight IDs for scoring, then SceneQueryBuilder for final results). All other paths use SceneQueryBuilder directly.</p> <p>Tech Stack: TypeScript, Prisma, SQLite, Vitest</p>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-1-add-scenescoringdata-type","title":"Task 1: Add SceneScoringData Type","text":"<p>Files: - Modify: <code>server/types/entities.ts</code></p> <p>Step 1: Add the type definition</p> <p>Add after the existing type exports (around line 200):</p> <pre><code>/**\n * Lightweight scene data for scoring operations\n * Contains only IDs needed for similarity/recommendation scoring\n */\nexport interface SceneScoringData {\n  id: string;\n  studioId: string | null;\n  performerIds: string[];\n  tagIds: string[];\n  oCounter: number;\n  date: string | null;\n}\n</code></pre> <p>Step 2: Export from index</p> <p>Modify <code>server/types/index.ts</code> to add export:</p> <pre><code>export type {\n  NormalizedScene,\n  NormalizedPerformer,\n  NormalizedStudio,\n  NormalizedTag,\n  NormalizedGallery,\n  NormalizedGroup,\n  SceneScoringData,  // Add this line\n} from \"./entities.js\";\n</code></pre> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/types/entities.ts server/types/index.ts\ngit commit -m \"feat: add SceneScoringData type for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-2-add-getscenesforscoring-method","title":"Task 2: Add getScenesForScoring Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>server/services/__tests__/StashEntityService.scoring.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { StashEntityService } from \"../StashEntityService.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $queryRawUnsafe: vi.fn(),\n  },\n}));\n\ndescribe(\"StashEntityService.getScenesForScoring\", () =&gt; {\n  let service: StashEntityService;\n\n  beforeEach(() =&gt; {\n    service = new StashEntityService();\n    vi.clearAllMocks();\n  });\n\n  it(\"should return lightweight scoring data for all scenes\", async () =&gt; {\n    const mockRows = [\n      {\n        id: \"scene-1\",\n        studioId: \"studio-1\",\n        oCounter: 5,\n        date: \"2024-01-15\",\n        performerIds: \"perf-1,perf-2\",\n        tagIds: \"tag-1,tag-2,tag-3\",\n      },\n      {\n        id: \"scene-2\",\n        studioId: null,\n        oCounter: 0,\n        date: null,\n        performerIds: \"\",\n        tagIds: \"tag-1\",\n      },\n    ];\n\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue(mockRows);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual({\n      id: \"scene-1\",\n      studioId: \"studio-1\",\n      performerIds: [\"perf-1\", \"perf-2\"],\n      tagIds: [\"tag-1\", \"tag-2\", \"tag-3\"],\n      oCounter: 5,\n      date: \"2024-01-15\",\n    });\n    expect(result[1]).toEqual({\n      id: \"scene-2\",\n      studioId: null,\n      performerIds: [],\n      tagIds: [\"tag-1\"],\n      oCounter: 0,\n      date: null,\n    });\n  });\n\n  it(\"should return empty array when no scenes exist\", async () =&gt; {\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue([]);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toEqual([]);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: FAIL with \"getScenesForScoring is not a function\"</p> <p>Step 3: Implement the method</p> <p>Add to <code>server/services/StashEntityService.ts</code> after line 161 (after <code>getAllScenes</code>):</p> <pre><code>  /**\n   * Get lightweight scene data for scoring operations\n   * Returns only IDs needed for similarity/recommendation calculations\n   * Much more efficient than loading full scene objects\n   */\n  async getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n    const startTime = Date.now();\n\n    // Single query that aggregates performer and tag IDs\n    const sql = `\n      SELECT\n        s.id,\n        s.studioId,\n        s.oCounter,\n        s.date,\n        COALESCE(GROUP_CONCAT(DISTINCT sp.performerId), '') as performerIds,\n        COALESCE(GROUP_CONCAT(DISTINCT st.tagId), '') as tagIds\n      FROM StashScene s\n      LEFT JOIN ScenePerformer sp ON s.id = sp.sceneId\n      LEFT JOIN SceneTag st ON s.id = st.sceneId\n      WHERE s.deletedAt IS NULL\n      GROUP BY s.id\n    `;\n\n    const rows = await prisma.$queryRawUnsafe&lt;Array&lt;{\n      id: string;\n      studioId: string | null;\n      oCounter: number;\n      date: string | null;\n      performerIds: string;\n      tagIds: string;\n    }&gt;&gt;(sql);\n\n    const result: SceneScoringData[] = rows.map(row =&gt; ({\n      id: row.id,\n      studioId: row.studioId,\n      performerIds: row.performerIds ? row.performerIds.split(',').filter(Boolean) : [],\n      tagIds: row.tagIds ? row.tagIds.split(',').filter(Boolean) : [],\n      oCounter: row.oCounter || 0,\n      date: row.date,\n    }));\n\n    logger.info(`getScenesForScoring: ${Date.now() - startTime}ms, count=${result.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 4: Add import for SceneScoringData</p> <p>Update the import at top of <code>StashEntityService.ts</code>:</p> <pre><code>import type {\n  NormalizedGallery,\n  NormalizedGroup,\n  NormalizedPerformer,\n  NormalizedScene,\n  NormalizedStudio,\n  NormalizedTag,\n  SceneScoringData,  // Add this\n} from \"../types/index.js\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/services/__tests__/StashEntityService.scoring.test.ts\ngit commit -m \"feat: add getScenesForScoring for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-3-add-getscenesbyids-to-scenequerybuilder","title":"Task 3: Add getScenesByIds to SceneQueryBuilder","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code>:</p> <pre><code>  it(\"should fetch scenes by IDs with full relations\", async () =&gt; {\n    // First get some scene IDs\n    const initial = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 3,\n    });\n\n    if (initial.scenes.length &lt; 2) {\n      console.log(\"Skipping getByIds test - not enough scenes\");\n      return;\n    }\n\n    const idsToFetch = initial.scenes.slice(0, 2).map(s =&gt; s.id);\n\n    const result = await sceneQueryBuilder.getByIds({\n      userId: 1,\n      ids: idsToFetch,\n    });\n\n    expect(result.scenes).toHaveLength(2);\n    expect(result.scenes.map(s =&gt; s.id).sort()).toEqual(idsToFetch.sort());\n\n    // Verify relations are populated\n    for (const scene of result.scenes) {\n      expect(scene).toHaveProperty(\"performers\");\n      expect(scene).toHaveProperty(\"tags\");\n      expect(scene).toHaveProperty(\"groups\");\n      expect(scene).toHaveProperty(\"galleries\");\n      expect(Array.isArray(scene.performers)).toBe(true);\n      expect(Array.isArray(scene.tags)).toBe(true);\n    }\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: FAIL with \"getByIds is not a function\"</p> <p>Step 3: Add the interface</p> <p>Add after <code>SceneQueryResult</code> interface (around line 34) in <code>SceneQueryBuilder.ts</code>:</p> <pre><code>// Query by IDs options\nexport interface SceneByIdsOptions {\n  userId: number;\n  ids: string[];\n}\n</code></pre> <p>Step 4: Implement getByIds method</p> <p>Add before the closing brace of the class (around line 1760):</p> <pre><code>  /**\n   * Get scenes by IDs with full relations\n   * Used after scoring to fetch the final paginated results\n   */\n  async getByIds(options: SceneByIdsOptions): Promise&lt;SceneQueryResult&gt; {\n    const { userId, ids } = options;\n\n    if (ids.length === 0) {\n      return { scenes: [], total: 0 };\n    }\n\n    // Use execute with ID filter\n    return this.execute({\n      userId,\n      filters: {\n        ids: { value: ids, modifier: \"INCLUDES\" },\n      },\n      sort: \"created_at\", // Default sort, results will be reordered by caller if needed\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: ids.length, // Get all requested IDs\n    });\n  }\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"feat: add getByIds method to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-4-refactor-findsimilarscenes-to-use-new-architecture","title":"Task 4: Refactor findSimilarScenes to Use New Architecture","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Add imports</p> <p>At top of <code>scenes.ts</code>, add:</p> <pre><code>import { sceneQueryBuilder } from \"../../services/SceneQueryBuilder.js\";\n</code></pre> <p>And update the stashEntityService import to include SceneScoringData type.</p> <p>Step 2: Refactor findSimilarScenes</p> <p>Replace the <code>findSimilarScenes</code> function (lines 1219-1374) with:</p> <pre><code>/**\n * Find similar scenes based on weighted scoring\n * Performers: 3 points each\n * Tags: 1 point each\n * Studio: 1 point\n *\n * Uses two-phase query:\n * 1. Lightweight scoring query to score all scenes\n * 2. SceneQueryBuilder to fetch final results with relations\n */\nexport const findSimilarScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const { id } = req.params;\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = 12;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Get excluded scene IDs for this user\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n\n    // Filter out excluded scenes and current scene\n    const scoringData = allScoringData.filter(\n      s =&gt; s.id !== id &amp;&amp; !excludedIds.has(s.id)\n    );\n\n    // Find the current scene's data\n    const currentScene = allScoringData.find(s =&gt; s.id === id);\n    if (!currentScene) {\n      return res.status(404).json({ error: \"Scene not found\" });\n    }\n\n    // Check if current scene has any metadata\n    const hasMetadata =\n      currentScene.performerIds.length &gt; 0 ||\n      currentScene.studioId ||\n      currentScene.tagIds.length &gt; 0;\n\n    if (!hasMetadata) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n      });\n    }\n\n    // Build sets for fast lookup\n    const currentPerformerIds = new Set(currentScene.performerIds);\n    const currentTagIds = new Set(currentScene.tagIds);\n    const currentStudioId = currentScene.studioId;\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n      date: string | null;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n\n    for (const scene of scoringData) {\n      let score = 0;\n\n      // Score for matching performers (3 points each)\n      for (const performerId of scene.performerIds) {\n        if (currentPerformerIds.has(performerId)) {\n          score += 3;\n        }\n      }\n\n      // Score for matching studio (1 point)\n      if (currentStudioId &amp;&amp; scene.studioId === currentStudioId) {\n        score += 1;\n      }\n\n      // Score for matching tags (1 point each)\n      for (const tagId of scene.tagIds) {\n        if (currentTagIds.has(tagId)) {\n          score += 1;\n        }\n      }\n\n      if (score &gt; 0) {\n        scoredScenes.push({ id: scene.id, score, date: scene.date });\n      }\n    }\n\n    // Sort by score descending, then by date descending\n    scoredScenes.sort((a, b) =&gt; {\n      if (b.score !== a.score) {\n        return b.score - a.score;\n      }\n      const dateA = a.date ? new Date(a.date).getTime() : 0;\n      const dateB = b.date ? new Date(b.date).getTime() : 0;\n      return dateB - dateA;\n    });\n\n    // Paginate\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = scoredScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: scoredScenes.length,\n        page,\n        perPage,\n      });\n    }\n\n    // Phase 2: Fetch full scene data via SceneQueryBuilder\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order (getByIds may return in different order)\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: scoredScenes.length,\n      page,\n      perPage,\n    });\n  } catch (error) {\n    logger.error(\"Error finding similar scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to find similar scenes\" });\n  }\n};\n</code></pre> <p>Step 3: Run the application and test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Open a scene detail page and verify Similar Scenes shows performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: findSimilarScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-5-add-getexcludedsceneids-to-userrestrictionservice","title":"Task 5: Add getExcludedSceneIds to UserRestrictionService","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code></p> <p>Step 1: Check if method exists</p> <p>Search for existing <code>getExcludedSceneIds</code> method. If it doesn't exist:</p> <p>Step 2: Add the method</p> <pre><code>  /**\n   * Get set of scene IDs that should be excluded for a user\n   * @param userId - User ID\n   * @param hiddenOnly - If true, only return hidden entities (not content restrictions)\n   */\n  async getExcludedSceneIds(userId: number, hiddenOnly: boolean = false): Promise&lt;Set&lt;string&gt;&gt; {\n    const scenes = await stashEntityService.getAllScenes();\n    const filtered = await this.filterScenesForUser(scenes, userId, hiddenOnly);\n\n    const allIds = new Set(scenes.map(s =&gt; s.id));\n    const visibleIds = new Set(filtered.map(s =&gt; s.id));\n\n    const excludedIds = new Set&lt;string&gt;();\n    for (const id of allIds) {\n      if (!visibleIds.has(id)) {\n        excludedIds.add(id);\n      }\n    }\n\n    return excludedIds;\n  }\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"feat: add getExcludedSceneIds helper method\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-6-refactor-getrecommendedscenes","title":"Task 6: Refactor getRecommendedScenes","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Refactor the function</p> <p>Replace <code>getRecommendedScenes</code> (around line 1380) with similar two-phase pattern:</p> <pre><code>/**\n * Get recommended scenes based on user preferences and watch history\n * Uses favorites, ratings (80+), watch status, and engagement quality\n *\n * Two-phase query:\n * 1. Lightweight scoring data for all scenes\n * 2. SceneQueryBuilder for final paginated results\n */\nexport const getRecommendedScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = parseInt(req.query.per_page as string) || 24;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n\n    // Build preference sets\n    const favoritePerformers = new Set(\n      performerRatings.filter(r =&gt; r.favorite).map(r =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter(r =&gt; r.favorite).map(r =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter(r =&gt; r.favorite).map(r =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.tagId)\n    );\n\n    // Build watch history map\n    const watchMap = new Map(\n      watchHistory.map(wh =&gt; [\n        wh.sceneId,\n        {\n          playCount: wh.playCount || 0,\n          lastPlayedAt: wh.lastPlayedAt,\n        },\n      ])\n    );\n\n    // Get excluded scene IDs\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n    const scoringData = allScoringData.filter(s =&gt; !excludedIds.has(s.id));\n\n    // Count criteria for feedback\n    const criteriaCounts = {\n      favoritePerformers: favoritePerformers.size,\n      highlyRatedPerformers: highlyRatedPerformers.size,\n      favoriteStudios: favoriteStudios.size,\n      highlyRatedStudios: highlyRatedStudios.size,\n      favoriteTags: favoriteTags.size,\n      highlyRatedTags: highlyRatedTags.size,\n    };\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n    const now = new Date();\n\n    for (const scene of scoringData) {\n      let baseScore = 0;\n\n      // Score performers\n      for (const performerId of scene.performerIds) {\n        if (favoritePerformers.has(performerId)) {\n          baseScore += 50;\n        } else if (highlyRatedPerformers.has(performerId)) {\n          baseScore += 30;\n        }\n      }\n\n      // Score studio\n      if (scene.studioId) {\n        if (favoriteStudios.has(scene.studioId)) {\n          baseScore += 25;\n        } else if (highlyRatedStudios.has(scene.studioId)) {\n          baseScore += 15;\n        }\n      }\n\n      // Score tags\n      for (const tagId of scene.tagIds) {\n        if (favoriteTags.has(tagId)) {\n          baseScore += 10;\n        } else if (highlyRatedTags.has(tagId)) {\n          baseScore += 5;\n        }\n      }\n\n      if (baseScore === 0) continue;\n\n      // Watch status modifier\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        adjustedScore += 30; // Never watched bonus\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) / (24 * 60 * 60 * 1000);\n        if (daysSinceWatched &gt; 14) {\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          adjustedScore -= 10;\n        } else {\n          adjustedScore -= 30; // Very recently watched penalty\n        }\n      }\n\n      // Engagement multiplier\n      const engagementMultiplier = 1.0 + Math.min(scene.oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ id: scene.id, score: finalScore });\n      }\n    }\n\n    // Sort by score descending\n    scoredScenes.sort((a, b) =&gt; b.score - a.score);\n\n    // Cap at 500 and paginate\n    const cappedScenes = scoredScenes.slice(0, 500);\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = cappedScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: cappedScenes.length,\n        page,\n        perPage,\n        criteria: criteriaCounts,\n      });\n    }\n\n    // Phase 2: Fetch full scene data\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: cappedScenes.length,\n      page,\n      perPage,\n      criteria: criteriaCounts,\n    });\n  } catch (error) {\n    logger.error(\"Error getting recommended scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to get recommendations\" });\n  }\n};\n</code></pre> <p>Step 2: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Check homepage Recommended section shows performer/tag counts</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: getRecommendedScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-7-refactor-standard-carousels","title":"Task 7: Refactor Standard Carousels","text":"<p>Files: - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Find executeCarouselQuery function</p> <p>Locate the <code>executeCarouselQuery</code> function that uses <code>getAllScenes()</code>.</p> <p>Step 2: Refactor to use SceneQueryBuilder</p> <p>Replace the <code>getAllScenes()</code> path with SceneQueryBuilder. The function should: 1. Build filters from carousel query 2. Call <code>sceneQueryBuilder.execute()</code> 3. Return scenes with full relations</p> <p>Step 3: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Homepage carousels show performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/carousel.ts\ngit commit -m \"refactor: standard carousels use SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-8-remove-deprecated-methods","title":"Task 8: Remove Deprecated Methods","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Mark methods as deprecated</p> <p>Add JSDoc <code>@deprecated</code> tags to: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code> - <code>getScenesByIdsWithRelations()</code></p> <p>Step 2: Update remaining callers</p> <p>Search for any remaining usages and update them to use SceneQueryBuilder or <code>getScenesForScoring()</code>.</p> <p>Step 3: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: deprecate old scene query methods, update remaining callers\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-9-update-entity-visibility-filtering","title":"Task 9: Update Entity Visibility Filtering","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/studios.ts</code></p> <p>Step 1: Create getVisibleSceneIdsByEntity method</p> <p>Add to <code>StashEntityService.ts</code>:</p> <pre><code>  /**\n   * Get scene IDs visible to a user, grouped by entity type\n   * Used for empty entity filtering without loading full scenes\n   */\n  async getVisibleSceneIdsByPerformer(userId: number): Promise&lt;Map&lt;string, Set&lt;string&gt;&gt;&gt; {\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, false);\n\n    const junctions = await prisma.scenePerformer.findMany({\n      where: {\n        scene: { deletedAt: null },\n        sceneId: { notIn: Array.from(excludedIds) },\n      },\n      select: { sceneId: true, performerId: true },\n    });\n\n    const result = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const j of junctions) {\n      const set = result.get(j.performerId) || new Set();\n      set.add(j.sceneId);\n      result.set(j.performerId, set);\n    }\n\n    return result;\n  }\n</code></pre> <p>Step 2: Update performers.ts visibility checks</p> <p>Replace <code>getAllScenesWithPerformers()</code> calls with the new method.</p> <p>Step 3: Test manually</p> <p>Test non-admin user can browse performers page correctly.</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: entity visibility uses direct junction queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-10-final-cleanup-and-testing","title":"Task 10: Final Cleanup and Testing","text":"<p>Files: - All modified files</p> <p>Step 1: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Manual verification checklist</p> <ul> <li> Scene cards show correct performer counts (not 0)</li> <li> Scene cards show correct tag counts (not 0)</li> <li> Scene cards show correct group counts (not 0)</li> <li> Scene cards show correct gallery counts (not 0)</li> <li> Hovering indicators shows entity tooltip grids</li> <li> Studio name appears in card subtitles</li> <li> Similar Scenes section displays full card data</li> <li> Recommended sidebar shows studio names</li> <li> Homepage carousels show full card data</li> <li> Scenes browse works with filters</li> <li> Non-admin user filtering works correctly</li> </ul> <p>Step 4: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: query architecture consolidation complete\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#summary","title":"Summary","text":"<p>This plan consolidates all scene queries to use <code>SceneQueryBuilder</code>, ensuring consistent scene objects with populated relations. The key changes are:</p> <ol> <li>New <code>getScenesForScoring()</code> - Lightweight query for scoring operations</li> <li>New <code>getByIds()</code> on SceneQueryBuilder - Fetch specific scenes with relations</li> <li>Two-phase query pattern - Score with lightweight data, fetch with full relations</li> <li>Deprecated old methods - <code>getAllScenes*()</code> variants marked deprecated</li> <li>Direct junction queries - For entity visibility filtering</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/","title":"Recommendations Improvements Design","text":"<p>Date: 2025-12-16 Branch: <code>feature/recommendations-improvements</code> Related Issues: #181, #172</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#problem-statement","title":"Problem Statement","text":"<p>Users report the Recommended page shows no content despite having favorited/rated scenes. The current algorithm only considers explicit Performer, Studio, and Tag ratings\u2014not Scene ratings. Users naturally rate scenes first, leading to confusion when recommendations don't appear.</p> <p>Additionally, error messages are unhelpful and logging doesn't capture enough detail to diagnose issues.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#design-overview","title":"Design Overview","text":"<p>Four improvements:</p> <ol> <li>Scene-based recommendations - Derive entity preferences from rated/favorited scenes</li> <li>Inline user feedback - Show users what's missing when recommendations are empty</li> <li>Better error handling - Improved logging and user-facing error messages</li> <li>Unit tests - Test coverage for recommendation scoring logic</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#1-scene-based-recommendations","title":"1. Scene-Based Recommendations","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#concept","title":"Concept","text":"<p>When a user favorites or rates a scene highly, we extract its entities (performers, studio, tags) and add them to the preference pool with diminished weights compared to explicit entity ratings.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-formula","title":"Weight Formula","text":"<pre><code>// Skip scenes rated below threshold\nif (sceneRating &lt; 40) continue;\n\n// Favorited-only scenes get implicit rating\nconst effectiveRating = sceneRating ?? (isFavorited ? 85 : null);\nif (effectiveRating === null) continue;\n\n// Calculate weight multiplier\nconst BASE_WEIGHT = 0.4;\nconst FAVORITE_BONUS = 0.15;\n\nlet weightMultiplier = (effectiveRating / 100) * BASE_WEIGHT;\nif (isFavorited) {\n  weightMultiplier += FAVORITE_BONUS;\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-examples","title":"Weight Examples","text":"Scenario Multiplier Performer pts vs Explicit (5 pts) Scene rated 100 + favorited 0.55 2.75 55% Scene favorited only (\u219285) 0.49 2.45 49% Scene rated 100, not fav 0.40 2.00 40% Scene rated 80 + favorited 0.47 2.35 47% Scene rated 80, not fav 0.32 1.60 32% Scene rated 60, not fav 0.24 1.20 24% Scene rated 40, not fav 0.16 0.80 16% Scene rated 39 - 0 (skipped) -"},{"location":"plans/2025-12-16-recommendations-improvements-design/#implementation","title":"Implementation","text":"<p>In <code>getRecommendedScenes()</code>:</p> <ol> <li>Fetch <code>sceneRatings</code> alongside existing performer/studio/tag ratings</li> <li>Build derived preference maps from favorited/rated scenes:</li> <li><code>derivedPerformerWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedStudioWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedTagWeights: Map&lt;string, number&gt;</code></li> <li>When scoring, combine explicit preferences with derived weights</li> <li>Apply same sqrt diminishing returns to derived weights</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#derived-weight-accumulation","title":"Derived Weight Accumulation","text":"<p>When multiple scenes contribute to the same entity, weights accumulate but with diminishing returns:</p> <pre><code>// For each scene's performer\nconst sceneWeight = calculateSceneWeight(scene);\nconst currentWeight = derivedPerformerWeights.get(performerId) || 0;\nderivedPerformerWeights.set(performerId, currentWeight + sceneWeight);\n\n// When scoring, apply sqrt to accumulated derived weights\nconst derivedPerformerScore = Math.sqrt(derivedPerformerWeight) * 5;\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#2-inline-user-feedback","title":"2. Inline User Feedback","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#empty-state-message","title":"Empty State Message","text":"<p>When recommendations return empty, the API response includes diagnostic info:</p> <pre><code>// Response structure\n{\n  scenes: [],\n  count: 0,\n  page: 1,\n  perPage: 24,\n  message: \"No recommendations yet\",\n  criteria: {\n    favoritedPerformers: 0,\n    ratedPerformers: 0,\n    favoritedStudios: 0,\n    ratedStudios: 0,\n    favoritedTags: 0,\n    ratedTags: 0,\n    favoritedScenes: 3,\n    ratedScenes: 5\n  }\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-display","title":"Client Display","text":"<p>The Recommended page shows:</p> <p>No Recommendations Yet</p> <p>To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.</p> <p>Your current activity: - 0 favorited performers, 0 highly-rated performers - 0 favorited studios, 0 highly-rated studios - 0 favorited tags, 0 highly-rated tags - 3 favorited scenes, 5 rated scenes</p> <p>Tip: Rating more scenes helps us learn your preferences!</p> <p>If they have scene activity but no results, clarify:</p> <p>We're analyzing your rated scenes to find recommendations...</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#3-better-error-handling","title":"3. Better Error Handling","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#server-side-logging","title":"Server-Side Logging","text":"<p>Update the catch block to capture full error details:</p> <pre><code>catch (error) {\n  const err = error as Error;\n  logger.error(\"Error getting recommended scenes:\", {\n    message: err.message,\n    name: err.name,\n    stack: err.stack,\n    userId,\n  });\n\n  const errorType = err.name || \"Unknown error\";\n  res.status(500).json({\n    error: \"Failed to get recommended scenes\",\n    errorType\n  });\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-side-display","title":"Client-Side Display","text":"<pre><code>{error &amp;&amp; (\n  &lt;ErrorMessage&gt;\n    Unable to load recommendations. ({error.errorType || \"Please try again later\"})\n  &lt;/ErrorMessage&gt;\n)}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#4-unit-tests","title":"4. Unit Tests","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-file","title":"Test File","text":"<p>Create <code>server/tests/recommendations/recommendationScoring.test.ts</code></p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-cases","title":"Test Cases","text":"<p>Explicit entity scoring: - Favorited performer adds 5 points - Highly-rated performer (80+) adds 3 points - Favorited studio adds 3 points - Multiple performers use sqrt diminishing returns</p> <p>Scene-derived scoring: - Scene rated 100 derives 40% weight for entities - Scene rated 100 + favorited derives 55% weight - Scene favorited only uses implicit rating of 85 - Scene rated &lt; 40 contributes nothing - Multiple scenes for same performer accumulate with sqrt</p> <p>Edge cases: - User with no ratings/favorites returns empty with message - User with only scene ratings (no explicit) still gets recommendations - Scene with no performers/studio/tags contributes nothing - Combination of explicit + derived preferences</p> <p>Weight calculation: - <code>calculateSceneWeight(100, true)</code> returns 0.55 - <code>calculateSceneWeight(85, false)</code> returns 0.34 - <code>calculateSceneWeight(39, false)</code> returns 0 (below floor)</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#files-to-modify","title":"Files to Modify","text":"File Changes <code>server/controllers/library/scenes.ts</code> Update <code>getRecommendedScenes()</code> with scene-derived scoring, criteria response, error handling <code>client/src/components/pages/Recommended.jsx</code> Display criteria counts in empty state, show error type <code>server/tests/recommendations/recommendationScoring.test.ts</code> New test file"},{"location":"plans/2025-12-16-recommendations-improvements-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Negative signals from low-rated scenes (future enhancement)</li> <li>Collaborative filtering (\"users like you also liked\")</li> <li>Watch time / percentage watched as signal</li> <li>Admin diagnostic endpoint (replaced by inline feedback)</li> </ul>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#testing-plan","title":"Testing Plan","text":"<ol> <li>Unit tests pass for scoring logic</li> <li>Manual test: User with only scene favorites sees recommendations</li> <li>Manual test: Empty state shows correct criteria counts</li> <li>Manual test: Error state shows error type</li> <li>Verify existing explicit-rating users still get correct recommendations</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/","title":"Recommendations Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Enable scene-based recommendations, add inline user feedback, improve error handling, and add unit tests.</p> <p>Architecture: Extract a pure <code>RecommendationScoringService</code> from the controller to make scoring logic testable. The service calculates entity weights from both explicit ratings and scene-derived preferences. Controller handles HTTP concerns only.</p> <p>Tech Stack: TypeScript, Vitest, Prisma, React</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-1-extract-recommendation-scoring-service","title":"Task 1: Extract Recommendation Scoring Service","text":"<p>Create a pure service with testable scoring functions.</p> <p>Files: - Create: <code>server/services/RecommendationScoringService.ts</code></p> <p>Step 1: Create the service file with types and constants</p> <pre><code>// server/services/RecommendationScoringService.ts\nimport type { NormalizedScene } from \"../types/index.js\";\n\n// Configuration constants\nexport const SCENE_WEIGHT_BASE = 0.4;\nexport const SCENE_WEIGHT_FAVORITE_BONUS = 0.15;\nexport const SCENE_RATING_FLOOR = 40;\nexport const SCENE_FAVORITED_IMPLICIT_RATING = 85;\n\n// Explicit entity scoring weights (from current algorithm)\nexport const PERFORMER_FAVORITE_WEIGHT = 5;\nexport const PERFORMER_RATED_WEIGHT = 3;\nexport const STUDIO_FAVORITE_WEIGHT = 3;\nexport const STUDIO_RATED_WEIGHT = 2;\nexport const TAG_SCENE_FAVORITE_WEIGHT = 1.0;\nexport const TAG_SCENE_RATED_WEIGHT = 0.5;\nexport const TAG_PERFORMER_FAVORITE_WEIGHT = 0.3;\nexport const TAG_PERFORMER_RATED_WEIGHT = 0.15;\nexport const TAG_STUDIO_FAVORITE_WEIGHT = 0.5;\nexport const TAG_STUDIO_RATED_WEIGHT = 0.25;\n\nexport interface SceneRatingInput {\n  sceneId: string;\n  rating: number | null;\n  favorite: boolean;\n}\n\nexport interface EntityPreferences {\n  favoritePerformers: Set&lt;string&gt;;\n  highlyRatedPerformers: Set&lt;string&gt;;\n  favoriteStudios: Set&lt;string&gt;;\n  highlyRatedStudios: Set&lt;string&gt;;\n  favoriteTags: Set&lt;string&gt;;\n  highlyRatedTags: Set&lt;string&gt;;\n  // Derived weights from scenes (accumulated per entity)\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n}\n\nexport interface UserCriteriaCounts {\n  favoritedPerformers: number;\n  ratedPerformers: number;\n  favoritedStudios: number;\n  ratedStudios: number;\n  favoritedTags: number;\n  ratedTags: number;\n  favoritedScenes: number;\n  ratedScenes: number;\n}\n\n/**\n * Calculate weight multiplier for a scene based on rating and favorite status\n * Returns 0 if scene should be skipped (below floor, no rating/favorite)\n */\nexport function calculateSceneWeightMultiplier(\n  rating: number | null,\n  favorite: boolean\n): number {\n  // Determine effective rating\n  let effectiveRating: number | null = rating;\n\n  if (effectiveRating === null &amp;&amp; favorite) {\n    effectiveRating = SCENE_FAVORITED_IMPLICIT_RATING;\n  }\n\n  if (effectiveRating === null) {\n    return 0;\n  }\n\n  if (effectiveRating &lt; SCENE_RATING_FLOOR) {\n    return 0;\n  }\n\n  let multiplier = (effectiveRating / 100) * SCENE_WEIGHT_BASE;\n\n  if (favorite) {\n    multiplier += SCENE_WEIGHT_FAVORITE_BONUS;\n  }\n\n  return multiplier;\n}\n\n/**\n * Build derived entity weights from rated/favorited scenes\n */\nexport function buildDerivedWeightsFromScenes(\n  sceneRatings: SceneRatingInput[],\n  getSceneById: (sceneId: string) =&gt; NormalizedScene | undefined\n): {\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n} {\n  const derivedPerformerWeights = new Map&lt;string, number&gt;();\n  const derivedStudioWeights = new Map&lt;string, number&gt;();\n  const derivedTagWeights = new Map&lt;string, number&gt;();\n\n  for (const sceneRating of sceneRatings) {\n    const multiplier = calculateSceneWeightMultiplier(\n      sceneRating.rating,\n      sceneRating.favorite\n    );\n\n    if (multiplier === 0) continue;\n\n    const scene = getSceneById(sceneRating.sceneId);\n    if (!scene) continue;\n\n    // Accumulate performer weights\n    if (scene.performers) {\n      for (const performer of scene.performers) {\n        const performerId = String(performer.id);\n        const current = derivedPerformerWeights.get(performerId) || 0;\n        derivedPerformerWeights.set(performerId, current + multiplier);\n      }\n    }\n\n    // Accumulate studio weight\n    if (scene.studio) {\n      const studioId = String(scene.studio.id);\n      const current = derivedStudioWeights.get(studioId) || 0;\n      derivedStudioWeights.set(studioId, current + multiplier);\n    }\n\n    // Accumulate tag weights (scene tags only, not performer/studio tags)\n    if (scene.tags) {\n      for (const tag of scene.tags) {\n        const tagId = String(tag.id);\n        const current = derivedTagWeights.get(tagId) || 0;\n        derivedTagWeights.set(tagId, current + multiplier);\n      }\n    }\n  }\n\n  return {\n    derivedPerformerWeights,\n    derivedStudioWeights,\n    derivedTagWeights,\n  };\n}\n\n/**\n * Score a scene based on user preferences (explicit + derived)\n * Returns the base score before watch status modifiers\n */\nexport function scoreSceneByPreferences(\n  scene: NormalizedScene,\n  prefs: EntityPreferences\n): number {\n  let baseScore = 0;\n\n  // Score performers with diminishing returns (sqrt scaling)\n  if (scene.performers) {\n    let favoritePerformerCount = 0;\n    let highlyRatedPerformerCount = 0;\n    let derivedPerformerWeight = 0;\n\n    for (const performer of scene.performers) {\n      const performerId = String(performer.id);\n\n      if (prefs.favoritePerformers.has(performerId)) {\n        favoritePerformerCount++;\n      } else if (prefs.highlyRatedPerformers.has(performerId)) {\n        highlyRatedPerformerCount++;\n      }\n\n      // Add derived weight\n      const derived = prefs.derivedPerformerWeights.get(performerId);\n      if (derived) {\n        derivedPerformerWeight += derived;\n      }\n    }\n\n    if (favoritePerformerCount &gt; 0) {\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerCount);\n    }\n    if (highlyRatedPerformerCount &gt; 0) {\n      baseScore += PERFORMER_RATED_WEIGHT * Math.sqrt(highlyRatedPerformerCount);\n    }\n    if (derivedPerformerWeight &gt; 0) {\n      // Apply sqrt to accumulated derived weight, scale by favorite weight\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(derivedPerformerWeight);\n    }\n  }\n\n  // Score studio\n  if (scene.studio) {\n    const studioId = String(scene.studio.id);\n\n    if (prefs.favoriteStudios.has(studioId)) {\n      baseScore += STUDIO_FAVORITE_WEIGHT;\n    } else if (prefs.highlyRatedStudios.has(studioId)) {\n      baseScore += STUDIO_RATED_WEIGHT;\n    }\n\n    // Add derived studio weight\n    const derivedStudio = prefs.derivedStudioWeights.get(studioId);\n    if (derivedStudio) {\n      baseScore += STUDIO_FAVORITE_WEIGHT * Math.sqrt(derivedStudio);\n    }\n  }\n\n  // Score tags with source weighting\n  const sceneTags = new Set&lt;string&gt;();\n  const performerTags = new Set&lt;string&gt;();\n  const studioTags = new Set&lt;string&gt;();\n\n  (scene.tags || []).forEach((t) =&gt; sceneTags.add(String(t.id)));\n  (scene.performers || []).forEach((p) =&gt; {\n    (p.tags || []).forEach((t) =&gt; performerTags.add(String(t.id)));\n  });\n  if (scene.studio?.tags) {\n    scene.studio.tags.forEach((t) =&gt; studioTags.add(String(t.id)));\n  }\n\n  let favoriteSceneTagCount = 0;\n  let favoritePerformerTagCount = 0;\n  let favoriteStudioTagCount = 0;\n  let ratedSceneTagCount = 0;\n  let ratedPerformerTagCount = 0;\n  let ratedStudioTagCount = 0;\n  let derivedTagWeight = 0;\n\n  for (const tagId of sceneTags) {\n    if (prefs.favoriteTags.has(tagId)) favoriteSceneTagCount++;\n    else if (prefs.highlyRatedTags.has(tagId)) ratedSceneTagCount++;\n\n    const derived = prefs.derivedTagWeights.get(tagId);\n    if (derived) derivedTagWeight += derived;\n  }\n\n  for (const tagId of performerTags) {\n    if (!sceneTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoritePerformerTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedPerformerTagCount++;\n    }\n  }\n\n  for (const tagId of studioTags) {\n    if (!sceneTags.has(tagId) &amp;&amp; !performerTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoriteStudioTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedStudioTagCount++;\n    }\n  }\n\n  if (favoriteSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(favoriteSceneTagCount);\n  }\n  if (favoritePerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerTagCount);\n  }\n  if (favoriteStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_FAVORITE_WEIGHT * Math.sqrt(favoriteStudioTagCount);\n  }\n  if (ratedSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_RATED_WEIGHT * Math.sqrt(ratedSceneTagCount);\n  }\n  if (ratedPerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_RATED_WEIGHT * Math.sqrt(ratedPerformerTagCount);\n  }\n  if (ratedStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_RATED_WEIGHT * Math.sqrt(ratedStudioTagCount);\n  }\n  if (derivedTagWeight &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(derivedTagWeight);\n  }\n\n  return baseScore;\n}\n\n/**\n * Count user's criteria for feedback display\n */\nexport function countUserCriteria(\n  performerRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  studioRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  tagRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  sceneRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;\n): UserCriteriaCounts {\n  return {\n    favoritedPerformers: performerRatings.filter((r) =&gt; r.favorite).length,\n    ratedPerformers: performerRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedStudios: studioRatings.filter((r) =&gt; r.favorite).length,\n    ratedStudios: studioRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedTags: tagRatings.filter((r) =&gt; r.favorite).length,\n    ratedTags: tagRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedScenes: sceneRatings.filter((r) =&gt; r.favorite).length,\n    ratedScenes: sceneRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= SCENE_RATING_FLOOR).length,\n  };\n}\n\n/**\n * Check if user has any criteria that could generate recommendations\n */\nexport function hasAnyCriteria(counts: UserCriteriaCounts): boolean {\n  return (\n    counts.favoritedPerformers &gt; 0 ||\n    counts.ratedPerformers &gt; 0 ||\n    counts.favoritedStudios &gt; 0 ||\n    counts.ratedStudios &gt; 0 ||\n    counts.favoritedTags &gt; 0 ||\n    counts.ratedTags &gt; 0 ||\n    counts.favoritedScenes &gt; 0 ||\n    counts.ratedScenes &gt; 0\n  );\n}\n</code></pre> <p>Step 2: Run TypeScript compiler to verify no errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/RecommendationScoringService.ts\ngit commit -m \"feat: extract RecommendationScoringService with scoring logic\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-2-unit-tests-for-scene-weight-calculation","title":"Task 2: Unit Tests for Scene Weight Calculation","text":"<p>Files: - Create: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Create test file with weight calculation tests</p> <pre><code>// server/tests/recommendations/recommendationScoring.test.ts\nimport { describe, it, expect } from \"vitest\";\nimport {\n  calculateSceneWeightMultiplier,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n} from \"../../services/RecommendationScoringService.js\";\n\ndescribe(\"RecommendationScoringService\", () =&gt; {\n  describe(\"calculateSceneWeightMultiplier\", () =&gt; {\n    it(\"returns 0 for null rating without favorite\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(null, false)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for favorited-only scene (implicit 85)\", () =&gt; {\n      const expected = (SCENE_FAVORITED_IMPLICIT_RATING / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(expected, 5);\n      // Should be ~0.49 (0.34 + 0.15)\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(0.49, 2);\n    });\n\n    it(\"returns 0 for rating below floor (39)\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(39, false)).toBe(0);\n      expect(calculateSceneWeightMultiplier(39, true)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for rating at floor (40)\", () =&gt; {\n      const expected = (40 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(expected, 5);\n      // Should be 0.16\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(0.16, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 without favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(expected, 5);\n      // Should be 0.40\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(0.40, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 with favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(expected, 5);\n      // Should be 0.55\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(0.55, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 without favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(expected, 5);\n      // Should be 0.32\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(0.32, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 with favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(expected, 5);\n      // Should be 0.47\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(0.47, 2);\n    });\n\n    it(\"returns correct multiplier for rating 60 without favorite\", () =&gt; {\n      const expected = (60 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(expected, 5);\n      // Should be 0.24\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(0.24, 2);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene weight calculation\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-3-unit-tests-for-derived-weights-and-scoring","title":"Task 3: Unit Tests for Derived Weights and Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for buildDerivedWeightsFromScenes</p> <p>Add to the existing test file:</p> <pre><code>import {\n  calculateSceneWeightMultiplier,\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n  PERFORMER_FAVORITE_WEIGHT,\n  type SceneRatingInput,\n  type EntityPreferences,\n} from \"../../services/RecommendationScoringService.js\";\nimport type { NormalizedScene } from \"../../types/index.js\";\n\n// ... existing tests ...\n\ndescribe(\"buildDerivedWeightsFromScenes\", () =&gt; {\n  const mockScene1: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene 1\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" },\n      { id: \"perf2\", name: \"Performer 2\" },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\" },\n    tags: [\n      { id: \"tag1\", name: \"Tag 1\" },\n      { id: \"tag2\", name: \"Tag 2\" },\n    ],\n  } as NormalizedScene;\n\n  const mockScene2: NormalizedScene = {\n    id: \"scene2\",\n    title: \"Test Scene 2\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" }, // Same performer\n      { id: \"perf3\", name: \"Performer 3\" },\n    ],\n    studio: { id: \"studio2\", name: \"Studio 2\" },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }], // Same tag\n  } as NormalizedScene;\n\n  const sceneMap = new Map&lt;string, NormalizedScene&gt;([\n    [\"scene1\", mockScene1],\n    [\"scene2\", mockScene2],\n  ]);\n\n  const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n  it(\"extracts performer weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts studio weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedStudioWeights.get(\"studio1\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts tag weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedTagWeights.get(\"tag1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedTagWeights.get(\"tag2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"accumulates weights for same entity across multiple scenes\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false }, // perf1: 0.4\n      { sceneId: \"scene2\", rating: 100, favorite: false }, // perf1: +0.4 = 0.8\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.8, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf3\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"skips scenes rated below floor\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 39, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n    expect(result.derivedStudioWeights.size).toBe(0);\n    expect(result.derivedTagWeights.size).toBe(0);\n  });\n\n  it(\"handles favorited-only scenes with implicit rating\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: null, favorite: true },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    // Implicit 85 + favorite bonus = 0.49\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.49, 2);\n  });\n\n  it(\"handles scene not found in cache\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"nonexistent\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n  });\n});\n\ndescribe(\"countUserCriteria\", () =&gt; {\n  it(\"counts favorited and rated entities correctly\", () =&gt; {\n    const performerRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 85 },\n      { favorite: false, rating: 70 }, // Below 80, not counted as rated\n    ];\n    const studioRatings = [{ favorite: true, rating: 90 }];\n    const tagRatings = [\n      { favorite: false, rating: 80 },\n      { favorite: false, rating: 80 },\n    ];\n    const sceneRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 50 },\n      { favorite: false, rating: 30 }, // Below 40, not counted\n    ];\n\n    const counts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    expect(counts.favoritedPerformers).toBe(1);\n    expect(counts.ratedPerformers).toBe(1);\n    expect(counts.favoritedStudios).toBe(1);\n    expect(counts.ratedStudios).toBe(1);\n    expect(counts.favoritedTags).toBe(0);\n    expect(counts.ratedTags).toBe(2);\n    expect(counts.favoritedScenes).toBe(1);\n    expect(counts.ratedScenes).toBe(1); // Only rating &gt;= 40 counts\n  });\n});\n\ndescribe(\"hasAnyCriteria\", () =&gt; {\n  it(\"returns false when all counts are zero\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(false);\n  });\n\n  it(\"returns true when only scene favorites exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 1,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n\n  it(\"returns true when only scene ratings exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 3,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for derived weights and criteria counting\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-4-unit-tests-for-scene-scoring","title":"Task 4: Unit Tests for Scene Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for scoreSceneByPreferences</p> <p>Add to the existing test file:</p> <pre><code>describe(\"scoreSceneByPreferences\", () =&gt; {\n  const createEmptyPrefs = (): EntityPreferences =&gt; ({\n    favoritePerformers: new Set(),\n    highlyRatedPerformers: new Set(),\n    favoriteStudios: new Set(),\n    highlyRatedStudios: new Set(),\n    favoriteTags: new Set(),\n    highlyRatedTags: new Set(),\n    derivedPerformerWeights: new Map(),\n    derivedStudioWeights: new Map(),\n    derivedTagWeights: new Map(),\n  });\n\n  const mockScene: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\", tags: [] },\n      { id: \"perf2\", name: \"Performer 2\", tags: [] },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\", tags: [] },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }],\n  } as NormalizedScene;\n\n  it(\"returns 0 for scene with no matching preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    const score = scoreSceneByPreferences(mockScene, prefs);\n    expect(score).toBe(0);\n  });\n\n  it(\"scores favorite performer correctly (5 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT, 2); // 5 * sqrt(1) = 5\n  });\n\n  it(\"applies sqrt diminishing returns for multiple favorite performers\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n    prefs.favoritePerformers.add(\"perf2\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(2) \u2248 7.07\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(2), 2);\n  });\n\n  it(\"scores favorite studio correctly (3 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoriteStudios.add(\"studio1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBe(3);\n  });\n\n  it(\"scores derived performer weights with sqrt scaling\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    // Accumulated weight of 0.8 from two scenes\n    prefs.derivedPerformerWeights.set(\"perf1\", 0.8);\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(0.8) \u2248 4.47\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.8), 2);\n  });\n\n  it(\"combines explicit and derived preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\"); // 5 points\n    prefs.favoriteStudios.add(\"studio1\"); // 3 points\n    prefs.derivedPerformerWeights.set(\"perf2\", 0.4); // 5 * sqrt(0.4) \u2248 3.16\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    const expected =\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(1) + // perf1 explicit\n      3 + // studio\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.4); // perf2 derived\n\n    expect(score).toBeCloseTo(expected, 1);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene scoring with preferences\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-5-update-controller-to-use-scoring-service","title":"Task 5: Update Controller to Use Scoring Service","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1372-1687)</p> <p>Step 1: Add import for the scoring service</p> <p>At the top of the file with other imports, add:</p> <pre><code>import {\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  type EntityPreferences,\n  type SceneRatingInput,\n} from \"../../services/RecommendationScoringService.js\";\n</code></pre> <p>Step 2: Update getRecommendedScenes to fetch scene ratings</p> <p>Replace lines 1385-1392 (the Promise.all that fetches ratings):</p> <pre><code>    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n</code></pre> <p>Step 3: Update criteria checking to include scenes</p> <p>Replace lines 1394-1438 (building sets and hasCriteria check):</p> <pre><code>    // Build sets of favorite and highly-rated entities\n    const favoritePerformers = new Set(\n      performerRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.tagId)\n    );\n\n    // Count user criteria for feedback\n    const criteriaCounts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    // Check if user has any criteria (now includes scenes)\n    if (!hasAnyCriteria(criteriaCounts)) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No recommendations yet\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 4: Build derived weights from scene ratings</p> <p>After the hidden entities filtering (after line ~1468), add:</p> <pre><code>    // Build derived weights from rated/favorited scenes\n    const sceneRatingsForDerived: SceneRatingInput[] = sceneRatings.map((r) =&gt; ({\n      sceneId: r.sceneId,\n      rating: r.rating,\n      favorite: r.favorite,\n    }));\n\n    const sceneMap = new Map(allScenes.map((s) =&gt; [s.id, s]));\n    const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n    const {\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    } = buildDerivedWeightsFromScenes(sceneRatingsForDerived, getSceneById);\n\n    // Build entity preferences object\n    const prefs: EntityPreferences = {\n      favoritePerformers,\n      highlyRatedPerformers,\n      favoriteStudios,\n      highlyRatedStudios,\n      favoriteTags,\n      highlyRatedTags,\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    };\n</code></pre> <p>Step 5: Update scoring loop to use service</p> <p>Replace the scoring loop (lines ~1496-1619) with:</p> <pre><code>    for (const scene of allScenes) {\n      const baseScore = scoreSceneByPreferences(scene, prefs);\n\n      // Skip if no base score (doesn't match any criteria)\n      if (baseScore === 0) continue;\n\n      // Watch status modifier (reduced dominance: was +100/-100, now +30/-30)\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        // Never watched\n        adjustedScore += 30;\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) /\n          (24 * 60 * 60 * 1000);\n\n        if (daysSinceWatched &gt; 14) {\n          // Not recently watched\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          // Recently watched (1-14 days)\n          adjustedScore -= 10;\n        } else {\n          // Very recently watched (&lt;24 hours)\n          adjustedScore -= 30;\n        }\n      }\n\n      // Engagement quality multiplier\n      const oCounter = scene.o_counter || 0;\n      const engagementMultiplier = 1.0 + Math.min(oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      // Only include scenes with positive final scores\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ scene, score: finalScore });\n      }\n    }\n</code></pre> <p>Step 6: Run TypeScript compiler and lint</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: integrate scene-derived preferences into recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-6-add-criteria-to-empty-response","title":"Task 6: Add Criteria to Empty Response","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Update response when scenes found but scored to zero</p> <p>After the diversification/pagination logic, before the final res.json, add a check for empty results:</p> <pre><code>    // If no recommendations after scoring, include criteria for feedback\n    if (cappedScenes.length === 0) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No matching recommendations found\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: include criteria counts in empty recommendation responses\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-7-improve-error-handling-in-controller","title":"Task 7: Improve Error Handling in Controller","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1681-1686)</p> <p>Step 1: Update catch block with better error logging</p> <p>Replace the catch block:</p> <pre><code>  } catch (error) {\n    const err = error as Error;\n    logger.error(\"Error getting recommended scenes:\", {\n      message: err.message,\n      name: err.name,\n      stack: err.stack,\n      userId: req.user?.id,\n    });\n\n    const errorType = err.name || \"Unknown error\";\n    res.status(500).json({\n      error: \"Failed to get recommended scenes\",\n      errorType,\n    });\n  }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"fix: improve error logging and response for recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-8-update-client-to-display-criteria-feedback","title":"Task 8: Update Client to Display Criteria Feedback","text":"<p>Files: - Modify: <code>client/src/components/pages/Recommended.jsx</code></p> <p>Step 1: Add state for criteria</p> <p>Add to the state declarations (around line 25):</p> <pre><code>const [criteria, setCriteria] = useState(null);\n</code></pre> <p>Step 2: Update fetch handler to capture criteria</p> <p>Update the response destructuring (around line 52):</p> <pre><code>const { scenes: fetchedScenes, count, message: msg, criteria: criteriaCounts } = response.data;\n\nsetScenes(fetchedScenes);\nsetTotalCount(count);\nsetCriteria(criteriaCounts || null);\nif (msg) {\n  setMessage(msg);\n}\n</code></pre> <p>Step 3: Update error handling to capture errorType</p> <p>Update the error handling (around line 76):</p> <pre><code>setError({\n  message: err.response?.data?.error || \"Failed to load recommendations\",\n  errorType: err.response?.data?.errorType || null,\n});\n</code></pre> <p>Step 4: Update error display</p> <p>Update error prop passed to SceneGrid (around line 160):</p> <pre><code>error={!initMessage &amp;&amp; error ? error.message : null}\n</code></pre> <p>And add error type display after the PageHeader:</p> <pre><code>{error &amp;&amp; error.errorType &amp;&amp; (\n  &lt;div className=\"mb-4 text-sm text-gray-500\"&gt;\n    (Error type: {error.errorType})\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 5: Create criteria display component</p> <p>Add helper function before the return statement:</p> <pre><code>const renderCriteriaFeedback = () =&gt; {\n  if (!criteria) return null;\n\n  const hasAnyActivity =\n    criteria.favoritedPerformers &gt; 0 ||\n    criteria.ratedPerformers &gt; 0 ||\n    criteria.favoritedStudios &gt; 0 ||\n    criteria.ratedStudios &gt; 0 ||\n    criteria.favoritedTags &gt; 0 ||\n    criteria.ratedTags &gt; 0 ||\n    criteria.favoritedScenes &gt; 0 ||\n    criteria.ratedScenes &gt; 0;\n\n  if (!hasAnyActivity) {\n    return (\n      &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n        &lt;p&gt;To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n      &lt;p className=\"mb-2\"&gt;Your current activity:&lt;/p&gt;\n      &lt;ul className=\"list-disc list-inside space-y-1\"&gt;\n        &lt;li&gt;{criteria.favoritedPerformers} favorited performer{criteria.favoritedPerformers !== 1 ? 's' : ''}, {criteria.ratedPerformers} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedStudios} favorited studio{criteria.favoritedStudios !== 1 ? 's' : ''}, {criteria.ratedStudios} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedTags} favorited tag{criteria.favoritedTags !== 1 ? 's' : ''}, {criteria.ratedTags} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedScenes} favorited scene{criteria.favoritedScenes !== 1 ? 's' : ''}, {criteria.ratedScenes} rated scene{criteria.ratedScenes !== 1 ? 's' : ''}&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;p className=\"mt-2 italic\"&gt;Tip: Rating more scenes helps us learn your preferences!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 6: Update SceneGrid props to include criteria</p> <p>Update the SceneGrid component to pass criteria:</p> <pre><code>&lt;SceneGrid\n  scenes={scenes}\n  loading={loading}\n  error={!initMessage &amp;&amp; error ? error.message : null}\n  currentPage={page}\n  totalPages={totalPages}\n  onPageChange={handlePageChange}\n  onHideSuccess={handleHideSuccess}\n  perPage={perPage}\n  onPerPageChange={handlePerPageChange}\n  totalCount={totalCount}\n  emptyMessage={message || \"No Recommendations Yet\"}\n  emptyDescription={\n    criteria ? renderCriteriaFeedback() : \"Rate or Favorite more items to get personalized recommendations.\"\n  }\n/&gt;\n</code></pre> <p>Step 7: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing warnings)</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/Recommended.jsx\ngit commit -m \"feat: display criteria feedback on empty recommendations page\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-9-integration-test-manual-verification","title":"Task 9: Integration Test - Manual Verification","text":"<p>Files: None (manual testing)</p> <p>Step 1: Start the dev server</p> <p>Run: <code>npm run dev</code> (or your dev command)</p> <p>Step 2: Test with no ratings</p> <ol> <li>Log in as a user with no ratings/favorites</li> <li>Navigate to Recommended page</li> <li>Verify: Empty state shows criteria counts (all zeros)</li> <li>Verify: Message explains how to get recommendations</li> </ol> <p>Step 3: Test with only scene favorites</p> <ol> <li>Favorite 2-3 scenes from the library</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations appear (derived from scene content)</li> <li>Verify: Scenes with matching performers/studios/tags are shown</li> </ol> <p>Step 4: Test with explicit + scene ratings</p> <ol> <li>Also favorite a performer explicitly</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations include both explicit matches and derived matches</li> </ol> <p>Step 5: Test error display</p> <ol> <li>Temporarily break the database connection</li> <li>Navigate to Recommended page</li> <li>Verify: Error message shows with error type</li> </ol> <p>Step 6: Document results</p> <p>Note any issues found for follow-up.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-10-run-full-test-suite","title":"Task 10: Run Full Test Suite","text":"<p>Files: None</p> <p>Step 1: Run all server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 2: Run client tests (if any)</p> <p>Run: <code>cd client &amp;&amp; npm test</code> (if applicable) Expected: All tests PASS</p> <p>Step 3: Final commit for any cleanup</p> <p>If any issues found, fix and commit.</p> <p>Step 4: Push branch</p> <pre><code>git push -u origin feature/recommendations-improvements\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#summary","title":"Summary","text":"Task Description Files 1 Extract RecommendationScoringService <code>server/services/RecommendationScoringService.ts</code> 2 Unit tests for weight calculation <code>server/tests/recommendations/recommendationScoring.test.ts</code> 3 Unit tests for derived weights <code>server/tests/recommendations/recommendationScoring.test.ts</code> 4 Unit tests for scene scoring <code>server/tests/recommendations/recommendationScoring.test.ts</code> 5 Update controller to use service <code>server/controllers/library/scenes.ts</code> 6 Add criteria to empty response <code>server/controllers/library/scenes.ts</code> 7 Improve error handling <code>server/controllers/library/scenes.ts</code> 8 Update client for criteria feedback <code>client/src/components/pages/Recommended.jsx</code> 9 Manual integration testing - 10 Run full test suite -"},{"location":"plans/2025-12-23-carousel-see-more-design/","title":"Carousel \"See More\" Button Design","text":"<p>Issue: #192 Branch: <code>feature/192-carousel-see-more</code> Date: 2025-12-23</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#overview","title":"Overview","text":"<p>Add a \"More\" button to each carousel on the home page that navigates to the Scenes page with the carousel's filter pre-applied.</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#design-decisions","title":"Design Decisions","text":"<ul> <li>Button placement: Header row, to the right of the scroll navigation buttons</li> <li>Button style: Small pill button (<code>size=\"sm\"</code>, <code>variant=\"secondary\"</code>)</li> <li>Button text: \"More\" on all screen sizes (simple and consistent)</li> <li>Continue Watching: Links to <code>/watch-history</code> instead of Scenes</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#filter-to-url-mapping","title":"Filter-to-URL Mapping","text":""},{"location":"plans/2025-12-23-carousel-see-more-design/#hardcoded-carousels","title":"Hardcoded Carousels","text":"fetchKey URL <code>recentlyAddedScenes</code> <code>/scenes?sort=created_at&amp;dir=DESC</code> <code>highRatedScenes</code> <code>/scenes?rating_min=80</code> <code>favoritePerformerScenes</code> <code>/scenes?performerFavorite=true</code> <code>favoriteTagScenes</code> <code>/scenes?tagFavorite=true</code> <code>favoriteStudioScenes</code> <code>/scenes?studioFavorite=true</code> <code>continueWatching</code> <code>/watch-history</code>"},{"location":"plans/2025-12-23-carousel-see-more-design/#custom-carousels","title":"Custom Carousels","text":"<p>Custom carousels store rules in API format. To build the URL: 1. Use <code>carouselRulesToFilterState()</code> to convert rules to UI filter state 2. Use <code>buildSearchParams()</code> with <code>SCENE_FILTER_OPTIONS</code> to serialize to URL params</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-23-carousel-see-more-design/#1-clientsrccomponentsuiscenecarouseljsx","title":"1. <code>client/src/components/ui/SceneCarousel.jsx</code>","text":"<p>Add new prop: - <code>seeMoreUrl</code> (string, optional) - navigation target</p> <p>Changes: - Import <code>Link</code> from <code>react-router-dom</code> - Render \"More\" button to the right of scroll buttons when <code>seeMoreUrl</code> is provided - Button uses existing <code>Button</code> component with <code>size=\"sm\"</code>, <code>variant=\"secondary\"</code></p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#2-clientsrccomponentspageshomejsx","title":"2. <code>client/src/components/pages/Home.jsx</code>","text":"<p>Changes to <code>HomeCarousel</code> component: - Create mapping function <code>getSeeMoreUrl(fetchKey)</code> that returns the URL for each carousel type - Pass <code>seeMoreUrl</code> prop to <code>SceneCarousel</code></p> <p>Changes to <code>CustomCarousel</code> component: - Import <code>carouselRulesToFilterState</code> from <code>filterConfig.js</code> - Import <code>buildSearchParams</code> from <code>urlParams.js</code> - Import <code>SCENE_FILTER_OPTIONS</code> from <code>filterConfig.js</code> - Build URL from carousel rules and pass to <code>SceneCarousel</code></p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#3-clientsrccomponentsuicontinuewatchingcarouseljsx","title":"3. <code>client/src/components/ui/ContinueWatchingCarousel.jsx</code>","text":"<ul> <li>Pass <code>seeMoreUrl=\"/watch-history\"</code> to its <code>SceneCarousel</code></li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#verification-checklist","title":"Verification Checklist","text":"<p>During implementation, manually test each carousel's \"More\" button:</p> <ul> <li> <code>recentlyAddedScenes</code> - Scenes page loads sorted by created_at DESC</li> <li> <code>highRatedScenes</code> - Scenes page shows rating &gt;= 80 filter active</li> <li> <code>favoritePerformerScenes</code> - Scenes page shows \"Favorite Performers\" filter active</li> <li> <code>favoriteTagScenes</code> - Scenes page shows \"Favorite Tags\" filter active</li> <li> <code>favoriteStudioScenes</code> - Scenes page shows \"Favorite Studios\" filter active</li> <li> <code>continueWatching</code> - Navigates to Watch History page</li> <li> Custom carousels - Scenes page loads with matching filters from carousel rules</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Shuffle/randomize carousel content (carousels already use <code>sort: \"random\"</code>, investigate separately if needed)</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/","title":"Carousel \"See More\" Button Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add \"More\" buttons to home page carousels that navigate to filtered Scenes views.</p> <p>Architecture: Add optional <code>seeMoreUrl</code> prop to SceneCarousel, build URLs in Home.jsx based on carousel type (hardcoded mapping for built-in carousels, dynamic URL building for custom carousels using existing filter utilities).</p> <p>Tech Stack: React, react-router-dom, existing filterConfig.js and urlParams.js utilities</p>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-1-add-seemoreurl-prop-to-scenecarousel","title":"Task 1: Add seeMoreUrl prop to SceneCarousel","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCarousel.jsx</code></p> <p>Step 1: Add Link import and seeMoreUrl prop</p> <p>At line 1, update imports: <pre><code>import { useEffect, useRef, useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Button from \"./Button.jsx\";\n</code></pre></p> <p>At line 6, add <code>seeMoreUrl</code> to destructured props: <pre><code>const SceneCarousel = ({\n  title,\n  titleIcon,\n  scenes,\n  loading = false,\n  onSceneClick,\n  selectedScenes = [],\n  onToggleSelect,\n  seeMoreUrl,\n}) =&gt; {\n</code></pre></p> <p>Step 2: Add \"More\" button after scroll buttons</p> <p>At line 157-158, after the right scroll button's closing tag and before the <code>&lt;/div&gt;</code> that closes the button container, add the More button:</p> <pre><code>          /&gt;\n          {seeMoreUrl &amp;&amp; (\n            &lt;Link to={seeMoreUrl}&gt;\n              &lt;Button\n                variant=\"secondary\"\n                size=\"sm\"\n                className=\"ml-2\"\n              &gt;\n                More\n              &lt;/Button&gt;\n            &lt;/Link&gt;\n          )}\n        &lt;/div&gt;\n</code></pre> <p>Step 3: Verify hot reload shows no errors</p> <p>Check browser console for any React errors. The button won't appear yet since no carousels pass <code>seeMoreUrl</code>.</p> <p>Step 4: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser\ngit add client/src/components/ui/SceneCarousel.jsx\ngit commit -m \"feat: add seeMoreUrl prop to SceneCarousel component\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-2-add-url-mapping-for-hardcoded-carousels-in-homejsx","title":"Task 2: Add URL mapping for hardcoded carousels in Home.jsx","text":"<p>Files: - Modify: <code>client/src/components/pages/Home.jsx</code></p> <p>Step 1: Add getSeeMoreUrl helper function</p> <p>After line 33 (after the <code>isCustomCarousel</code> function), add this mapping function:</p> <pre><code>/**\n * Get the \"See More\" URL for a hardcoded carousel based on its fetchKey\n */\nconst getSeeMoreUrl = (fetchKey) =&gt; {\n  const urlMap = {\n    recentlyAddedScenes: \"/scenes?sort=created_at&amp;dir=DESC\",\n    highRatedScenes: \"/scenes?rating_min=80\",\n    favoritePerformerScenes: \"/scenes?performerFavorite=true\",\n    favoriteTagScenes: \"/scenes?tagFavorite=true\",\n    favoriteStudioScenes: \"/scenes?studioFavorite=true\",\n    continueWatching: \"/watch-history\",\n  };\n  return urlMap[fetchKey] || null;\n};\n</code></pre> <p>Step 2: Pass seeMoreUrl to HomeCarousel's SceneCarousel</p> <p>In the <code>HomeCarousel</code> component (around line 325-334), update the SceneCarousel call to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title={title}\n      titleIcon={icon}\n      scenes={scenes || []}\n      onSceneClick={createSceneClickHandler(scenes || [], title)}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl={getSeeMoreUrl(fetchKey)}\n    /&gt;\n  );\n</code></pre> <p>Step 3: Add fetchKey prop to HomeCarousel signature</p> <p>The <code>HomeCarousel</code> component already receives <code>fetchKey</code> as a prop (line 275), so no change needed there.</p> <p>Step 4: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>Hardcoded carousels (Recently Added, High Rated, Favorite Performers, etc.) should show \"More\" button</li> <li>Click \"More\" on each and verify:</li> <li>Recently Added: <code>/scenes?sort=created_at&amp;dir=DESC</code></li> <li>High Rated: <code>/scenes?rating_min=80</code></li> <li>Favorite Performers: <code>/scenes?performerFavorite=true</code></li> <li>Favorite Tags: <code>/scenes?tagFavorite=true</code></li> <li>Favorite Studios: <code>/scenes?studioFavorite=true</code></li> </ul> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Home.jsx\ngit commit -m \"feat: add See More URLs for hardcoded carousels\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-3-add-seemoreurl-to-continuewatchingcarousel","title":"Task 3: Add seeMoreUrl to ContinueWatchingCarousel","text":"<p>Files: - Modify: <code>client/src/components/ui/ContinueWatchingCarousel.jsx</code></p> <p>Step 1: Add seeMoreUrl prop to SceneCarousel call</p> <p>At line 178-188, update the SceneCarousel call to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title=\"Continue Watching\"\n      titleIcon={&lt;PlayCircle className=\"w-6 h-6\" color=\"#10b981\" /&gt;}\n      scenes={scenes}\n      onSceneClick={handleSceneClick}\n      showProgress={true}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl=\"/watch-history\"\n    /&gt;\n  );\n</code></pre> <p>Step 2: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>Continue Watching carousel should show \"More\" button</li> <li>Click \"More\" and verify it navigates to <code>/watch-history</code></li> </ul> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/ContinueWatchingCarousel.jsx\ngit commit -m \"feat: add See More link to Continue Watching carousel\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-4-add-url-building-for-custom-carousels","title":"Task 4: Add URL building for custom carousels","text":"<p>Files: - Modify: <code>client/src/components/pages/Home.jsx</code></p> <p>Step 1: Add imports for filter utilities</p> <p>At the top of Home.jsx, add imports after existing imports (around line 13):</p> <pre><code>import {\n  carouselRulesToFilterState,\n  SCENE_FILTER_OPTIONS,\n} from \"../../utils/filterConfig.js\";\nimport { buildSearchParams } from \"../../utils/urlParams.js\";\n</code></pre> <p>Step 2: Add helper function to build custom carousel URL</p> <p>After the <code>getSeeMoreUrl</code> function (around line 45), add:</p> <pre><code>/**\n * Build a \"See More\" URL for a custom carousel from its rules\n */\nconst buildCustomCarouselUrl = (rules, sort, direction) =&gt; {\n  if (!rules || typeof rules !== \"object\") {\n    return \"/scenes\";\n  }\n\n  // Convert API rules format to UI filter state\n  const filterState = carouselRulesToFilterState(rules);\n\n  // Build URL params using existing utility\n  const params = buildSearchParams({\n    searchText: \"\",\n    sortField: sort || \"random\",\n    sortDirection: direction || \"DESC\",\n    currentPage: 1,\n    perPage: 24,\n    filters: filterState,\n    filterOptions: SCENE_FILTER_OPTIONS,\n  });\n\n  const queryString = params.toString();\n  return queryString ? `/scenes?${queryString}` : \"/scenes\";\n};\n</code></pre> <p>Step 3: Update CustomCarousel to fetch full carousel data and pass seeMoreUrl</p> <p>The <code>CustomCarousel</code> component needs access to the carousel's rules. Currently it only gets <code>carouselId</code>, but the full carousel data is available in <code>customCarousels</code> state from the parent.</p> <p>First, update where <code>CustomCarousel</code> is rendered (around line 206-217) to pass the full carousel:</p> <pre><code>          return (\n            &lt;CustomCarousel\n              key={carousel.prefId}\n              carouselId={id}\n              carousel={customCarousels.find((c) =&gt; c.id === id)}\n              title={title}\n              icon={icon}\n              createSceneClickHandler={createSceneClickHandler}\n              selectedScenes={selectedScenes}\n              onToggleSelect={handleToggleSelect}\n              onInitializing={handleInitializing}\n            /&gt;\n          );\n</code></pre> <p>Step 4: Update CustomCarousel component to accept and use carousel prop</p> <p>Update the CustomCarousel component signature (around line 342) to accept the new prop:</p> <pre><code>const CustomCarousel = ({\n  carouselId,\n  carousel,\n  title,\n  icon,\n  createSceneClickHandler,\n  selectedScenes,\n  onToggleSelect,\n  onInitializing,\n}) =&gt; {\n</code></pre> <p>Then update the SceneCarousel call at the end of CustomCarousel (around line 415-424) to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title={title}\n      titleIcon={icon}\n      scenes={scenes}\n      onSceneClick={createSceneClickHandler(scenes, title)}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl={carousel ? buildCustomCarouselUrl(carousel.rules, carousel.sort, carousel.direction) : null}\n    /&gt;\n  );\n</code></pre> <p>Step 5: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>If you have custom carousels, they should show \"More\" button</li> <li>Click \"More\" and verify it navigates to <code>/scenes</code> with appropriate filter params</li> <li>Verify the filters are correctly applied on the Scenes page</li> </ul> <p>Step 6: Commit</p> <pre><code>git add client/src/components/pages/Home.jsx\ngit commit -m \"feat: add See More URLs for custom carousels\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-5-manual-verification-of-all-carousel-types","title":"Task 5: Manual verification of all carousel types","text":"<p>No code changes - verification only</p> <p>Step 1: Test each hardcoded carousel</p> <p>For each carousel, click \"More\" and verify:</p> Carousel Expected URL Verify Filter Active Recently Added <code>/scenes?sort=created_at&amp;dir=DESC</code> Sort dropdown shows \"Created At\", direction DESC High Rated <code>/scenes?rating_min=80</code> Rating filter shows min 80 Favorite Performers <code>/scenes?performerFavorite=true</code> \"Favorite Performers\" checkbox checked in filters Favorite Tags <code>/scenes?tagFavorite=true</code> \"Favorite Tags\" checkbox checked in filters Favorite Studios <code>/scenes?studioFavorite=true</code> \"Favorite Studios\" checkbox checked in filters Continue Watching <code>/watch-history</code> Watch History page loads <p>Step 2: Test custom carousels (if available)</p> <ul> <li>Create a custom carousel with specific filters (e.g., rating &gt; 60, specific performer)</li> <li>Go to home page, find the custom carousel</li> <li>Click \"More\"</li> <li>Verify the Scenes page loads with matching filters</li> </ul> <p>Step 3: Test edge cases</p> <ul> <li>Carousel with no scenes still shows \"More\" button (links work even if empty)</li> <li>Mobile viewport: verify \"More\" button is visible and tappable</li> <li>Verify no console errors</li> </ul> <p>Step 4: Final commit (if any fixes needed)</p> <p>If any fixes were needed during verification, commit them:</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during carousel See More verification\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-6-run-linting-and-tests","title":"Task 6: Run linting and tests","text":"<p>Step 1: Run ESLint</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/client\nnpm run lint\n</code></pre> <p>Expected: No new errors (fix any that appear)</p> <p>Step 2: Run existing tests</p> <pre><code>npm test\n</code></pre> <p>Expected: All tests pass</p> <p>Step 3: Commit any lint fixes</p> <pre><code>git add -A\ngit commit -m \"fix: address linting issues\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li><code>SceneCarousel</code> accepts optional <code>seeMoreUrl</code> prop and renders \"More\" button when provided</li> <li>All hardcoded carousels pass appropriate URLs via <code>getSeeMoreUrl()</code> mapping</li> <li><code>ContinueWatchingCarousel</code> links to <code>/watch-history</code></li> <li>Custom carousels dynamically build URLs from their rules using existing filter utilities</li> <li>All carousel types verified working</li> <li>Linting and tests pass</li> </ol>"},{"location":"plans/2025-12-23-scene-urls-design/","title":"Scene URLs Display Design","text":"<p>Issue: #195 - Show URLs for scenes in details panel Date: 2025-12-23 Status: Approved</p>"},{"location":"plans/2025-12-23-scene-urls-design/#problem","title":"Problem","text":"<p>Users want to see URLs associated with scenes so they can purchase content from creators they enjoy. Currently, scene URLs from Stash metadata are not displayed anywhere in the Peek UI.</p>"},{"location":"plans/2025-12-23-scene-urls-design/#solution","title":"Solution","text":"<p>Add a \"Links\" section to the Scene Details card, displaying scene URLs as rich link chips with site icons.</p>"},{"location":"plans/2025-12-23-scene-urls-design/#design-decisions","title":"Design Decisions","text":""},{"location":"plans/2025-12-23-scene-urls-design/#placement","title":"Placement","text":"<ul> <li>Add \"Links\" section immediately after Tags inside the existing Details card</li> <li>Only show the section if <code>scene.urls</code> exists and has items</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-design/#visual-style","title":"Visual Style","text":"<ul> <li>Rich link chips matching the <code>PerformerDetail.jsx</code> pattern</li> <li>Styled buttons with site icons/colors and readable names</li> <li>Consistent with existing UI patterns</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-design/#site-recognition","title":"Site Recognition","text":"<p>Expand site recognition to cover:</p> <p>Major studio networks: - Brazzers, Reality Kings, Bang Bros, Naughty America, Mofos, Digital Playground, Wicked Pictures</p> <p>Premium/artistic studios: - Vixen, Tushy, Blacked, Deeper, Slayed, Bellesa, X-Art, SexArt</p> <p>Existing sites (already supported): - Social media: Twitter/X, Instagram, Facebook, OnlyFans - Databases: IAFD, FreeOnes, Babepedia, Data18, Indexxx, AFDB, IMDb</p>"},{"location":"plans/2025-12-23-scene-urls-design/#fallback-for-unknown-sites","title":"Fallback for Unknown Sites","text":"<p>For URLs not in the curated list: 1. Extract domain name from URL 2. Attempt to load favicon from <code>https://domain.com/favicon.ico</code> 3. Display domain name as label with favicon (or generic link icon if favicon fails)</p>"},{"location":"plans/2025-12-23-scene-urls-design/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>Extract <code>getSiteInfo()</code> and <code>SectionLink</code> into shared utility module</li> <li>Add new site mappings for studio networks and premium studios</li> <li>Add favicon fallback logic with error handling</li> <li>Add \"Links\" section to <code>SceneDetails.jsx</code> after Tags</li> <li>Update <code>PerformerDetail.jsx</code> to use shared utility (removes duplication)</li> </ol>"},{"location":"plans/2025-12-23-scene-urls-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>client/src/utils/siteInfo.js</code> (new file)</li> <li><code>client/src/components/ui/SectionLink.jsx</code> (new file)</li> <li><code>client/src/components/pages/SceneDetails.jsx</code></li> <li><code>client/src/components/pages/PerformerDetail.jsx</code> (refactor to use shared utility)</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-implementation/","title":"Scene URLs Display Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Display scene URLs in the Scene Details card so users can purchase content from creators.</p> <p>Architecture: Extract existing <code>getSiteInfo()</code> and <code>SectionLink</code> from PerformerDetail into shared utilities. Add new site mappings for major studios. Implement dynamic favicon fallback. Add URLs section to SceneDetails after Tags.</p> <p>Tech Stack: React, Lucide icons, CSS-in-JS (inline styles)</p>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-1-create-shared-site-info-utility","title":"Task 1: Create Shared Site Info Utility","text":"<p>Files: - Create: <code>client/src/utils/siteInfo.js</code></p> <p>Step 1: Create the utility file with existing + new site mappings</p> <pre><code>import {\n  LucideDatabase,\n  LucideFacebook,\n  LucideFilm,\n  LucideGlobe,\n  LucideInstagram,\n  LucideLink,\n  LucideTwitter,\n  LucideVideo,\n} from \"lucide-react\";\n\n/**\n * Site information for URL display\n * Returns name, icon component, and brand color for known sites\n */\nexport const getSiteInfo = (url) =&gt; {\n  const urlLower = url.toLowerCase();\n\n  // === Social Media ===\n  if (urlLower.includes(\"twitter.com\") || urlLower.includes(\"x.com\")) {\n    return { name: \"Twitter\", icon: LucideTwitter, color: \"#1DA1F2\" };\n  }\n  if (urlLower.includes(\"instagram.com\")) {\n    return { name: \"Instagram\", icon: LucideInstagram, color: \"#E4405F\" };\n  }\n  if (urlLower.includes(\"facebook.com\")) {\n    return { name: \"Facebook\", icon: LucideFacebook, color: \"#1877F2\" };\n  }\n  if (urlLower.includes(\"onlyfans.com\")) {\n    return { name: \"OnlyFans\", icon: LucideVideo, color: \"#00AFF0\" };\n  }\n\n  // === Entertainment Databases ===\n  if (urlLower.includes(\"imdb.com\")) {\n    return { name: \"IMDb\", icon: LucideFilm, color: \"#F5C518\" };\n  }\n\n  // === Adult Industry Databases ===\n  if (urlLower.includes(\"iafd.com\")) {\n    return { name: \"IAFD\", icon: LucideDatabase, color: \"#9B59B6\" };\n  }\n  if (urlLower.includes(\"adultfilmdatabase.com\")) {\n    return { name: \"AFDB\", icon: LucideDatabase, color: \"#16A085\" };\n  }\n  if (urlLower.includes(\"freeones.com\")) {\n    return { name: \"FreeOnes\", icon: LucideDatabase, color: \"#E67E22\" };\n  }\n  if (urlLower.includes(\"babepedia.com\")) {\n    return { name: \"Babepedia\", icon: LucideDatabase, color: \"#E91E63\" };\n  }\n  if (urlLower.includes(\"data18.com\")) {\n    return { name: \"Data18\", icon: LucideDatabase, color: \"#27AE60\" };\n  }\n  if (urlLower.includes(\"indexxx.com\")) {\n    return { name: \"Indexxx\", icon: LucideDatabase, color: \"#8E44AD\" };\n  }\n  if (urlLower.includes(\"thenude.com\")) {\n    return { name: \"The Nude\", icon: LucideDatabase, color: \"#1ABC9C\" };\n  }\n  if (urlLower.includes(\"pornteengirl.com\")) {\n    return { name: \"PornTeenGirl\", icon: LucideGlobe, color: \"#2ECC71\" };\n  }\n\n  // === Major Studio Networks ===\n  if (urlLower.includes(\"brazzers.com\")) {\n    return { name: \"Brazzers\", icon: LucideGlobe, color: \"#FFA500\" };\n  }\n  if (urlLower.includes(\"realitykings.com\")) {\n    return { name: \"Reality Kings\", icon: LucideGlobe, color: \"#FFD700\" };\n  }\n  if (urlLower.includes(\"bangbros.com\")) {\n    return { name: \"Bang Bros\", icon: LucideGlobe, color: \"#FF6B6B\" };\n  }\n  if (urlLower.includes(\"naughtyamerica.com\")) {\n    return { name: \"Naughty America\", icon: LucideGlobe, color: \"#E74C3C\" };\n  }\n  if (urlLower.includes(\"mofos.com\")) {\n    return { name: \"Mofos\", icon: LucideGlobe, color: \"#3498DB\" };\n  }\n  if (urlLower.includes(\"digitalplayground.com\")) {\n    return { name: \"Digital Playground\", icon: LucideGlobe, color: \"#9B59B6\" };\n  }\n  if (urlLower.includes(\"wicked.com\")) {\n    return { name: \"Wicked Pictures\", icon: LucideGlobe, color: \"#E91E63\" };\n  }\n\n  // === Premium/Artistic Studios ===\n  if (urlLower.includes(\"vixen.com\")) {\n    return { name: \"Vixen\", icon: LucideGlobe, color: \"#000000\" };\n  }\n  if (urlLower.includes(\"tushy.com\")) {\n    return { name: \"Tushy\", icon: LucideGlobe, color: \"#FF69B4\" };\n  }\n  if (urlLower.includes(\"blacked.com\")) {\n    return { name: \"Blacked\", icon: LucideGlobe, color: \"#1C1C1C\" };\n  }\n  if (urlLower.includes(\"deeper.com\")) {\n    return { name: \"Deeper\", icon: LucideGlobe, color: \"#2C3E50\" };\n  }\n  if (urlLower.includes(\"slayed.com\")) {\n    return { name: \"Slayed\", icon: LucideGlobe, color: \"#8B0000\" };\n  }\n  if (urlLower.includes(\"bellesa.co\") || urlLower.includes(\"bellesafilms.com\")) {\n    return { name: \"Bellesa\", icon: LucideGlobe, color: \"#FF6B9D\" };\n  }\n  if (urlLower.includes(\"x-art.com\")) {\n    return { name: \"X-Art\", icon: LucideGlobe, color: \"#C0C0C0\" };\n  }\n  if (urlLower.includes(\"sexart.com\")) {\n    return { name: \"SexArt\", icon: LucideGlobe, color: \"#D4AF37\" };\n  }\n\n  // === Unknown site - extract domain ===\n  try {\n    const domain = new URL(url).hostname.replace(\"www.\", \"\");\n    return { name: domain, icon: LucideLink, color: \"#95A5A6\", useFavicon: true };\n  } catch {\n    return { name: \"Link\", icon: LucideLink, color: \"#95A5A6\" };\n  }\n};\n\n/**\n * Extract domain from URL for favicon fetching\n */\nexport const getDomainFromUrl = (url) =&gt; {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.origin;\n  } catch {\n    return null;\n  }\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/utils/siteInfo.js\ngit commit -m \"feat: add shared site info utility with studio mappings\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-2-create-shared-sectionlink-component","title":"Task 2: Create Shared SectionLink Component","text":"<p>Files: - Create: <code>client/src/components/ui/SectionLink.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Create the SectionLink component with favicon fallback</p> <pre><code>import { useState } from \"react\";\nimport { getSiteInfo, getDomainFromUrl } from \"../../utils/siteInfo.js\";\n\n/**\n * External link component with site icon/favicon\n * Shows site-specific icons for known sites, attempts favicon for unknown sites\n */\nconst SectionLink = ({ url }) =&gt; {\n  const [faviconError, setFaviconError] = useState(false);\n\n  if (!url) return null;\n\n  const { name, icon: Icon, color, useFavicon } = getSiteInfo(url);\n  const domain = getDomainFromUrl(url);\n  const faviconUrl = domain ? `${domain}/favicon.ico` : null;\n\n  // Show favicon for unknown sites, fall back to icon if favicon fails\n  const showFavicon = useFavicon &amp;&amp; faviconUrl &amp;&amp; !faviconError;\n\n  return (\n    &lt;a\n      href={url}\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n      className=\"inline-flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 hover:opacity-80\"\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        color: \"var(--text-primary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {showFavicon ? (\n        &lt;img\n          src={faviconUrl}\n          alt=\"\"\n          width={16}\n          height={16}\n          onError={() =&gt; setFaviconError(true)}\n          style={{ borderRadius: 2 }}\n        /&gt;\n      ) : (\n        &lt;Icon size={16} style={{ color }} /&gt;\n      )}\n      &lt;span&gt;{name}&lt;/span&gt;\n    &lt;/a&gt;\n  );\n};\n\nexport default SectionLink;\n</code></pre> <p>Step 2: Export from ui/index.js</p> <p>Add this line in alphabetical order (after SearchInput, before Sidebar):</p> <pre><code>export { default as SectionLink } from \"./SectionLink.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/SectionLink.jsx client/src/components/ui/index.js\ngit commit -m \"feat: add SectionLink component with favicon fallback\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-3-add-urls-to-scenedetails-component","title":"Task 3: Add URLs to SceneDetails Component","text":"<p>Files: - Modify: <code>client/src/components/pages/SceneDetails.jsx:1-5</code> (imports) - Modify: <code>client/src/components/pages/SceneDetails.jsx:335-369</code> (after Tags section)</p> <p>Step 1: Add SectionLink import</p> <p>Change line 3 from: <pre><code>import { Paper, useLazyLoad } from \"../ui/index.js\";\n</code></pre></p> <p>To: <pre><code>import { Paper, SectionLink, useLazyLoad } from \"../ui/index.js\";\n</code></pre></p> <p>Step 2: Add URLs section after Tags</p> <p>After the Tags section (ends at line 369), add the URLs section. Insert after line 369 (after the closing of the Tags IIFE):</p> <pre><code>                {/* URLs/Links */}\n                {scene.urls &amp;&amp; scene.urls.length &gt; 0 &amp;&amp; (\n                  &lt;div className=\"mt-6\"&gt;\n                    &lt;h3\n                      className=\"text-sm font-medium mb-3\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                    &gt;\n                      Links\n                    &lt;/h3&gt;\n                    &lt;div className=\"flex flex-wrap gap-2\"&gt;\n                      {scene.urls.map((url, index) =&gt; (\n                        &lt;SectionLink key={index} url={url} /&gt;\n                      ))}\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/SceneDetails.jsx\ngit commit -m \"feat: display scene URLs in details panel\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-4-add-urls-to-server-transform-functions","title":"Task 4: Add URLs to Server Transform Functions","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:1347-1403</code> (transformScene) - Modify: <code>server/services/StashEntityService.ts:1408-1480</code> (transformSceneForBrowse)</p> <p>Step 1: Add urls to transformScene method</p> <p>In the <code>transformScene</code> method (around line 1347), after the <code>organized</code> field (line 1359), add:</p> <pre><code>      // URLs\n      urls: scene.urls ? JSON.parse(scene.urls) : [],\n</code></pre> <p>Step 2: Add urls to transformSceneForBrowse method</p> <p>In the <code>transformSceneForBrowse</code> method (around line 1408), after the <code>organized</code> field (line 1419), add the same:</p> <pre><code>      // URLs\n      urls: scene.urls ? JSON.parse(scene.urls) : [],\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: include urls in scene transformation\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-5-refactor-performerdetail-to-use-shared-utilities","title":"Task 5: Refactor PerformerDetail to Use Shared Utilities","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx:1-35</code> (imports) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:36-92</code> (remove getSiteInfo) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:391-413</code> (remove SectionLink) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:747-760</code> (update usage)</p> <p>Step 1: Update imports</p> <p>Remove these imports from the lucide-react import (lines 3-14): - <code>LucideDatabase</code> - <code>LucideFacebook</code> - <code>LucideFilm</code> - <code>LucideGlobe</code> - <code>LucideInstagram</code> - <code>LucideLink</code> - <code>LucideTwitter</code> - <code>LucideVideo</code></p> <p>Keep only: <pre><code>import {\n  ArrowLeft,\n  LucideStar,\n} from \"lucide-react\";\n</code></pre></p> <p>Add import for SectionLink after line 34: <pre><code>import { SectionLink } from \"../ui/index.js\";\n</code></pre></p> <p>Step 2: Remove local getSiteInfo function</p> <p>Delete lines 36-92 (the entire <code>getSiteInfo</code> function).</p> <p>Step 3: Remove local SectionLink component</p> <p>Delete lines 391-413 (the entire <code>SectionLink</code> component, including the comment above it).</p> <p>Step 4: Verify SectionLink usage remains correct</p> <p>The existing usage at lines 749, 751, 754, 759 should continue to work as-is since we're importing the same component interface.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx\ngit commit -m \"refactor: use shared SectionLink in PerformerDetail\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-6-test-and-verify","title":"Task 6: Test and Verify","text":"<p>Step 1: Run the build to check for errors</p> <pre><code>cd server &amp;&amp; npm run build\ncd ../client &amp;&amp; npm run build\n</code></pre> <p>Step 2: Start the dev server and manually test</p> <pre><code>cd server &amp;&amp; npm run dev\n# In another terminal:\ncd client &amp;&amp; npm run dev\n</code></pre> <p>Manual testing checklist: - [ ] Navigate to a scene that has URLs in Stash - [ ] Verify URLs appear in the Details panel after Tags - [ ] Verify known sites (Brazzers, Vixen, etc.) show proper names - [ ] Verify unknown sites show domain name with favicon attempt - [ ] Verify clicking links opens in new tab - [ ] Navigate to PerformerDetail - verify links still work</p> <p>Step 3: Commit any fixes if needed, then final verification</p> <pre><code>git status\n# If clean, you're done!\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#summary","title":"Summary","text":"<p>This implementation: 1. Extracts site info logic into a reusable utility with 20+ known sites 2. Creates a shared SectionLink component with dynamic favicon fallback 3. Adds the URLs section to SceneDetails after Tags 4. Ensures the server includes <code>urls</code> in scene data 5. Refactors PerformerDetail to use the shared utilities (DRY)</p> <p>Total: 6 tasks, ~45 minutes estimated</p>"},{"location":"plans/2025-12-24-images-page-design/","title":"Images Page Design","text":"<p>Issue: #193 - Browse standalone images outside of galleries Date: 2025-12-24</p>"},{"location":"plans/2025-12-24-images-page-design/#overview","title":"Overview","text":"<p>Add an Images page to Peek that displays ALL images in the library (both standalone and gallery-associated), with full filtering, sorting, and the ability to view images in a lightbox. Gallery metadata acts as an \"umbrella\" over its images - images inherit their gallery's performers, tags, and studio for filtering purposes.</p>"},{"location":"plans/2025-12-24-images-page-design/#key-design-decisions","title":"Key Design Decisions","text":"<ol> <li> <p>Gallery-umbrella inheritance: Images inherit performers, tags, and studio from their parent galleries. If an image is in multiple galleries, it matches filters if ANY gallery matches (union approach).</p> </li> <li> <p>Data storage: All image metadata synced to Peek's database (already implemented). Image files streamed/proxied from Stash.</p> </li> <li> <p>Image proxy: Same pattern as video streaming - <code>/api/proxy/image/:imageId/:type</code> hides Stash API key from client.</p> </li> <li> <p>Navigation: \"Images\" appears after \"Galleries\" in sidebar, respecting user hide/reorder preferences.</p> </li> <li> <p>Image viewing: Clicking an image opens the existing Lightbox component (reused from GalleryDetail).</p> </li> <li> <p>Query architecture: Query-time JOINs using CTEs for gallery inheritance, with proper indexes for million-image scale.</p> </li> <li> <p>Multi-gallery conflict resolution: Union approach - image matches if ANY of its galleries match the filter criteria.</p> </li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#database-schema-changes","title":"Database Schema Changes","text":"<p>New migration adds missing fields and performance indexes:</p> <pre><code>-- StashImage additions\nALTER TABLE StashImage ADD COLUMN code TEXT;\nALTER TABLE StashImage ADD COLUMN details TEXT;\nALTER TABLE StashImage ADD COLUMN photographer TEXT;\nALTER TABLE StashImage ADD COLUMN urls TEXT;  -- JSON array\n\n-- StashGallery additions\nALTER TABLE StashGallery ADD COLUMN photographer TEXT;\nALTER TABLE StashGallery ADD COLUMN urls TEXT;  -- JSON array\n\n-- Performance indexes for gallery-umbrella queries\nCREATE INDEX IF NOT EXISTS ImageGallery_imageId_idx ON ImageGallery(imageId);\nCREATE INDEX IF NOT EXISTS GalleryPerformer_galleryId_idx ON GalleryPerformer(galleryId);\nCREATE INDEX IF NOT EXISTS GalleryTag_galleryId_idx ON GalleryTag(galleryId);\nCREATE INDEX IF NOT EXISTS StashGallery_studioId_deletedAt_idx ON StashGallery(studioId, deletedAt);\n</code></pre> <p>Update Prisma schema to match.</p>"},{"location":"plans/2025-12-24-images-page-design/#sync-service-updates","title":"Sync Service Updates","text":""},{"location":"plans/2025-12-24-images-page-design/#processimagesbatch","title":"processImagesBatch","text":"<p>Add new fields to the INSERT statement:</p> <pre><code>// Fields to add:\ncode, details, photographer, urls\n\n// Values:\n${this.escapeNullable(image.code)},\n${this.escapeNullable(image.details)},\n${this.escapeNullable(image.photographer)},\n${this.escapeNullable(image.urls ? JSON.stringify(image.urls) : null)}\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#processgalleriesbatch","title":"processGalleriesBatch","text":"<p>Add <code>photographer</code> and <code>urls</code> fields similarly.</p>"},{"location":"plans/2025-12-24-images-page-design/#stashapp-api","title":"stashapp-api","text":"<p>Ensure GraphQL queries request: <code>code</code>, <code>details</code>, <code>photographer</code>, <code>urls</code> for both images and galleries.</p>"},{"location":"plans/2025-12-24-images-page-design/#image-proxy-endpoint","title":"Image Proxy Endpoint","text":"<p>Route: <code>GET /api/proxy/image/:imageId/:type</code></p> <p>File: <code>server/routes/proxy/images.ts</code></p> <pre><code>router.get('/image/:imageId/:type', authenticated, async (req, res) =&gt; {\n  const { imageId, type } = req.params;\n\n  // Validate type\n  if (!['thumbnail', 'preview', 'image'].includes(type)) {\n    return res.status(400).json({ error: 'Invalid image type' });\n  }\n\n  // Get image from database\n  const image = await prisma.stashImage.findFirst({\n    where: { id: imageId, deletedAt: null }\n  });\n\n  if (!image) {\n    return res.status(404).json({ error: 'Image not found' });\n  }\n\n  // Get the appropriate path\n  const pathField = type === 'thumbnail' ? 'pathThumbnail'\n                  : type === 'preview' ? 'pathPreview'\n                  : 'pathImage';\n  const stashUrl = image[pathField];\n\n  if (!stashUrl) {\n    return res.status(404).json({ error: 'Image path not available' });\n  }\n\n  // Proxy the request to Stash (reuse existing proxy utility)\n  await proxyStashRequest(stashUrl, req, res);\n});\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#images-controller","title":"Images Controller","text":"<p>File: <code>server/controllers/library/images.ts</code></p>"},{"location":"plans/2025-12-24-images-page-design/#query-architecture-with-gallery-inheritance","title":"Query Architecture with Gallery Inheritance","text":"<p>Uses CTEs (Common Table Expressions) for efficient gallery-umbrella inheritance:</p> <pre><code>const buildImageQuery = (filters, sort, pagination) =&gt; {\n  return `\n    WITH effective_performers AS (\n      -- Direct image performers\n      SELECT imageId, performerId FROM ImagePerformer\n      UNION\n      -- Inherited from galleries\n      SELECT ig.imageId, gp.performerId\n      FROM ImageGallery ig\n      JOIN GalleryPerformer gp ON ig.galleryId = gp.galleryId\n    ),\n    effective_tags AS (\n      -- Direct image tags\n      SELECT imageId, tagId FROM ImageTag\n      UNION\n      -- Inherited from galleries\n      SELECT ig.imageId, gt.tagId\n      FROM ImageGallery ig\n      JOIN GalleryTag gt ON ig.galleryId = gt.galleryId\n    ),\n    effective_studios AS (\n      -- Direct image studio\n      SELECT id as imageId, studioId FROM StashImage WHERE studioId IS NOT NULL\n      UNION\n      -- Inherited from galleries (if image has no studio)\n      SELECT ig.imageId, g.studioId\n      FROM ImageGallery ig\n      JOIN StashGallery g ON ig.galleryId = g.id\n      WHERE g.studioId IS NOT NULL\n    )\n    SELECT DISTINCT i.*\n    FROM StashImage i\n    WHERE i.deletedAt IS NULL\n      ${performerFilter ? 'AND i.id IN (SELECT imageId FROM effective_performers WHERE performerId IN (?))' : ''}\n      ${tagFilter ? 'AND i.id IN (SELECT imageId FROM effective_tags WHERE tagId IN (?))' : ''}\n      ${studioFilter ? 'AND i.id IN (SELECT imageId FROM effective_studios WHERE studioId IN (?))' : ''}\n    ORDER BY ${sortColumn} ${sortDirection}\n    LIMIT ? OFFSET ?\n  `;\n};\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#endpoints","title":"Endpoints","text":"Endpoint Method Description <code>/api/library/images</code> POST Find images with filters/sort/pagination <code>/api/library/images/:id</code> GET Get single image with hydrated relationships <code>/api/library/images/minimal</code> POST Minimal list for dropdowns <code>/api/library/images/:id/rating</code> POST Set user rating (existing) <code>/api/library/images/:id/favorite</code> POST Toggle favorite (existing)"},{"location":"plans/2025-12-24-images-page-design/#filter-support","title":"Filter Support","text":"<p>Matching Stash's ImageFilterType:</p> Filter Type Description <code>title</code> text Search title <code>code</code> text Search code <code>details</code> text Search details <code>photographer</code> text Search photographer <code>rating100</code> numeric User rating comparison <code>o_counter</code> numeric O-counter comparison <code>date</code> date Date range filter <code>created_at</code> timestamp Creation time filter <code>updated_at</code> timestamp Update time filter <code>performers</code> multi-select Filter by performers (with gallery inheritance) <code>tags</code> multi-select Filter by tags (with gallery inheritance) <code>studios</code> hierarchical Filter by studio (with gallery inheritance) <code>galleries</code> multi-select Filter to specific galleries <code>organized</code> boolean Organized status <code>resolution</code> enum Resolution filter <code>orientation</code> enum Portrait/landscape/square <code>favorite</code> boolean User favorites"},{"location":"plans/2025-12-24-images-page-design/#sort-options","title":"Sort Options","text":"Sort Field Description <code>title</code> Alphabetical by title <code>date</code> By date field <code>rating</code> By user rating <code>path</code> By file path <code>filesize</code> By file size <code>o_counter</code> By o-counter <code>created_at</code> By creation time <code>updated_at</code> By update time <code>random</code> Random order <code>tag_count</code> By number of tags <code>performer_count</code> By number of performers"},{"location":"plans/2025-12-24-images-page-design/#frontend","title":"Frontend","text":""},{"location":"plans/2025-12-24-images-page-design/#navigation","title":"Navigation","text":"<p>Add \"Images\" to sidebar after \"Galleries\". Respects existing user preferences for hiding/reordering menu items.</p>"},{"location":"plans/2025-12-24-images-page-design/#images-page","title":"Images Page","text":"<p>File: <code>client/src/components/pages/Images.jsx</code></p> <p>Components: - Grid view using existing <code>CardGrid</code> component - Filter bar with chips for performers, tags, studios, galleries - Sort dropdown matching Stash's options - Search box for text search - Pagination</p>"},{"location":"plans/2025-12-24-images-page-design/#image-card","title":"Image Card","text":"<p>Displays: - Thumbnail image (via proxy endpoint) - Title (or filename if no title) - Resolution badge - Rating stars (if rated) - Favorite indicator - Gallery indicator icon (if image belongs to a gallery)</p>"},{"location":"plans/2025-12-24-images-page-design/#lightbox-integration","title":"Lightbox Integration","text":"<p>Clicking an image opens the existing Lightbox component from GalleryDetail. Future enhancements will add metadata display in pillarbox/letterbox spaces.</p>"},{"location":"plans/2025-12-24-images-page-design/#api-integration","title":"API Integration","text":"<pre><code>// client/src/services/api.js\nfindImages: async (params) =&gt; apiPost('/library/images', params),\ngetImage: async (id) =&gt; apiGet(`/library/images/${id}`),\ngetImageUrl: (imageId, type = 'thumbnail') =&gt; `/api/proxy/image/${imageId}/${type}`,\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#entity-detail-page-integration","title":"Entity Detail Page Integration","text":""},{"location":"plans/2025-12-24-images-page-design/#performer-studio-tag-detail-pages","title":"Performer, Studio, Tag Detail Pages","text":"<p>Add \"Images\" tab/section showing images associated with that entity (respecting gallery-umbrella inheritance).</p> <ul> <li>Uses <code>findImages</code> API with entity filter pre-applied</li> <li>Shows grid of thumbnails</li> <li>Clicking opens lightbox</li> </ul>"},{"location":"plans/2025-12-24-images-page-design/#gallerydetail-page","title":"GalleryDetail Page","text":"<p>Refactor <code>getGalleryImages</code> endpoint to query Peek's database instead of Stash API directly. Continue using existing lightbox component.</p>"},{"location":"plans/2025-12-24-images-page-design/#content-restrictions","title":"Content Restrictions","text":"<p>Following existing patterns:</p> <ul> <li>Tag-based restrictions: Images respect INCLUDE/EXCLUDE rules, including inherited gallery tags</li> <li>Hidden entities: Images with hidden performers/tags/studios or in hidden galleries are filtered</li> <li>Empty entity filtering: Soft-deleted images hidden from non-admins</li> <li>Admin bypass: Admins skip content restrictions but still see hidden entity filtering</li> </ul>"},{"location":"plans/2025-12-24-images-page-design/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/2025-12-24-images-page-design/#phase-1-database-sync","title":"Phase 1: Database &amp; Sync","text":"<ol> <li>Create migration for new fields and indexes</li> <li>Update Prisma schema</li> <li>Update sync service for new fields</li> <li>Update stashapp-api if needed</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-2-backend-api","title":"Phase 2: Backend API","text":"<ol> <li>Create image proxy endpoint</li> <li>Create images controller with CTE queries</li> <li>Add routes</li> <li>Refactor GalleryDetail to use local DB</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-3-frontend","title":"Phase 3: Frontend","text":"<ol> <li>Add Images to navigation</li> <li>Create Images page with grid/filters/sort</li> <li>Integrate lightbox</li> <li>Add Images tab to entity detail pages</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-4-polish","title":"Phase 4: Polish","text":"<ol> <li>Test with large datasets</li> <li>Optimize queries if needed</li> <li>Add any missing filter/sort options</li> </ol>"},{"location":"plans/2025-12-24-images-page-implementation/","title":"Images Page Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add an Images page that displays all images (standalone and gallery-associated) with filtering, sorting, and gallery-umbrella inheritance for metadata.</p> <p>Architecture: Refactor existing images controller to query Peek's local SQLite database instead of Stash API. Use CTEs for efficient gallery-umbrella inheritance. Add new frontend page following the Galleries page pattern.</p> <p>Tech Stack: TypeScript/Express backend, React frontend, SQLite with Prisma, existing CardGrid/Lightbox components.</p>"},{"location":"plans/2025-12-24-images-page-implementation/#task-1-database-migration-add-missing-fields","title":"Task 1: Database Migration - Add Missing Fields","text":"<p>Files: - Create: <code>server/prisma/migrations/2025XXXX_add_image_gallery_fields/migration.sql</code> - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Create migration file</p> <p>Create <code>server/prisma/migrations/20251224100000_add_image_gallery_fields/migration.sql</code>:</p> <pre><code>-- Add missing fields to StashImage\nALTER TABLE \"StashImage\" ADD COLUMN \"code\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"details\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"photographer\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"urls\" TEXT;\n\n-- Add missing fields to StashGallery\nALTER TABLE \"StashGallery\" ADD COLUMN \"photographer\" TEXT;\nALTER TABLE \"StashGallery\" ADD COLUMN \"urls\" TEXT;\n\n-- Performance indexes for gallery-umbrella queries\nCREATE INDEX IF NOT EXISTS \"ImageGallery_imageId_idx\" ON \"ImageGallery\"(\"imageId\");\nCREATE INDEX IF NOT EXISTS \"GalleryPerformer_galleryId_idx\" ON \"GalleryPerformer\"(\"galleryId\");\nCREATE INDEX IF NOT EXISTS \"GalleryTag_galleryId_idx\" ON \"GalleryTag\"(\"galleryId\");\nCREATE INDEX IF NOT EXISTS \"StashGallery_studioId_deletedAt_idx\" ON \"StashGallery\"(\"studioId\", \"deletedAt\");\nCREATE INDEX IF NOT EXISTS \"StashImage_title_idx\" ON \"StashImage\"(\"title\");\nCREATE INDEX IF NOT EXISTS \"StashImage_browse_idx\" ON \"StashImage\"(\"deletedAt\", \"stashCreatedAt\" DESC);\n</code></pre> <p>Step 2: Update Prisma schema</p> <p>In <code>server/prisma/schema.prisma</code>, find the <code>StashImage</code> model and add:</p> <pre><code>model StashImage {\n  id              String    @id\n  stashInstanceId String?\n  title           String?\n  code            String?       // NEW\n  details         String?       // NEW\n  photographer    String?       // NEW\n  urls            String?       // NEW (JSON array)\n  date            String?\n  studioId        String?\n  rating100       Int?\n  oCounter        Int       @default(0)\n  organized       Boolean   @default(false)\n  filePath        String?\n  width           Int?\n  height          Int?\n  fileSize        BigInt?\n  pathThumbnail   String?\n  pathPreview     String?\n  pathImage       String?\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  performers ImagePerformer[]\n  tags       ImageTag[]\n  galleries  ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n  @@index([title])\n  @@index([deletedAt, stashCreatedAt(sort: Desc)])\n}\n</code></pre> <p>Find the <code>StashGallery</code> model and add:</p> <pre><code>model StashGallery {\n  // ... existing fields ...\n  photographer    String?       // NEW\n  urls            String?       // NEW (JSON array)\n  // ... rest of model ...\n}\n</code></pre> <p>Step 3: Run migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add_image_gallery_fields</code></p> <p>Expected: Migration applies successfully, Prisma client regenerated.</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/migrations server/prisma/schema.prisma\ngit commit -m \"feat: add missing image/gallery fields and performance indexes\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-2-update-sync-service-image-fields","title":"Task 2: Update Sync Service - Image Fields","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:1840-1891</code></p> <p>Step 1: Update processImagesBatch INSERT statement</p> <p>Find the <code>processImagesBatch</code> method around line 1840. Update the SQL INSERT to include new fields.</p> <p>Change the values template from:</p> <pre><code>return `(\n  '${this.escape(image.id)}',\n  ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n  ${this.escapeNullable(image.title)},\n  ${this.escapeNullable(image.date)},\n  // ... existing fields ...\n)`;\n</code></pre> <p>To:</p> <pre><code>return `(\n  '${this.escape(image.id)}',\n  ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n  ${this.escapeNullable(image.title)},\n  ${this.escapeNullable(image.code)},\n  ${this.escapeNullable(image.details)},\n  ${this.escapeNullable(image.photographer)},\n  ${this.escapeNullable(image.urls ? JSON.stringify(image.urls) : null)},\n  ${this.escapeNullable(image.date)},\n  // ... rest of existing fields ...\n)`;\n</code></pre> <p>Update the INSERT column list to include: <code>code, details, photographer, urls</code></p> <p>Update the ON CONFLICT SET clause to include the new fields.</p> <p>Step 2: Verify sync fetches new fields</p> <p>Check that stashapp-api's <code>findImages</code> query includes <code>code</code>, <code>details</code>, <code>photographer</code>, <code>urls</code> fields. If not, this requires updating stashapp-api first.</p> <p>Step 3: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --grep \"StashSyncService\"</code></p> <p>Expected: Existing tests pass.</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: sync code, details, photographer, urls for images\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-3-update-sync-service-gallery-fields","title":"Task 3: Update Sync Service - Gallery Fields","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code> (processGalleriesBatch method)</p> <p>Step 1: Find processGalleriesBatch method</p> <p>Search for <code>processGalleriesBatch</code> in the file.</p> <p>Step 2: Update INSERT statement</p> <p>Add <code>photographer</code> and <code>urls</code> to the INSERT column list and values.</p> <pre><code>${this.escapeNullable(gallery.photographer)},\n${this.escapeNullable(gallery.urls ? JSON.stringify(gallery.urls) : null)},\n</code></pre> <p>Step 3: Update ON CONFLICT clause</p> <p>Add the new fields to the SET clause.</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: sync photographer and urls for galleries\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-4-add-image-proxy-endpoint","title":"Task 4: Add Image Proxy Endpoint","text":"<p>Files: - Modify: <code>server/controllers/proxy.ts</code> - Modify: <code>server/routes/proxy.ts</code> (or wherever proxy routes are defined)</p> <p>Step 1: Add proxyImage controller function</p> <p>Add to <code>server/controllers/proxy.ts</code>:</p> <pre><code>/**\n * Proxy image requests by image ID and type\n * GET /api/proxy/image/:imageId/:type\n * :type = \"thumbnail\" | \"preview\" | \"image\"\n */\nexport const proxyImage = async (req: Request, res: Response) =&gt; {\n  const { imageId, type } = req.params;\n\n  if (!imageId) {\n    return res.status(400).json({ error: \"Missing image ID\" });\n  }\n\n  const validTypes = [\"thumbnail\", \"preview\", \"image\"];\n  if (!type || !validTypes.includes(type)) {\n    return res.status(400).json({ error: \"Invalid image type. Must be: thumbnail, preview, or image\" });\n  }\n\n  // Get image from database\n  const image = await prisma.stashImage.findFirst({\n    where: { id: imageId, deletedAt: null },\n  });\n\n  if (!image) {\n    return res.status(404).json({ error: \"Image not found\" });\n  }\n\n  // Get the appropriate path\n  const pathMap: Record&lt;string, string | null&gt; = {\n    thumbnail: image.pathThumbnail,\n    preview: image.pathPreview,\n    image: image.pathImage,\n  };\n  const stashPath = pathMap[type];\n\n  if (!stashPath) {\n    return res.status(404).json({ error: `Image ${type} path not available` });\n  }\n\n  let stashUrl: string;\n  let apiKey: string;\n\n  try {\n    stashUrl = stashInstanceManager.getBaseUrl();\n    apiKey = stashInstanceManager.getApiKey();\n  } catch {\n    logger.error(\"No Stash instance configured\");\n    return res.status(500).json({ error: \"Stash configuration missing\" });\n  }\n\n  // Acquire concurrency slot before making request\n  await acquireConcurrencySlot();\n\n  try {\n    // Construct full Stash URL with API key\n    const fullUrl = `${stashUrl}${stashPath}${stashPath.includes(\"?\") ? \"&amp;\" : \"?\"}apikey=${apiKey}`;\n\n    logger.debug(\"Proxying image request\", {\n      imageId,\n      type,\n      url: fullUrl.replace(apiKey, \"***\"),\n    });\n\n    const urlObj = new URL(fullUrl);\n    const httpModule = urlObj.protocol === \"https:\" ? https : http;\n    const agent = getAgentForUrl(urlObj);\n\n    const proxyReq = httpModule.get(fullUrl, { agent }, (proxyRes) =&gt; {\n      if (proxyRes.headers[\"content-type\"]) {\n        res.setHeader(\"Content-Type\", proxyRes.headers[\"content-type\"]);\n      }\n      if (proxyRes.headers[\"content-length\"]) {\n        res.setHeader(\"Content-Length\", proxyRes.headers[\"content-length\"]);\n      }\n      // Cache images for 24 hours\n      res.setHeader(\"Cache-Control\", \"public, max-age=86400\");\n      res.status(proxyRes.statusCode || 200);\n      proxyRes.pipe(res);\n      proxyRes.on(\"end\", releaseConcurrencySlot);\n      proxyRes.on(\"error\", releaseConcurrencySlot);\n    });\n\n    proxyReq.on(\"error\", (error: Error) =&gt; {\n      releaseConcurrencySlot();\n      logger.error(\"Error proxying image\", { imageId, type, error: error.message });\n      if (!res.headersSent) {\n        res.status(500).json({ error: \"Proxy request failed\" });\n      }\n    });\n\n    proxyReq.setTimeout(30000, () =&gt; {\n      releaseConcurrencySlot();\n      proxyReq.destroy();\n      if (!res.headersSent) {\n        res.status(504).json({ error: \"Proxy request timeout\" });\n      }\n    });\n  } catch (error) {\n    releaseConcurrencySlot();\n    logger.error(\"Error proxying image\", { error });\n    if (!res.headersSent) {\n      res.status(500).json({ error: \"Internal server error\" });\n    }\n  }\n};\n</code></pre> <p>Step 2: Add route</p> <p>Find the proxy routes file and add:</p> <pre><code>router.get(\"/image/:imageId/:type\", proxyImage);\n</code></pre> <p>Step 3: Add prisma import</p> <p>Add at top of <code>proxy.ts</code>:</p> <pre><code>import prisma from \"../prisma/singleton.js\";\n</code></pre> <p>Step 4: Test manually</p> <p>Start server and test: <code>curl http://localhost:3000/api/proxy/image/123/thumbnail</code></p> <p>Expected: Returns 404 if image doesn't exist, or proxies image if it does.</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/proxy.ts server/routes/proxy.ts\ngit commit -m \"feat: add image proxy endpoint\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-5-refactor-images-controller-database-queries","title":"Task 5: Refactor Images Controller - Database Queries","text":"<p>Files: - Modify: <code>server/controllers/library/images.ts</code></p> <p>Step 1: Add StashEntityService methods for images</p> <p>First, check if <code>StashEntityService</code> already has <code>getAllImages</code>, <code>getImage</code>, <code>getImagesByIds</code> methods. If not, add them following the pattern of <code>getAllGalleries</code>.</p> <p>Step 2: Rewrite findImages to use local database</p> <p>Replace the current implementation that queries Stash API with one that queries the local database using CTEs for gallery inheritance.</p> <pre><code>import type { Response } from \"express\";\nimport { AuthenticatedRequest } from \"../../middleware/auth.js\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { stashEntityService } from \"../../services/StashEntityService.js\";\nimport { emptyEntityFilterService } from \"../../services/EmptyEntityFilterService.js\";\nimport { filteredEntityCacheService } from \"../../services/FilteredEntityCacheService.js\";\nimport { userRestrictionService } from \"../../services/UserRestrictionService.js\";\nimport { expandStudioIds, expandTagIds } from \"../../utils/hierarchyUtils.js\";\nimport { logger } from \"../../utils/logger.js\";\nimport { buildStashEntityUrl } from \"../../utils/stashUrl.js\";\n\n// ... keep existing calculateEntityImageCount function ...\n\n/**\n * Find images endpoint - queries local database with gallery-umbrella inheritance\n */\nexport const findImages = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const { filter, image_filter, ids } = req.body;\n\n    const sortField = filter?.sort || \"title\";\n    const sortDirection = filter?.direction || \"ASC\";\n    const page = filter?.page || 1;\n    const perPage = filter?.per_page || 40;\n    const searchQuery = filter?.q || \"\";\n\n    // Step 1: Get all images from cache/database\n    let images = await stashEntityService.getAllImages();\n\n    if (images.length === 0) {\n      logger.warn(\"Image cache not initialized, returning empty result\");\n      return res.json({\n        findImages: {\n          count: 0,\n          images: [],\n        },\n      });\n    }\n\n    // Step 2: Merge with user data (ratings/favorites)\n    images = await mergeImagesWithUserData(images, userId);\n\n    // Step 3: Apply content restrictions\n    const requestingUser = req.user;\n    images = await userRestrictionService.filterImagesForUser(\n      images,\n      userId,\n      requestingUser?.role === \"ADMIN\"\n    );\n\n    // Step 4: Apply search query\n    if (searchQuery) {\n      const lowerQuery = searchQuery.toLowerCase();\n      images = images.filter((img) =&gt; {\n        const title = img.title || \"\";\n        const details = img.details || \"\";\n        const photographer = img.photographer || \"\";\n        return (\n          title.toLowerCase().includes(lowerQuery) ||\n          details.toLowerCase().includes(lowerQuery) ||\n          photographer.toLowerCase().includes(lowerQuery)\n        );\n      });\n    }\n\n    // Step 5: Apply filters with gallery-umbrella inheritance\n    images = await applyImageFiltersWithInheritance(images, image_filter, ids);\n\n    // Step 6: Sort\n    images = sortImages(images, sortField, sortDirection);\n\n    // Step 7: Paginate\n    const total = images.length;\n    const startIndex = (page - 1) * perPage;\n    const endIndex = startIndex + perPage;\n    const paginatedImages = images.slice(startIndex, endIndex);\n\n    // Step 8: Add stashUrl to each image\n    const imagesWithStashUrl = paginatedImages.map((image) =&gt; ({\n      ...image,\n      stashUrl: buildStashEntityUrl(\"image\", image.id),\n    }));\n\n    res.json({\n      findImages: {\n        count: total,\n        images: imagesWithStashUrl,\n      },\n    });\n  } catch (error) {\n    logger.error(\"Error in findImages\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n\n/**\n * Apply image filters with gallery-umbrella inheritance\n */\nasync function applyImageFiltersWithInheritance(\n  images: any[],\n  filters: any,\n  ids?: string[]\n): Promise&lt;any[]&gt; {\n  if (!filters &amp;&amp; !ids) return images;\n\n  let filtered = images;\n\n  // Filter by IDs\n  if (ids &amp;&amp; Array.isArray(ids) &amp;&amp; ids.length &gt; 0) {\n    const idSet = new Set(ids);\n    filtered = filtered.filter((img) =&gt; idSet.has(img.id));\n  }\n\n  // Filter by favorite\n  if (filters?.favorite !== undefined) {\n    filtered = filtered.filter((img) =&gt; img.favorite === filters.favorite);\n  }\n\n  // Filter by rating100\n  if (filters?.rating100) {\n    const { modifier, value, value2 } = filters.rating100;\n    filtered = filtered.filter((img) =&gt; {\n      const rating = img.rating100 || 0;\n      if (modifier === \"GREATER_THAN\") return rating &gt; value;\n      if (modifier === \"LESS_THAN\") return rating &lt; value;\n      if (modifier === \"EQUALS\") return rating === value;\n      if (modifier === \"NOT_EQUALS\") return rating !== value;\n      if (modifier === \"BETWEEN\") return rating &gt;= value &amp;&amp; rating &lt;= value2;\n      return true;\n    });\n  }\n\n  // Filter by performers (with gallery inheritance)\n  if (filters?.performers?.value) {\n    const performerIds = new Set(filters.performers.value.map(String));\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct performers\n      if (img.performers?.some((p: any) =&gt; performerIds.has(String(p.id)))) {\n        return true;\n      }\n      // Check gallery performers (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.performers?.some((p: any) =&gt; performerIds.has(String(p.id)))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by tags (with gallery inheritance)\n  if (filters?.tags?.value) {\n    const expandedTagIds = new Set(\n      await expandTagIds(\n        filters.tags.value.map(String),\n        filters.tags.depth ?? 0\n      )\n    );\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct tags\n      if (img.tags?.some((t: any) =&gt; expandedTagIds.has(String(t.id)))) {\n        return true;\n      }\n      // Check gallery tags (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.tags?.some((t: any) =&gt; expandedTagIds.has(String(t.id)))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by studios (with gallery inheritance)\n  if (filters?.studios?.value) {\n    const expandedStudioIds = new Set(\n      await expandStudioIds(\n        filters.studios.value.map(String),\n        filters.studios.depth ?? 0\n      )\n    );\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct studio\n      if (img.studio &amp;&amp; expandedStudioIds.has(String(img.studio.id))) {\n        return true;\n      }\n      // Check gallery studio (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.studio &amp;&amp; expandedStudioIds.has(String(g.studio.id))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by specific galleries\n  if (filters?.galleries?.value) {\n    const galleryIds = new Set(filters.galleries.value.map(String));\n    filtered = filtered.filter((img) =&gt;\n      img.galleries?.some((g: any) =&gt; galleryIds.has(String(g.id)))\n    );\n  }\n\n  return filtered;\n}\n\n/**\n * Sort images\n */\nfunction sortImages(images: any[], sortField: string, sortDirection: string): any[] {\n  const direction = sortDirection === \"DESC\" ? -1 : 1;\n\n  return images.sort((a, b) =&gt; {\n    let aVal, bVal;\n\n    switch (sortField) {\n      case \"title\":\n        aVal = (a.title || a.filePath || \"\").toLowerCase();\n        bVal = (b.title || b.filePath || \"\").toLowerCase();\n        break;\n      case \"date\":\n        aVal = a.date || \"\";\n        bVal = b.date || \"\";\n        break;\n      case \"rating\":\n      case \"rating100\":\n        aVal = a.rating100 || 0;\n        bVal = b.rating100 || 0;\n        break;\n      case \"o_counter\":\n        aVal = a.oCounter || 0;\n        bVal = b.oCounter || 0;\n        break;\n      case \"filesize\":\n        aVal = Number(a.fileSize) || 0;\n        bVal = Number(b.fileSize) || 0;\n        break;\n      case \"path\":\n        aVal = (a.filePath || \"\").toLowerCase();\n        bVal = (b.filePath || \"\").toLowerCase();\n        break;\n      case \"created_at\":\n        aVal = a.stashCreatedAt || \"\";\n        bVal = b.stashCreatedAt || \"\";\n        break;\n      case \"updated_at\":\n        aVal = a.stashUpdatedAt || \"\";\n        bVal = b.stashUpdatedAt || \"\";\n        break;\n      case \"random\":\n        return Math.random() - 0.5;\n      default:\n        aVal = (a.title || \"\").toLowerCase();\n        bVal = (b.title || \"\").toLowerCase();\n    }\n\n    if (aVal &lt; bVal) return -1 * direction;\n    if (aVal &gt; bVal) return 1 * direction;\n    return 0;\n  });\n}\n\n/**\n * Merge images with user rating/favorite data\n */\nasync function mergeImagesWithUserData(images: any[], userId: number): Promise&lt;any[]&gt; {\n  const ratings = await prisma.imageRating.findMany({ where: { userId } });\n\n  const ratingMap = new Map(\n    ratings.map((r) =&gt; [\n      r.imageId,\n      {\n        rating: r.rating,\n        rating100: r.rating,\n        favorite: r.favorite,\n      },\n    ])\n  );\n\n  return images.map((image) =&gt; ({\n    ...image,\n    rating: null,\n    rating100: null,\n    favorite: false,\n    ...ratingMap.get(image.id),\n  }));\n}\n</code></pre> <p>Step 3: Add findImageById endpoint</p> <pre><code>/**\n * Find single image by ID\n */\nexport const findImageById = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const { id } = req.params;\n\n    const image = await stashEntityService.getImage(id);\n\n    if (!image) {\n      return res.status(404).json({ error: \"Image not found\" });\n    }\n\n    // Merge with user data\n    const images = await mergeImagesWithUserData([image], userId);\n    const mergedImage = images[0];\n\n    res.json(mergedImage);\n  } catch (error) {\n    logger.error(\"Error in findImageById\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find image\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/images.ts\ngit commit -m \"refactor: images controller to use local database with gallery inheritance\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-6-add-stashentityservice-image-methods","title":"Task 6: Add StashEntityService Image Methods","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Add getAllImages method</p> <p>Find where <code>getAllGalleries</code> is defined and add similar methods for images:</p> <pre><code>/**\n * Get all images from cache\n */\nasync getAllImages(): Promise&lt;NormalizedImage[]&gt; {\n  const cached = await prisma.stashImage.findMany({\n    where: { deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached.map(this.normalizeImage.bind(this));\n}\n\n/**\n * Get single image by ID\n */\nasync getImage(id: string): Promise&lt;NormalizedImage | null&gt; {\n  const cached = await prisma.stashImage.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached ? this.normalizeImage(cached) : null;\n}\n\n/**\n * Get images by IDs\n */\nasync getImagesByIds(ids: string[]): Promise&lt;NormalizedImage[]&gt; {\n  const cached = await prisma.stashImage.findMany({\n    where: { id: { in: ids }, deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached.map(this.normalizeImage.bind(this));\n}\n\n/**\n * Normalize image from database to API format\n */\nprivate normalizeImage(dbImage: any): NormalizedImage {\n  return {\n    id: dbImage.id,\n    title: dbImage.title,\n    code: dbImage.code,\n    details: dbImage.details,\n    photographer: dbImage.photographer,\n    urls: dbImage.urls ? JSON.parse(dbImage.urls) : [],\n    date: dbImage.date,\n    rating100: dbImage.rating100,\n    o_counter: dbImage.oCounter,\n    organized: dbImage.organized,\n    file_path: dbImage.filePath,\n    width: dbImage.width,\n    height: dbImage.height,\n    file_size: dbImage.fileSize ? Number(dbImage.fileSize) : null,\n    paths: {\n      thumbnail: dbImage.pathThumbnail,\n      preview: dbImage.pathPreview,\n      image: dbImage.pathImage,\n    },\n    created_at: dbImage.stashCreatedAt?.toISOString(),\n    updated_at: dbImage.stashUpdatedAt?.toISOString(),\n    studio: dbImage.studioId ? { id: dbImage.studioId } : null,\n    performers: dbImage.performers?.map((ip: any) =&gt; ({\n      id: ip.performer.id,\n      name: ip.performer.name,\n    })) || [],\n    tags: dbImage.tags?.map((it: any) =&gt; ({\n      id: it.tag.id,\n      name: it.tag.name,\n    })) || [],\n    galleries: dbImage.galleries?.map((ig: any) =&gt; ({\n      id: ig.gallery.id,\n      title: ig.gallery.title,\n    })) || [],\n  };\n}\n</code></pre> <p>Step 2: Add NormalizedImage type</p> <p>In <code>server/types/index.ts</code>, add:</p> <pre><code>export interface NormalizedImage {\n  id: string;\n  title: string | null;\n  code: string | null;\n  details: string | null;\n  photographer: string | null;\n  urls: string[];\n  date: string | null;\n  rating100: number | null;\n  o_counter: number;\n  organized: boolean;\n  file_path: string | null;\n  width: number | null;\n  height: number | null;\n  file_size: number | null;\n  paths: {\n    thumbnail: string | null;\n    preview: string | null;\n    image: string | null;\n  };\n  created_at: string | null;\n  updated_at: string | null;\n  studio: { id: string } | null;\n  performers: { id: string; name: string }[];\n  tags: { id: string; name: string }[];\n  galleries: { id: string; title: string | null }[];\n  // User data (merged)\n  rating?: number | null;\n  favorite?: boolean;\n}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/index.ts\ngit commit -m \"feat: add image methods to StashEntityService\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-7-add-image-routes","title":"Task 7: Add Image Routes","text":"<p>Files: - Modify: <code>server/routes/library/images.ts</code></p> <p>Step 1: Add additional routes</p> <pre><code>import express from \"express\";\nimport { findImages, findImageById } from \"../../controllers/library/images.js\";\nimport { authenticateToken, requireCacheReady } from \"../../middleware/auth.js\";\nimport { authenticated } from \"../../utils/routeHelpers.js\";\n\nconst router = express.Router();\n\n// Find images (with filters, pagination, sorting)\nrouter.post(\n  \"/images\",\n  authenticateToken,\n  requireCacheReady,\n  authenticated(findImages)\n);\n\n// Get single image by ID\nrouter.get(\n  \"/images/:id\",\n  authenticateToken,\n  requireCacheReady,\n  authenticated(findImageById)\n);\n\nexport default router;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/routes/library/images.ts\ngit commit -m \"feat: add image routes\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-8-add-navigation-item","title":"Task 8: Add Navigation Item","text":"<p>Files: - Modify: <code>client/src/constants/navigation.js</code></p> <p>Step 1: Add Images nav item after Galleries</p> <p>Find the <code>NAV_DEFINITIONS</code> array and add after the galleries entry:</p> <pre><code>{\n  key: \"images\",\n  name: \"Images\",\n  path: \"/images\",\n  icon: \"image\",\n  description: \"Browse all images in your library\",\n},\n</code></pre> <p>Step 2: Update Sidebar getCurrentPage</p> <p>In <code>client/src/components/ui/Sidebar.jsx</code>, find <code>getCurrentPage</code> function and add:</p> <pre><code>if (path.startsWith(\"/images\")) return \"Images\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/constants/navigation.js client/src/components/ui/Sidebar.jsx\ngit commit -m \"feat: add Images to navigation\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-9-create-images-page-component","title":"Task 9: Create Images Page Component","text":"<p>Files: - Create: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Create the Images page</p> <p>Follow the Galleries.jsx pattern:</p> <pre><code>import { useRef, useState } from \"react\";\nimport { useLocation, useNavigate, useSearchParams } from \"react-router-dom\";\nimport deepEqual from \"fast-deep-equal\";\nimport { STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { useInitialFocus } from \"../../hooks/useFocusTrap.js\";\nimport { useGridColumns } from \"../../hooks/useGridColumns.js\";\nimport { usePageTitle } from \"../../hooks/usePageTitle.js\";\nimport { useGridPageTVNavigation } from \"../../hooks/useGridPageTVNavigation.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport { ImageCard } from \"../cards/index.js\";\nimport {\n  SyncProgressBanner,\n  ErrorMessage,\n  PageHeader,\n  PageLayout,\n  SearchControls,\n} from \"../ui/index.js\";\n\nconst getImages = async (query) =&gt; {\n  const params = {\n    filter: {\n      page: query.page || 1,\n      per_page: query.per_page || 24,\n      sort: query.sort || \"title\",\n      direction: query.direction || \"ASC\",\n      q: query.q || \"\",\n    },\n    image_filter: {},\n  };\n\n  // Add filters\n  if (query.performers?.length) {\n    params.image_filter.performers = { value: query.performers };\n  }\n  if (query.tags?.length) {\n    params.image_filter.tags = { value: query.tags };\n  }\n  if (query.studios?.length) {\n    params.image_filter.studios = { value: query.studios };\n  }\n  if (query.galleries?.length) {\n    params.image_filter.galleries = { value: query.galleries };\n  }\n  if (query.favorite !== undefined) {\n    params.image_filter.favorite = query.favorite;\n  }\n  if (query.rating100) {\n    params.image_filter.rating100 = query.rating100;\n  }\n\n  const result = await libraryApi.findImages(params);\n  return {\n    images: result?.findImages?.images || [],\n    count: result?.findImages?.count || 0,\n  };\n};\n\nconst Images = () =&gt; {\n  usePageTitle(\"Images\");\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [searchParams] = useSearchParams();\n  const pageRef = useRef(null);\n  const gridRef = useRef(null);\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n  const columns = useGridColumns(\"images\");\n\n  const [lastQuery, setLastQuery] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const [initMessage, setInitMessage] = useState(null);\n\n  const handleQueryChange = async (newQuery, retryCount = 0) =&gt; {\n    if (isAuthLoading || !isAuthenticated) {\n      return;\n    }\n\n    if (lastQuery &amp;&amp; deepEqual(newQuery, lastQuery)) {\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setLastQuery(newQuery);\n      setError(null);\n      setInitMessage(null);\n      const result = await getImages(newQuery);\n      setData(result);\n      setIsLoading(false);\n    } catch (err) {\n      if (err.isInitializing &amp;&amp; retryCount &lt; 60) {\n        setInitMessage(\"Server is syncing library, please wait...\");\n        setTimeout(() =&gt; {\n          handleQueryChange(newQuery, retryCount + 1);\n        }, 5000);\n        return;\n      }\n      setError(err.message || \"An error occurred\");\n      setIsLoading(false);\n    }\n  };\n\n  const currentImages = data?.images || [];\n  const totalCount = data?.count || 0;\n\n  const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\n  const totalPages = Math.ceil(totalCount / urlPerPage);\n\n  // TV Navigation\n  const {\n    isTVMode,\n    _tvNavigation,\n    searchControlsProps,\n    gridItemProps,\n  } = useGridPageTVNavigation({\n    items: currentImages,\n    columns,\n    onNavigate: (item) =&gt; {\n      // Open lightbox instead of navigating\n      // TODO: Implement lightbox opening\n    },\n    gridRef,\n    currentPage: parseInt(searchParams.get(\"page\")) || 1,\n    totalPages,\n    navigate,\n    location,\n  });\n\n  useInitialFocus(pageRef, \".search-input\");\n\n  return (\n    &lt;PageLayout ref={pageRef}&gt;\n      &lt;SyncProgressBanner /&gt;\n\n      &lt;div className={STANDARD_GRID_CONTAINER_CLASSNAMES}&gt;\n        &lt;PageHeader\n          title=\"Images\"\n          count={totalCount}\n          isLoading={isLoading}\n        /&gt;\n\n        &lt;SearchControls\n          entityType=\"image\"\n          onQueryChange={handleQueryChange}\n          sortOptions={[\n            { value: \"title\", label: \"Title\" },\n            { value: \"date\", label: \"Date\" },\n            { value: \"rating\", label: \"Rating\" },\n            { value: \"path\", label: \"Path\" },\n            { value: \"filesize\", label: \"File Size\" },\n            { value: \"created_at\", label: \"Created\" },\n            { value: \"updated_at\", label: \"Updated\" },\n            { value: \"random\", label: \"Random\" },\n          ]}\n          defaultSort=\"title\"\n          filterTypes={[\"performers\", \"tags\", \"studios\", \"galleries\", \"favorite\", \"rating\"]}\n          {...searchControlsProps}\n        /&gt;\n\n        {initMessage &amp;&amp; (\n          &lt;div className=\"text-center py-8 text-muted-foreground\"&gt;\n            {initMessage}\n          &lt;/div&gt;\n        )}\n\n        {error &amp;&amp; &lt;ErrorMessage message={error} /&gt;}\n\n        {!error &amp;&amp; !initMessage &amp;&amp; (\n          &lt;div\n            ref={gridRef}\n            className=\"grid gap-4\"\n            style={{\n              gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,\n            }}\n          &gt;\n            {currentImages.map((image, index) =&gt; (\n              &lt;ImageCard\n                key={image.id}\n                image={image}\n                {...gridItemProps(index)}\n              /&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n\n        {!isLoading &amp;&amp; currentImages.length === 0 &amp;&amp; !error &amp;&amp; (\n          &lt;div className=\"text-center py-8 text-muted-foreground\"&gt;\n            No images found\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/PageLayout&gt;\n  );\n};\n\nexport default Images;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"feat: create Images page component\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-10-create-imagecard-component","title":"Task 10: Create ImageCard Component","text":"<p>Files: - Create: <code>client/src/components/cards/ImageCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Create ImageCard component</p> <pre><code>import { useState } from \"react\";\nimport { ThemedIcon } from \"../icons/index.js\";\nimport { RatingDisplay } from \"../ui/index.js\";\n\n/**\n * Get proxied image URL\n */\nconst getImageUrl = (imageId, type = \"thumbnail\") =&gt; {\n  return `/api/proxy/image/${imageId}/${type}`;\n};\n\n/**\n * Format resolution string\n */\nconst formatResolution = (width, height) =&gt; {\n  if (!width || !height) return null;\n  if (height &gt;= 2160) return \"4K\";\n  if (height &gt;= 1440) return \"1440p\";\n  if (height &gt;= 1080) return \"1080p\";\n  if (height &gt;= 720) return \"720p\";\n  if (height &gt;= 480) return \"480p\";\n  return `${width}x${height}`;\n};\n\nconst ImageCard = ({ image, onClick, ...props }) =&gt; {\n  const [imageError, setImageError] = useState(false);\n\n  const handleClick = () =&gt; {\n    if (onClick) {\n      onClick(image);\n    }\n  };\n\n  const resolution = formatResolution(image.width, image.height);\n  const hasGallery = image.galleries?.length &gt; 0;\n\n  return (\n    &lt;div\n      className=\"group relative aspect-[3/4] overflow-hidden rounded-lg bg-card cursor-pointer transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-primary\"\n      onClick={handleClick}\n      tabIndex={0}\n      {...props}\n    &gt;\n      {/* Image */}\n      {!imageError ? (\n        &lt;img\n          src={getImageUrl(image.id, \"thumbnail\")}\n          alt={image.title || \"Image\"}\n          className=\"h-full w-full object-cover\"\n          loading=\"lazy\"\n          onError={() =&gt; setImageError(true)}\n        /&gt;\n      ) : (\n        &lt;div className=\"flex h-full w-full items-center justify-center bg-muted\"&gt;\n          &lt;ThemedIcon name=\"image\" className=\"h-12 w-12 text-muted-foreground\" /&gt;\n        &lt;/div&gt;\n      )}\n\n      {/* Overlay with info */}\n      &lt;div className=\"absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity\"&gt;\n        &lt;div className=\"absolute bottom-0 left-0 right-0 p-3\"&gt;\n          &lt;h3 className=\"text-sm font-medium text-white line-clamp-2\"&gt;\n            {image.title || \"Untitled\"}\n          &lt;/h3&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Badges */}\n      &lt;div className=\"absolute top-2 left-2 flex gap-1\"&gt;\n        {resolution &amp;&amp; (\n          &lt;span className=\"px-1.5 py-0.5 text-xs font-medium bg-black/60 text-white rounded\"&gt;\n            {resolution}\n          &lt;/span&gt;\n        )}\n        {hasGallery &amp;&amp; (\n          &lt;span className=\"px-1.5 py-0.5 bg-black/60 text-white rounded\"&gt;\n            &lt;ThemedIcon name=\"gallery-vertical\" className=\"h-3 w-3\" /&gt;\n          &lt;/span&gt;\n        )}\n      &lt;/div&gt;\n\n      {/* Favorite indicator */}\n      {image.favorite &amp;&amp; (\n        &lt;div className=\"absolute top-2 right-2\"&gt;\n          &lt;ThemedIcon name=\"heart\" className=\"h-4 w-4 text-red-500 fill-red-500\" /&gt;\n        &lt;/div&gt;\n      )}\n\n      {/* Rating */}\n      {image.rating100 &gt; 0 &amp;&amp; (\n        &lt;div className=\"absolute bottom-2 right-2\"&gt;\n          &lt;RatingDisplay rating={image.rating100} size=\"sm\" /&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ImageCard;\n</code></pre> <p>Step 2: Export from index</p> <p>Add to <code>client/src/components/cards/index.js</code>:</p> <pre><code>export { default as ImageCard } from \"./ImageCard.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/cards/ImageCard.jsx client/src/components/cards/index.js\ngit commit -m \"feat: create ImageCard component\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-11-add-route-to-app","title":"Task 11: Add Route to App","text":"<p>Files: - Modify: <code>client/src/App.jsx</code></p> <p>Step 1: Import Images page</p> <p>Add import:</p> <pre><code>import Images from \"./components/pages/Images.jsx\";\n</code></pre> <p>Step 2: Add route</p> <p>Find where routes are defined and add after Galleries:</p> <pre><code>&lt;Route path=\"/images\" element={&lt;Images /&gt;} /&gt;\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/App.jsx\ngit commit -m \"feat: add Images route to App\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-12-integrate-lightbox-with-images-page","title":"Task 12: Integrate Lightbox with Images Page","text":"<p>Files: - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Import Lightbox</p> <p>Check how GalleryDetail uses Lightbox and import the same component.</p> <p>Step 2: Add lightbox state</p> <pre><code>const [lightboxOpen, setLightboxOpen] = useState(false);\nconst [lightboxIndex, setLightboxIndex] = useState(0);\n\nconst handleImageClick = (image) =&gt; {\n  const index = currentImages.findIndex((img) =&gt; img.id === image.id);\n  setLightboxIndex(index);\n  setLightboxOpen(true);\n};\n</code></pre> <p>Step 3: Add Lightbox component</p> <pre><code>{lightboxOpen &amp;&amp; (\n  &lt;Lightbox\n    images={currentImages.map((img) =&gt; ({\n      id: img.id,\n      src: getImageUrl(img.id, \"image\"),\n      thumbnail: getImageUrl(img.id, \"thumbnail\"),\n      title: img.title,\n    }))}\n    initialIndex={lightboxIndex}\n    onClose={() =&gt; setLightboxOpen(false)}\n  /&gt;\n)}\n</code></pre> <p>Step 4: Pass onClick to ImageCard</p> <pre><code>&lt;ImageCard\n  key={image.id}\n  image={image}\n  onClick={handleImageClick}\n  {...gridItemProps(index)}\n/&gt;\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"feat: integrate lightbox with Images page\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-13-refactor-gallerydetail-to-use-local-database","title":"Task 13: Refactor GalleryDetail to Use Local Database","text":"<p>Files: - Modify: <code>server/controllers/library/galleries.ts:600-669</code></p> <p>Step 1: Update getGalleryImages</p> <p>Replace the Stash API query with a local database query:</p> <pre><code>export const getGalleryImages = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const { galleryId } = req.params;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    // Query images from local database\n    const images = await prisma.stashImage.findMany({\n      where: {\n        deletedAt: null,\n        galleries: {\n          some: { galleryId },\n        },\n      },\n      include: {\n        performers: { include: { performer: true } },\n        tags: { include: { tag: true } },\n      },\n      orderBy: { filePath: \"asc\" },\n    });\n\n    // Transform to API format\n    const transformedImages = images.map((image) =&gt; ({\n      id: image.id,\n      title: image.title,\n      paths: {\n        thumbnail: `/api/proxy/image/${image.id}/thumbnail`,\n        preview: `/api/proxy/image/${image.id}/preview`,\n        image: `/api/proxy/image/${image.id}/image`,\n      },\n      width: image.width,\n      height: image.height,\n      rating100: image.rating100,\n      o_counter: image.oCounter,\n      performers: image.performers.map((ip) =&gt; ({\n        id: ip.performer.id,\n        name: ip.performer.name,\n      })),\n      tags: image.tags.map((it) =&gt; ({\n        id: it.tag.id,\n        name: it.tag.name,\n      })),\n    }));\n\n    // Merge with user data\n    const mergedImages = await mergeImagesWithUserData(transformedImages, userId);\n\n    res.json({\n      images: mergedImages,\n      count: mergedImages.length,\n    });\n  } catch (error) {\n    logger.error(\"Error fetching gallery images\", {\n      galleryId: req.params.galleryId,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to fetch gallery images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/controllers/library/galleries.ts\ngit commit -m \"refactor: GalleryDetail images to use local database\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-14-add-images-tab-to-entity-detail-pages","title":"Task 14: Add Images Tab to Entity Detail Pages","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code></p> <p>Step 1: Check existing tab implementation</p> <p>Look at how Galleries tab is implemented on these pages.</p> <p>Step 2: Add Images tab</p> <p>Follow the same pattern - add \"Images\" to the tabs array and render an images grid when that tab is selected, using the same <code>findImages</code> API with the appropriate entity filter.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx client/src/components/pages/StudioDetail.jsx client/src/components/pages/TagDetail.jsx\ngit commit -m \"feat: add Images tab to entity detail pages\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-15-test-and-verify","title":"Task 15: Test and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass.</p> <p>Step 2: Run client build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Expected: Build succeeds with no errors.</p> <p>Step 3: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint &amp;&amp; cd ../client &amp;&amp; npm run lint</code></p> <p>Expected: No linting errors.</p> <p>Step 4: Manual testing</p> <ol> <li>Start the server and client</li> <li>Navigate to Images page</li> <li>Verify images load</li> <li>Test filters (performers, tags, studios, galleries)</li> <li>Test sorting options</li> <li>Click an image to verify lightbox opens</li> <li>Navigate to Performer/Studio/Tag detail pages</li> <li>Verify Images tab appears and works</li> </ol> <p>Step 5: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup and testing\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#summary","title":"Summary","text":"<p>This plan implements the Images page feature in 15 tasks:</p> <ol> <li>Database migration for new fields</li> <li>Sync service update for images</li> <li>Sync service update for galleries</li> <li>Image proxy endpoint</li> <li>Images controller refactor</li> <li>StashEntityService image methods</li> <li>Image routes</li> <li>Navigation item</li> <li>Images page component</li> <li>ImageCard component</li> <li>App route</li> <li>Lightbox integration</li> <li>GalleryDetail refactor</li> <li>Entity detail page tabs</li> <li>Testing and verification</li> </ol> <p>Each task is a small, focused change that can be completed and committed independently.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/","title":"Content Exclusion Limit Fix","text":"<p>Issue: #200 (Part 2) - Tag exclusions capped at 500 items Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#problem","title":"Problem","text":"<p>Content restriction exclusions configured in user settings are being truncated to 500 items. Users with extensive tag exclusions see excluded content appearing when browsing.</p> <p>User logs show: <pre><code>\"computed 1531 exclusions in 9ms\"\n\"Exclusion set truncated to 500 items\"\n\"originalSize\": 1531\n</code></pre></p> <p>This defeats the purpose of content restrictions for users with many exclusions.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In <code>SceneQueryBuilder.buildExclusionFilter()</code>, there's a hardcoded limit:</p> <pre><code>// SceneQueryBuilder.ts:96-114\nprivate buildExclusionFilter(excludedIds: Set&lt;string&gt;): FilterClause {\n  const ids = Array.from(excludedIds);\n\n  if (ids.length &lt;= 500) {\n    // Direct IN clause for smaller sets\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n    return {\n      sql: `s.id NOT IN (${placeholders})`,\n      params: ids,\n    };\n  }\n\n  // For larger sets - TRUNCATES to 500!\n  const placeholders = ids.slice(0, 500).map(() =&gt; \"?\").join(\", \");\n  logger.warn(\"Exclusion set truncated to 500 items\", {\n    originalSize: ids.length,\n  });\n  return {\n    sql: `s.id NOT IN (${placeholders})`,\n    params: ids.slice(0, 500),\n  };\n}\n</code></pre> <p>The comment mentions \"consider pre-computing a materialized view\" but no alternative is implemented.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#solution-options","title":"Solution Options","text":""},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-a-chunked-not-in-clauses-recommended","title":"Option A: Chunked NOT IN Clauses (Recommended)","text":"<p>Split the exclusion set into chunks and combine with AND:</p> <pre><code>WHERE s.id NOT IN (chunk1) AND s.id NOT IN (chunk2) AND ...\n</code></pre> <p>SQLite handles each chunk efficiently, and combining with AND maintains correct semantics.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-b-temp-table-with-left-join","title":"Option B: Temp Table with LEFT JOIN","text":"<p>Create a temporary table with excluded IDs and use a LEFT JOIN:</p> <pre><code>CREATE TEMP TABLE excluded_scenes (id TEXT);\nINSERT INTO excluded_scenes VALUES (...);\n\nSELECT ... FROM StashScene s\nLEFT JOIN excluded_scenes e ON s.id = e.id\nWHERE e.id IS NULL;\n</code></pre> <p>Trade-off: Adds complexity with temp table lifecycle management.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-c-subquery-with-values","title":"Option C: Subquery with VALUES","text":"<p>Use a subquery with inline VALUES:</p> <pre><code>WHERE s.id NOT IN (SELECT id FROM (VALUES ('id1'), ('id2'), ...))\n</code></pre> <p>Trade-off: SQLite VALUES syntax has limits and this may not work well with very large sets.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#design-decision","title":"Design Decision","text":"<p>Use Option A - Chunked NOT IN clauses.</p> <p>Rationale: - Simple to implement - No temp table management - SQLite handles multiple NOT IN clauses efficiently - Easy to understand and debug - Chunk size of 500 is safe for SQLite parameter limits</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#1-update-buildexclusionfilter-method","title":"1. Update buildExclusionFilter method","text":"<pre><code>private buildExclusionFilter(excludedIds: Set&lt;string&gt;): FilterClause {\n  if (!excludedIds || excludedIds.size === 0) {\n    return { sql: \"\", params: [] };\n  }\n\n  const ids = Array.from(excludedIds);\n  const CHUNK_SIZE = 500;\n\n  if (ids.length &lt;= CHUNK_SIZE) {\n    // Single IN clause for small sets\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n    return {\n      sql: `s.id NOT IN (${placeholders})`,\n      params: ids,\n    };\n  }\n\n  // Chunk large sets into multiple NOT IN clauses\n  const clauses: string[] = [];\n  const allParams: string[] = [];\n\n  for (let i = 0; i &lt; ids.length; i += CHUNK_SIZE) {\n    const chunk = ids.slice(i, i + CHUNK_SIZE);\n    const placeholders = chunk.map(() =&gt; \"?\").join(\", \");\n    clauses.push(`s.id NOT IN (${placeholders})`);\n    allParams.push(...chunk);\n  }\n\n  logger.debug(\"Large exclusion set chunked\", {\n    totalSize: ids.length,\n    chunks: clauses.length,\n  });\n\n  return {\n    sql: `(${clauses.join(\" AND \")})`,\n    params: allParams,\n  };\n}\n</code></pre>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#2-add-integration-test","title":"2. Add integration test","text":"<p>Add a test case that verifies exclusion works with &gt;500 items:</p> <pre><code>it(\"should handle large exclusion sets (&gt;500 items)\", async () =&gt; {\n  // Create 600 excluded scene IDs\n  const excludedIds = new Set(\n    Array.from({ length: 600 }, (_, i) =&gt; `excluded-${i}`)\n  );\n\n  const result = await sceneQueryBuilder.execute({\n    userId: 1,\n    excludedSceneIds: excludedIds,\n    sort: \"created_at\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n  });\n\n  // Verify none of the excluded IDs appear in results\n  for (const scene of result.scenes) {\n    expect(excludedIds.has(scene.id)).toBe(false);\n  }\n});\n</code></pre>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>server/services/SceneQueryBuilder.ts</code></li> <li>Update <code>buildExclusionFilter()</code> method</li> <li><code>server/tests/services/SceneQueryBuilder.integration.test.ts</code></li> <li>Add test for large exclusion sets</li> </ul>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Each chunk adds an AND clause, but SQLite query optimizer handles this efficiently</li> <li>Log at debug level to avoid spam in production</li> <li>Consider adding metrics to track exclusion set sizes in production</li> </ul>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#testing","title":"Testing","text":"<ol> <li>Create user with &gt;500 tag exclusions</li> <li>Browse scenes and verify excluded content does not appear</li> <li>Check logs for \"Large exclusion set chunked\" debug message</li> <li>Verify query performance is acceptable (should be similar to current)</li> </ol>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert to the original truncation behavior. The only risk is performance degradation with very large exclusion sets.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/","title":"Incremental Sync Per-Entity Timestamp Fix","text":"<p>Issue: #200 (Part 1) - Full performer sync on every incremental sync Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#problem","title":"Problem","text":"<p>Every scheduled incremental sync performs a complete resync of all performers (1,947 entities taking 10+ minutes), even when no performers have changed. The user's logs show the sync timestamp remains unchanged across multiple sync cycles:</p> <pre><code>\"since\":\"2025-12-17T08:18:12.430Z\" (unchanged across all syncs)\nPerformers synced: 1,947 consistently\nDuration: 663-996 seconds per sync\n</code></pre> <p>The application becomes unavailable for ~10 minutes during each hourly sync.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In <code>StashSyncService.incrementalSync()</code>, the code retrieves the last sync timestamp using <code>getLastSyncTime()</code>:</p> <pre><code>// StashSyncService.ts:405\nconst lastSync = await this.getLastSyncTime(stashInstanceId);\n</code></pre> <p>This method only queries the scene entity type's timestamp:</p> <pre><code>// StashSyncService.ts:2158-2167\nprivate async getLastSyncTime(stashInstanceId?: string): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: {\n      stashInstanceId: stashInstanceId || null,\n      entityType: \"scene\", // &lt;-- Only looks at scene!\n    },\n  });\n  return syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n}\n</code></pre> <p>This same timestamp is then used for ALL entity types (performers, tags, studios, etc.):</p> <pre><code>// StashSyncService.ts:429\nresult = await this.syncPerformers(stashInstanceId, false, lastSync);\n</code></pre> <p>The database schema stores per-entity-type timestamps (<code>SyncState.entityType</code>), but <code>incrementalSync()</code> ignores them.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#solution","title":"Solution","text":"<p>Replace <code>incrementalSync()</code> with per-entity timestamp logic, similar to what <code>smartIncrementalSync()</code> already does correctly.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#option-a-refactor-incrementalsync-to-use-per-entity-timestamps-recommended","title":"Option A: Refactor incrementalSync to Use Per-Entity Timestamps (Recommended)","text":"<p>Modify <code>incrementalSync()</code> to: 1. Loop through each entity type 2. Get that entity type's specific last sync timestamp using <code>getEntitySyncState()</code> 3. Only sync entities changed since that timestamp</p> <p>This matches how <code>smartIncrementalSync()</code> works but without the change count check.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#option-b-replace-incrementalsync-with-smartincrementalsync","title":"Option B: Replace incrementalSync with smartIncrementalSync","text":"<p>Change the scheduler to call <code>smartIncrementalSync()</code> instead of <code>incrementalSync()</code>.</p> <p>Trade-off: <code>smartIncrementalSync</code> does an extra API call per entity type to check change counts before syncing. This adds latency but can skip entity types with zero changes entirely.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#design-decision","title":"Design Decision","text":"<p>Use Option A - Refactor <code>incrementalSync()</code> to use per-entity timestamps.</p> <p>Rationale: - Maintains separation between \"smart\" sync (checks change counts, used on startup) and regular incremental sync (used on schedule) - Avoids extra API calls on every scheduled sync - Fixes the core bug without changing sync behavior</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-incremental-sync-fix-design/#1-refactor-incrementalsync-method","title":"1. Refactor incrementalSync method","text":"<p>Replace the single <code>getLastSyncTime()</code> call with per-entity lookups:</p> <pre><code>async incrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n  // ... existing setup code ...\n\n  const entityTypes: EntityType[] = [\n    \"tag\", \"studio\", \"performer\", \"group\", \"gallery\", \"scene\", \"image\",\n  ];\n\n  for (const entityType of entityTypes) {\n    this.checkAbort();\n\n    // Get THIS entity type's last sync timestamp\n    const syncState = await this.getEntitySyncState(stashInstanceId, entityType);\n    const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n    if (!lastSync) {\n      // Never synced - do full sync for this entity type\n      const result = await this.syncEntityType(entityType, stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n    } else {\n      // Incremental sync using this entity's timestamp\n      const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"incremental\", result);\n    }\n  }\n\n  // ... rest of method ...\n}\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#2-remove-getlastsynctime-method","title":"2. Remove getLastSyncTime method","text":"<p>This method is no longer needed after the refactor. Remove it to prevent future misuse.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#3-add-logging-for-visibility","title":"3. Add logging for visibility","text":"<p>Log which timestamp is being used for each entity type:</p> <pre><code>logger.info(`${entityType}: syncing changes since ${lastSync.toISOString()}`);\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>server/services/StashSyncService.ts</code></li> <li>Refactor <code>incrementalSync()</code> method</li> <li>Remove <code>getLastSyncTime()</code> method</li> </ul>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#testing","title":"Testing","text":"<ol> <li>Run a full sync to establish baseline timestamps</li> <li>Wait for scheduled incremental sync</li> <li>Verify logs show different timestamps per entity type</li> <li>Verify performer sync only fetches changed performers (count should be 0 or minimal if nothing changed)</li> <li>Verify total sync time is greatly reduced when no changes exist</li> </ol>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert the <code>incrementalSync()</code> changes. The <code>smartIncrementalSync()</code> method remains unchanged as a fallback.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/","title":"Incremental Sync Per-Entity Timestamp Fix - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix incremental sync to use per-entity timestamps instead of a single scene timestamp, preventing unnecessary full syncs of unchanged entities.</p> <p>Architecture: Refactor <code>incrementalSync()</code> to loop through entity types and look up each entity's own last sync timestamp via <code>getEntitySyncState()</code>. Remove the broken <code>getLastSyncTime()</code> method that only queries scenes.</p> <p>Tech Stack: TypeScript, Prisma, Node.js</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-1-add-unit-test-for-per-entity-timestamp-logic","title":"Task 1: Add Unit Test for Per-Entity Timestamp Logic","text":"<p>Files: - Create: <code>server/services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Step 1: Create the test file with per-entity timestamp test</p> <pre><code>/**\n * Unit Tests for StashSyncService\n *\n * Tests the incremental sync logic without requiring a real Stash instance.\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from \"vitest\";\n\n// Mock prisma before importing the service\nconst mockPrisma = {\n  syncState: {\n    findFirst: vi.fn(),\n    findMany: vi.fn(),\n    update: vi.fn(),\n    create: vi.fn(),\n  },\n  syncSettings: {\n    findFirst: vi.fn(),\n  },\n  $executeRawUnsafe: vi.fn(),\n};\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: mockPrisma,\n}));\n\n// Mock the stash instance manager\nvi.mock(\"../StashInstanceManager.js\", () =&gt; ({\n  stashInstanceManager: {\n    getDefault: vi.fn(() =&gt; ({\n      findTags: vi.fn().mockResolvedValue({ findTags: { tags: [], count: 0 } }),\n      findStudios: vi.fn().mockResolvedValue({ findStudios: { studios: [], count: 0 } }),\n      findPerformers: vi.fn().mockResolvedValue({ findPerformers: { performers: [], count: 0 } }),\n      findGroups: vi.fn().mockResolvedValue({ findGroups: { groups: [], count: 0 } }),\n      findGalleries: vi.fn().mockResolvedValue({ findGalleries: { galleries: [], count: 0 } }),\n      findScenesCompact: vi.fn().mockResolvedValue({ findScenes: { scenes: [], count: 0 } }),\n      findImages: vi.fn().mockResolvedValue({ findImages: { images: [], count: 0 } }),\n    })),\n    hasInstances: vi.fn(() =&gt; true),\n  },\n}));\n\n// Mock user stats service\nvi.mock(\"../UserStatsService.js\", () =&gt; ({\n  userStatsService: {\n    rebuildAllStats: vi.fn().mockResolvedValue(undefined),\n  },\n}));\n\ndescribe(\"StashSyncService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"incrementalSync\", () =&gt; {\n    it(\"should use per-entity timestamps, not a single global timestamp\", async () =&gt; {\n      // Import after mocks are set up\n      const { stashSyncService } = await import(\"../StashSyncService.js\");\n\n      // Set up different timestamps for different entity types\n      const tagTimestamp = new Date(\"2025-12-20T10:00:00Z\");\n      const performerTimestamp = new Date(\"2025-12-22T15:00:00Z\");\n      const sceneTimestamp = new Date(\"2025-12-25T08:00:00Z\");\n\n      mockPrisma.syncState.findFirst.mockImplementation(({ where }) =&gt; {\n        if (where.entityType === \"tag\") {\n          return Promise.resolve({ lastIncrementalSync: tagTimestamp, lastFullSync: null });\n        }\n        if (where.entityType === \"performer\") {\n          return Promise.resolve({ lastIncrementalSync: performerTimestamp, lastFullSync: null });\n        }\n        if (where.entityType === \"scene\") {\n          return Promise.resolve({ lastIncrementalSync: sceneTimestamp, lastFullSync: null });\n        }\n        // Return timestamps for other entity types\n        return Promise.resolve({ lastIncrementalSync: new Date(\"2025-12-24T12:00:00Z\"), lastFullSync: null });\n      });\n\n      // Run incremental sync\n      await stashSyncService.incrementalSync();\n\n      // Verify that findFirst was called for each entity type (not just scene)\n      const findFirstCalls = mockPrisma.syncState.findFirst.mock.calls;\n\n      // Should have calls for: tag, studio, performer, group, gallery, scene, image\n      const entityTypesQueried = findFirstCalls.map((call) =&gt; call[0]?.where?.entityType);\n\n      expect(entityTypesQueried).toContain(\"tag\");\n      expect(entityTypesQueried).toContain(\"performer\");\n      expect(entityTypesQueried).toContain(\"scene\");\n      expect(entityTypesQueried).toContain(\"studio\");\n      expect(entityTypesQueried).toContain(\"group\");\n      expect(entityTypesQueried).toContain(\"gallery\");\n      expect(entityTypesQueried).toContain(\"image\");\n    });\n\n    it(\"should perform full sync for entity types that have never been synced\", async () =&gt; {\n      const { stashSyncService } = await import(\"../StashSyncService.js\");\n\n      // Tags have been synced, but performers have not\n      mockPrisma.syncState.findFirst.mockImplementation(({ where }) =&gt; {\n        if (where.entityType === \"tag\") {\n          return Promise.resolve({\n            lastIncrementalSync: new Date(\"2025-12-20T10:00:00Z\"),\n            lastFullSync: null,\n          });\n        }\n        // No sync state for other entities\n        return Promise.resolve(null);\n      });\n\n      await stashSyncService.incrementalSync();\n\n      // Verify sync state was created/updated for entities\n      expect(mockPrisma.syncState.findFirst).toHaveBeenCalled();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run the test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Expected: FAIL - The current implementation only queries \"scene\" entity type, so the test expecting per-entity queries will fail.</p> <p>Step 3: Commit the failing test</p> <pre><code>git add server/services/__tests__/StashSyncService.unit.test.ts\ngit commit -m \"test: add failing test for per-entity sync timestamps\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-2-refactor-incrementalsync-to-use-per-entity-timestamps","title":"Task 2: Refactor incrementalSync to Use Per-Entity Timestamps","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:393-480</code></p> <p>Step 1: Replace the incrementalSync method</p> <p>Find the <code>incrementalSync</code> method (around line 393) and replace it entirely with:</p> <pre><code>  /**\n   * Incremental sync - fetches only changed entities\n   * Uses per-entity-type timestamps so each entity type syncs from its own last sync time\n   */\n  async incrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n    if (this.syncInProgress) {\n      logger.warn(\"Sync already in progress, skipping\");\n      return [];\n    }\n\n    this.syncInProgress = true;\n    this.abortController = new AbortController();\n    const startTime = Date.now();\n    const results: SyncResult[] = [];\n\n    try {\n      logger.info(\"Starting incremental sync with per-entity timestamps...\");\n\n      // Entity types in dependency order (tags first since others reference them)\n      const entityTypes: EntityType[] = [\n        \"tag\",\n        \"studio\",\n        \"performer\",\n        \"group\",\n        \"gallery\",\n        \"scene\",\n        \"image\",\n      ];\n\n      for (const entityType of entityTypes) {\n        this.checkAbort();\n\n        // Get THIS entity type's last sync timestamp\n        const syncState = await this.getEntitySyncState(stashInstanceId, entityType);\n        const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n        if (!lastSync) {\n          // Never synced - do full sync for this entity type only\n          logger.info(`${entityType}: No previous sync, syncing all`);\n          const result = await this.syncEntityType(entityType, stashInstanceId, true);\n          results.push(result);\n          await this.saveSyncState(stashInstanceId, \"full\", result);\n        } else {\n          // Incremental sync using this entity's own timestamp\n          logger.info(`${entityType}: syncing changes since ${lastSync.toISOString()}`);\n          const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n          results.push(result);\n          await this.saveSyncState(stashInstanceId, \"incremental\", result);\n        }\n      }\n\n      // Rebuild user stats to reflect current entity relationships\n      logger.info(\"Rebuilding user stats after sync...\");\n      await userStatsService.rebuildAllStats();\n      logger.info(\"User stats rebuild complete\");\n\n      const duration = Date.now() - startTime;\n      logger.info(\"Incremental sync completed\", {\n        durationMs: duration,\n        results: results.map((r) =&gt; ({ type: r.entityType, synced: r.synced })),\n      });\n\n      return results;\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n\n      if (errorMsg === \"Sync aborted\") {\n        logger.info(\"Incremental sync aborted by user\");\n      } else {\n        logger.error(\"Incremental sync failed\", { error: errorMsg });\n      }\n\n      throw error;\n    } finally {\n      this.syncInProgress = false;\n      this.abortController = null;\n    }\n  }\n</code></pre> <p>Step 2: Run the unit test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Expected: PASS - The refactored method now queries per-entity timestamps.</p> <p>Step 3: Commit the refactored method</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"fix: use per-entity timestamps in incrementalSync\n\nPreviously, incrementalSync used a single timestamp from the scene\nentity type for all entities. This caused full re-syncs of performers,\ntags, etc. even when they hadn't changed.\n\nNow each entity type uses its own lastFullSync/lastIncrementalSync\ntimestamp, matching how smartIncrementalSync already works.\n\nFixes #200 (Part 1)\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-3-remove-obsolete-getlastsynctime-method","title":"Task 3: Remove Obsolete getLastSyncTime Method","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:2158-2167</code></p> <p>Step 1: Find and remove the getLastSyncTime method</p> <p>Locate the <code>getLastSyncTime</code> method (around line 2158) and delete it entirely:</p> <pre><code>// DELETE THIS ENTIRE METHOD:\nprivate async getLastSyncTime(stashInstanceId?: string): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: {\n      stashInstanceId: stashInstanceId || null,\n      entityType: \"scene\", // Use scene as the reference entity type\n    },\n  });\n\n  return syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n}\n</code></pre> <p>Step 2: Verify no other code references this method</p> <p>Run: <code>cd server &amp;&amp; grep -r \"getLastSyncTime\" --include=\"*.ts\" .</code></p> <p>Expected: No matches (the only caller was in <code>incrementalSync</code> which we refactored).</p> <p>Step 3: Run all sync-related tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService</code></p> <p>Expected: All tests pass.</p> <p>Step 4: Commit the removal</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"refactor: remove obsolete getLastSyncTime method\n\nThis method was the root cause of the bug - it only queried the scene\nentity type's timestamp, ignoring per-entity timestamps. With the\nincrementalSync refactor, it's no longer needed.\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-4-run-linting-and-full-test-suite","title":"Task 4: Run Linting and Full Test Suite","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors.</p> <p>Step 2: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass.</p> <p>Step 3: Fix any issues and commit if needed</p> <p>If there are any lint or test failures, fix them and commit:</p> <pre><code>git add -A\ngit commit -m \"fix: address lint/test issues from sync refactor\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-5-manual-verification-optional-requires-running-server","title":"Task 5: Manual Verification (Optional - Requires Running Server)","text":"<p>Files: - None (manual testing)</p> <p>Step 1: Start the server</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code></p> <p>Step 2: Trigger a sync and check logs</p> <p>Look for log messages like: <pre><code>tag: syncing changes since 2025-12-25T10:00:00.000Z\nstudio: syncing changes since 2025-12-25T10:00:00.000Z\nperformer: syncing changes since 2025-12-25T10:00:00.000Z\n</code></pre></p> <p>Each entity type should show its OWN timestamp, not the same timestamp for all.</p> <p>Step 3: Verify sync counts are minimal</p> <p>If nothing has changed in Stash, each entity type should sync 0 items: <pre><code>Performers synced: 0 in 0.5s\nTags synced: 0 in 0.3s\n</code></pre></p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li><code>incrementalSync()</code> now uses per-entity timestamps via <code>getEntitySyncState()</code></li> <li>The broken <code>getLastSyncTime()</code> method is removed</li> <li>Each entity type logs which timestamp it's using for visibility</li> <li>Entity types with no previous sync get a full sync for that type only</li> <li>Scheduled syncs should complete in seconds instead of 10+ minutes when nothing has changed</li> </ol>"},{"location":"plans/2025-12-26-random-sort-fix-design/","title":"Random Sort Randomization Fix","text":"<p>Issue: #200 (Part 3) - Random sort not actually random Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#problem","title":"Problem","text":"<p>Despite configuring \"Random\" as the default sort order, scenes display in identical order on repeated visits. The \"random\" order is deterministic per user, producing the same results every time.</p> <p>User reports:</p> <p>\"Identical query logs with identical 'sort':'random' parameter produce consistent results across separate calls\"</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In the scenes controller, the random seed is set to just the user ID:</p> <pre><code>// scenes.ts:906\nrandomSeed: userId, // Stable random per user\n</code></pre> <p>This makes the random order deterministic - the same user always sees the same \"random\" order because the seed never changes.</p> <p>The carousel controller does this correctly:</p> <pre><code>// carousel.ts:327\nrandomSeed: sort === 'random' ? userId + Date.now() : userId,\n</code></pre> <p>By adding <code>Date.now()</code>, carousels get different random orders on each request.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#design-considerations","title":"Design Considerations","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#the-pagination-problem","title":"The Pagination Problem","text":"<p>True randomness on every request breaks pagination. If the order changes between page 1 and page 2 requests, users would see duplicate or missing items.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#session-based-randomness","title":"Session-Based Randomness","text":"<p>The solution is to make randomness stable within a browsing session but different across sessions: - Same session = same random order (pagination works) - New session = new random order (users see variety)</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#what-defines-a-session","title":"What Defines a \"Session\"?","text":"<p>Options: 1. Time-based window - Seed changes every N minutes 2. Client-provided seed - Client sends a seed that persists during browsing 3. Request parameter - Client explicitly requests \"reshuffle\"</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#design-decision","title":"Design Decision","text":"<p>Use client-provided session seed with automatic refresh</p> <p>The client will: 1. Generate a random seed on page load (stored in component state or URL) 2. Pass this seed with all scene requests 3. Generate a new seed when user explicitly clicks \"Shuffle\" or revisits the page</p> <p>This gives users control while maintaining pagination stability.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#1-add-randomseed-query-parameter-to-api","title":"1. Add randomSeed query parameter to API","text":"<p>Update the scenes endpoint to accept an optional <code>randomSeed</code> parameter:</p> <pre><code>// scenes.ts - in findScenes handler\nconst randomSeed = req.query.randomSeed\n  ? parseInt(String(req.query.randomSeed), 10)\n  : undefined;\n\n// When building query options\nrandomSeed: sortField === 'random'\n  ? (randomSeed ?? userId + Date.now())  // Use provided seed or generate new\n  : userId,\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#2-update-scenequerybuilder-for-better-randomization","title":"2. Update SceneQueryBuilder for better randomization","text":"<p>The current random formula is: <pre><code>((CAST(substr(s.id, 1, 8) AS INTEGER) * 1103515245 + ${randomSeed}) % 2147483647)\n</code></pre></p> <p>This assumes scene IDs are numeric strings. If IDs are UUIDs or alphanumeric, the CAST may fail or produce collisions.</p> <p>Improve with a hash-based approach: <pre><code>// Use a simple string hash of the full ID\n((CAST(\n  (unicode(substr(s.id, 1, 1)) * 31 +\n   unicode(substr(s.id, 2, 1)) * 17 +\n   unicode(substr(s.id, 3, 1)) * 13 +\n   unicode(substr(s.id, 4, 1)) * 7 +\n   unicode(substr(s.id, 5, 1))) AS INTEGER\n) * 1103515245 + ${randomSeed}) % 2147483647)\n</code></pre></p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#3-client-side-generate-and-persist-random-seed","title":"3. Client-side: Generate and persist random seed","text":"<p>In the scenes browse component:</p> <pre><code>// Generate seed on mount or when user requests shuffle\nconst [randomSeed, setRandomSeed] = useState(() =&gt;\n  Math.floor(Math.random() * 2147483647)\n);\n\n// Pass to API\nconst fetchScenes = async (page: number) =&gt; {\n  const params = new URLSearchParams({\n    sort: 'random',\n    randomSeed: String(randomSeed),\n    page: String(page),\n  });\n  // ...\n};\n\n// Shuffle button handler\nconst handleShuffle = () =&gt; {\n  setRandomSeed(Math.floor(Math.random() * 2147483647));\n  // Refetch will happen via useEffect dependency\n};\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#4-optional-add-shuffle-button-to-ui","title":"4. Optional: Add Shuffle button to UI","text":"<p>Add a shuffle button when random sort is active:</p> <pre><code>{sort === 'random' &amp;&amp; (\n  &lt;Button onClick={handleShuffle} variant=\"ghost\" size=\"sm\"&gt;\n    &lt;ShuffleIcon className=\"w-4 h-4 mr-1\" /&gt;\n    Shuffle\n  &lt;/Button&gt;\n)}\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#server","title":"Server","text":"<ul> <li><code>server/controllers/library/scenes.ts</code></li> <li>Accept <code>randomSeed</code> query parameter</li> <li>Use provided seed or generate time-based default</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-design/#client","title":"Client","text":"<ul> <li><code>client/src/components/pages/ScenesBrowse.jsx</code> (or equivalent)</li> <li>Generate random seed on mount</li> <li>Pass seed to API calls</li> <li>Add optional Shuffle button</li> <li><code>client/src/hooks/useScenes.ts</code> (if exists)</li> <li>Pass randomSeed parameter through</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-design/#alternative-minimal-fix-server-only","title":"Alternative: Minimal Fix (Server-Only)","text":"<p>If client changes are not desired, a simpler server-only fix:</p> <pre><code>// scenes.ts:906\nrandomSeed: sortField === 'random'\n  ? userId + Math.floor(Date.now() / (5 * 60 * 1000))  // Changes every 5 minutes\n  : userId,\n</code></pre> <p>This gives new random orders every 5 minutes while maintaining pagination stability within that window.</p> <p>Trade-off: Users can't control when to shuffle, and pagination may break at the 5-minute boundary.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#testing","title":"Testing","text":"<ol> <li>Browse scenes with random sort</li> <li>Navigate to page 2, verify no duplicates from page 1</li> <li>Refresh the page or wait for seed timeout</li> <li>Verify order has changed from previous session</li> <li>If Shuffle button implemented, verify it triggers re-randomization</li> </ol>"},{"location":"plans/2025-12-26-random-sort-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert to the stable <code>userId</code> seed. Users will have deterministic \"random\" order, which is the current behavior.</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/","title":"Random Sort Randomization Fix - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix random sort so users see different random orders on each page visit while maintaining pagination stability within a session, following Stash's proven implementation pattern.</p> <p>Architecture: Client generates an 8-digit random seed when sort changes to \"random\", embeds it in the sort parameter as <code>random_&lt;seed&gt;</code>. Server parses the seed and uses it for deterministic ordering. Same seed = same order across pagination and direction toggles.</p> <p>Tech Stack: React (client), Express/TypeScript (server), SQLite (database)</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#summary","title":"Summary","text":"<p>The current implementation uses <code>randomSeed: userId</code> which produces identical \"random\" orders every time. Stash solves this elegantly by embedding the seed in the sort parameter itself (<code>random_12345678</code>). This plan follows their proven pattern.</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#stashs-approach-reference","title":"Stash's Approach (Reference)","text":"<p>From <code>~/code/stash</code>: - Client: <code>filter.ts</code> - generates seed as <code>Math.floor(Math.random() * 10 ** 8)</code> - API format: Sort parameter is <code>\"random_12345678\"</code> instead of just <code>\"random\"</code> - Server: <code>sql.go</code> - parses seed from sort string, uses formula for deterministic order - Direction toggle: Same seed, just ASC/DESC changes - reversed order of same results - Reshuffle: Reset seed to -1, regenerate on next query</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#server","title":"Server","text":"<ul> <li><code>server/controllers/library/scenes.ts</code> - Parse <code>random_&lt;seed&gt;</code> from sort parameter</li> <li><code>server/services/SceneQueryBuilder.ts</code> - Update buildSortClause to accept seed separately</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#client","title":"Client","text":"<ul> <li><code>client/src/components/ui/SearchControls.jsx</code> - Generate seed, embed in sort parameter</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#tests","title":"Tests","text":"<ul> <li><code>server/tests/services/SceneQueryBuilder.integration.test.ts</code> - Test different seeds</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-1-update-server-to-parse-random_-format","title":"Task 1: Update Server to Parse random_ Format <p>Files: - Modify: <code>server/controllers/library/scenes.ts:860-920</code></p> <p>Step 1: Read the current implementation</p> <p>Review lines 860-920 to understand current sort handling.</p> <p>Step 2: Add seed parsing logic</p> <p>Before calling sceneQueryBuilder, parse the sort parameter:</p> <pre><code>// Around line 875, after extracting sortField\nlet randomSeed: number | undefined;\nlet actualSortField = sortField;\n\n// Parse random_&lt;seed&gt; format (e.g., \"random_12345678\")\nif (sortField.startsWith('random_')) {\n  const seedStr = sortField.slice(7); // Remove \"random_\" prefix\n  const parsedSeed = parseInt(seedStr, 10);\n  if (!isNaN(parsedSeed)) {\n    randomSeed = parsedSeed % 1e8; // Cap at 10^8 like Stash does\n    actualSortField = 'random';\n  }\n} else if (sortField === 'random') {\n  // Plain \"random\" without seed - generate time-based seed\n  randomSeed = (userId + Date.now()) % 1e8;\n}\n\n// Then use actualSortField and randomSeed in the query\n</code></pre> <p>Step 3: Update the sceneQueryBuilder.execute call</p> <pre><code>const result = await sceneQueryBuilder.execute({\n  userId,\n  filters,\n  excludedSceneIds: excludedIds,\n  sort: actualSortField,  // Use \"random\" not \"random_12345\"\n  sortDirection: sortDirection.toUpperCase() as \"ASC\" | \"DESC\",\n  page,\n  perPage,\n  randomSeed: actualSortField === 'random' ? randomSeed : userId,\n});\n</code></pre> <p>Step 4: Build and verify</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: TypeScript compiles successfully</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: parse random_&lt;seed&gt; format from sort parameter\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-2-update-scenequerybuilder-random-formula","title":"Task 2: Update SceneQueryBuilder Random Formula <p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts:1100-1102</code></p> <p>Step 1: Read current random sort implementation</p> <p>The current formula at line 1101: <pre><code>random: `((CAST(substr(s.id, 1, 8) AS INTEGER) * 1103515245 + ${randomSeed || 12345}) % 2147483647) ${dir}`,\n</code></pre></p> <p>Step 2: Update to match Stash's formula</p> <p>Stash uses a more robust formula that handles string IDs better: <pre><code>// Stash formula: ((id+seed)*(id+seed)*52959209 + (id+seed)*1047483763) % 2147483647\nrandom: `(((CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * (CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * 52959209 + (CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * 1047483763) % 2147483647) ${dir}`,\n</code></pre></p> <p>This formula: - Adds seed to ID first (better distribution) - Uses multiplication for better randomization - Matches Stash's proven algorithm</p> <p>Step 3: Build and verify</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: TypeScript compiles successfully</p> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"refactor: use Stash's random sort formula for better distribution\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-3-generate-and-embed-seed-in-client-searchcontrols","title":"Task 3: Generate and Embed Seed in Client SearchControls <p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Add randomSeed state</p> <p>Near the top of the component, after other useState declarations (around line 98):</p> <pre><code>// Random seed for stable pagination when sorting by random\n// -1 means uninitialized, will be generated when needed\nconst [randomSeed, setRandomSeed] = useState(-1);\n</code></pre> <p>Step 2: Create helper to get sort with seed</p> <p>Add a helper function inside the component:</p> <pre><code>// Get sort value, embedding random seed when needed\nconst getSortWithSeed = useCallback((sort) =&gt; {\n  if (sort === 'random') {\n    let seed = randomSeed;\n    if (seed === -1) {\n      // Generate new 8-digit seed\n      seed = Math.floor(Math.random() * 1e8);\n      setRandomSeed(seed);\n    }\n    return `random_${seed}`;\n  }\n  return sort;\n}, [randomSeed]);\n</code></pre> <p>Step 3: Update handleSortChange to reset seed on sort type change</p> <p>Modify handleSortChange (around line 618):</p> <pre><code>const handleSortChange = (field) =&gt; {\n  let newSortDirection = \"DESC\";\n  let newSortField = sortField;\n\n  // If same field, toggle direction (keep same seed for random)\n  if (field === sortField) {\n    newSortDirection = sortDirection === \"ASC\" ? \"DESC\" : \"ASC\";\n  } else {\n    // New field, default to DESC\n    newSortField = field;\n\n    // Reset random seed when changing TO or FROM random sort\n    if (field === 'random' || sortField === 'random') {\n      setRandomSeed(-1);\n    }\n  }\n  setSort([newSortField, newSortDirection]);\n\n  // Build query with seed-embedded sort\n  const query = {\n    filter: {\n      direction: newSortDirection,\n      page: currentPage,\n      per_page: perPage,\n      q: searchText,\n      sort: getSortWithSeed(newSortField),\n    },\n    ...buildFilter(artifactType, filters, unitPreference),\n  };\n\n  onQueryChange(query);\n};\n</code></pre> <p>Step 4: Update all query building to use getSortWithSeed</p> <p>There are multiple places where queries are built. Each needs to use <code>getSortWithSeed(sortField)</code> instead of just <code>sortField</code>:</p> <ol> <li><code>initializeState()</code> - line ~342</li> <li><code>clearFilters()</code> - line ~408</li> <li><code>handleFilterSubmit()</code> - line ~436</li> <li><code>handleRemoveFilter()</code> - line ~464</li> <li><code>handleLoadPreset()</code> - line ~538</li> <li><code>handlePageChange()</code> - line ~561</li> <li><code>handleChangeSearchText()</code> - line ~604</li> <li><code>handleSortChange()</code> - line ~633 (already done above)</li> <li><code>handlePerPageChange()</code> - line ~656</li> </ol> <p>For each, change: <pre><code>sort: sortField,\n</code></pre> to: <pre><code>sort: getSortWithSeed(sortField),\n</code></pre></p> <p>Step 5: Handle preset loading - reset seed</p> <p>In handleLoadPreset (around line 531), reset the seed when loading a preset:</p> <pre><code>const handleLoadPreset = useCallback(\n  (preset) =&gt; {\n    setCurrentPage(1);\n    setFilters({ ...permanentFilters, ...preset.filters });\n    setSort([preset.sort, preset.direction]);\n\n    // Reset random seed when loading preset (like Stash does)\n    setRandomSeed(-1);\n\n    // ... rest of function\n  },\n  [/* deps */]\n);\n</code></pre> <p>Step 6: Test locally</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code> Test: - Navigate to scenes, select random sort - Check network tab - sort should be <code>random_XXXXXXXX</code> - Navigate pages - same seed used - Toggle direction - same seed, just direction changes - Change to different sort, then back to random - new seed</p> <p>Step 7: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: embed random seed in sort parameter for stable pagination\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-4-add-integration-tests","title":"Task 4: Add Integration Tests <p>Files: - Modify: <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code></p> <p>Step 1: Add test for different seeds producing different orders</p> <pre><code>it(\"should return different results with different random seeds\", async () =&gt; {\n  const seed1 = 11111111;\n  const seed2 = 99999999;\n\n  const result1 = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed1,\n  });\n\n  const result2 = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed2,\n  });\n\n  // Different seeds should give different orders\n  if (result1.scenes.length &gt;= 3 &amp;&amp; result2.scenes.length &gt;= 3) {\n    const order1 = result1.scenes.map((s) =&gt; s.id).join(\",\");\n    const order2 = result2.scenes.map((s) =&gt; s.id).join(\",\");\n    expect(order1).not.toEqual(order2);\n  }\n});\n\nit(\"should reverse order when direction changes with same seed\", async () =&gt; {\n  const seed = 12345678;\n\n  const ascResult = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"ASC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed,\n  });\n\n  const descResult = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed,\n  });\n\n  // Same seed with opposite directions should give reversed order\n  if (ascResult.scenes.length &gt;= 2 &amp;&amp; descResult.scenes.length &gt;= 2) {\n    const ascIds = ascResult.scenes.map((s) =&gt; s.id);\n    const descIds = descResult.scenes.map((s) =&gt; s.id);\n    expect(ascIds).toEqual(descIds.reverse());\n  }\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneQueryBuilder.integration</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"test: add tests for random seed variation and direction reversal\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-5-run-full-test-suite-and-lint","title":"Task 5: Run Full Test Suite and Lint <p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run client tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run</code> Expected: All tests pass</p> <p>Step 3: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint &amp;&amp; cd ../client &amp;&amp; npm run lint</code> Expected: No lint errors</p> <p>Step 4: Build both projects</p> <p>Run: <code>cd server &amp;&amp; npm run build &amp;&amp; cd ../client &amp;&amp; npm run build</code> Expected: Both build successfully</p>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-6-manual-testing-checklist","title":"Task 6: Manual Testing Checklist <ol> <li>Random sort produces different orders on page refresh:</li> <li>Navigate to Scenes page with random sort</li> <li>Note the order of first few scenes</li> <li>Refresh the page (F5)</li> <li> <p>Verify order has changed (new seed generated on mount)</p> </li> <li> <p>Pagination remains stable within session:</p> </li> <li>Set random sort</li> <li>Note scene IDs on page 1</li> <li>Go to page 2</li> <li>Go back to page 1</li> <li> <p>Verify same scenes appear</p> </li> <li> <p>Direction toggle reverses same results:</p> </li> <li>Set random sort, note order: A, B, C</li> <li>Toggle direction (click sort direction button)</li> <li> <p>Verify order is reversed: C, B, A (same scenes, reversed)</p> </li> <li> <p>Changing sort type generates new seed:</p> </li> <li>Set random sort, note order</li> <li>Change to date sort</li> <li>Change back to random sort</li> <li> <p>Verify order is different (new seed)</p> </li> <li> <p>Loading preset resets seed:</p> </li> <li>Set random sort, note order</li> <li>Save as preset</li> <li>Change pages</li> <li>Load the preset</li> <li>Verify order is different (seed was reset)</li> </ol>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#future-enhancement-shuffle-button","title":"Future Enhancement: Shuffle Button <p>Following Stash's pattern, a future PR could add a shuffle button when random sort is active:</p> <pre><code>{sortField === 'random' &amp;&amp; (\n  &lt;Button\n    onClick={() =&gt; {\n      setRandomSeed(-1);\n      // Trigger refetch\n    }}\n    variant=\"ghost\"\n    size=\"sm\"\n    title=\"Shuffle\"\n  &gt;\n    &lt;ShuffleIcon className=\"w-4 h-4\" /&gt;\n  &lt;/Button&gt;\n)}\n</code></pre> <p>This is out of scope for the initial fix.</p>","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/","title":"Images Page Fixes Design","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#overview","title":"Overview","text":"<p>Fixes and enhancements for the Images page feature discovered during testing.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#issues-identified","title":"Issues Identified","text":"# Issue Root Cause Fix Type 1 Lightbox doesn't load full-size image Images.jsx maps to <code>src</code> but Lightbox expects <code>paths.image</code> Bug fix 2 Favorite not persisting for images API exists but need to verify call is made correctly Bug fix 3 O Counter not clickable on ImageCard <code>CardRatingRow</code> only allows interactive O counter for scenes Feature add 4 O Counter missing from Lightbox Lightbox doesn't have O counter controls Feature add 5 Image view history New feature - track when images are viewed in lightbox Feature add"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-details","title":"Fix Details","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-1-lightbox-full-size-image-not-loading","title":"Fix 1: Lightbox Full-Size Image Not Loading","text":"<p>Problem: In <code>Images.jsx</code> line 167-176, images are mapped with <code>src</code> property but Lightbox expects <code>paths.image</code>:</p> <pre><code>// Current (wrong)\nimages={currentImages.map((img) =&gt; ({\n  src: img.paths?.image || `/api/proxy/image/${img.id}/image`,\n  ...\n}))}\n\n// Lightbox expects (line 214)\nconst imageSrc = currentImage?.paths?.image || currentImage?.paths?.preview;\n</code></pre> <p>Fix: Change the mapping to use <code>paths</code> object structure that Lightbox expects.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-2-favorite-not-persisting","title":"Fix 2: Favorite Not Persisting","text":"<p>Problem: The backend code is correct - <code>ImageRating</code> stores per-user favorites. Need to verify the Lightbox API call succeeds and data refreshes properly.</p> <p>Investigation: Check if <code>libraryApi.updateFavorite(\"image\", ...)</code> is called correctly and if Images page state updates after Lightbox interaction.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-3-o-counter-on-imagecard-clickable","title":"Fix 3: O Counter on ImageCard (Clickable)","text":"<p>Current state: <code>CardRatingRow</code> only allows interactive O counter for scenes (line 511: <code>const isScene = entityType === \"scene\"</code>).</p> <p>Required changes: 1. Create <code>ImageViewHistory</code> model in schema (similar to <code>WatchHistory</code>) 2. Add <code>incrementImageOCounter</code> endpoint in a new <code>imageViewHistory.ts</code> controller 3. Update <code>CardRatingRow</code> to allow interactive O counter for images 4. Pass <code>initialOCounter</code> to ImageCard's <code>ratingControlsProps</code></p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-4-o-counter-in-lightbox","title":"Fix 4: O Counter in Lightbox","text":"<p>Current state: Lightbox has Rating and Favorite controls but no O Counter.</p> <p>Required changes: 1. Add <code>OCounterButton</code> component to Lightbox controls 2. Wire up the increment API call 3. Update parent state via <code>onImagesUpdate</code> callback</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-5-image-view-history","title":"Fix 5: Image View History","text":"<p>New feature: Track when images are viewed in lightbox, similar to scene play history.</p> <p>Schema addition: <pre><code>model ImageViewHistory {\n  id        Int      @id @default(autoincrement())\n  userId    Int\n  imageId   String\n\n  viewCount   Int  @default(0)\n  viewHistory Json @default(\"[]\") // Array of timestamps\n  oCount      Int  @default(0)\n  oHistory    Json @default(\"[]\")\n\n  lastViewedAt DateTime?\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, imageId])\n  @@index([userId])\n  @@index([imageId])\n}\n</code></pre></p> <p>Behavior: - <code>viewCount</code>/<code>viewHistory</code>: Incremented when image is viewed in Lightbox (automatic) - <code>oCount</code>/<code>oHistory</code>: Incremented when user clicks O counter (manual) - Optional sync to Stash for O counter if user has <code>syncToStash</code> enabled</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#data-flow","title":"Data Flow","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#per-user-data-model","title":"Per-User Data Model","text":"<p>All image interaction data (rating, favorite, O counter, view history) is stored per-user in Peek: - <code>ImageRating</code>: rating, favorite (existing) - <code>ImageViewHistory</code>: viewCount, viewHistory, oCount, oHistory (new)</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#stash-sync-optional","title":"Stash Sync (Optional)","text":"<p>When user has <code>syncToStash</code> enabled: - Rating: Syncs to Stash via <code>imageUpdate</code> - O Counter: Syncs to Stash via <code>imageIncrementO</code> - Favorite: Peek-only (Stash doesn't support favorite for images) - View History: Peek-only</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#backend","title":"Backend","text":"<ul> <li><code>server/prisma/schema.prisma</code> - Add ImageViewHistory model</li> <li><code>server/controllers/imageViewHistory.ts</code> - New controller for O counter and view tracking</li> <li><code>server/routes/imageViewHistory.ts</code> - New routes</li> <li><code>server/routes/index.ts</code> - Register new routes</li> </ul>"},{"location":"plans/2025-12-29-images-page-fixes-design/#frontend","title":"Frontend","text":"<ul> <li><code>client/src/components/pages/Images.jsx</code> - Fix Lightbox image mapping</li> <li><code>client/src/components/ui/Lightbox.jsx</code> - Add O counter control</li> <li><code>client/src/components/ui/CardComponents.jsx</code> - Allow interactive O counter for images</li> <li><code>client/src/components/cards/ImageCard.jsx</code> - Pass O counter to ratingControlsProps</li> <li><code>client/src/services/api.js</code> - Add image O counter API methods</li> </ul>"},{"location":"plans/2026-01-02-image-query-builder/","title":"ImageQueryBuilder Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the memory-intensive <code>getAllImages()</code> pattern with SQL-native querying that filters, sorts, and paginates at the database level.</p> <p>Architecture: Create <code>ImageQueryBuilder</code> service mirroring <code>SceneQueryBuilder</code>. It builds parameterized SQL queries with JOINs to <code>ImageRating</code>, <code>ImageViewHistory</code>, and <code>UserExcludedEntity</code> tables. The controller calls <code>imageQueryBuilder.execute()</code> which returns only the requested page of results.</p> <p>Tech Stack: TypeScript, Prisma raw SQL (<code>$queryRawUnsafe</code>), SQLite</p>"},{"location":"plans/2026-01-02-image-query-builder/#context","title":"Context","text":""},{"location":"plans/2026-01-02-image-query-builder/#the-problem","title":"The Problem","text":"<p>The current <code>findImages</code> controller in <code>server/controllers/library/images.ts</code>: 1. Loads ALL images via <code>stashEntityService.getAllImages()</code> (line 296) 2. Filters in JavaScript (~100 lines of in-memory logic) 3. Sorts in JavaScript (~70 lines) 4. Paginates in JavaScript</p> <p>With 50k+ images, this causes memory spikes and slow responses.</p>"},{"location":"plans/2026-01-02-image-query-builder/#the-solution","title":"The Solution","text":"<p><code>ImageQueryBuilder</code> will: - Query <code>StashImage</code> directly via SQL - JOIN to <code>ImageRating</code> and <code>ImageViewHistory</code> for user data - JOIN to <code>UserExcludedEntity</code> for exclusion filtering - Use subqueries on <code>ImagePerformer</code>, <code>ImageTag</code> for filter conditions - Return only the paginated page</p>"},{"location":"plans/2026-01-02-image-query-builder/#key-differences-from-scenequerybuilder","title":"Key Differences from SceneQueryBuilder","text":"<ol> <li>User data tables: <code>ImageRating</code> and <code>ImageViewHistory</code> (not <code>SceneRating</code> and <code>WatchHistory</code>)</li> <li>Simpler tag filtering: No <code>inheritedTagIds</code> column - just query <code>ImageTag</code> junction table</li> <li>No groups filter: Images don't have groups</li> <li>Gallery filter: Images can be filtered by gallery membership</li> </ol>"},{"location":"plans/2026-01-02-image-query-builder/#task-1-create-imagequerybuilder-with-basic-structure","title":"Task 1: Create ImageQueryBuilder with Basic Structure","text":"<p>Files: - Create: <code>server/services/ImageQueryBuilder.ts</code> - Test: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>server/services/__tests__/ImageQueryBuilder.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport { imageQueryBuilder } from \"../ImageQueryBuilder.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\ndescribe(\"ImageQueryBuilder\", () =&gt; {\n  const testUserId = 9999;\n\n  beforeEach(async () =&gt; {\n    // Create test user\n    await prisma.user.create({\n      data: { id: testUserId, username: \"test-iqb\", password: \"test\" },\n    });\n\n    // Create test images\n    await prisma.stashImage.createMany({\n      data: [\n        { id: \"img-1\", title: \"Image One\", stashCreatedAt: new Date(\"2024-01-01\") },\n        { id: \"img-2\", title: \"Image Two\", stashCreatedAt: new Date(\"2024-01-02\") },\n        { id: \"img-3\", title: \"Image Three\", stashCreatedAt: new Date(\"2024-01-03\") },\n      ],\n    });\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.stashImage.deleteMany({ where: { id: { startsWith: \"img-\" } } });\n    await prisma.user.deleteMany({ where: { id: testUserId } });\n  });\n\n  describe(\"execute\", () =&gt; {\n    it(\"returns paginated images with total count\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 2,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images).toHaveLength(2);\n      expect(result.images[0].id).toBe(\"img-3\"); // Most recent first\n    });\n\n    it(\"respects page parameter\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 2,\n        perPage: 2,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images).toHaveLength(1);\n      expect(result.images[0].id).toBe(\"img-1\"); // Third image on page 2\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL with \"Cannot find module '../ImageQueryBuilder.js'\"</p> <p>Step 3: Write minimal implementation</p> <p>Create <code>server/services/ImageQueryBuilder.ts</code>:</p> <pre><code>/**\n * ImageQueryBuilder - SQL-native image querying\n *\n * Builds parameterized SQL queries for image filtering, sorting, and pagination.\n * Eliminates the need to load all images into memory.\n */\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Filter clause builder result\ninterface FilterClause {\n  sql: string;\n  params: (string | number | boolean)[];\n}\n\n// Query builder options\nexport interface ImageQueryOptions {\n  userId: number;\n  filters?: ImageFilter;\n  applyExclusions?: boolean; // Default true - use pre-computed exclusions\n  sort: string;\n  sortDirection: \"ASC\" | \"DESC\";\n  page: number;\n  perPage: number;\n  randomSeed?: number;\n}\n\n// Image filter type\nexport interface ImageFilter {\n  ids?: { value: string[]; modifier?: string };\n  favorite?: boolean;\n  rating100?: { value: number; value2?: number; modifier: string };\n  o_counter?: { value: number; value2?: number; modifier: string };\n  performers?: { value: string[]; modifier?: string };\n  tags?: { value: string[]; modifier?: string; depth?: number };\n  studios?: { value: string[]; modifier?: string; depth?: number };\n  galleries?: { value: string[]; modifier?: string };\n  q?: string; // Search query\n}\n\n// Query result\nexport interface ImageQueryResult {\n  images: any[];\n  total: number;\n}\n\n/**\n * Builds and executes SQL queries for image filtering\n */\nclass ImageQueryBuilder {\n  // Column list for SELECT - all StashImage fields plus user data\n  private readonly SELECT_COLUMNS = `\n    i.id, i.title, i.code, i.details, i.photographer, i.urls, i.date,\n    i.studioId, i.rating100 AS stashRating100, i.oCounter AS stashOCounter,\n    i.organized, i.filePath, i.width, i.height, i.fileSize,\n    i.pathThumbnail, i.pathPreview, i.pathImage,\n    i.stashCreatedAt, i.stashUpdatedAt,\n    r.rating AS userRating, r.favorite AS userFavorite,\n    v.viewCount AS userViewCount, v.oCount AS userOCount,\n    v.lastViewedAt AS userLastViewedAt\n  `.trim();\n\n  // Base FROM clause with user data JOINs\n  private buildFromClause(\n    userId: number,\n    applyExclusions: boolean = true\n  ): { sql: string; params: number[] } {\n    const baseJoins = `\n        FROM StashImage i\n        LEFT JOIN ImageRating r ON i.id = r.imageId AND r.userId = ?\n        LEFT JOIN ImageViewHistory v ON i.id = v.imageId AND v.userId = ?\n    `.trim();\n\n    if (applyExclusions) {\n      return {\n        sql: `${baseJoins}\n        LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'image' AND e.entityId = i.id`,\n        params: [userId, userId, userId],\n      };\n    }\n\n    return {\n      sql: baseJoins,\n      params: [userId, userId],\n    };\n  }\n\n  // Base WHERE clause (always filter deleted, optionally filter excluded)\n  private buildBaseWhere(applyExclusions: boolean = true): FilterClause {\n    if (applyExclusions) {\n      return {\n        sql: \"i.deletedAt IS NULL AND e.id IS NULL\",\n        params: [],\n      };\n    }\n    return {\n      sql: \"i.deletedAt IS NULL\",\n      params: [],\n    };\n  }\n\n  // Build sort clause\n  private buildSortClause(sort: string, dir: \"ASC\" | \"DESC\"): string {\n    const sortMap: Record&lt;string, string&gt; = {\n      title: `COALESCE(i.title, i.filePath) ${dir}`,\n      date: `i.date ${dir}`,\n      rating: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      rating100: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      o_counter: `COALESCE(v.oCount, i.oCounter, 0) ${dir}`,\n      filesize: `COALESCE(i.fileSize, 0) ${dir}`,\n      path: `i.filePath ${dir}`,\n      created_at: `i.stashCreatedAt ${dir}`,\n      updated_at: `i.stashUpdatedAt ${dir}`,\n    };\n\n    const sortExpr = sortMap[sort] || sortMap[\"created_at\"];\n    return `${sortExpr}, i.id ${dir}`;\n  }\n\n  async execute(options: ImageQueryOptions): Promise&lt;ImageQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage, applyExclusions = true, filters } = options;\n\n    // Build FROM clause with optional exclusion JOIN\n    const fromClause = this.buildFromClause(userId, applyExclusions);\n\n    // Build WHERE clauses\n    const whereClauses: FilterClause[] = [this.buildBaseWhere(applyExclusions)];\n\n    // Combine WHERE clauses\n    const whereSQL = whereClauses\n      .map((c) =&gt; c.sql)\n      .filter(Boolean)\n      .join(\" AND \");\n    const whereParams = whereClauses.flatMap((c) =&gt; c.params);\n\n    // Build sort\n    const sortClause = this.buildSortClause(\n      options.sort,\n      options.sortDirection\n    );\n\n    // Calculate offset\n    const offset = (page - 1) * perPage;\n\n    // Build main query\n    const sql = `\n      SELECT ${this.SELECT_COLUMNS}\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n      ORDER BY ${sortClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    const params = [...fromClause.params, ...whereParams, perPage, offset];\n\n    logger.debug(\"ImageQueryBuilder.execute\", {\n      whereClauseCount: whereClauses.length,\n      applyExclusions,\n      sort: options.sort,\n      paramCount: params.length,\n    });\n\n    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Count query\n    const countSql = `\n      SELECT COUNT(DISTINCT i.id) as total\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n    `;\n    const countParams = [...fromClause.params, ...whereParams];\n    const countResult = await prisma.$queryRawUnsafe&lt;{ total: number }[]&gt;(\n      countSql,\n      ...countParams\n    );\n    const total = Number(countResult[0]?.total || 0);\n\n    const duration = Date.now() - startTime;\n    logger.debug(\"ImageQueryBuilder.execute completed\", {\n      total,\n      returned: rows.length,\n      durationMs: duration,\n    });\n\n    return { images: rows, total };\n  }\n}\n\n// Export singleton instance\nexport const imageQueryBuilder = new ImageQueryBuilder();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add ImageQueryBuilder with basic pagination\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-2-add-user-data-filters-favorite-rating-o_counter","title":"Task 2: Add User Data Filters (favorite, rating, o_counter)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to <code>server/services/__tests__/ImageQueryBuilder.test.ts</code>:</p> <pre><code>  describe(\"user data filters\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Add user ratings\n      await prisma.imageRating.createMany({\n        data: [\n          { userId: testUserId, imageId: \"img-1\", rating: 80, favorite: true },\n          { userId: testUserId, imageId: \"img-2\", rating: 40, favorite: false },\n        ],\n      });\n      // Add view history\n      await prisma.imageViewHistory.createMany({\n        data: [\n          { userId: testUserId, imageId: \"img-1\", oCount: 5, viewCount: 10 },\n          { userId: testUserId, imageId: \"img-3\", oCount: 2, viewCount: 3 },\n        ],\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageRating.deleteMany({ where: { userId: testUserId } });\n      await prisma.imageViewHistory.deleteMany({ where: { userId: testUserId } });\n    });\n\n    it(\"filters by favorite\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { favorite: true },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by rating100 GREATER_THAN\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { rating100: { value: 50, modifier: \"GREATER_THAN\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by o_counter GREATER_THAN\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { o_counter: { value: 3, modifier: \"GREATER_THAN\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - filters not implemented</p> <p>Step 3: Add filter implementations</p> <p>Add these methods to <code>ImageQueryBuilder</code> class in <code>server/services/ImageQueryBuilder.ts</code>:</p> <pre><code>  // Build favorite filter\n  private buildFavoriteFilter(favorite: boolean | undefined): FilterClause {\n    if (favorite === undefined) {\n      return { sql: \"\", params: [] };\n    }\n    return {\n      sql: favorite ? \"r.favorite = 1\" : \"(r.favorite = 0 OR r.favorite IS NULL)\",\n      params: [],\n    };\n  }\n\n  // Build rating filter\n  private buildRatingFilter(\n    filter: { value: number; value2?: number; modifier: string } | undefined\n  ): FilterClause {\n    if (!filter) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier } = filter;\n    const ratingExpr = \"COALESCE(r.rating, i.rating100, 0)\";\n\n    switch (modifier) {\n      case \"GREATER_THAN\":\n        return { sql: `${ratingExpr} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${ratingExpr} &lt; ?`, params: [value] };\n      case \"EQUALS\":\n        return { sql: `${ratingExpr} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${ratingExpr} != ?`, params: [value] };\n      case \"BETWEEN\":\n        return { sql: `${ratingExpr} BETWEEN ? AND ?`, params: [value, value2 ?? value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build o_counter filter\n  private buildOCounterFilter(\n    filter: { value: number; value2?: number; modifier: string } | undefined\n  ): FilterClause {\n    if (!filter) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier } = filter;\n    const oExpr = \"COALESCE(v.oCount, i.oCounter, 0)\";\n\n    switch (modifier) {\n      case \"GREATER_THAN\":\n        return { sql: `${oExpr} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${oExpr} &lt; ?`, params: [value] };\n      case \"EQUALS\":\n        return { sql: `${oExpr} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${oExpr} != ?`, params: [value] };\n      case \"BETWEEN\":\n        return { sql: `${oExpr} BETWEEN ? AND ?`, params: [value, value2 ?? value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update the <code>execute</code> method to use these filters:</p> <pre><code>    // Add user data filters\n    if (filters?.favorite !== undefined) {\n      const favoriteFilter = this.buildFavoriteFilter(filters.favorite);\n      if (favoriteFilter.sql) whereClauses.push(favoriteFilter);\n    }\n\n    if (filters?.rating100) {\n      const ratingFilter = this.buildRatingFilter(filters.rating100);\n      if (ratingFilter.sql) whereClauses.push(ratingFilter);\n    }\n\n    if (filters?.o_counter) {\n      const oCounterFilter = this.buildOCounterFilter(filters.o_counter);\n      if (oCounterFilter.sql) whereClauses.push(oCounterFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add user data filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-3-add-entity-filters-performers-tags-studios-galleries","title":"Task 3: Add Entity Filters (performers, tags, studios, galleries)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to test file:</p> <pre><code>  describe(\"entity filters\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Create performers\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"perf-1\", name: \"Performer One\" },\n          { id: \"perf-2\", name: \"Performer Two\" },\n        ],\n      });\n      // Create tags\n      await prisma.stashTag.createMany({\n        data: [\n          { id: \"tag-1\", name: \"Tag One\" },\n          { id: \"tag-2\", name: \"Tag Two\" },\n        ],\n      });\n      // Create studio\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Studio One\" },\n      });\n      // Create gallery\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Gallery One\" },\n      });\n\n      // Link performers to images\n      await prisma.imagePerformer.createMany({\n        data: [\n          { imageId: \"img-1\", performerId: \"perf-1\" },\n          { imageId: \"img-2\", performerId: \"perf-2\" },\n        ],\n      });\n      // Link tags to images\n      await prisma.imageTag.createMany({\n        data: [\n          { imageId: \"img-1\", tagId: \"tag-1\" },\n          { imageId: \"img-2\", tagId: \"tag-2\" },\n        ],\n      });\n      // Set studio on image\n      await prisma.stashImage.update({\n        where: { id: \"img-1\" },\n        data: { studioId: \"studio-1\" },\n      });\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"img-1\", galleryId: \"gallery-1\" },\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageGallery.deleteMany({});\n      await prisma.imagePerformer.deleteMany({});\n      await prisma.imageTag.deleteMany({});\n      await prisma.stashGallery.deleteMany({ where: { id: \"gallery-1\" } });\n      await prisma.stashStudio.deleteMany({ where: { id: \"studio-1\" } });\n      await prisma.stashTag.deleteMany({ where: { id: { startsWith: \"tag-\" } } });\n      await prisma.stashPerformer.deleteMany({ where: { id: { startsWith: \"perf-\" } } });\n    });\n\n    it(\"filters by performer INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { performers: { value: [\"perf-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by tag INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { tags: { value: [\"tag-2\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-2\");\n    });\n\n    it(\"filters by studio INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { studios: { value: [\"studio-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by gallery INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { galleries: { value: [\"gallery-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - entity filters not implemented</p> <p>Step 3: Add entity filter implementations</p> <p>Add these methods to <code>ImageQueryBuilder</code>:</p> <pre><code>  // Build performer filter\n  private buildPerformerFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImagePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `i.id IN (\n            SELECT imageId FROM ImagePerformer\n            WHERE performerId IN (${placeholders})\n            GROUP BY imageId\n            HAVING COUNT(DISTINCT performerId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImagePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build tag filter\n  private buildTagFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImageTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `i.id IN (\n            SELECT imageId FROM ImageTag\n            WHERE tagId IN (${placeholders})\n            GROUP BY imageId\n            HAVING COUNT(DISTINCT tagId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImageTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build studio filter\n  private buildStudioFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.studioId IN (${placeholders})`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `(i.studioId IS NULL OR i.studioId NOT IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build gallery filter\n  private buildGalleryFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImageGallery WHERE galleryId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImageGallery WHERE galleryId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update <code>execute</code> to use entity filters:</p> <pre><code>    // Add entity filters\n    if (filters?.performers) {\n      const performerFilter = this.buildPerformerFilter(filters.performers);\n      if (performerFilter.sql) whereClauses.push(performerFilter);\n    }\n\n    if (filters?.tags) {\n      const tagFilter = this.buildTagFilter(filters.tags);\n      if (tagFilter.sql) whereClauses.push(tagFilter);\n    }\n\n    if (filters?.studios) {\n      const studioFilter = this.buildStudioFilter(filters.studios);\n      if (studioFilter.sql) whereClauses.push(studioFilter);\n    }\n\n    if (filters?.galleries) {\n      const galleryFilter = this.buildGalleryFilter(filters.galleries);\n      if (galleryFilter.sql) whereClauses.push(galleryFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add entity filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-4-add-search-query-and-id-filters","title":"Task 4: Add Search Query and ID Filters","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to test file:</p> <pre><code>  describe(\"search and ID filters\", () =&gt; {\n    it(\"filters by search query\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { q: \"Two\" },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-2\");\n    });\n\n    it(\"filters by IDs\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { ids: { value: [\"img-1\", \"img-3\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(2);\n      expect(result.images.map((i: any) =&gt; i.id).sort()).toEqual([\"img-1\", \"img-3\"].sort());\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL</p> <p>Step 3: Add implementations</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  // Build search query filter\n  private buildSearchFilter(q: string | undefined): FilterClause {\n    if (!q || q.trim() === \"\") {\n      return { sql: \"\", params: [] };\n    }\n\n    const searchTerm = `%${q.trim()}%`;\n    return {\n      sql: `(\n        i.title LIKE ? OR\n        i.details LIKE ? OR\n        i.photographer LIKE ? OR\n        i.filePath LIKE ?\n      )`,\n      params: [searchTerm, searchTerm, searchTerm, searchTerm],\n    };\n  }\n\n  // Build ID filter\n  private buildIdFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (${placeholders})`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (${placeholders})`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update <code>execute</code> to use these filters:</p> <pre><code>    // Add search filter\n    if (filters?.q) {\n      const searchFilter = this.buildSearchFilter(filters.q);\n      if (searchFilter.sql) whereClauses.push(searchFilter);\n    }\n\n    // Add ID filter\n    if (filters?.ids) {\n      const idFilter = this.buildIdFilter(filters.ids);\n      if (idFilter.sql) whereClauses.push(idFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add search and ID filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-5-add-random-sort-with-seed","title":"Task 5: Add Random Sort with Seed","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to test file:</p> <pre><code>  describe(\"random sort\", () =&gt; {\n    it(\"returns stable random order with seed\", async () =&gt; {\n      const result1 = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"random\",\n        sortDirection: \"ASC\",\n        page: 1,\n        perPage: 10,\n        randomSeed: 12345,\n      });\n\n      const result2 = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"random\",\n        sortDirection: \"ASC\",\n        page: 1,\n        perPage: 10,\n        randomSeed: 12345,\n      });\n\n      // Same seed should produce same order\n      expect(result1.images.map((i: any) =&gt; i.id)).toEqual(\n        result2.images.map((i: any) =&gt; i.id)\n      );\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL</p> <p>Step 3: Update sort clause to handle random</p> <p>Update <code>buildSortClause</code> method:</p> <pre><code>  // Build sort clause\n  private buildSortClause(\n    sort: string,\n    dir: \"ASC\" | \"DESC\",\n    randomSeed?: number\n  ): string {\n    // Handle random sort with seed\n    if (sort === \"random\" &amp;&amp; randomSeed !== undefined) {\n      // Use deterministic random based on seed and id\n      // Formula: (id_numeric * seed) % large_prime gives stable ordering\n      return `((CAST(i.id AS INTEGER) * ${randomSeed}) % 2147483647) ${dir}, i.id ${dir}`;\n    }\n\n    const sortMap: Record&lt;string, string&gt; = {\n      title: `COALESCE(i.title, i.filePath) ${dir}`,\n      date: `i.date ${dir}`,\n      rating: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      rating100: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      o_counter: `COALESCE(v.oCount, i.oCounter, 0) ${dir}`,\n      filesize: `COALESCE(i.fileSize, 0) ${dir}`,\n      path: `i.filePath ${dir}`,\n      created_at: `i.stashCreatedAt ${dir}`,\n      updated_at: `i.stashUpdatedAt ${dir}`,\n      random: `RANDOM()`, // Fallback for random without seed\n    };\n\n    const sortExpr = sortMap[sort] || sortMap[\"created_at\"];\n    return `${sortExpr}, i.id ${dir}`;\n  }\n</code></pre> <p>Update the call in <code>execute</code>:</p> <pre><code>    const sortClause = this.buildSortClause(\n      options.sort,\n      options.sortDirection,\n      options.randomSeed\n    );\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add random sort with seed to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-6-add-exclusion-filtering-test","title":"Task 6: Add Exclusion Filtering Test","text":"<p>Files: - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the test</p> <p>Add to test file:</p> <pre><code>  describe(\"exclusion filtering\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Exclude img-2 for the test user\n      await prisma.userExcludedEntity.create({\n        data: {\n          userId: testUserId,\n          entityType: \"image\",\n          entityId: \"img-2\",\n          reason: \"hidden\",\n        },\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.userExcludedEntity.deleteMany({ where: { userId: testUserId } });\n    });\n\n    it(\"excludes images when applyExclusions is true (default)\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(2);\n      expect(result.images.map((i: any) =&gt; i.id)).not.toContain(\"img-2\");\n    });\n\n    it(\"includes all images when applyExclusions is false\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        applyExclusions: false,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images.map((i: any) =&gt; i.id)).toContain(\"img-2\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS (exclusion logic already implemented in Task 1)</p> <p>Step 3: Commit</p> <pre><code>git add server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"test: add exclusion filtering tests for ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-7-add-getbyids-helper-method","title":"Task 7: Add getByIds Helper Method","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to test file:</p> <pre><code>  describe(\"getByIds\", () =&gt; {\n    it(\"returns images by IDs with user data\", async () =&gt; {\n      await prisma.imageRating.create({\n        data: { userId: testUserId, imageId: \"img-1\", rating: 90, favorite: true },\n      });\n\n      const result = await imageQueryBuilder.getByIds({\n        userId: testUserId,\n        ids: [\"img-1\", \"img-3\"],\n      });\n\n      expect(result.images).toHaveLength(2);\n\n      const img1 = result.images.find((i: any) =&gt; i.id === \"img-1\");\n      expect(img1.userRating).toBe(90);\n      expect(img1.userFavorite).toBe(1); // SQLite returns 1 for true\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageRating.deleteMany({ where: { userId: testUserId } });\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - getByIds not defined</p> <p>Step 3: Add getByIds method</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  /**\n   * Get images by IDs with user data\n   */\n  async getByIds(options: { userId: number; ids: string[] }): Promise&lt;ImageQueryResult&gt; {\n    const { userId, ids } = options;\n\n    if (ids.length === 0) {\n      return { images: [], total: 0 };\n    }\n\n    return this.execute({\n      userId,\n      filters: { ids: { value: ids, modifier: \"INCLUDES\" } },\n      applyExclusions: false, // IDs explicitly requested, don't filter\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: ids.length,\n    });\n  }\n</code></pre> <p>Also export the options type:</p> <pre><code>export interface ImageByIdsOptions {\n  userId: number;\n  ids: string[];\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add getByIds helper to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-8-update-images-controller-to-use-imagequerybuilder","title":"Task 8: Update Images Controller to Use ImageQueryBuilder","text":"<p>Files: - Modify: <code>server/controllers/library/images.ts</code></p> <p>Step 1: Update findImages to use ImageQueryBuilder</p> <p>Replace the entire <code>findImages</code> function in <code>server/controllers/library/images.ts</code>:</p> <pre><code>import { imageQueryBuilder, type ImageFilter } from \"../../services/ImageQueryBuilder.js\";\n\n/**\n * Find images endpoint - uses SQL-native ImageQueryBuilder\n */\nexport const findImages = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  const startTime = Date.now();\n  try {\n    const userId = req.user?.id;\n    const requestingUser = req.user;\n    const { filter, image_filter, ids } = req.body;\n\n    const sortFieldRaw = filter?.sort || \"title\";\n    const sortDirection = filter?.direction || \"ASC\";\n    const page = filter?.page || 1;\n    const perPage = filter?.per_page || 40;\n    const searchQuery = filter?.q || \"\";\n\n    // Parse random_&lt;seed&gt; format\n    let randomSeed: number | undefined;\n    let sortField = sortFieldRaw;\n\n    if (sortFieldRaw.startsWith(\"random_\")) {\n      const seedStr = sortFieldRaw.slice(7);\n      const parsedSeed = parseInt(seedStr, 10);\n      if (!isNaN(parsedSeed)) {\n        randomSeed = parsedSeed % 1e8;\n        sortField = \"random\";\n      }\n    } else if (sortFieldRaw === \"random\") {\n      randomSeed = (userId + Date.now()) % 1e8;\n    }\n\n    // Build filter object from request\n    const filters: ImageFilter = {};\n\n    if (searchQuery) {\n      filters.q = searchQuery;\n    }\n\n    if (ids &amp;&amp; Array.isArray(ids) &amp;&amp; ids.length &gt; 0) {\n      filters.ids = { value: ids, modifier: \"INCLUDES\" };\n    }\n\n    if (image_filter?.favorite !== undefined) {\n      filters.favorite = image_filter.favorite;\n    }\n\n    if (image_filter?.rating100) {\n      filters.rating100 = image_filter.rating100;\n    }\n\n    if (image_filter?.o_counter) {\n      filters.o_counter = image_filter.o_counter;\n    }\n\n    if (image_filter?.performers?.value) {\n      filters.performers = {\n        value: image_filter.performers.value.map(String),\n        modifier: image_filter.performers.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.tags?.value) {\n      filters.tags = {\n        value: image_filter.tags.value.map(String),\n        modifier: image_filter.tags.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.studios?.value) {\n      filters.studios = {\n        value: image_filter.studios.value.map(String),\n        modifier: image_filter.studios.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.galleries?.value) {\n      filters.galleries = {\n        value: image_filter.galleries.value.map(String),\n        modifier: image_filter.galleries.modifier || \"INCLUDES\",\n      };\n    }\n\n    // Admins skip exclusions\n    const applyExclusions = requestingUser?.role !== \"ADMIN\";\n\n    // Execute query\n    const result = await imageQueryBuilder.execute({\n      userId,\n      filters,\n      applyExclusions,\n      sort: sortField,\n      sortDirection: sortDirection.toUpperCase() as \"ASC\" | \"DESC\",\n      page,\n      perPage,\n      randomSeed,\n    });\n\n    // Add stashUrl to each image\n    const imagesWithStashUrl = result.images.map((image) =&gt; ({\n      ...image,\n      stashUrl: buildStashEntityUrl(\"image\", image.id),\n    }));\n\n    const totalTime = Date.now() - startTime;\n    logger.debug(\"findImages completed\", {\n      totalTime: `${totalTime}ms`,\n      totalImages: result.total,\n      returnedImages: imagesWithStashUrl.length,\n      page,\n      perPage,\n    });\n\n    res.json({\n      findImages: {\n        count: result.total,\n        images: imagesWithStashUrl,\n      },\n    });\n  } catch (error) {\n    logger.error(\"Error in findImages\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 2: Remove unused imports and functions</p> <p>Remove these from <code>images.ts</code>: - <code>stashEntityService</code> import (if no longer used by findImageById) - <code>entityExclusionHelper</code> import - <code>expandStudioIds</code>, <code>expandTagIds</code> imports - <code>mergeImagesWithUserData</code> function - <code>applyImageFiltersWithInheritance</code> function - <code>sortImages</code> function</p> <p>Keep <code>findImageById</code> as-is for now (single image lookup can stay simple).</p> <p>Step 3: Run full test suite</p> <p>Run: <code>npm test</code> Expected: All tests pass</p> <p>Step 4: Manual verification</p> <p>Start the server and test the images page: 1. Navigate to images page 2. Apply filters (performer, tag, studio) 3. Test sorting options 4. Test random sort with pagination</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/library/images.ts\ngit commit -m \"refactor: replace in-memory filtering with ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-9-hydrate-related-entities-performers-tags-galleries-studio","title":"Task 9: Hydrate Related Entities (performers, tags, galleries, studio)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code></p> <p>Step 1: Add hydration method</p> <p>The raw SQL returns flat data. We need to hydrate related entities for the API response.</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  /**\n   * Hydrate image rows with related entities\n   */\n  private async hydrateImages(rows: any[]): Promise&lt;any[]&gt; {\n    if (rows.length === 0) return [];\n\n    const imageIds = rows.map((r) =&gt; r.id);\n\n    // Fetch all related data in parallel\n    const [performers, tags, galleries, studios] = await Promise.all([\n      prisma.imagePerformer.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { performer: true },\n      }),\n      prisma.imageTag.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { tag: true },\n      }),\n      prisma.imageGallery.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { gallery: true },\n      }),\n      prisma.stashStudio.findMany({\n        where: { id: { in: rows.map((r) =&gt; r.studioId).filter(Boolean) } },\n      }),\n    ]);\n\n    // Build lookup maps\n    const performersByImage = new Map&lt;string, any[]&gt;();\n    for (const ip of performers) {\n      if (!performersByImage.has(ip.imageId)) {\n        performersByImage.set(ip.imageId, []);\n      }\n      performersByImage.get(ip.imageId)!.push(ip.performer);\n    }\n\n    const tagsByImage = new Map&lt;string, any[]&gt;();\n    for (const it of tags) {\n      if (!tagsByImage.has(it.imageId)) {\n        tagsByImage.set(it.imageId, []);\n      }\n      tagsByImage.get(it.imageId)!.push(it.tag);\n    }\n\n    const galleriesByImage = new Map&lt;string, any[]&gt;();\n    for (const ig of galleries) {\n      if (!galleriesByImage.has(ig.imageId)) {\n        galleriesByImage.set(ig.imageId, []);\n      }\n      galleriesByImage.get(ig.imageId)!.push(ig.gallery);\n    }\n\n    const studiosById = new Map(studios.map((s) =&gt; [s.id, s]));\n\n    // Hydrate each row\n    return rows.map((row) =&gt; ({\n      ...row,\n      performers: performersByImage.get(row.id) || [],\n      tags: tagsByImage.get(row.id) || [],\n      galleries: galleriesByImage.get(row.id) || [],\n      studio: row.studioId ? studiosById.get(row.studioId) : null,\n    }));\n  }\n</code></pre> <p>Update <code>execute</code> to use hydration:</p> <pre><code>    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Hydrate with related entities\n    const hydratedImages = await this.hydrateImages(rows);\n\n    // ... count query ...\n\n    return { images: hydratedImages, total };\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts\ngit commit -m \"feat: add entity hydration to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-10-final-integration-test-and-cleanup","title":"Task 10: Final Integration Test and Cleanup","text":"<p>Files: - Test: <code>server/tests/controllers/images.integration.test.ts</code> (create)</p> <p>Step 1: Create integration test</p> <p>Create <code>server/tests/controllers/images.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport request from \"supertest\";\nimport app from \"../../app.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\ndescribe(\"Images API Integration\", () =&gt; {\n  const testUserId = 8888;\n  let authToken: string;\n\n  beforeEach(async () =&gt; {\n    // Create test user and get token\n    await prisma.user.create({\n      data: { id: testUserId, username: \"img-test\", password: \"test\" },\n    });\n    // Create test images\n    await prisma.stashImage.createMany({\n      data: [\n        { id: \"int-img-1\", title: \"Test Image One\", stashCreatedAt: new Date() },\n        { id: \"int-img-2\", title: \"Test Image Two\", stashCreatedAt: new Date() },\n      ],\n    });\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.stashImage.deleteMany({ where: { id: { startsWith: \"int-img-\" } } });\n    await prisma.user.deleteMany({ where: { id: testUserId } });\n  });\n\n  it(\"returns paginated images\", async () =&gt; {\n    const response = await request(app)\n      .post(\"/api/library/images\")\n      .send({\n        filter: { page: 1, per_page: 10, sort: \"created_at\", direction: \"DESC\" },\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.findImages).toBeDefined();\n    expect(response.body.findImages.count).toBeGreaterThanOrEqual(2);\n  });\n});\n</code></pre> <p>Step 2: Run integration tests</p> <p>Run: <code>npm run test:integration -- server/tests/controllers/images.integration.test.ts</code> Expected: PASS</p> <p>Step 3: Run full test suite</p> <p>Run: <code>npm test &amp;&amp; npm run lint &amp;&amp; npm run build</code> Expected: All pass</p> <p>Step 4: Final commit</p> <pre><code>git add server/tests/controllers/images.integration.test.ts\ngit commit -m \"test: add images API integration tests\"\n</code></pre> <p>Plan complete and saved to <code>docs/plans/2026-01-02-image-query-builder.md</code>. Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2026-01-03-api-types-design/","title":"API Types Design","text":""},{"location":"plans/2026-01-03-api-types-design/#overview","title":"Overview","text":"<p>Add explicit TypeScript types for API request/response contracts across the peek-stash-browser server. This enables:</p> <ol> <li>Type safety - Compile-time validation of request/response shapes</li> <li>Self-documenting APIs - Types serve as living documentation</li> <li>Auto-generated docs - Simple script can extract types to markdown</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#current-state","title":"Current State","text":""},{"location":"plans/2026-01-03-api-types-design/#route-structure","title":"Route Structure","text":"<p>Routes are thin and delegate to controllers: <pre><code>// routes/library/scenes.ts\nrouter.post(\"/scenes\", requireCacheReady, authenticated(findScenes));\n</code></pre></p>"},{"location":"plans/2026-01-03-api-types-design/#controller-signatures","title":"Controller Signatures","text":"<p>Controllers use generic Express types with implicit shapes: <pre><code>export const findScenes = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  const { filter, scene_filter, ids } = req.body;  // implicit\n  // ...\n  res.json({ findScenes: { count, scenes } });     // implicit\n}\n</code></pre></p>"},{"location":"plans/2026-01-03-api-types-design/#existing-types","title":"Existing Types","text":"<p>Strong types exist for entities (<code>NormalizedScene</code>, <code>PeekSceneFilter</code>, etc.) but not for API contracts.</p>"},{"location":"plans/2026-01-03-api-types-design/#proposed-design","title":"Proposed Design","text":""},{"location":"plans/2026-01-03-api-types-design/#1-type-organization","title":"1. Type Organization","text":"<p>Create <code>server/types/api/</code> directory with types per domain:</p> <pre><code>server/types/api/\n\u251c\u2500\u2500 index.ts           # Re-exports all API types\n\u251c\u2500\u2500 common.ts          # Shared types (pagination, errors)\n\u251c\u2500\u2500 library.ts         # Library endpoint types (scenes, performers, etc.)\n\u251c\u2500\u2500 auth.ts            # Auth endpoint types\n\u251c\u2500\u2500 playlists.ts       # Playlist endpoint types\n\u251c\u2500\u2500 carousels.ts       # Carousel endpoint types\n\u251c\u2500\u2500 ratings.ts         # Rating endpoint types\n\u251c\u2500\u2500 watchHistory.ts    # Watch history endpoint types\n\u251c\u2500\u2500 setup.ts           # Setup wizard endpoint types\n\u2514\u2500\u2500 user.ts            # User settings endpoint types\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#2-type-pattern","title":"2. Type Pattern","text":"<p>Each endpoint gets a request and response type:</p> <pre><code>// types/api/library.ts\n\nimport type { NormalizedScene, PeekSceneFilter } from \"../index.js\";\nimport type { PaginationFilter, PaginatedResponse } from \"./common.js\";\n\n// POST /api/library/scenes\nexport interface FindScenesRequest {\n  filter?: PaginationFilter;\n  scene_filter?: PeekSceneFilter;\n  ids?: string[];\n}\n\nexport interface FindScenesResponse {\n  findScenes: {\n    count: number;\n    scenes: NormalizedScene[];\n  };\n}\n\n// GET /api/library/scenes/:id/similar\nexport interface FindSimilarScenesParams {\n  id: string;\n}\n\nexport interface FindSimilarScenesQuery {\n  page?: string;\n}\n\nexport interface FindSimilarScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#3-common-types","title":"3. Common Types","text":"<pre><code>// types/api/common.ts\n\nexport interface PaginationFilter {\n  page?: number;\n  per_page?: number;\n  sort?: string;\n  direction?: \"ASC\" | \"DESC\";\n  q?: string;\n}\n\nexport interface PaginatedResponse&lt;T&gt; {\n  count: number;\n  items: T[];\n  page?: number;\n  perPage?: number;\n}\n\nexport interface ApiError {\n  error: string;\n  details?: string;\n  errorType?: string;\n}\n\nexport interface ApiSuccess {\n  success: true;\n  message?: string;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#4-typed-request-helper","title":"4. Typed Request Helper","text":"<p>Extend Express types to use our API types:</p> <pre><code>// types/api/express.ts\n\nimport type { Request, Response } from \"express\";\nimport type { RequestUser } from \"../../middleware/auth.js\";\n\nexport interface TypedRequest&lt;\n  TBody = unknown,\n  TParams = unknown,\n  TQuery = unknown\n&gt; extends Request {\n  body: TBody;\n  params: TParams;\n  query: TQuery;\n  user?: RequestUser;\n}\n\nexport interface TypedAuthRequest&lt;\n  TBody = unknown,\n  TParams = unknown,\n  TQuery = unknown\n&gt; extends TypedRequest&lt;TBody, TParams, TQuery&gt; {\n  user: RequestUser;  // Required, not optional\n}\n\nexport interface TypedResponse&lt;T&gt; extends Response {\n  json: (body: T) =&gt; this;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#5-controller-updates","title":"5. Controller Updates","text":"<p>Controllers become explicitly typed:</p> <pre><code>// controllers/library/scenes.ts\n\nimport type { TypedAuthRequest, TypedResponse } from \"../../types/api/express.js\";\nimport type {\n  FindScenesRequest,\n  FindScenesResponse,\n} from \"../../types/api/library.js\";\n\nexport const findScenes = async (\n  req: TypedAuthRequest&lt;FindScenesRequest&gt;,\n  res: TypedResponse&lt;FindScenesResponse&gt;\n) =&gt; {\n  // req.body is now typed as FindScenesRequest\n  // res.json() expects FindScenesResponse\n  const { filter, scene_filter, ids } = req.body;\n  // ...\n};\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#implementation-scope-library-routes-first","title":"Implementation Scope: Library Routes First","text":"<p>Focus on the library routes as the highest-value target:</p>"},{"location":"plans/2026-01-03-api-types-design/#library-routes-to-type","title":"Library Routes to Type","text":"Route Method Request Type Response Type <code>/library/scenes</code> POST <code>FindScenesRequest</code> <code>FindScenesResponse</code> <code>/library/scenes/:id</code> PUT <code>UpdateSceneRequest</code> <code>UpdateSceneResponse</code> <code>/library/scenes/:id/similar</code> GET params + query <code>FindSimilarScenesResponse</code> <code>/library/scenes/recommended</code> GET query <code>GetRecommendedScenesResponse</code> <code>/library/performers</code> POST <code>FindPerformersRequest</code> <code>FindPerformersResponse</code> <code>/library/performers/minimal</code> POST <code>FindPerformersMinimalRequest</code> <code>FindPerformersMinimalResponse</code> <code>/library/performers/:id</code> PUT <code>UpdatePerformerRequest</code> <code>UpdatePerformerResponse</code> <code>/library/studios</code> POST <code>FindStudiosRequest</code> <code>FindStudiosResponse</code> <code>/library/studios/minimal</code> POST <code>FindStudiosMinimalRequest</code> <code>FindStudiosMinimalResponse</code> <code>/library/tags</code> POST <code>FindTagsRequest</code> <code>FindTagsResponse</code> <code>/library/tags/minimal</code> POST <code>FindTagsMinimalRequest</code> <code>FindTagsMinimalResponse</code> <code>/library/galleries</code> POST <code>FindGalleriesRequest</code> <code>FindGalleriesResponse</code> <code>/library/galleries/:id</code> GET params <code>FindGalleryByIdResponse</code> <code>/library/galleries/:id/images</code> GET params + query <code>GetGalleryImagesResponse</code> <code>/library/galleries/minimal</code> POST <code>FindGalleriesMinimalRequest</code> <code>FindGalleriesMinimalResponse</code> <code>/library/groups</code> POST <code>FindGroupsRequest</code> <code>FindGroupsResponse</code> <code>/library/groups/minimal</code> POST <code>FindGroupsMinimalRequest</code> <code>FindGroupsMinimalResponse</code> <code>/library/images</code> POST <code>FindImagesRequest</code> <code>FindImagesResponse</code>"},{"location":"plans/2026-01-03-api-types-design/#test-coverage-audit","title":"Test Coverage Audit","text":""},{"location":"plans/2026-01-03-api-types-design/#current-test-coverage","title":"Current Test Coverage","text":"<p>The existing tests focus on services and filter logic, not HTTP contracts:</p> Test File What It Tests <code>tests/filters/sceneFilters.test.ts</code> <code>applyQuickSceneFilters()</code> function <code>tests/filters/sceneFiltersExpensive.test.ts</code> <code>applyExpensiveSceneFilters()</code> function <code>tests/filters/performerFilters.test.ts</code> Performer filter logic <code>tests/filters/galleryFilters.test.ts</code> Gallery filter logic <code>tests/filters/groupFilters.test.ts</code> Group filter logic <code>tests/filters/studioFilters.test.ts</code> Studio filter logic <code>tests/filters/tagFilters.test.ts</code> Tag filter logic <code>tests/services/SceneQueryBuilder.test.ts</code> SQL query builder <code>services/__tests__/StashEntityService.test.ts</code> Entity service <code>services/__tests__/StashSyncService.*.test.ts</code> Sync service <code>tests/utils/codecDetection.test.ts</code> Codec detection utility"},{"location":"plans/2026-01-03-api-types-design/#test-gap","title":"Test Gap","text":"<p>No HTTP-level integration tests exist. This means:</p> <ol> <li>Response shape changes could go undetected</li> <li>No validation that routes return expected structures</li> <li>Client/server contract is implicitly trusted</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#mitigation-strategy","title":"Mitigation Strategy","text":"<p>Adding API types provides compile-time safety, but we should also add lightweight response shape tests:</p> <pre><code>// tests/api/library.integration.test.ts\n\nimport { describe, it, expect } from \"vitest\";\nimport request from \"supertest\";\nimport { app } from \"../../initializers/api.js\";\n\ndescribe(\"POST /api/library/scenes\", () =&gt; {\n  it(\"returns expected response shape\", async () =&gt; {\n    const res = await request(app)\n      .post(\"/api/library/scenes\")\n      .set(\"Authorization\", `Bearer ${testToken}`)\n      .send({ filter: { page: 1, per_page: 10 } });\n\n    expect(res.status).toBe(200);\n    expect(res.body).toHaveProperty(\"findScenes\");\n    expect(res.body.findScenes).toHaveProperty(\"count\");\n    expect(res.body.findScenes).toHaveProperty(\"scenes\");\n    expect(Array.isArray(res.body.findScenes.scenes)).toBe(true);\n  });\n});\n</code></pre> <p>This is optional for Phase 1 but recommended as a follow-up.</p>"},{"location":"plans/2026-01-03-api-types-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2026-01-03-api-types-design/#phase-1-type-infrastructure-this-branch","title":"Phase 1: Type Infrastructure (this branch)","text":"<ol> <li>Create <code>types/api/</code> directory structure</li> <li>Add <code>common.ts</code> with shared types</li> <li>Add <code>express.ts</code> with typed request/response helpers</li> <li>Add <code>library.ts</code> with all library endpoint types</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#phase-2-controller-updates","title":"Phase 2: Controller Updates","text":"<ol> <li>Update library controllers to use typed request/response</li> <li>Fix any type errors that surface (these are bugs!)</li> <li>Run existing tests to ensure no regressions</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#phase-3-remaining-endpoints","title":"Phase 3: Remaining Endpoints","text":"<p>Apply same pattern to other route groups: - Auth routes - Playlist routes - Carousel routes - Rating routes - Watch history routes - Setup routes - User routes</p>"},{"location":"plans/2026-01-03-api-types-design/#phase-4-documentation-generator","title":"Phase 4: Documentation Generator","text":"<p>Simple script to extract API types to markdown: <pre><code>npm run generate-api-docs\n</code></pre></p> <p>Outputs <code>docs/development/api-reference.md</code> with: - All routes listed - Request/response types inline - Auto-updated from type definitions</p>"},{"location":"plans/2026-01-03-api-types-design/#dry-considerations","title":"DRY Considerations","text":""},{"location":"plans/2026-01-03-api-types-design/#reuse-existing-entity-types","title":"Reuse Existing Entity Types","text":"<p>Don't duplicate - import from existing type files:</p> <pre><code>import type {\n  NormalizedScene,\n  NormalizedPerformer,\n  PeekSceneFilter,\n  PeekPerformerFilter,\n} from \"../index.js\";\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#generic-response-wrappers","title":"Generic Response Wrappers","text":"<p>For consistent patterns like <code>{ success: true, entity: T }</code>:</p> <pre><code>export type SuccessResponse&lt;T extends string, V&gt; = {\n  success: true;\n} &amp; { [K in T]: V };\n\n// Usage:\ntype UpdateSceneResponse = SuccessResponse&lt;\"scene\", NormalizedScene&gt;;\n// Results in: { success: true; scene: NormalizedScene }\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#filter-types","title":"Filter Types","text":"<p>Leverage existing filter types from <code>types/filters.ts</code> and <code>types/peekFilters.ts</code>.</p>"},{"location":"plans/2026-01-03-api-types-design/#risks-and-mitigations","title":"Risks and Mitigations","text":"Risk Impact Mitigation Type changes break client High Existing tests validate filter logic; add integration tests in Phase 4 Large refactor scope Medium Phase by route group; library first as highest value Type/runtime mismatch Medium TypeScript strict mode catches most issues Migration complexity Low Controllers only need signature changes; logic unchanged"},{"location":"plans/2026-01-03-api-types-design/#success-criteria","title":"Success Criteria","text":"<ol> <li>All library controllers have typed request/response signatures</li> <li>No new runtime errors introduced (existing tests pass)</li> <li>TypeScript catches at least one latent bug during migration</li> <li>Generated API docs reflect actual types</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#open-questions","title":"Open Questions","text":"<ol> <li>Should we validate request bodies at runtime? (e.g., with Zod)</li> <li>Pro: Catches malformed requests before they hit business logic</li> <li>Con: Adds runtime overhead and complexity</li> <li> <p>Recommendation: Defer to Phase 4; types are enough for now</p> </li> <li> <p>Should response types be strict or permissive?</p> </li> <li>Strict: <code>res.json()</code> only accepts exact type</li> <li>Permissive: Allow additional fields</li> <li>Recommendation: Start strict; loosen if needed</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#implementation-status","title":"Implementation Status","text":""},{"location":"plans/2026-01-03-api-types-design/#completed-phase-1-2026-01-03","title":"Completed (Phase 1 - 2026-01-03)","text":"<ul> <li> Type infrastructure (<code>types/api/common.ts</code>, <code>types/api/express.ts</code>)</li> <li> Library endpoint types (<code>types/api/library.ts</code>)</li> <li> API types index (<code>types/api/index.ts</code>)</li> <li> Scenes controller typed signatures</li> <li> Performers controller typed signatures</li> <li> Updated <code>authenticated()</code> helper for type compatibility</li> </ul> <p>Commits: - <code>feat(types): add common API types</code> - <code>feat(types): add typed Express request/response helpers</code> - <code>feat(types): add library API request/response types</code> - <code>feat(types): add API types index</code> - <code>feat(types): add typed signatures to scenes controller</code> - <code>feat(types): add typed signatures to performers controller</code> - <code>fix: remove unused imports from typed controllers</code></p> <p>Bugs Found During Migration: - <code>ids</code> filter format needed normalization (was <code>string[]</code>, expected <code>{ value: string[], modifier: string }</code>) - <code>groupIdForSort</code> needed parsing from string to number</p>"},{"location":"plans/2026-01-03-api-types-design/#remaining-future-phases","title":"Remaining (Future Phases)","text":"<ul> <li> Studios controller typed signatures</li> <li> Tags controller typed signatures</li> <li> Galleries controller typed signatures</li> <li> Groups controller typed signatures</li> <li> Images controller typed signatures</li> <li> Auth endpoints</li> <li> Playlist endpoints</li> <li> Carousel endpoints</li> <li> Rating endpoints</li> <li> Watch history endpoints</li> <li> Setup endpoints</li> <li> User endpoints</li> <li> API documentation generator script</li> </ul>"},{"location":"plans/2026-01-03-api-types-implementation/","title":"API Types Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add explicit TypeScript types for API request/response contracts to enable compile-time safety and self-documenting endpoints.</p> <p>Architecture: Create <code>server/types/api/</code> directory with typed request/response interfaces. Extend Express Request/Response types with generics. Update library controllers to use typed signatures.</p> <p>Tech Stack: TypeScript strict mode, Express.js types</p>"},{"location":"plans/2026-01-03-api-types-implementation/#task-1-create-common-api-types","title":"Task 1: Create Common API Types","text":"<p>Files: - Create: <code>server/types/api/common.ts</code></p> <p>Step 1: Create the common types file</p> <pre><code>// server/types/api/common.ts\n/**\n * Common API Types\n *\n * Shared types used across all API endpoints.\n */\n\n/**\n * Standard pagination filter accepted by most list endpoints\n */\nexport interface PaginationFilter {\n  page?: number;\n  per_page?: number;\n  sort?: string;\n  direction?: \"ASC\" | \"DESC\";\n  q?: string;\n}\n\n/**\n * Standard error response\n */\nexport interface ApiErrorResponse {\n  error: string;\n  details?: string;\n  errorType?: string;\n}\n\n/**\n * Standard success response with optional message\n */\nexport interface ApiSuccessResponse {\n  success: true;\n  message?: string;\n}\n\n/**\n * Cache not ready response (503)\n */\nexport interface CacheNotReadyResponse {\n  error: string;\n  message: string;\n  ready: false;\n}\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to common.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/common.ts\ngit commit -m \"feat(types): add common API types\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-2-create-typed-express-helpers","title":"Task 2: Create Typed Express Helpers","text":"<p>Files: - Create: <code>server/types/api/express.ts</code></p> <p>Step 1: Create typed Express request/response interfaces</p> <pre><code>// server/types/api/express.ts\n/**\n * Typed Express Request/Response Helpers\n *\n * Extends Express types to provide type safety for API handlers.\n */\nimport type { Request, Response } from \"express\";\nimport type { RequestUser } from \"../../middleware/auth.js\";\n\n/**\n * Typed request with body, params, and query generics\n */\nexport interface TypedRequest&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt; extends Request {\n  body: TBody;\n  params: TParams;\n  query: TQuery;\n  user?: RequestUser;\n}\n\n/**\n * Typed request that requires authentication\n * user is guaranteed to exist\n */\nexport interface TypedAuthRequest&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt; extends TypedRequest&lt;TBody, TParams, TQuery&gt; {\n  user: RequestUser;\n}\n\n/**\n * Typed response with json body generic\n * Note: Express Response.json returns Response, not the body type\n */\nexport type TypedResponse&lt;T&gt; = Response&lt;T&gt;;\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to express.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/express.ts\ngit commit -m \"feat(types): add typed Express request/response helpers\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-3-create-library-scenes-api-types","title":"Task 3: Create Library Scenes API Types","text":"<p>Files: - Create: <code>server/types/api/library.ts</code></p> <p>Step 1: Create library API types for scenes</p> <pre><code>// server/types/api/library.ts\n/**\n * Library API Types\n *\n * Request and response types for /api/library/* endpoints.\n */\nimport type {\n  NormalizedScene,\n  NormalizedPerformer,\n  NormalizedStudio,\n  NormalizedTag,\n  NormalizedGallery,\n  NormalizedGroup,\n  PeekSceneFilter,\n  PeekPerformerFilter,\n  PeekStudioFilter,\n  PeekTagFilter,\n  PeekGalleryFilter,\n  PeekGroupFilter,\n} from \"../index.js\";\nimport type { PaginationFilter, ApiErrorResponse } from \"./common.js\";\n\n// =============================================================================\n// SCENES\n// =============================================================================\n\n/**\n * POST /api/library/scenes - Find scenes with filters\n */\nexport interface FindScenesRequest {\n  filter?: PaginationFilter;\n  scene_filter?: PeekSceneFilter;\n  ids?: string[];\n}\n\nexport interface FindScenesResponse {\n  findScenes: {\n    count: number;\n    scenes: NormalizedScene[];\n  };\n}\n\n/**\n * GET /api/library/scenes/:id/similar - Find similar scenes\n */\nexport interface FindSimilarScenesParams {\n  id: string;\n}\n\nexport interface FindSimilarScenesQuery {\n  page?: string;\n}\n\nexport interface FindSimilarScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n}\n\n/**\n * GET /api/library/scenes/recommended - Get recommended scenes\n */\nexport interface GetRecommendedScenesQuery {\n  page?: string;\n  per_page?: string;\n}\n\nexport interface GetRecommendedScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n  message?: string;\n  criteria?: {\n    favoritePerformers: number;\n    highlyRatedPerformers: number;\n    favoriteStudios: number;\n    highlyRatedStudios: number;\n    favoriteTags: number;\n    highlyRatedTags: number;\n    favoriteScenes: number;\n    highlyRatedScenes: number;\n  };\n}\n\n/**\n * PUT /api/library/scenes/:id - Update scene\n */\nexport interface UpdateSceneParams {\n  id: string;\n}\n\nexport interface UpdateSceneRequest {\n  title?: string;\n  details?: string;\n  date?: string;\n  rating100?: number;\n  studio_id?: string;\n  performer_ids?: string[];\n  tag_ids?: string[];\n  [key: string]: unknown; // Allow pass-through to Stash API\n}\n\nexport interface UpdateSceneResponse {\n  success: true;\n  scene: NormalizedScene;\n}\n\n// =============================================================================\n// PERFORMERS\n// =============================================================================\n\n/**\n * POST /api/library/performers - Find performers with filters\n */\nexport interface FindPerformersRequest {\n  filter?: PaginationFilter;\n  performer_filter?: PeekPerformerFilter;\n  ids?: string[];\n}\n\nexport interface FindPerformersResponse {\n  findPerformers: {\n    count: number;\n    performers: NormalizedPerformer[];\n  };\n}\n\n/**\n * POST /api/library/performers/minimal - Get minimal performer data\n */\nexport interface FindPerformersMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindPerformersMinimalResponse {\n  performers: Array&lt;{ id: string; name: string }&gt;;\n}\n\n/**\n * PUT /api/library/performers/:id - Update performer\n */\nexport interface UpdatePerformerParams {\n  id: string;\n}\n\nexport interface UpdatePerformerRequest {\n  name?: string;\n  details?: string;\n  [key: string]: unknown;\n}\n\nexport interface UpdatePerformerResponse {\n  success: true;\n  performer: NormalizedPerformer;\n}\n\n// =============================================================================\n// STUDIOS\n// =============================================================================\n\n/**\n * POST /api/library/studios - Find studios with filters\n */\nexport interface FindStudiosRequest {\n  filter?: PaginationFilter;\n  studio_filter?: PeekStudioFilter;\n  ids?: string[];\n}\n\nexport interface FindStudiosResponse {\n  findStudios: {\n    count: number;\n    studios: NormalizedStudio[];\n  };\n}\n\n/**\n * POST /api/library/studios/minimal - Get minimal studio data\n */\nexport interface FindStudiosMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindStudiosMinimalResponse {\n  studios: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// TAGS\n// =============================================================================\n\n/**\n * POST /api/library/tags - Find tags with filters\n */\nexport interface FindTagsRequest {\n  filter?: PaginationFilter;\n  tag_filter?: PeekTagFilter;\n  ids?: string[];\n}\n\nexport interface FindTagsResponse {\n  findTags: {\n    count: number;\n    tags: NormalizedTag[];\n  };\n}\n\n/**\n * POST /api/library/tags/minimal - Get minimal tag data\n */\nexport interface FindTagsMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindTagsMinimalResponse {\n  tags: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// GALLERIES\n// =============================================================================\n\n/**\n * POST /api/library/galleries - Find galleries with filters\n */\nexport interface FindGalleriesRequest {\n  filter?: PaginationFilter;\n  gallery_filter?: PeekGalleryFilter;\n  ids?: string[];\n}\n\nexport interface FindGalleriesResponse {\n  findGalleries: {\n    count: number;\n    galleries: NormalizedGallery[];\n  };\n}\n\n/**\n * GET /api/library/galleries/:id - Get single gallery\n */\nexport interface GetGalleryParams {\n  id: string;\n}\n\nexport interface GetGalleryResponse {\n  gallery: NormalizedGallery | null;\n}\n\n/**\n * GET /api/library/galleries/:id/images - Get gallery images\n */\nexport interface GetGalleryImagesParams {\n  id: string;\n}\n\nexport interface GetGalleryImagesQuery {\n  page?: string;\n  per_page?: string;\n}\n\nexport interface GetGalleryImagesResponse {\n  images: Array&lt;{\n    id: string;\n    title?: string;\n    files?: Array&lt;{ width?: number; height?: number }&gt;;\n    paths?: { thumbnail?: string };\n  }&gt;;\n  count: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n/**\n * POST /api/library/galleries/minimal - Get minimal gallery data\n */\nexport interface FindGalleriesMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindGalleriesMinimalResponse {\n  galleries: Array&lt;{ id: string; title: string }&gt;;\n}\n\n// =============================================================================\n// GROUPS\n// =============================================================================\n\n/**\n * POST /api/library/groups - Find groups with filters\n */\nexport interface FindGroupsRequest {\n  filter?: PaginationFilter;\n  group_filter?: PeekGroupFilter;\n  ids?: string[];\n}\n\nexport interface FindGroupsResponse {\n  findGroups: {\n    count: number;\n    groups: NormalizedGroup[];\n  };\n}\n\n/**\n * POST /api/library/groups/minimal - Get minimal group data\n */\nexport interface FindGroupsMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindGroupsMinimalResponse {\n  groups: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// IMAGES\n// =============================================================================\n\n/**\n * POST /api/library/images - Find images with filters\n */\nexport interface FindImagesRequest {\n  filter?: PaginationFilter;\n  image_filter?: Record&lt;string, unknown&gt;; // TODO: Add PeekImageFilter\n  ids?: string[];\n}\n\nexport interface FindImagesResponse {\n  findImages: {\n    count: number;\n    images: Array&lt;{\n      id: string;\n      title?: string;\n      rating100?: number;\n      favorite?: boolean;\n      o_counter?: number;\n      files?: Array&lt;{ width?: number; height?: number }&gt;;\n      paths?: { thumbnail?: string };\n      galleries?: Array&lt;{ id: string; title?: string }&gt;;\n      performers?: Array&lt;{ id: string; name: string }&gt;;\n      studio?: { id: string; name: string } | null;\n      tags?: Array&lt;{ id: string; name: string }&gt;;\n    }&gt;;\n  };\n}\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to library.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/library.ts\ngit commit -m \"feat(types): add library API request/response types\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-4-create-api-types-index","title":"Task 4: Create API Types Index","text":"<p>Files: - Create: <code>server/types/api/index.ts</code></p> <p>Step 1: Create index file that re-exports all API types</p> <pre><code>// server/types/api/index.ts\n/**\n * API Types Index\n *\n * Re-exports all API request/response types for easy importing.\n *\n * Usage:\n *   import type { FindScenesRequest, FindScenesResponse } from \"../types/api/index.js\";\n */\n\n// Common types\nexport type {\n  PaginationFilter,\n  ApiErrorResponse,\n  ApiSuccessResponse,\n  CacheNotReadyResponse,\n} from \"./common.js\";\n\n// Express typed helpers\nexport type {\n  TypedRequest,\n  TypedAuthRequest,\n  TypedResponse,\n} from \"./express.js\";\n\n// Library endpoint types\nexport type {\n  // Scenes\n  FindScenesRequest,\n  FindScenesResponse,\n  FindSimilarScenesParams,\n  FindSimilarScenesQuery,\n  FindSimilarScenesResponse,\n  GetRecommendedScenesQuery,\n  GetRecommendedScenesResponse,\n  UpdateSceneParams,\n  UpdateSceneRequest,\n  UpdateSceneResponse,\n  // Performers\n  FindPerformersRequest,\n  FindPerformersResponse,\n  FindPerformersMinimalRequest,\n  FindPerformersMinimalResponse,\n  UpdatePerformerParams,\n  UpdatePerformerRequest,\n  UpdatePerformerResponse,\n  // Studios\n  FindStudiosRequest,\n  FindStudiosResponse,\n  FindStudiosMinimalRequest,\n  FindStudiosMinimalResponse,\n  // Tags\n  FindTagsRequest,\n  FindTagsResponse,\n  FindTagsMinimalRequest,\n  FindTagsMinimalResponse,\n  // Galleries\n  FindGalleriesRequest,\n  FindGalleriesResponse,\n  GetGalleryParams,\n  GetGalleryResponse,\n  GetGalleryImagesParams,\n  GetGalleryImagesQuery,\n  GetGalleryImagesResponse,\n  FindGalleriesMinimalRequest,\n  FindGalleriesMinimalResponse,\n  // Groups\n  FindGroupsRequest,\n  FindGroupsResponse,\n  FindGroupsMinimalRequest,\n  FindGroupsMinimalResponse,\n  // Images\n  FindImagesRequest,\n  FindImagesResponse,\n} from \"./library.js\";\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/index.ts\ngit commit -m \"feat(types): add API types index\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-5-update-scenes-controller-with-typed-signatures","title":"Task 5: Update Scenes Controller with Typed Signatures","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Add imports for new types</p> <p>At the top of the file, after existing imports, add:</p> <pre><code>import type {\n  TypedAuthRequest,\n  TypedResponse,\n  FindScenesRequest,\n  FindScenesResponse,\n  FindSimilarScenesParams,\n  FindSimilarScenesQuery,\n  FindSimilarScenesResponse,\n  GetRecommendedScenesQuery,\n  GetRecommendedScenesResponse,\n  UpdateSceneParams,\n  UpdateSceneRequest,\n  UpdateSceneResponse,\n  ApiErrorResponse,\n} from \"../../types/api/index.js\";\n</code></pre> <p>Step 2: Update findScenes signature</p> <p>Change: <pre><code>export const findScenes = async (req: AuthenticatedRequest, res: Response) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findScenes = async (\n  req: TypedAuthRequest&lt;FindScenesRequest&gt;,\n  res: TypedResponse&lt;FindScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 3: Update findSimilarScenes signature</p> <p>Change: <pre><code>export const findSimilarScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findSimilarScenes = async (\n  req: TypedAuthRequest&lt;unknown, FindSimilarScenesParams, FindSimilarScenesQuery&gt;,\n  res: TypedResponse&lt;FindSimilarScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 4: Update getRecommendedScenes signature</p> <p>Change: <pre><code>export const getRecommendedScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const getRecommendedScenes = async (\n  req: TypedAuthRequest&lt;unknown, Record&lt;string, string&gt;, GetRecommendedScenesQuery&gt;,\n  res: TypedResponse&lt;GetRecommendedScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 5: Update updateScene signature</p> <p>Change: <pre><code>export const updateScene = async (req: AuthenticatedRequest, res: Response) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const updateScene = async (\n  req: TypedAuthRequest&lt;UpdateSceneRequest, UpdateSceneParams&gt;,\n  res: TypedResponse&lt;UpdateSceneResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 6: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors (or type errors that reveal bugs to fix)</p> <p>Step 7: Run existing tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 8: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat(types): add typed signatures to scenes controller\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-6-update-performers-controller-with-typed-signatures","title":"Task 6: Update Performers Controller with Typed Signatures","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code></p> <p>Step 1: Add imports for new types</p> <p>At the top of the file, after existing imports, add:</p> <pre><code>import type {\n  TypedAuthRequest,\n  TypedResponse,\n  FindPerformersRequest,\n  FindPerformersResponse,\n  FindPerformersMinimalRequest,\n  FindPerformersMinimalResponse,\n  UpdatePerformerParams,\n  UpdatePerformerRequest,\n  UpdatePerformerResponse,\n  ApiErrorResponse,\n} from \"../../types/api/index.js\";\n</code></pre> <p>Step 2: Update findPerformers signature</p> <p>Change: <pre><code>export const findPerformers = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findPerformers = async (\n  req: TypedAuthRequest&lt;FindPerformersRequest&gt;,\n  res: TypedResponse&lt;FindPerformersResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 3: Update findPerformersMinimal signature</p> <p>Change: <pre><code>export const findPerformersMinimal = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findPerformersMinimal = async (\n  req: TypedAuthRequest&lt;FindPerformersMinimalRequest&gt;,\n  res: TypedResponse&lt;FindPerformersMinimalResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 4: Update updatePerformer signature</p> <p>Change: <pre><code>export const updatePerformer = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const updatePerformer = async (\n  req: TypedAuthRequest&lt;UpdatePerformerRequest, UpdatePerformerParams&gt;,\n  res: TypedResponse&lt;UpdatePerformerResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 5: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Run existing tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/library/performers.ts\ngit commit -m \"feat(types): add typed signatures to performers controller\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-7-update-routehelpers-authenticated-wrapper","title":"Task 7: Update routeHelpers authenticated() Wrapper","text":"<p>Files: - Modify: <code>server/utils/routeHelpers.ts</code></p> <p>Step 1: Read current file</p> <p>Read the file to understand current implementation.</p> <p>Step 2: Update to support generic typed handlers</p> <p>The <code>authenticated()</code> wrapper should preserve type information. Update it to use generics:</p> <pre><code>import type { Response, NextFunction } from \"express\";\nimport type { TypedAuthRequest } from \"../types/api/index.js\";\n\n/**\n * Wrapper for authenticated route handlers\n * Ensures TypeScript knows req.user exists\n */\nexport function authenticated&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt;(\n  handler: (\n    req: TypedAuthRequest&lt;TBody, TParams, TQuery&gt;,\n    res: Response,\n    next: NextFunction\n  ) =&gt; Promise&lt;void&gt; | void\n) {\n  return handler as (\n    req: TypedAuthRequest&lt;TBody, TParams, TQuery&gt;,\n    res: Response,\n    next: NextFunction\n  ) =&gt; Promise&lt;void&gt; | void;\n}\n</code></pre> <p>Step 3: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/utils/routeHelpers.ts\ngit commit -m \"refactor(types): update authenticated() helper to preserve type info\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-8-verify-all-tests-pass","title":"Task 8: Verify All Tests Pass","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run TypeScript check</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Run linter</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing ones)</p>"},{"location":"plans/2026-01-03-api-types-implementation/#task-9-update-design-doc-status","title":"Task 9: Update Design Doc Status","text":"<p>Files: - Modify: <code>docs/plans/2026-01-03-api-types-design.md</code></p> <p>Step 1: Add implementation status</p> <p>Add a section at the end of the design doc:</p> <pre><code>## Implementation Status\n\n### Completed (Phase 1)\n- [x] Type infrastructure (`types/api/common.ts`, `types/api/express.ts`)\n- [x] Library endpoint types (`types/api/library.ts`)\n- [x] Scenes controller typed signatures\n- [x] Performers controller typed signatures\n- [x] Updated `authenticated()` helper\n\n### Remaining (Future Phases)\n- [ ] Studios controller typed signatures\n- [ ] Tags controller typed signatures\n- [ ] Galleries controller typed signatures\n- [ ] Groups controller typed signatures\n- [ ] Images controller typed signatures\n- [ ] Auth endpoints\n- [ ] Playlist endpoints\n- [ ] Carousel endpoints\n- [ ] Rating endpoints\n- [ ] Watch history endpoints\n- [ ] Setup endpoints\n- [ ] User endpoints\n- [ ] API documentation generator script\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add docs/plans/2026-01-03-api-types-design.md\ngit commit -m \"docs: update API types design with implementation status\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li>New files created:</li> <li><code>server/types/api/common.ts</code> - Shared API types</li> <li><code>server/types/api/express.ts</code> - Typed Express helpers</li> <li><code>server/types/api/library.ts</code> - Library endpoint types</li> <li> <p><code>server/types/api/index.ts</code> - Re-exports</p> </li> <li> <p>Files modified:</p> </li> <li><code>server/controllers/library/scenes.ts</code> - Typed signatures</li> <li><code>server/controllers/library/performers.ts</code> - Typed signatures</li> <li><code>server/utils/routeHelpers.ts</code> - Generic authenticated() helper</li> <li> <p><code>docs/plans/2026-01-03-api-types-design.md</code> - Status update</p> </li> <li> <p>Verification:</p> </li> <li>All existing tests pass</li> <li>TypeScript compiles without errors</li> <li> <p>Linter passes</p> </li> <li> <p>Next steps (future work):</p> </li> <li>Apply same pattern to remaining controllers</li> <li>Add remaining endpoint types (auth, playlists, etc.)</li> <li>Create documentation generator script</li> </ol>"},{"location":"plans/2026-01-04-api-docs-generator-design/","title":"API Documentation Generator Design","text":""},{"location":"plans/2026-01-04-api-docs-generator-design/#overview","title":"Overview","text":"<p>Generate <code>docs/development/api-reference.md</code> from TypeScript source files, auto-updated via <code>npm run generate-api-docs</code>. Published to GitHub Pages alongside existing mkdocs documentation.</p>"},{"location":"plans/2026-01-04-api-docs-generator-design/#goals","title":"Goals","text":"<ol> <li>Document all API routes with method, path, and authentication requirements</li> <li>Show request/response types extracted from TypeScript</li> <li>Link to controller source files</li> <li>Auto-generate on CI before mkdocs build</li> </ol>"},{"location":"plans/2026-01-04-api-docs-generator-design/#data-flow","title":"Data Flow","text":"<pre><code>server/routes/**/*.ts \u2500\u2500\u2510\n                        \u251c\u2500\u2500\u25b6 TypeScript Compiler API \u2500\u2500\u25b6 Merged endpoint data \u2500\u2500\u25b6 Markdown\nserver/types/api/*.ts \u2500\u2500\u2518\n</code></pre> <p>Matching strategy: 1. Parse route files to get <code>{ method, path, controllerName }</code> 2. Follow imports to controller files 3. Extract type parameters from controller signatures (<code>TypedAuthRequest&lt;T&gt;</code>, <code>TypedResponse&lt;T&gt;</code>) 4. Resolve those types from <code>types/api/*.ts</code> 5. Render to markdown</p>"},{"location":"plans/2026-01-04-api-docs-generator-design/#output-format","title":"Output Format","text":"<p>Single file: <code>docs/development/api-reference.md</code></p> <p>Each endpoint documented as:</p> <pre><code>### POST /api/library/scenes\n\nFind scenes with filtering and pagination.\n\n**Authentication:** Required\n\n**Request Body:**\n```typescript\ninterface FindScenesRequest {\n  filter?: PaginationFilter;\n  scene_filter?: PeekSceneFilter;\n  ids?: string[];\n}\n</code></pre> <p>Response: <pre><code>interface FindScenesResponse {\n  findScenes: {\n    count: number;\n    scenes: NormalizedScene[];\n  };\n}\n</code></pre></p> <p>Controller: <code>findScenes</code> in <code>controllers/library/scenes.ts</code> <pre><code>### Grouping\n\nEndpoints grouped by domain:\n- Library (scenes, performers, studios, tags, galleries, groups, images)\n- Authentication\n- Playlists\n- Carousels\n- Ratings\n- Watch History\n- Image View History\n- Setup\n- User Settings\n- Sync\n\n## Script Details\n\n**Location:** `server/scripts/generate-api-docs.ts`\n\n**npm script:**\n```json\n{\n  \"scripts\": {\n    \"generate-api-docs\": \"npx tsx scripts/generate-api-docs.ts\"\n  }\n}\n</code></pre></p> <p>Why TypeScript Compiler API: Already compiling TS at build time; compiler gives accurate type resolution for imports, generics, and union types.</p>"},{"location":"plans/2026-01-04-api-docs-generator-design/#ci-integration","title":"CI Integration","text":"<p>Add to <code>.github/workflows/docs.yml</code> before mkdocs build: <pre><code>- name: Generate API docs\n  run: cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Update <code>mkdocs.yml</code> nav: <pre><code>nav:\n  - Development:\n      - Technical Overview: development/technical-overview.md\n      - API Reference: development/api-reference.md\n      - Regression Testing Guide: development/regression-testing.md\n</code></pre></p>"},{"location":"plans/2026-01-04-api-docs-generator-design/#edge-cases","title":"Edge Cases","text":"<p>Untyped controllers: Show <code>Request Body: unknown</code> / <code>Response: unknown</code> - visible gaps encourage typing.</p> <p>Excluded routes: Skip <code>video.ts</code> (streaming endpoints, not JSON APIs) via hardcoded skip list.</p> <p>Nested routers: Parse mount hierarchy from <code>server/initializers/api.ts</code> to build full paths like <code>/api/library/scenes</code>.</p> <p>Complex types: Show type name with link to source file rather than inlining large definitions like <code>NormalizedScene</code>.</p>"},{"location":"plans/2026-01-04-api-docs-generator-design/#not-in-scope","title":"Not In Scope","text":"<ul> <li>UI consumer mapping (one-time manual audit)</li> <li>Runtime request validation</li> <li>OpenAPI/Swagger output format</li> </ul>"},{"location":"plans/2026-01-04-api-docs-generator-design/#success-criteria","title":"Success Criteria","text":"<ol> <li><code>npm run generate-api-docs</code> produces valid markdown</li> <li>All typed endpoints show request/response types</li> <li>Untyped endpoints show <code>unknown</code> (not silent)</li> <li>CI publishes to GitHub Pages on merge to main</li> </ol>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/","title":"API Documentation Generator Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Create a script that generates <code>docs/development/api-reference.md</code> from TypeScript source files.</p> <p>Architecture: Use TypeScript Compiler API to parse route files and extract controller type signatures. Match routes to their request/response types and render to markdown. Run via <code>npm run generate-api-docs</code>.</p> <p>Tech Stack: TypeScript, ts.createProgram(), Node.js fs</p>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-1-add-tsx-dependency-and-npm-script","title":"Task 1: Add tsx dependency and npm script","text":"<p>Files: - Modify: <code>server/package.json</code></p> <p>Step 1: Add tsx as dev dependency</p> <p>Run: <pre><code>cd server &amp;&amp; npm install --save-dev tsx\n</code></pre></p> <p>Step 2: Add generate-api-docs script to package.json</p> <p>Add to scripts section: <pre><code>\"generate-api-docs\": \"npx tsx scripts/generate-api-docs.ts\"\n</code></pre></p> <p>Step 3: Verify installation</p> <p>Run: <pre><code>cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Expected: Error \"Cannot find module\" (script doesn't exist yet)</p> <p>Step 4: Commit</p> <pre><code>git add server/package.json server/package-lock.json\ngit commit -m \"chore: add tsx and generate-api-docs script\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-2-create-route-parser-module","title":"Task 2: Create route parser module","text":"<p>Files: - Create: <code>server/scripts/generate-api-docs.ts</code> - Create: <code>server/scripts/lib/routeParser.ts</code></p> <p>Step 1: Create routeParser.ts with route extraction</p> <pre><code>// server/scripts/lib/routeParser.ts\nimport * as ts from \"typescript\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nexport interface RouteDefinition {\n  method: string;\n  path: string;\n  fullPath: string;\n  controllerName: string;\n  controllerFile: string;\n  requiresAuth: boolean;\n}\n\nexport interface RouteGroup {\n  name: string;\n  basePath: string;\n  routes: RouteDefinition[];\n}\n\n/**\n * Parse Express route files to extract route definitions\n */\nexport function parseRouteFile(filePath: string, basePath: string): RouteDefinition[] {\n  const content = fs.readFileSync(filePath, \"utf-8\");\n  const routes: RouteDefinition[] = [];\n\n  // Check for router.use(authenticate) at file level\n  const hasFileAuth = /router\\.use\\(authenticate\\)/.test(content);\n\n  // Match router.METHOD(\"path\", ..., handler) patterns\n  const routeRegex = /router\\.(get|post|put|delete|patch)\\(\\s*[\"'`]([^\"'`]+)[\"'`]\\s*,\\s*(?:[^,]+,\\s*)*(authenticated\\()?(\\w+)\\)?/g;\n\n  let match;\n  while ((match = routeRegex.exec(content)) !== null) {\n    const [, method, routePath, hasAuthenticated, controllerName] = match;\n\n    routes.push({\n      method: method.toUpperCase(),\n      path: routePath,\n      fullPath: basePath + routePath,\n      controllerName,\n      controllerFile: extractControllerFile(content, controllerName),\n      requiresAuth: hasFileAuth || !!hasAuthenticated,\n    });\n  }\n\n  return routes;\n}\n\n/**\n * Extract controller file path from import statements\n */\nfunction extractControllerFile(content: string, controllerName: string): string {\n  // Match: import { controllerName, ... } from \"path\"\n  const importRegex = new RegExp(\n    `import\\\\s*{[^}]*\\\\b${controllerName}\\\\b[^}]*}\\\\s*from\\\\s*[\"'\\`]([^\"'\\`]+)[\"'\\`]`,\n    \"m\"\n  );\n  const match = content.match(importRegex);\n  return match ? match[1].replace(/\\.js$/, \".ts\") : \"unknown\";\n}\n\n/**\n * Parse api.ts to get route mount points\n */\nexport function parseApiMounts(apiFilePath: string): Map&lt;string, string&gt; {\n  const content = fs.readFileSync(apiFilePath, \"utf-8\");\n  const mounts = new Map&lt;string, string&gt;();\n\n  // Match: app.use(\"/api/path\", routesImport)\n  const mountRegex = /app\\.use\\(\\s*[\"'`]([^\"'`]+)[\"'`]\\s*,\\s*(\\w+)\\s*\\)/g;\n\n  let match;\n  while ((match = mountRegex.exec(content)) !== null) {\n    const [, path, routeVar] = match;\n    mounts.set(routeVar, path);\n  }\n\n  return mounts;\n}\n</code></pre> <p>Step 2: Create main script skeleton</p> <pre><code>// server/scripts/generate-api-docs.ts\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { parseRouteFile, parseApiMounts, type RouteGroup } from \"./lib/routeParser.js\";\n\nconst SERVER_DIR = path.resolve(import.meta.dirname, \"..\");\nconst ROUTES_DIR = path.join(SERVER_DIR, \"routes\");\nconst API_FILE = path.join(SERVER_DIR, \"initializers\", \"api.ts\");\nconst OUTPUT_FILE = path.resolve(SERVER_DIR, \"..\", \"docs\", \"development\", \"api-reference.md\");\n\nasync function main() {\n  console.log(\"Generating API documentation...\");\n\n  // Parse mount points from api.ts\n  const mounts = parseApiMounts(API_FILE);\n  console.log(`Found ${mounts.size} route mounts`);\n\n  // For now, just output mount info\n  for (const [routeVar, basePath] of mounts) {\n    console.log(`  ${routeVar} -&gt; ${basePath}`);\n  }\n\n  console.log(\"Done (skeleton only)\");\n}\n\nmain().catch(console.error);\n</code></pre> <p>Step 3: Run to verify parsing works</p> <p>Run: <pre><code>cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Expected: Output showing route mounts like \"carouselRoutes -&gt; /api/carousels\"</p> <p>Step 4: Commit</p> <pre><code>git add server/scripts/\ngit commit -m \"feat(api-docs): add route parser module\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-3-add-controller-type-extraction","title":"Task 3: Add controller type extraction","text":"<p>Files: - Create: <code>server/scripts/lib/typeExtractor.ts</code> - Modify: <code>server/scripts/lib/routeParser.ts</code></p> <p>Step 1: Create typeExtractor.ts</p> <pre><code>// server/scripts/lib/typeExtractor.ts\nimport * as ts from \"typescript\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nexport interface TypeInfo {\n  name: string;\n  definition: string;\n  sourceFile: string;\n}\n\nexport interface ControllerTypes {\n  requestBody?: TypeInfo;\n  requestParams?: TypeInfo;\n  requestQuery?: TypeInfo;\n  response?: TypeInfo;\n}\n\n/**\n * Extract type parameters from a controller function signature\n */\nexport function extractControllerTypes(\n  controllerFile: string,\n  controllerName: string,\n  serverDir: string\n): ControllerTypes {\n  const fullPath = path.resolve(serverDir, \"controllers\", controllerFile.replace(/^\\.\\.\\/controllers\\//, \"\"));\n\n  if (!fs.existsSync(fullPath)) {\n    return {};\n  }\n\n  const content = fs.readFileSync(fullPath, \"utf-8\");\n  const result: ControllerTypes = {};\n\n  // Match: export const controllerName = async (req: TypedAuthRequest&lt;Body, Params, Query&gt;, res: TypedResponse&lt;Response&gt;)\n  const signatureRegex = new RegExp(\n    `export\\\\s+const\\\\s+${controllerName}\\\\s*=\\\\s*async\\\\s*\\\\(\\\\s*req:\\\\s*(?:TypedAuthRequest|TypedRequest)(?:&lt;([^&gt;]+)&gt;)?\\\\s*,\\\\s*res:\\\\s*TypedResponse&lt;([^&gt;]+)&gt;`,\n    \"m\"\n  );\n\n  const match = content.match(signatureRegex);\n  if (match) {\n    const [, reqTypes, resType] = match;\n\n    // Parse request type parameters (Body, Params, Query)\n    if (reqTypes) {\n      const parts = splitTypeParams(reqTypes);\n      if (parts[0] &amp;&amp; parts[0] !== \"unknown\") {\n        result.requestBody = { name: parts[0], definition: \"\", sourceFile: \"\" };\n      }\n      if (parts[1]) {\n        result.requestParams = { name: parts[1], definition: \"\", sourceFile: \"\" };\n      }\n      if (parts[2]) {\n        result.requestQuery = { name: parts[2], definition: \"\", sourceFile: \"\" };\n      }\n    }\n\n    // Parse response type (strip | ApiErrorResponse)\n    if (resType) {\n      const cleanType = resType.replace(/\\s*\\|\\s*ApiErrorResponse/, \"\").trim();\n      result.response = { name: cleanType, definition: \"\", sourceFile: \"\" };\n    }\n  }\n\n  return result;\n}\n\n/**\n * Split generic type parameters, handling nested generics\n */\nfunction splitTypeParams(typeStr: string): string[] {\n  const result: string[] = [];\n  let current = \"\";\n  let depth = 0;\n\n  for (const char of typeStr) {\n    if (char === \"&lt;\") depth++;\n    else if (char === \"&gt;\") depth--;\n    else if (char === \",\" &amp;&amp; depth === 0) {\n      result.push(current.trim());\n      current = \"\";\n      continue;\n    }\n    current += char;\n  }\n  if (current.trim()) {\n    result.push(current.trim());\n  }\n\n  return result;\n}\n</code></pre> <p>Step 2: Run to verify extraction</p> <p>Run: <pre><code>cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Expected: No errors, script runs</p> <p>Step 3: Commit</p> <pre><code>git add server/scripts/lib/typeExtractor.ts\ngit commit -m \"feat(api-docs): add controller type extraction\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-4-add-type-definition-resolver","title":"Task 4: Add type definition resolver","text":"<p>Files: - Modify: <code>server/scripts/lib/typeExtractor.ts</code></p> <p>Step 1: Add resolveTypeDefinition function</p> <p>Add to typeExtractor.ts:</p> <pre><code>/**\n * Resolve a type name to its full definition from types/api/*.ts files\n */\nexport function resolveTypeDefinition(\n  typeName: string,\n  serverDir: string\n): TypeInfo | null {\n  const apiTypesDir = path.join(serverDir, \"types\", \"api\");\n\n  if (!fs.existsSync(apiTypesDir)) {\n    return null;\n  }\n\n  const files = fs.readdirSync(apiTypesDir).filter(f =&gt; f.endsWith(\".ts\") &amp;&amp; f !== \"index.ts\");\n\n  for (const file of files) {\n    const filePath = path.join(apiTypesDir, file);\n    const content = fs.readFileSync(filePath, \"utf-8\");\n\n    // Match: export interface TypeName { ... }\n    const interfaceRegex = new RegExp(\n      `export\\\\s+interface\\\\s+${typeName}\\\\s*(?:extends[^{]+)?{([^}]+(?:{[^}]*}[^}]*)*)}`,\n      \"m\"\n    );\n\n    const match = content.match(interfaceRegex);\n    if (match) {\n      return {\n        name: typeName,\n        definition: `interface ${typeName} {${match[1]}}`,\n        sourceFile: `types/api/${file}`,\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Enrich ControllerTypes with resolved definitions\n */\nexport function enrichTypes(types: ControllerTypes, serverDir: string): ControllerTypes {\n  const enrich = (info?: TypeInfo): TypeInfo | undefined =&gt; {\n    if (!info) return undefined;\n    const resolved = resolveTypeDefinition(info.name, serverDir);\n    return resolved || info;\n  };\n\n  return {\n    requestBody: enrich(types.requestBody),\n    requestParams: enrich(types.requestParams),\n    requestQuery: enrich(types.requestQuery),\n    response: enrich(types.response),\n  };\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/scripts/lib/typeExtractor.ts\ngit commit -m \"feat(api-docs): add type definition resolver\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-5-generate-markdown-output","title":"Task 5: Generate markdown output","text":"<p>Files: - Create: <code>server/scripts/lib/markdownGenerator.ts</code> - Modify: <code>server/scripts/generate-api-docs.ts</code></p> <p>Step 1: Create markdownGenerator.ts</p> <pre><code>// server/scripts/lib/markdownGenerator.ts\nimport type { RouteDefinition } from \"./routeParser.js\";\nimport type { ControllerTypes } from \"./typeExtractor.js\";\n\nexport interface DocumentedRoute extends RouteDefinition {\n  types: ControllerTypes;\n}\n\nexport interface DocumentedGroup {\n  name: string;\n  description: string;\n  routes: DocumentedRoute[];\n}\n\n/**\n * Generate markdown documentation from route groups\n */\nexport function generateMarkdown(groups: DocumentedGroup[]): string {\n  const lines: string[] = [];\n\n  // Header\n  lines.push(\"# API Reference\");\n  lines.push(\"\");\n  lines.push(\"&gt; Auto-generated from TypeScript source files.\");\n  lines.push(`&gt; Last updated: ${new Date().toISOString().split(\"T\")[0]}`);\n  lines.push(\"\");\n\n  // Table of contents\n  lines.push(\"## Contents\");\n  lines.push(\"\");\n  for (const group of groups) {\n    const anchor = group.name.toLowerCase().replace(/\\s+/g, \"-\");\n    lines.push(`- [${group.name}](#${anchor})`);\n  }\n  lines.push(\"\");\n\n  // Each group\n  for (const group of groups) {\n    lines.push(`## ${group.name}`);\n    lines.push(\"\");\n    if (group.description) {\n      lines.push(group.description);\n      lines.push(\"\");\n    }\n\n    for (const route of group.routes) {\n      lines.push(`### ${route.method} ${route.fullPath}`);\n      lines.push(\"\");\n      lines.push(`**Authentication:** ${route.requiresAuth ? \"Required\" : \"None\"}`);\n      lines.push(\"\");\n\n      // Request body\n      if (route.types.requestBody?.definition) {\n        lines.push(\"**Request Body:**\");\n        lines.push(\"\");\n        lines.push(\"```typescript\");\n        lines.push(formatTypeDefinition(route.types.requestBody.definition));\n        lines.push(\"```\");\n        lines.push(\"\");\n      }\n\n      // Request params\n      if (route.types.requestParams?.definition) {\n        lines.push(\"**URL Parameters:**\");\n        lines.push(\"\");\n        lines.push(\"```typescript\");\n        lines.push(formatTypeDefinition(route.types.requestParams.definition));\n        lines.push(\"```\");\n        lines.push(\"\");\n      }\n\n      // Request query\n      if (route.types.requestQuery?.definition) {\n        lines.push(\"**Query Parameters:**\");\n        lines.push(\"\");\n        lines.push(\"```typescript\");\n        lines.push(formatTypeDefinition(route.types.requestQuery.definition));\n        lines.push(\"```\");\n        lines.push(\"\");\n      }\n\n      // Response\n      if (route.types.response?.definition) {\n        lines.push(\"**Response:**\");\n        lines.push(\"\");\n        lines.push(\"```typescript\");\n        lines.push(formatTypeDefinition(route.types.response.definition));\n        lines.push(\"```\");\n        lines.push(\"\");\n      } else if (route.types.response?.name) {\n        lines.push(`**Response:** \\`${route.types.response.name}\\``);\n        lines.push(\"\");\n      }\n\n      // Controller reference\n      lines.push(`**Controller:** \\`${route.controllerName}\\` in \\`${route.controllerFile}\\``);\n      lines.push(\"\");\n      lines.push(\"---\");\n      lines.push(\"\");\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Format type definition for readability\n */\nfunction formatTypeDefinition(definition: string): string {\n  // Basic formatting - add newlines after { and before }\n  return definition\n    .replace(/{\\s*/g, \"{\\n  \")\n    .replace(/;\\s*/g, \";\\n  \")\n    .replace(/\\s*}/g, \"\\n}\")\n    .replace(/\\n\\s*\\n/g, \"\\n\");\n}\n</code></pre> <p>Step 2: Update main script to generate output</p> <p>Replace <code>server/scripts/generate-api-docs.ts</code>:</p> <pre><code>// server/scripts/generate-api-docs.ts\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { parseRouteFile, parseApiMounts } from \"./lib/routeParser.js\";\nimport { extractControllerTypes, enrichTypes } from \"./lib/typeExtractor.js\";\nimport { generateMarkdown, type DocumentedGroup, type DocumentedRoute } from \"./lib/markdownGenerator.js\";\n\nconst SERVER_DIR = path.resolve(import.meta.dirname, \"..\");\nconst ROUTES_DIR = path.join(SERVER_DIR, \"routes\");\nconst API_FILE = path.join(SERVER_DIR, \"initializers\", \"api.ts\");\nconst OUTPUT_FILE = path.resolve(SERVER_DIR, \"..\", \"docs\", \"development\", \"api-reference.md\");\n\n// Route files to skip (non-JSON APIs)\nconst SKIP_ROUTES = [\"video.ts\"];\n\n// Group ordering and descriptions\nconst GROUP_CONFIG: Record&lt;string, { order: number; description: string }&gt; = {\n  \"/api/library\": { order: 1, description: \"Browse and search media library content.\" },\n  \"/api/auth\": { order: 2, description: \"Authentication and session management.\" },\n  \"/api/playlists\": { order: 3, description: \"User playlist management.\" },\n  \"/api/carousels\": { order: 4, description: \"Custom homepage carousel management.\" },\n  \"/api/ratings\": { order: 5, description: \"Rating and favorite management for all entity types.\" },\n  \"/api/watch-history\": { order: 6, description: \"Scene watch history and playback tracking.\" },\n  \"/api/image-view-history\": { order: 7, description: \"Image view history and O counter tracking.\" },\n  \"/api/themes/custom\": { order: 8, description: \"Custom theme management.\" },\n  \"/api/setup\": { order: 9, description: \"Initial setup wizard endpoints.\" },\n  \"/api/user\": { order: 10, description: \"User settings and preferences.\" },\n  \"/api/sync\": { order: 11, description: \"Cache synchronization with Stash.\" },\n  \"/api/exclusions\": { order: 12, description: \"Entity exclusion management.\" },\n};\n\nasync function main() {\n  console.log(\"Generating API documentation...\");\n\n  // Parse mount points from api.ts\n  const mounts = parseApiMounts(API_FILE);\n  console.log(`Found ${mounts.size} route mounts`);\n\n  // Collect all routes by base path\n  const routesByPath = new Map&lt;string, DocumentedRoute[]&gt;();\n\n  // Find and parse all route files\n  const routeFiles = findRouteFiles(ROUTES_DIR);\n\n  for (const routeFile of routeFiles) {\n    const fileName = path.basename(routeFile);\n    if (SKIP_ROUTES.includes(fileName)) {\n      console.log(`  Skipping ${fileName}`);\n      continue;\n    }\n\n    // Find base path for this route file\n    const basePath = findBasePath(routeFile, mounts, ROUTES_DIR);\n    if (!basePath) {\n      console.log(`  No mount found for ${routeFile}`);\n      continue;\n    }\n\n    // Parse routes\n    const routes = parseRouteFile(routeFile, basePath);\n    console.log(`  ${fileName}: ${routes.length} routes at ${basePath}`);\n\n    // Extract and enrich types for each route\n    for (const route of routes) {\n      const types = extractControllerTypes(route.controllerFile, route.controllerName, SERVER_DIR);\n      const enrichedTypes = enrichTypes(types, SERVER_DIR);\n\n      const documented: DocumentedRoute = { ...route, types: enrichedTypes };\n\n      const existing = routesByPath.get(basePath) || [];\n      existing.push(documented);\n      routesByPath.set(basePath, existing);\n    }\n  }\n\n  // Build groups\n  const groups: DocumentedGroup[] = [];\n  for (const [basePath, routes] of routesByPath) {\n    const config = GROUP_CONFIG[basePath] || { order: 99, description: \"\" };\n    groups.push({\n      name: formatGroupName(basePath),\n      description: config.description,\n      routes: routes.sort((a, b) =&gt; a.fullPath.localeCompare(b.fullPath)),\n    });\n  }\n\n  // Sort groups by configured order\n  groups.sort((a, b) =&gt; {\n    const pathA = Object.keys(GROUP_CONFIG).find(k =&gt; formatGroupName(k) === a.name) || \"\";\n    const pathB = Object.keys(GROUP_CONFIG).find(k =&gt; formatGroupName(k) === b.name) || \"\";\n    return (GROUP_CONFIG[pathA]?.order || 99) - (GROUP_CONFIG[pathB]?.order || 99);\n  });\n\n  // Generate markdown\n  const markdown = generateMarkdown(groups);\n\n  // Write output\n  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });\n  fs.writeFileSync(OUTPUT_FILE, markdown);\n  console.log(`\\nWrote ${OUTPUT_FILE}`);\n\n  // Summary\n  const totalRoutes = groups.reduce((sum, g) =&gt; sum + g.routes.length, 0);\n  console.log(`Total: ${groups.length} groups, ${totalRoutes} endpoints`);\n}\n\nfunction findRouteFiles(dir: string): string[] {\n  const files: string[] = [];\n\n  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n    const fullPath = path.join(dir, entry.name);\n    if (entry.isDirectory()) {\n      files.push(...findRouteFiles(fullPath));\n    } else if (entry.name.endsWith(\".ts\")) {\n      files.push(fullPath);\n    }\n  }\n\n  return files;\n}\n\nfunction findBasePath(routeFile: string, mounts: Map&lt;string, string&gt;, routesDir: string): string | null {\n  const relativePath = path.relative(routesDir, routeFile);\n  const fileName = path.basename(routeFile, \".ts\");\n\n  // Check each mount to find matching import\n  for (const [varName, basePath] of mounts) {\n    // Convert varName like \"libraryScenesRoutes\" to match file \"library/scenes.ts\"\n    const normalized = varName.replace(/Routes$/, \"\").toLowerCase();\n    const fileNormalized = relativePath.replace(/\\\\/g, \"/\").replace(/\\.ts$/, \"\").replace(/\\//g, \"\").toLowerCase();\n\n    if (normalized === fileNormalized || normalized === fileName.toLowerCase()) {\n      return basePath;\n    }\n  }\n\n  return null;\n}\n\nfunction formatGroupName(basePath: string): string {\n  // /api/library -&gt; Library\n  // /api/watch-history -&gt; Watch History\n  return basePath\n    .replace(/^\\/api\\//, \"\")\n    .split(/[-/]/)\n    .map(s =&gt; s.charAt(0).toUpperCase() + s.slice(1))\n    .join(\" \");\n}\n\nmain().catch(console.error);\n</code></pre> <p>Step 3: Run to generate documentation</p> <p>Run: <pre><code>cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Expected: Creates <code>docs/development/api-reference.md</code> with endpoint documentation</p> <p>Step 4: Commit</p> <pre><code>git add server/scripts/ docs/development/api-reference.md\ngit commit -m \"feat(api-docs): generate markdown documentation\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-6-update-mkdocs-navigation","title":"Task 6: Update mkdocs navigation","text":"<p>Files: - Modify: <code>mkdocs.yml</code></p> <p>Step 1: Add API Reference to nav</p> <p>In <code>mkdocs.yml</code>, update the Development section:</p> <pre><code>  - Development:\n      - Technical Overview: development/technical-overview.md\n      - API Reference: development/api-reference.md\n      - Regression Testing Guide: development/regression-testing.md\n</code></pre> <p>Step 2: Verify mkdocs build locally (optional)</p> <p>Run: <pre><code>mkdocs build --strict\n</code></pre></p> <p>Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add mkdocs.yml\ngit commit -m \"docs: add API Reference to navigation\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-7-update-ci-workflow","title":"Task 7: Update CI workflow","text":"<p>Files: - Modify: <code>.github/workflows/docs.yml</code></p> <p>Step 1: Add Node.js setup and doc generation step</p> <p>Update <code>.github/workflows/docs.yml</code>:</p> <pre><code>name: Deploy Documentation\n\non:\n  push:\n    branches:\n      - master\n      - main\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n      - 'server/routes/**'\n      - 'server/types/api/**'\n      - 'server/controllers/**'\n      - 'server/scripts/**'\n      - '.github/workflows/docs.yml'\n  workflow_dispatch:\n\npermissions:\n  contents: write\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n          cache-dependency-path: server/package-lock.json\n\n      - name: Install server dependencies\n        run: cd server &amp;&amp; npm ci\n\n      - name: Generate API documentation\n        run: cd server &amp;&amp; npm run generate-api-docs\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.x'\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: |\n          pip install --upgrade pip\n          pip install mkdocs-material\n          pip install mkdocs-minify-plugin\n\n      - name: Build documentation\n        run: mkdocs build --strict\n\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./site\n          publish_branch: gh-pages\n          user_name: 'github-actions[bot]'\n          user_email: 'github-actions[bot]@users.noreply.github.com'\n          commit_message: 'docs: Deploy documentation from ${{ github.sha }}'\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add .github/workflows/docs.yml\ngit commit -m \"ci: add API docs generation to docs workflow\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-8-test-and-verify","title":"Task 8: Test and verify","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run full generation</p> <p>Run: <pre><code>cd server &amp;&amp; npm run generate-api-docs\n</code></pre></p> <p>Expected: No errors, markdown file updated</p> <p>Step 2: Check output quality</p> <p>Run: <pre><code>head -100 docs/development/api-reference.md\n</code></pre></p> <p>Expected: Valid markdown with endpoint documentation</p> <p>Step 3: Run TypeScript check</p> <p>Run: <pre><code>cd server &amp;&amp; npx tsc --noEmit\n</code></pre></p> <p>Expected: No type errors</p> <p>Step 4: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: All tests pass</p> <p>Step 5: Commit generated docs</p> <pre><code>git add docs/development/api-reference.md\ngit commit -m \"docs: generate initial API reference\"\n</code></pre>"},{"location":"plans/2026-01-04-api-docs-generator-implementation/#task-9-create-pr","title":"Task 9: Create PR","text":"<p>Step 1: Push branch</p> <pre><code>git push -u origin feature/api-docs-generator\n</code></pre> <p>Step 2: Create PR</p> <pre><code>gh pr create --title \"feat: add API documentation generator\" --body \"## Summary\n\n- Add \\`npm run generate-api-docs\\` script to extract API documentation from TypeScript\n- Parse route files and controller signatures to extract endpoint info\n- Resolve request/response types from \\`types/api/*.ts\\`\n- Generate \\`docs/development/api-reference.md\\` for mkdocs\n\n## Changes\n\n- Add tsx dev dependency\n- Create \\`server/scripts/generate-api-docs.ts\\` and supporting modules\n- Update docs.yml workflow to generate docs before mkdocs build\n- Add API Reference to mkdocs navigation\n\n## Test plan\n\n- [x] \\`npm run generate-api-docs\\` runs without errors\n- [x] Generated markdown is valid\n- [x] TypeScript compiles\n- [x] All tests pass\n\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/","title":"Integration Test Expansion Plan","text":"<p>Date: 2026-01-04 Branch: <code>feature/expand-integration-test-coverage</code> Goal: Comprehensive integration test coverage before 3.1.0 release</p>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#current-state","title":"Current State","text":"<ul> <li>76 tests passing across 10 test files</li> <li>Basic CRUD operations covered</li> <li>Content restrictions well-tested (495 lines)</li> <li>Most entity filtering NOT tested</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#ui-filter-options-available-to-users","title":"UI Filter Options Available to Users","text":""},{"location":"plans/2026-01-04-integration-test-expansion-plan/#scene-filters-21-options","title":"Scene Filters (21+ options)","text":"Filter Modifiers Tested? Title text search No Details text search No Performers INCLUDES/INCLUDES_ALL/EXCLUDES Basic only Studio INCLUDES/EXCLUDES + hierarchy Basic only Tags INCLUDES/INCLUDES_ALL/EXCLUDES + hierarchy Basic only Collections/Groups INCLUDES/INCLUDES_ALL/EXCLUDES No Rating numeric range No O Count numeric range No Duration numeric range No Favorite Scenes boolean No Favorite Performers boolean (user-specific) No Favorite Studios boolean (user-specific) No Favorite Tags boolean (user-specific) No Scene Date date range No Created Date date range No Updated Date date range No Last Played Date date range No Resolution with modifiers No Bitrate numeric range No Framerate numeric range No Orientation LANDSCAPE/PORTRAIT/SQUARE No Video Codec text search No Audio Codec text search No Director text search No Play Duration numeric range No Play Count numeric range No Performer Count numeric range No Performer Age numeric range (calculated) No Tag Count numeric range No"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#performer-filters-16-options","title":"Performer Filters (16 options)","text":"<ul> <li>Name, Tags, Gender, Rating, O Count, Scene Count, Favorite</li> <li>Age, Birth Year, Death Year, Career Length, Birthdate, Death Date</li> <li>Hair Color, Eye Color, Ethnicity, Breast Type, Measurements, Tattoos, Piercings, Height, Weight</li> <li>Currently tested: Basic pagination only</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#studio-filters-10-options","title":"Studio Filters (10 options)","text":"<ul> <li>Name, Details, Tags, Rating, Scene Count, O Count, Play Count, Favorite, Created At, Updated At</li> <li>Currently tested: Basic pagination only</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#tag-filters-11-options","title":"Tag Filters (11 options)","text":"<ul> <li>Name, Description, Rating, Scene Count, O Count, Play Count, Favorite</li> <li>Performers, Studios, Scenes, Collections</li> <li>Currently tested: Basic pagination only</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#gallery-filters-7-options","title":"Gallery Filters (7 options)","text":"<ul> <li>Title, Performers, Studios, Tags, Rating, Image Count, Favorite</li> <li>Currently tested: Basic pagination only</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#group-filters-13-options","title":"Group Filters (13 options)","text":"<ul> <li>Name, Synopsis, Director, Performers, Studio, Tags, Rating, Scene Count, Duration, Favorite</li> <li>Release Date, Created At, Updated At</li> <li>Currently tested: Basic pagination only</li> </ul>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#310-beta-features-requiring-tests","title":"3.1.0-Beta Features Requiring Tests","text":"<ol> <li>Pre-computed Exclusions System - Exclusions computed at sync time, applied to queries</li> <li>Entity Soft-Delete - Soft-deleted entities filtered from results</li> <li>Inherited Tag Support - Denormalized inherited tags in scenes</li> <li>Gallery Inheritance - Image-to-gallery inheritance</li> <li>Random Sort with Seed - Stable pagination with deterministic randomization</li> <li>Cascading Exclusions - Empty entity handling, cascade logic</li> <li>Incremental Hide/Unhide - User-level entity hiding</li> <li>Full Sync Trigger - After database migrations</li> </ol>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#priority-test-list","title":"Priority Test List","text":""},{"location":"plans/2026-01-04-integration-test-expansion-plan/#phase-1-critical-blocks-310-release","title":"Phase 1: Critical (Blocks 3.1.0 Release)","text":"<ol> <li>Scene Favorite Filters (<code>scene-favorite-filters.integration.test.ts</code>)</li> <li><code>favorite</code> (scene favorite)</li> <li><code>performer_favorite</code> (scenes with user's favorite performers)</li> <li><code>studio_favorite</code> (scenes from user's favorite studios)</li> <li> <p><code>tag_favorite</code> (scenes with user's favorite tags)</p> </li> <li> <p>Scene Date Filters (<code>scene-date-filters.integration.test.ts</code>)</p> </li> <li><code>date</code> (scene date range)</li> <li><code>created_at</code> (created date range)</li> <li><code>updated_at</code> (updated date range)</li> <li> <p><code>last_played_at</code> (last played date range)</p> </li> <li> <p>Tag Hierarchy Filters (<code>scene-tag-hierarchy.integration.test.ts</code>)</p> </li> <li>Tag depth parameter</li> <li>Parent tag includes children</li> <li> <p>Inherited tag filtering</p> </li> <li> <p>Exclusion Application (<code>exclusion-application.integration.test.ts</code>)</p> </li> <li>User exclusions filter out entities</li> <li>Soft-deleted entities filtered</li> <li> <p>Cascade exclusions work correctly</p> </li> <li> <p>Random Sort Stability (<code>random-sort.integration.test.ts</code>)</p> </li> <li>Same seed returns same order</li> <li>Different seeds return different orders</li> <li> <p>Pagination stable with seed</p> </li> <li> <p>Combined Filters (<code>combined-filters.integration.test.ts</code>)</p> </li> <li>Multiple filters simultaneously</li> <li>Filter AND logic</li> <li>Performance with complex queries</li> </ol>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#phase-2-high-priority-before-release-candidate","title":"Phase 2: High Priority (Before Release Candidate)","text":"<ol> <li>Scene Numeric Filters (<code>scene-numeric-filters.integration.test.ts</code>)</li> <li><code>rating100</code> with EQUALS, GREATER_THAN, LESS_THAN, BETWEEN</li> <li><code>o_counter</code> range</li> <li><code>play_count</code> range</li> <li><code>duration</code> range</li> <li><code>performer_count</code> range</li> <li> <p><code>tag_count</code> range</p> </li> <li> <p>Scene Video Filters (<code>scene-video-filters.integration.test.ts</code>)</p> </li> <li><code>resolution</code> with modifiers</li> <li><code>bitrate</code> range</li> <li><code>framerate</code> range</li> <li><code>orientation</code> (LANDSCAPE/PORTRAIT/SQUARE)</li> <li><code>video_codec</code> text match</li> <li> <p><code>audio_codec</code> text match</p> </li> <li> <p>Performer Age Filter (<code>performer-age-filter.integration.test.ts</code>)</p> </li> <li> <p><code>performer_age</code> with age calculation from birthdate</p> </li> <li> <p>Text Search Filters (<code>text-search.integration.test.ts</code>)</p> <ul> <li>Scene title search</li> <li>Scene details search</li> <li>Performer name search</li> <li>Studio name search</li> </ul> </li> </ol>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#phase-3-medium-priority-before-ga","title":"Phase 3: Medium Priority (Before GA)","text":"<ol> <li> <p>Performer Filters (<code>performer-filters.integration.test.ts</code>)</p> <ul> <li>All 16 performer filter options</li> <li>Gender filtering</li> <li>Physical attribute filtering</li> </ul> </li> <li> <p>Gallery Filters (<code>gallery-filters.integration.test.ts</code>)</p> <ul> <li>All 7 gallery filter options</li> <li>Performer/studio/tag filtering</li> </ul> </li> <li> <p>Group Filters (<code>group-filters.integration.test.ts</code>)</p> <ul> <li>All 13 group filter options</li> <li>Director, synopsis search</li> </ul> </li> <li> <p>Studio Filters (<code>studio-filters.integration.test.ts</code>)</p> <ul> <li>All 10 studio filter options</li> </ul> </li> <li> <p>Tag Filters (<code>tag-filters.integration.test.ts</code>)</p> <ul> <li>All 11 tag filter options</li> <li>Entity relationship counts</li> </ul> </li> <li> <p>Image Filters (<code>image-filters.integration.test.ts</code>)</p> <ul> <li>Basic image filtering via ImageQueryBuilder</li> </ul> </li> <li> <p>Sort Options (<code>sort-options.integration.test.ts</code>)</p> <ul> <li>All 20+ sort fields</li> <li>ASC/DESC direction</li> <li>Scene index with groups</li> </ul> </li> <li> <p>Pagination Edge Cases (<code>pagination-edge-cases.integration.test.ts</code>)</p> <ul> <li>Various per_page values (1, 10, 100, 1000)</li> <li>Empty result sets</li> <li>Last page handling</li> <li>Beyond-range page numbers</li> </ul> </li> </ol>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#phase-4-enhancement-post-release","title":"Phase 4: Enhancement (Post Release)","text":"<ol> <li>Performance testing with large datasets</li> <li>Complex filter combinations (3+ filters)</li> <li>Filter preset save/load</li> <li>Unit preference conversions</li> </ol>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#test-entity-requirements","title":"Test Entity Requirements","text":"<p>Need to add to <code>testEntities.ts</code>: <pre><code>export const TEST_ENTITIES = {\n  // Existing\n  sceneWithRelations: \"31339\",\n  performerWithScenes: \"443\",\n  studioWithScenes: \"13\",\n  tagWithEntities: \"74\",\n  groupWithScenes: \"161\",\n  galleryWithImages: \"803\",\n\n  // Need to add for filter testing\n  sceneWithHighRating: \"TBD\",      // Scene with rating &gt;= 80\n  sceneWithLowRating: \"TBD\",       // Scene with rating &lt;= 20\n  sceneFromLastWeek: \"TBD\",        // Recently created scene\n  sceneFromLastYear: \"TBD\",        // Older scene\n  performerWithAge: \"TBD\",         // Performer with birthdate set\n  tagParentWithChildren: \"TBD\",    // Tag with child tags\n  tagChildOfParent: \"TBD\",         // Child tag\n  landscapeScene: \"TBD\",           // Scene with landscape orientation\n  portraitScene: \"TBD\",            // Scene with portrait orientation\n  h264Scene: \"TBD\",                // Scene with H.264 codec\n  hevcScene: \"TBD\",                // Scene with HEVC codec\n};\n</code></pre></p>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#file-structure","title":"File Structure","text":"<pre><code>server/integration/\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 auth.integration.test.ts          # Existing\n\u2502   \u251c\u2500\u2500 health.integration.test.ts        # Existing\n\u2502   \u251c\u2500\u2500 scenes.integration.test.ts        # Existing - basic\n\u2502   \u251c\u2500\u2500 performers.integration.test.ts    # Existing - basic\n\u2502   \u251c\u2500\u2500 studios.integration.test.ts       # Existing - basic\n\u2502   \u251c\u2500\u2500 tags.integration.test.ts          # Existing - basic\n\u2502   \u251c\u2500\u2500 groups.integration.test.ts        # Existing - basic\n\u2502   \u251c\u2500\u2500 galleries.integration.test.ts     # Existing - basic\n\u2502   \u251c\u2500\u2500 images.integration.test.ts        # Existing - basic\n\u2502   \u251c\u2500\u2500 content-restrictions.integration.test.ts  # Existing - comprehensive\n\u2502   \u2502\n\u2502   \u2502 # Phase 1 - Critical\n\u2502   \u251c\u2500\u2500 scene-favorite-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 scene-date-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 scene-tag-hierarchy.integration.test.ts\n\u2502   \u251c\u2500\u2500 exclusion-application.integration.test.ts\n\u2502   \u251c\u2500\u2500 random-sort.integration.test.ts\n\u2502   \u251c\u2500\u2500 combined-filters.integration.test.ts\n\u2502   \u2502\n\u2502   \u2502 # Phase 2 - High Priority\n\u2502   \u251c\u2500\u2500 scene-numeric-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 scene-video-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 performer-age-filter.integration.test.ts\n\u2502   \u251c\u2500\u2500 text-search.integration.test.ts\n\u2502   \u2502\n\u2502   \u2502 # Phase 3 - Medium Priority\n\u2502   \u251c\u2500\u2500 performer-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 gallery-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 group-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 studio-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 tag-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 image-filters.integration.test.ts\n\u2502   \u251c\u2500\u2500 sort-options.integration.test.ts\n\u2502   \u2514\u2500\u2500 pagination-edge-cases.integration.test.ts\n\u251c\u2500\u2500 fixtures/\n\u2502   \u2514\u2500\u2500 testEntities.ts                   # Needs expansion\n\u2514\u2500\u2500 helpers/\n    \u251c\u2500\u2500 testClient.ts\n    \u251c\u2500\u2500 config.ts\n    \u251c\u2500\u2500 globalSetup.ts\n    \u2514\u2500\u2500 testSetup.ts\n</code></pre>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#api-request-format-reference","title":"API Request Format Reference","text":""},{"location":"plans/2026-01-04-integration-test-expansion-plan/#scene-filter-request","title":"Scene Filter Request","text":"<pre><code>{\n  filter: {\n    page: 1,\n    per_page: 40,\n    sort: \"created_at\",\n    direction: \"DESC\"\n  },\n  scene_filter: {\n    // Entity filters\n    performers: { value: [\"123\"], modifier: \"INCLUDES\" },\n    studios: { value: [\"456\"], modifier: \"INCLUDES\", depth: 2 },\n    tags: { value: [\"789\"], modifier: \"INCLUDES_ALL\", depth: 3 },\n    groups: { value: [\"101\"], modifier: \"EXCLUDES\" },\n\n    // Boolean filters\n    favorite: true,\n    performer_favorite: true,\n    studio_favorite: true,\n    tag_favorite: true,\n\n    // Numeric range filters\n    rating100: { value: 80, modifier: \"GREATER_THAN\" },\n    o_counter: { value: 1, value2: 10, modifier: \"BETWEEN\" },\n    duration: { value: 600, modifier: \"GREATER_THAN\" },\n\n    // Date range filters\n    date: { value: \"2024-01-01\", value2: \"2024-12-31\", modifier: \"BETWEEN\" },\n    created_at: { value: \"2024-06-01\", modifier: \"GREATER_THAN\" },\n\n    // Video filters\n    resolution: { value: \"1080\", modifier: \"GREATER_THAN\" },\n    orientation: \"LANDSCAPE\",\n    video_codec: { value: \"hevc\", modifier: \"INCLUDES\" }\n  }\n}\n</code></pre>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#fetch-by-id","title":"Fetch by ID","text":"<pre><code>{\n  ids: [\"31339\", \"31340\"]\n}\n</code></pre>"},{"location":"plans/2026-01-04-integration-test-expansion-plan/#notes","title":"Notes","text":"<ul> <li>Each test file should have <code>beforeAll</code> to login <code>adminClient</code></li> <li>Use correct response format: <code>response.data.findScenes.scenes</code></li> <li>Use correct request format: <code>{ filter: {...}, scene_filter: {...} }</code></li> <li>Test both positive cases (filter returns expected) and negative cases (filter excludes expected)</li> <li>Run full suite after each new test file: <code>npm run test:integration</code></li> </ul>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/","title":"Integration Test Failures Analysis","text":"<p>Date: 2026-01-04 Status: RESOLVED Final Results: 76 passed, 0 failed</p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#summary","title":"Summary","text":"<p>The original test run showed 46 passed, 30 failed. After investigation, all 30 failures were test implementation issues, not application bugs. The tests have been fixed and all 76 tests now pass.</p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issues-found-and-fixed","title":"Issues Found and Fixed","text":""},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issue-1-adminclient-singleton-not-shared-across-processes","title":"Issue 1: adminClient Singleton Not Shared Across Processes","text":"<p>Root Cause: Vitest's <code>globalSetup.ts</code> runs in a separate process from the test workers. The <code>adminClient.login()</code> call in globalSetup authenticated a different instance than the one imported by test files.</p> <p>Fix: Added <code>beforeAll(async () =&gt; { await adminClient.login(...) })</code> to each test file that uses <code>adminClient</code>.</p> <p>Files Changed: - <code>integration/api/scenes.integration.test.ts</code> - <code>integration/api/performers.integration.test.ts</code> - <code>integration/api/studios.integration.test.ts</code> - <code>integration/api/tags.integration.test.ts</code> - <code>integration/api/galleries.integration.test.ts</code> - <code>integration/api/groups.integration.test.ts</code> - <code>integration/api/images.integration.test.ts</code></p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issue-2-incorrect-api-response-format-expectations","title":"Issue 2: Incorrect API Response Format Expectations","text":"<p>Root Cause: Tests expected <code>response.data.scenes</code> but the API returns <code>response.data.findScenes.scenes</code>.</p> <p>API Response Formats: | Endpoint | Response Format | |----------|-----------------| | <code>/api/library/scenes</code> | <code>{ findScenes: { count, scenes } }</code> | | <code>/api/library/performers</code> | <code>{ findPerformers: { count, performers } }</code> | | <code>/api/library/studios</code> | <code>{ findStudios: { count, studios } }</code> | | <code>/api/library/tags</code> | <code>{ findTags: { count, tags } }</code> | | <code>/api/library/galleries</code> | <code>{ findGalleries: { count, galleries } }</code> | | <code>/api/library/groups</code> | <code>{ findGroups: { count, groups } }</code> | | <code>/api/library/images</code> | <code>{ findImages: { count, images } }</code> | | <code>/api/library/*/minimal</code> | <code>{ &lt;entities&gt;: [...] }</code> (no wrapper) |</p> <p>Fix: Updated all test files to use correct response paths.</p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issue-3-incorrect-request-body-format","title":"Issue 3: Incorrect Request Body Format","text":"<p>Root Cause: Tests sent <code>{ page: 1, per_page: 10 }</code> but the API expects <code>{ filter: { page: 1, per_page: 10 } }</code>.</p> <p>Correct Request Formats: ```typescript // Pagination { filter: { page: 1, per_page: 10, sort: \"created_at\", direction: \"DESC\" } }</p> <p>// Filtering by entity { filter: { per_page: 50 }, scene_filter: { performers: { value: [\"123\"], modifier: \"INCLUDES\" } } }</p> <p>// Fetch by ID { ids: [\"123\", \"456\"] } ```</p> <p>Fix: Updated test requests to use the correct nested structure.</p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issue-4-role-case-mismatch","title":"Issue 4: Role Case Mismatch","text":"<p>Root Cause: Tests expected lowercase <code>\"admin\"</code> but the API returns uppercase <code>\"ADMIN\"</code> (matching Prisma enum).</p> <p>Fix: Changed <code>expect(role).toBe(\"admin\")</code> to <code>expect(role).toBe(\"ADMIN\")</code>.</p> <p>Files Changed: - <code>integration/api/auth.integration.test.ts</code></p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#issue-5-wrong-route-paths","title":"Issue 5: Wrong Route Paths","text":"<p>Root Cause: Tests called <code>/api/scenes</code> but the actual routes are at <code>/api/library/scenes</code>.</p> <p>Fix: Updated route paths in protected routes authentication tests.</p> <p>Files Changed: - <code>integration/api/auth.integration.test.ts</code></p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#verification","title":"Verification","text":"<p>After all fixes, the full test suite passes:</p> <p>``` Test Files  10 passed (10) Tests       76 passed (76) ```</p>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#lessons-learned","title":"Lessons Learned","text":"<ol> <li> <p>Vitest globalSetup runs in a separate process - Module singletons don't share state with test workers. Use <code>beforeAll</code> in test files for setup that requires shared state.</p> </li> <li> <p>Test against actual API contracts - Before writing tests, verify the actual request/response format by checking:</p> </li> <li>Controller code (<code>res.json(...)</code> calls)</li> <li>Frontend API service calls</li> <li> <p>TypeScript types</p> </li> <li> <p>Integration tests successfully validated the infrastructure - Even though the failures were test issues, the process of fixing them verified that:</p> </li> <li>The test server starts correctly</li> <li>Database migrations work</li> <li>Authentication flows correctly</li> <li>Stash sync completes</li> <li>Library endpoints return data</li> </ol>"},{"location":"plans/2026-01-04-integration-test-failures-analysis/#no-application-bugs-found","title":"No Application Bugs Found","text":"<p>The integration test infrastructure is working correctly. All 30 \"failures\" were due to incorrect test implementation, not application bugs.</p> <p>The pre-release skill (`/pre-release`) can now be used with confidence - if tests fail, they're detecting real issues.</p>"},{"location":"plans/2026-01-04-integration-testing-design/","title":"Integration Testing Infrastructure Design","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add API integration tests that validate Peek works correctly against a real Stash server.</p> <p>Architecture: Spin up a real Express server, make HTTP requests against it, validate responses. Tests run against a persistent SQLite database synced from the user's Stash.</p> <p>Tech Stack: Vitest, native fetch, existing Express app</p>"},{"location":"plans/2026-01-04-integration-testing-design/#critical-principle-tests-expose-real-bugs","title":"Critical Principle: Tests Expose Real Bugs","text":"<p>When an integration test fails: 1. Assume the test is right - It's checking real behavior against real data 2. Investigate the failure - Don't modify the test to make it pass 3. Fix the application code - If the test reveals a bug, fix the bug 4. Only adjust the test if - The test itself has a logic error or wrong assumptions</p> <p>Integration tests hit real APIs with real data. Failures are likely real bugs that need fixing, not tests that need adjusting.</p>"},{"location":"plans/2026-01-04-integration-testing-design/#architecture-overview","title":"Architecture Overview","text":""},{"location":"plans/2026-01-04-integration-testing-design/#directory-structure","title":"Directory Structure","text":"<pre><code>server/\n\u251c\u2500\u2500 tests/                    # Existing unit tests\n\u251c\u2500\u2500 integration/              # New integration tests\n\u2502   \u251c\u2500\u2500 setup/                # Fresh DB setup tests\n\u2502   \u2502   \u2514\u2500\u2500 initialSetup.test.ts\n\u2502   \u251c\u2500\u2500 api/                  # API endpoint tests\n\u2502   \u2502   \u251c\u2500\u2500 scenes.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 performers.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 studios.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 tags.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 groups.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 galleries.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 images.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 auth.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 contentRestrictions.test.ts\n\u2502   \u2502   \u251c\u2500\u2500 hiddenEntities.test.ts\n\u2502   \u2502   \u2514\u2500\u2500 playlists.test.ts\n\u2502   \u251c\u2500\u2500 fixtures/\n\u2502   \u2502   \u251c\u2500\u2500 testEntities.ts          # Gitignored - user's entity IDs\n\u2502   \u2502   \u2514\u2500\u2500 testEntities.example.ts  # Template showing structure\n\u2502   \u251c\u2500\u2500 helpers/\n\u2502   \u2502   \u251c\u2500\u2500 globalSetup.ts     # Starts server before tests\n\u2502   \u2502   \u251c\u2500\u2500 globalTeardown.ts  # Stops server after tests\n\u2502   \u2502   \u251c\u2500\u2500 testClient.ts      # HTTP client with auth\n\u2502   \u2502   \u2514\u2500\u2500 dbSetup.ts         # DB initialization helpers\n\u2502   \u251c\u2500\u2500 test.db                # Gitignored - persistent test database\n\u2502   \u2514\u2500\u2500 vitest.integration.config.ts\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#configuration-secrets","title":"Configuration &amp; Secrets","text":""},{"location":"plans/2026-01-04-integration-testing-design/#environment-variables","title":"Environment Variables","text":"<p>Tests reuse existing <code>.env</code> file (already gitignored): - <code>STASH_URL</code> - Stash server URL - <code>STASH_API_KEY</code> - Stash API key</p> <p>Test-specific overrides in <code>integration/.env.integration</code> (gitignored).</p>"},{"location":"plans/2026-01-04-integration-testing-design/#gitignore-additions","title":"Gitignore Additions","text":"<pre><code># Integration test secrets and data\nserver/integration/.env.integration\nserver/integration/fixtures/testEntities.ts\nserver/integration/*.db\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#test-entities-template","title":"Test Entities Template","text":"<p><code>testEntities.example.ts</code> (committed): <pre><code>// Copy to testEntities.ts and fill in IDs from your Stash\nexport const TEST_ENTITIES = {\n  // A scene that exists and has performers, tags, studio\n  sceneWithRelations: \"12345\",\n  // A performer with multiple scenes\n  performerWithScenes: \"67\",\n  // A tag used on multiple entities\n  commonTag: \"89\",\n  // A studio with scenes\n  studioWithScenes: \"12\",\n  // A group with scenes\n  groupWithScenes: \"34\",\n  // A gallery with images\n  galleryWithImages: \"56\",\n  // A tag to use for content restriction tests\n  restrictableTag: \"78\",\n};\n</code></pre></p>"},{"location":"plans/2026-01-04-integration-testing-design/#test-execution-flow","title":"Test Execution Flow","text":""},{"location":"plans/2026-01-04-integration-testing-design/#npm-scripts","title":"NPM Scripts","text":"<pre><code>{\n  \"test:integration\": \"vitest run --config integration/vitest.integration.config.ts\",\n  \"test:integration:watch\": \"vitest --config integration/vitest.integration.config.ts\",\n  \"test:integration:fresh\": \"FRESH_DB=true npm run test:integration\"\n}\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#standard-run-npm-run-testintegration","title":"Standard Run (<code>npm run test:integration</code>)","text":"<ol> <li>Loads <code>.env</code> from project root</li> <li>Uses persistent <code>integration/test.db</code></li> <li>If DB doesn't exist, runs setup automatically (create admin, connect Stash, sync)</li> <li>Starts Express server on port 9999</li> <li>Runs all integration tests</li> <li>Stops server</li> <li>Test users created during tests are cleaned up; admin and synced data persist</li> </ol>"},{"location":"plans/2026-01-04-integration-testing-design/#fresh-run-npm-run-testintegrationfresh","title":"Fresh Run (<code>npm run test:integration:fresh</code>)","text":"<ol> <li>Deletes <code>integration/test.db</code> if exists</li> <li>Runs setup test suite first (tests the setup wizard flow)</li> <li>Then runs all other integration tests</li> </ol>"},{"location":"plans/2026-01-04-integration-testing-design/#test-lifecycle","title":"Test Lifecycle","text":"<ul> <li>Before each test file: Creates a test user for isolation</li> <li>After each test file: Cleans up test user and test-specific data</li> <li>Global setup: Validates Stash reachable, starts server</li> <li>Global teardown: Stops server</li> </ul>"},{"location":"plans/2026-01-04-integration-testing-design/#test-server-http-client","title":"Test Server &amp; HTTP Client","text":""},{"location":"plans/2026-01-04-integration-testing-design/#global-setup","title":"Global Setup","text":"<pre><code>// integration/helpers/globalSetup.ts\nexport async function setup() {\n  // 1. Set DATABASE_URL to integration/test.db\n  // 2. Run prisma migrations if needed\n  // 3. If FRESH_DB or DB empty, run initial setup\n  // 4. Start Express server on port 9999\n  // 5. Export base URL for tests\n}\n\nexport async function teardown() {\n  // Stop Express server\n}\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#test-client","title":"Test Client","text":"<pre><code>// integration/helpers/testClient.ts\nexport class TestClient {\n  private baseUrl: string;\n  private token?: string;\n\n  async login(username: string, password: string): Promise&lt;void&gt;;\n  async get&lt;T&gt;(path: string): Promise&lt;{ status: number; data: T }&gt;;\n  async post&lt;T&gt;(path: string, body: object): Promise&lt;{ status: number; data: T }&gt;;\n  async put&lt;T&gt;(path: string, body: object): Promise&lt;{ status: number; data: T }&gt;;\n  async delete&lt;T&gt;(path: string): Promise&lt;{ status: number; data: T }&gt;;\n}\n\n// Pre-configured instances\nexport const adminClient: TestClient;  // Logged in as admin\nexport const guestClient: TestClient;  // No auth\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#test-priority-tiers","title":"Test Priority Tiers","text":""},{"location":"plans/2026-01-04-integration-testing-design/#tier-1-critical-initial-implementation","title":"Tier 1 - Critical (Initial Implementation)","text":"<ol> <li>Stash connection &amp; sync - Data comes through correctly</li> <li>All entity queries - scenes, performers, studios, tags, groups, galleries, images</li> <li>Basic filters - performer, studio, tag filters work across entities</li> <li>Authentication - login/logout, protected routes reject unauthenticated</li> <li>Content restrictions - excluded content doesn't appear in results</li> </ol>"},{"location":"plans/2026-01-04-integration-testing-design/#tier-2-important-second-phase","title":"Tier 2 - Important (Second Phase)","text":"<ol> <li>Pagination - page/per_page parameters work correctly</li> <li>Sorting - different sort options return correctly ordered results</li> <li>Similar scenes - recommendations return relevant results</li> <li>User hidden entities - hiding works, cascades correctly</li> <li>Playlist operations - CRUD, adding/removing items</li> </ol>"},{"location":"plans/2026-01-04-integration-testing-design/#tier-3-nice-to-have-future","title":"Tier 3 - Nice to Have (Future)","text":"<ol> <li>Watch history tracking</li> <li>Ratings/favorites sync to Stash</li> <li>Custom carousels</li> <li>O-counter updates</li> </ol>"},{"location":"plans/2026-01-04-integration-testing-design/#pre-release-command","title":"Pre-Release Command","text":"<p>New skill at <code>.claude/skills/pre-release.md</code>:</p> <pre><code>---\nname: pre-release\ndescription: Run all validation checks before tagging a release\n---\n\n# Pre-Release Checks\n\n## Steps\n\n1. Run server unit tests: `cd server &amp;&amp; npm test`\n2. Run server linter: `cd server &amp;&amp; npm run lint`\n3. Run client unit tests: `cd client &amp;&amp; npm test`\n4. Run client linter: `cd client &amp;&amp; npm run lint`\n5. Run integration tests: `cd server &amp;&amp; npm run test:integration`\n6. Build client: `cd client &amp;&amp; npm run build`\n7. Build production Docker image: `docker build -f Dockerfile.production -t peek:test .`\n8. Report results summary\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#claudemd-documentation","title":"CLAUDE.md Documentation","text":"<p>Add to CLAUDE.md:</p> <pre><code>### Integration Testing\n\nIntegration tests run against a real Stash server to validate API functionality.\n\n**Setup (first time):**\n1. Ensure `.env` has `STASH_URL` and `STASH_API_KEY`\n2. Copy `server/integration/fixtures/testEntities.example.ts` to `testEntities.ts`\n3. Fill in entity IDs from your Stash library\n\n**Running tests:**\n- `npm run test:integration` - Run against persistent test DB\n- `npm run test:integration:fresh` - Reset DB and test setup flow\n- `npm run test:integration:watch` - Watch mode for development\n\n**Pre-release:**\nRun `/pre-release` to execute all validation checks before tagging a release.\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-design/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Tests use the user's real Stash server (read-only for most operations)</li> <li>Write operations (ratings, favorites, O-counters) use consistent test entities</li> <li>No Dockerized test Stash - too much infrastructure for marginal benefit</li> <li>Server runs directly via Node.js, not in Docker during tests</li> <li>Persistent DB avoids slow Stash sync on every test run</li> </ul>"},{"location":"plans/2026-01-04-integration-testing-implementation/","title":"Integration Testing Infrastructure Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add API integration tests that validate Peek works correctly against a real Stash server.</p> <p>Architecture: Vitest with separate config for integration tests, Express server started in globalSetup, HTTP client wrapper for authenticated requests, persistent SQLite test database.</p> <p>Tech Stack: Vitest, native fetch, Express, Prisma, existing app code</p>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-1-create-integration-test-directory-structure","title":"Task 1: Create Integration Test Directory Structure","text":"<p>Files: - Create: <code>server/integration/vitest.integration.config.ts</code> - Create: <code>server/integration/helpers/globalSetup.ts</code> - Create: <code>server/integration/helpers/globalTeardown.ts</code> - Create: <code>server/integration/fixtures/testEntities.example.ts</code> - Modify: <code>server/package.json</code> (add scripts) - Modify: <code>.gitignore</code> (add integration test files)</p> <p>Step 1: Create Vitest integration config</p> <p>Create <code>server/integration/vitest.integration.config.ts</code>:</p> <pre><code>import { defineConfig } from \"vitest/config\";\nimport path from \"path\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: \"node\",\n    include: [\"**/*.integration.test.ts\"],\n    exclude: [\"node_modules\", \"dist\"],\n    globalSetup: \"./helpers/globalSetup.ts\",\n    globalTeardown: \"./helpers/globalTeardown.ts\",\n    testTimeout: 30000, // 30s for integration tests\n    hookTimeout: 60000, // 60s for setup/teardown hooks\n    fileParallelism: false, // Run sequentially\n    root: path.resolve(__dirname),\n  },\n});\n</code></pre> <p>Step 2: Create placeholder globalSetup</p> <p>Create <code>server/integration/helpers/globalSetup.ts</code>:</p> <pre><code>export async function setup() {\n  console.log(\"[Integration Tests] Global setup - placeholder\");\n}\n\nexport default setup;\n</code></pre> <p>Step 3: Create placeholder globalTeardown</p> <p>Create <code>server/integration/helpers/globalTeardown.ts</code>:</p> <pre><code>export async function teardown() {\n  console.log(\"[Integration Tests] Global teardown - placeholder\");\n}\n\nexport default teardown;\n</code></pre> <p>Step 4: Create test entities example file</p> <p>Create <code>server/integration/fixtures/testEntities.example.ts</code>:</p> <pre><code>/**\n * Test Entity IDs\n *\n * Copy this file to testEntities.ts and fill in IDs from your Stash library.\n * These entities are used by integration tests to validate API behavior.\n *\n * Requirements:\n * - sceneWithRelations: A scene that has performers, tags, and a studio\n * - performerWithScenes: A performer that appears in multiple scenes\n * - studioWithScenes: A studio with multiple scenes\n * - tagWithEntities: A tag used on scenes, performers, or studios\n * - groupWithScenes: A group/collection containing scenes\n * - galleryWithImages: A gallery containing images\n * - restrictableTag: A tag that can be used for content restriction tests\n */\nexport const TEST_ENTITIES = {\n  sceneWithRelations: \"REPLACE_WITH_SCENE_ID\",\n  performerWithScenes: \"REPLACE_WITH_PERFORMER_ID\",\n  studioWithScenes: \"REPLACE_WITH_STUDIO_ID\",\n  tagWithEntities: \"REPLACE_WITH_TAG_ID\",\n  groupWithScenes: \"REPLACE_WITH_GROUP_ID\",\n  galleryWithImages: \"REPLACE_WITH_GALLERY_ID\",\n  restrictableTag: \"REPLACE_WITH_TAG_ID_FOR_RESTRICTIONS\",\n};\n\n/**\n * Test Admin Credentials\n *\n * These are used to create/login the test admin user.\n * The integration test setup will create this user if it doesn't exist.\n */\nexport const TEST_ADMIN = {\n  username: \"integration_admin\",\n  password: \"integration_test_password_123\",\n};\n</code></pre> <p>Step 5: Add npm scripts to package.json</p> <p>Modify <code>server/package.json</code>, add to scripts:</p> <pre><code>\"test:integration\": \"vitest run --config integration/vitest.integration.config.ts\",\n\"test:integration:watch\": \"vitest --config integration/vitest.integration.config.ts\",\n\"test:integration:fresh\": \"FRESH_DB=true npm run test:integration\"\n</code></pre> <p>Step 6: Update .gitignore</p> <p>Add to <code>.gitignore</code>:</p> <pre><code># Integration test secrets and data\nserver/integration/fixtures/testEntities.ts\nserver/integration/*.db\nserver/integration/.env.integration\n</code></pre> <p>Step 7: Run vitest to verify config works</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: \"No test files found\" or empty test run (no errors about config)</p> <p>Step 8: Commit</p> <pre><code>git add server/integration/ server/package.json .gitignore\ngit commit -m \"feat(tests): add integration test directory structure and config\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-2-create-test-http-client","title":"Task 2: Create Test HTTP Client","text":"<p>Files: - Create: <code>server/integration/helpers/testClient.ts</code> - Create: <code>server/integration/helpers/config.ts</code></p> <p>Step 1: Create config helper</p> <p>Create <code>server/integration/helpers/config.ts</code>:</p> <pre><code>import path from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport const TEST_CONFIG = {\n  serverPort: 9999,\n  get baseUrl() {\n    return `http://localhost:${this.serverPort}`;\n  },\n  get databasePath() {\n    return path.resolve(__dirname, \"../test.db\");\n  },\n  get databaseUrl() {\n    return `file:${this.databasePath}`;\n  },\n};\n</code></pre> <p>Step 2: Create TestClient class</p> <p>Create <code>server/integration/helpers/testClient.ts</code>:</p> <pre><code>import { TEST_CONFIG } from \"./config.js\";\n\ninterface RequestOptions {\n  headers?: Record&lt;string, string&gt;;\n}\n\ninterface ApiResponse&lt;T&gt; {\n  status: number;\n  data: T;\n  ok: boolean;\n}\n\nexport class TestClient {\n  private token?: string;\n  private baseUrl: string;\n\n  constructor(baseUrl: string = TEST_CONFIG.baseUrl) {\n    this.baseUrl = baseUrl;\n  }\n\n  async login(username: string, password: string): Promise&lt;void&gt; {\n    const response = await fetch(`${this.baseUrl}/api/auth/login`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ username, password }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Login failed: ${response.status} ${await response.text()}`);\n    }\n\n    // Extract token from Set-Cookie header\n    const setCookie = response.headers.get(\"set-cookie\");\n    if (setCookie) {\n      const tokenMatch = setCookie.match(/token=([^;]+)/);\n      if (tokenMatch) {\n        this.token = tokenMatch[1];\n      }\n    }\n\n    // Also check response body for token (some auth flows return it there)\n    const data = await response.json();\n    if (data.token) {\n      this.token = data.token;\n    }\n  }\n\n  setToken(token: string): void {\n    this.token = token;\n  }\n\n  clearToken(): void {\n    this.token = undefined;\n  }\n\n  private getHeaders(options?: RequestOptions): Record&lt;string, string&gt; {\n    const headers: Record&lt;string, string&gt; = {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    };\n\n    if (this.token) {\n      headers[\"Cookie\"] = `token=${this.token}`;\n    }\n\n    return headers;\n  }\n\n  async get&lt;T = unknown&gt;(path: string, options?: RequestOptions): Promise&lt;ApiResponse&lt;T&gt;&gt; {\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      method: \"GET\",\n      headers: this.getHeaders(options),\n    });\n\n    const data = await response.json().catch(() =&gt; ({}));\n    return {\n      status: response.status,\n      data: data as T,\n      ok: response.ok,\n    };\n  }\n\n  async post&lt;T = unknown&gt;(path: string, body?: object, options?: RequestOptions): Promise&lt;ApiResponse&lt;T&gt;&gt; {\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      method: \"POST\",\n      headers: this.getHeaders(options),\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    const data = await response.json().catch(() =&gt; ({}));\n    return {\n      status: response.status,\n      data: data as T,\n      ok: response.ok,\n    };\n  }\n\n  async put&lt;T = unknown&gt;(path: string, body?: object, options?: RequestOptions): Promise&lt;ApiResponse&lt;T&gt;&gt; {\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      method: \"PUT\",\n      headers: this.getHeaders(options),\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    const data = await response.json().catch(() =&gt; ({}));\n    return {\n      status: response.status,\n      data: data as T,\n      ok: response.ok,\n    };\n  }\n\n  async delete&lt;T = unknown&gt;(path: string, options?: RequestOptions): Promise&lt;ApiResponse&lt;T&gt;&gt; {\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      method: \"DELETE\",\n      headers: this.getHeaders(options),\n    });\n\n    const data = await response.json().catch(() =&gt; ({}));\n    return {\n      status: response.status,\n      data: data as T,\n      ok: response.ok,\n    };\n  }\n}\n\n// Singleton instances for common use cases\nexport const adminClient = new TestClient();\nexport const guestClient = new TestClient();\n</code></pre> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to integration test files</p> <p>Step 4: Commit</p> <pre><code>git add server/integration/helpers/\ngit commit -m \"feat(tests): add TestClient HTTP helper for integration tests\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-3-implement-global-setup-server-startup","title":"Task 3: Implement Global Setup (Server Startup)","text":"<p>Files: - Modify: <code>server/integration/helpers/globalSetup.ts</code> - Create: <code>server/integration/helpers/serverManager.ts</code> - Modify: <code>server/initializers/api.ts</code> (export app separately from listen)</p> <p>Step 1: Refactor api.ts to export app without starting</p> <p>Modify <code>server/initializers/api.ts</code>. Change the end of the file (around line 150-161):</p> <p>Find: <pre><code>  // Start API server immediately so /api/setup/status is available\n  app.listen(8000, () =&gt; {\n    logger.info(\"Server is running\", {\n      url: \"http://localhost:8000\",\n      transcodingSystem: \"session-based\",\n    });\n  });\n\n  logger.info(\"Server started - accepting connections during cache load\");\n\n  return app;\n};\n</code></pre></p> <p>Replace with: <pre><code>  return app;\n};\n\n/**\n * Start the API server on the specified port.\n * Separated from setupAPI() to allow integration tests to start on a different port.\n */\nexport const startServer = (app: ReturnType&lt;typeof setupAPI&gt;, port: number = 8000) =&gt; {\n  return app.listen(port, () =&gt; {\n    logger.info(\"Server is running\", {\n      url: `http://localhost:${port}`,\n      transcodingSystem: \"session-based\",\n    });\n  });\n};\n</code></pre></p> <p>Step 2: Update index.ts to use startServer</p> <p>Modify <code>server/index.ts</code>, find where <code>setupAPI()</code> is called (around line 46):</p> <p>Find: <pre><code>  // Start API server (needed for setup wizard if no Stash configured)\n  setupAPI();\n</code></pre></p> <p>Replace with: <pre><code>  import { startServer } from \"./initializers/api.js\";\n  // ... (at top of file, add to existing imports)\n\n  // Start API server (needed for setup wizard if no Stash configured)\n  const app = setupAPI();\n  startServer(app, 8000);\n</code></pre></p> <p>Actually, let's be more careful. Find the import line: <pre><code>import { setupAPI } from \"./initializers/api.js\";\n</code></pre></p> <p>Replace with: <pre><code>import { setupAPI, startServer } from \"./initializers/api.js\";\n</code></pre></p> <p>Then find: <pre><code>  setupAPI();\n</code></pre></p> <p>Replace with: <pre><code>  const app = setupAPI();\n  startServer(app);\n</code></pre></p> <p>Step 3: Create serverManager helper</p> <p>Create <code>server/integration/helpers/serverManager.ts</code>:</p> <pre><code>import type { Server } from \"http\";\n\n// Store server instance globally for teardown\nlet serverInstance: Server | null = null;\n\nexport function setServerInstance(server: Server): void {\n  serverInstance = server;\n}\n\nexport function getServerInstance(): Server | null {\n  return serverInstance;\n}\n\nexport async function stopServer(): Promise&lt;void&gt; {\n  if (serverInstance) {\n    return new Promise((resolve, reject) =&gt; {\n      serverInstance!.close((err) =&gt; {\n        if (err) {\n          reject(err);\n        } else {\n          serverInstance = null;\n          resolve();\n        }\n      });\n    });\n  }\n}\n</code></pre> <p>Step 4: Implement globalSetup</p> <p>Replace <code>server/integration/helpers/globalSetup.ts</code>:</p> <pre><code>import dotenv from \"dotenv\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { TEST_CONFIG } from \"./config.js\";\nimport { setServerInstance } from \"./serverManager.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport async function setup() {\n  console.log(\"[Integration Tests] Starting global setup...\");\n\n  // Load environment from project root\n  const envPath = path.resolve(__dirname, \"../../../.env\");\n  if (!fs.existsSync(envPath)) {\n    throw new Error(`Missing .env file at ${envPath}. Integration tests require STASH_URL and STASH_API_KEY.`);\n  }\n  dotenv.config({ path: envPath });\n\n  // Validate required env vars\n  if (!process.env.STASH_URL || !process.env.STASH_API_KEY) {\n    throw new Error(\"Integration tests require STASH_URL and STASH_API_KEY in .env\");\n  }\n\n  // Check if testEntities.ts exists\n  const testEntitiesPath = path.resolve(__dirname, \"../fixtures/testEntities.ts\");\n  if (!fs.existsSync(testEntitiesPath)) {\n    throw new Error(\n      `Missing testEntities.ts. Copy testEntities.example.ts to testEntities.ts and fill in entity IDs from your Stash.`\n    );\n  }\n\n  // Set test database URL\n  process.env.DATABASE_URL = TEST_CONFIG.databaseUrl;\n\n  // Handle fresh DB mode\n  if (process.env.FRESH_DB === \"true\" &amp;&amp; fs.existsSync(TEST_CONFIG.databasePath)) {\n    console.log(\"[Integration Tests] FRESH_DB=true, deleting existing test database...\");\n    fs.unlinkSync(TEST_CONFIG.databasePath);\n  }\n\n  // Run prisma migrations\n  console.log(\"[Integration Tests] Running database migrations...\");\n  const { execSync } = await import(\"child_process\");\n  execSync(\"npx prisma db push --skip-generate\", {\n    cwd: path.resolve(__dirname, \"../..\"),\n    env: { ...process.env, DATABASE_URL: TEST_CONFIG.databaseUrl },\n    stdio: \"inherit\",\n  });\n\n  // Import and start the server\n  console.log(\"[Integration Tests] Starting test server on port\", TEST_CONFIG.serverPort);\n\n  // Dynamic import to ensure env vars are set first\n  const { setupAPI, startServer } = await import(\"../../initializers/api.js\");\n  const app = setupAPI();\n  const server = startServer(app, TEST_CONFIG.serverPort);\n\n  setServerInstance(server);\n\n  // Wait for server to be ready\n  await waitForServer();\n\n  console.log(\"[Integration Tests] Global setup complete\");\n}\n\nasync function waitForServer(maxAttempts = 30, delayMs = 500): Promise&lt;void&gt; {\n  for (let i = 0; i &lt; maxAttempts; i++) {\n    try {\n      const response = await fetch(`${TEST_CONFIG.baseUrl}/api/health`);\n      if (response.ok) {\n        console.log(\"[Integration Tests] Server is ready\");\n        return;\n      }\n    } catch {\n      // Server not ready yet\n    }\n    await new Promise((r) =&gt; setTimeout(r, delayMs));\n  }\n  throw new Error(\"Server failed to start within timeout\");\n}\n\nexport default setup;\n</code></pre> <p>Step 5: Implement globalTeardown</p> <p>Replace <code>server/integration/helpers/globalTeardown.ts</code>:</p> <pre><code>import { stopServer } from \"./serverManager.js\";\n\nexport async function teardown() {\n  console.log(\"[Integration Tests] Starting global teardown...\");\n\n  await stopServer();\n\n  console.log(\"[Integration Tests] Global teardown complete\");\n}\n\nexport default teardown;\n</code></pre> <p>Step 6: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 7: Commit</p> <pre><code>git add server/initializers/api.ts server/index.ts server/integration/helpers/\ngit commit -m \"feat(tests): implement integration test server startup and teardown\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-4-add-first-integration-test-health-check","title":"Task 4: Add First Integration Test (Health Check)","text":"<p>Files: - Create: <code>server/integration/api/health.integration.test.ts</code></p> <p>Step 1: Create health check test</p> <p>Create <code>server/integration/api/health.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { guestClient } from \"../helpers/testClient.js\";\n\ndescribe(\"Health API\", () =&gt; {\n  it(\"returns healthy status without authentication\", async () =&gt; {\n    const response = await guestClient.get&lt;{ status: string }&gt;(\"/api/health\");\n\n    expect(response.ok).toBe(true);\n    expect(response.status).toBe(200);\n    expect(response.data.status).toBe(\"healthy\");\n  });\n\n  it(\"returns version without authentication\", async () =&gt; {\n    const response = await guestClient.get&lt;{ server: string }&gt;(\"/api/version\");\n\n    expect(response.ok).toBe(true);\n    expect(response.status).toBe(200);\n    expect(response.data.server).toBeDefined();\n    expect(typeof response.data.server).toBe(\"string\");\n  });\n});\n</code></pre> <p>Step 2: Run the integration test</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass (2 passing)</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/health.integration.test.ts\ngit commit -m \"feat(tests): add first integration test for health endpoint\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-5-add-test-setup-helper-admin-user-initial-sync","title":"Task 5: Add Test Setup Helper (Admin User &amp; Initial Sync)","text":"<p>Files: - Create: <code>server/integration/helpers/testSetup.ts</code> - Modify: <code>server/integration/helpers/globalSetup.ts</code></p> <p>Step 1: Create testSetup helper</p> <p>Create <code>server/integration/helpers/testSetup.ts</code>:</p> <pre><code>import { adminClient } from \"./testClient.js\";\nimport { TEST_CONFIG } from \"./config.js\";\n\ninterface SetupStatus {\n  setupComplete: boolean;\n  hasUsers: boolean;\n  hasStashInstance: boolean;\n}\n\n/**\n * Ensures the test database is set up with an admin user and Stash connection.\n * Only runs the setup if needed (idempotent).\n */\nexport async function ensureTestSetup(): Promise&lt;void&gt; {\n  const status = await getSetupStatus();\n\n  if (status.setupComplete) {\n    console.log(\"[Integration Tests] Setup already complete, logging in admin...\");\n    await loginAdmin();\n    return;\n  }\n\n  console.log(\"[Integration Tests] Running initial setup...\");\n\n  // Step 1: Create admin user if needed\n  if (!status.hasUsers) {\n    console.log(\"[Integration Tests] Creating admin user...\");\n    await createAdminUser();\n  }\n\n  // Step 2: Connect to Stash if needed\n  if (!status.hasStashInstance) {\n    console.log(\"[Integration Tests] Connecting to Stash...\");\n    await connectStash();\n  }\n\n  // Step 3: Login as admin\n  await loginAdmin();\n\n  // Step 4: Wait for initial sync to complete\n  console.log(\"[Integration Tests] Waiting for initial sync...\");\n  await waitForSync();\n\n  console.log(\"[Integration Tests] Setup complete\");\n}\n\nasync function getSetupStatus(): Promise&lt;SetupStatus&gt; {\n  const response = await fetch(`${TEST_CONFIG.baseUrl}/api/setup/status`);\n  if (!response.ok) {\n    throw new Error(`Failed to get setup status: ${response.status}`);\n  }\n  return response.json();\n}\n\nasync function createAdminUser(): Promise&lt;void&gt; {\n  // Import test credentials\n  const { TEST_ADMIN } = await import(\"../fixtures/testEntities.js\");\n\n  const response = await fetch(`${TEST_CONFIG.baseUrl}/api/setup/create-admin`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      username: TEST_ADMIN.username,\n      password: TEST_ADMIN.password,\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Failed to create admin user: ${response.status} ${error}`);\n  }\n}\n\nasync function connectStash(): Promise&lt;void&gt; {\n  // Test connection first\n  const testResponse = await fetch(`${TEST_CONFIG.baseUrl}/api/setup/test-stash-connection`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      url: process.env.STASH_URL,\n      apiKey: process.env.STASH_API_KEY,\n    }),\n  });\n\n  if (!testResponse.ok) {\n    const error = await testResponse.text();\n    throw new Error(`Failed to test Stash connection: ${testResponse.status} ${error}`);\n  }\n\n  // Create the instance\n  const createResponse = await fetch(`${TEST_CONFIG.baseUrl}/api/setup/create-stash-instance`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({\n      name: \"Integration Test Stash\",\n      url: process.env.STASH_URL,\n      apiKey: process.env.STASH_API_KEY,\n    }),\n  });\n\n  if (!createResponse.ok) {\n    const error = await createResponse.text();\n    throw new Error(`Failed to create Stash instance: ${createResponse.status} ${error}`);\n  }\n}\n\nasync function loginAdmin(): Promise&lt;void&gt; {\n  const { TEST_ADMIN } = await import(\"../fixtures/testEntities.js\");\n  await adminClient.login(TEST_ADMIN.username, TEST_ADMIN.password);\n}\n\nasync function waitForSync(maxAttempts = 120, delayMs = 2000): Promise&lt;void&gt; {\n  for (let i = 0; i &lt; maxAttempts; i++) {\n    const response = await adminClient.get&lt;{ isSyncing: boolean }&gt;(\"/api/sync/status\");\n\n    if (response.ok &amp;&amp; !response.data.isSyncing) {\n      // Verify we have data\n      const sceneResponse = await adminClient.post&lt;{ count: number }&gt;(\"/api/library/scenes\", {\n        per_page: 1,\n      });\n\n      if (sceneResponse.ok &amp;&amp; sceneResponse.data.count &gt; 0) {\n        console.log(`[Integration Tests] Sync complete. ${sceneResponse.data.count} scenes available.`);\n        return;\n      }\n    }\n\n    if (i % 10 === 0) {\n      console.log(`[Integration Tests] Waiting for sync... (attempt ${i + 1}/${maxAttempts})`);\n    }\n\n    await new Promise((r) =&gt; setTimeout(r, delayMs));\n  }\n\n  throw new Error(\"Sync did not complete within timeout\");\n}\n</code></pre> <p>Step 2: Update globalSetup to run ensureTestSetup</p> <p>Modify <code>server/integration/helpers/globalSetup.ts</code>, add at the end of the setup function (before the final console.log):</p> <p>Find: <pre><code>  console.log(\"[Integration Tests] Global setup complete\");\n}\n</code></pre></p> <p>Replace with: <pre><code>  // Ensure admin user exists and is logged in\n  const { ensureTestSetup } = await import(\"./testSetup.js\");\n  await ensureTestSetup();\n\n  console.log(\"[Integration Tests] Global setup complete\");\n}\n</code></pre></p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/integration/helpers/\ngit commit -m \"feat(tests): add test setup helper for admin user and initial sync\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-6-add-scene-api-integration-tests","title":"Task 6: Add Scene API Integration Tests","text":"<p>Files: - Create: <code>server/integration/api/scenes.integration.test.ts</code></p> <p>Step 1: Create scene API tests</p> <p>Create <code>server/integration/api/scenes.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeAll } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Scene API\", () =&gt; {\n  describe(\"POST /api/library/scenes\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/scenes\", {});\n\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns scenes with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{ id: string; title: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.scenes).toBeDefined();\n      expect(Array.isArray(response.data.scenes)).toBe(true);\n      expect(response.data.scenes.length).toBeLessThanOrEqual(10);\n      expect(response.data.count).toBeGreaterThan(0);\n    });\n\n    it(\"returns scene by ID with relations\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{\n          id: string;\n          title: string;\n          performers?: Array&lt;{ id: string; name: string }&gt;;\n          tags?: Array&lt;{ id: string; name: string }&gt;;\n          studio?: { id: string; name: string };\n        }&gt;;\n      }&gt;(\"/api/library/scenes\", {\n        ids: [TEST_ENTITIES.sceneWithRelations],\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.scenes).toHaveLength(1);\n\n      const scene = response.data.scenes[0];\n      expect(scene.id).toBe(TEST_ENTITIES.sceneWithRelations);\n      expect(scene.title).toBeDefined();\n      // The test entity should have relations\n      expect(scene.performers).toBeDefined();\n      expect(scene.tags).toBeDefined();\n    });\n\n    it(\"filters scenes by performer\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{\n          id: string;\n          performers: Array&lt;{ id: string }&gt;;\n        }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        performers: {\n          value: [TEST_ENTITIES.performerWithScenes],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 50,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.count).toBeGreaterThan(0);\n\n      // All returned scenes should include the performer\n      for (const scene of response.data.scenes) {\n        const performerIds = scene.performers.map((p) =&gt; p.id);\n        expect(performerIds).toContain(TEST_ENTITIES.performerWithScenes);\n      }\n    });\n\n    it(\"filters scenes by studio\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{\n          id: string;\n          studio: { id: string };\n        }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        studios: {\n          value: [TEST_ENTITIES.studioWithScenes],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 50,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.count).toBeGreaterThan(0);\n\n      // All returned scenes should be from the studio\n      for (const scene of response.data.scenes) {\n        expect(scene.studio?.id).toBe(TEST_ENTITIES.studioWithScenes);\n      }\n    });\n\n    it(\"filters scenes by tag\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{\n          id: string;\n          tags: Array&lt;{ id: string }&gt;;\n        }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        tags: {\n          value: [TEST_ENTITIES.tagWithEntities],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 50,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.count).toBeGreaterThan(0);\n\n      // All returned scenes should have the tag (direct or inherited)\n      // Note: Tags can be inherited, so we check the scene has it\n      for (const scene of response.data.scenes) {\n        const tagIds = scene.tags.map((t) =&gt; t.id);\n        expect(tagIds).toContain(TEST_ENTITIES.tagWithEntities);\n      }\n    });\n\n    it(\"respects per_page limit\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{ id: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        per_page: 5,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.scenes.length).toBeLessThanOrEqual(5);\n    });\n\n    it(\"paginates correctly\", async () =&gt; {\n      // Get first page\n      const page1 = await adminClient.post&lt;{\n        scenes: Array&lt;{ id: string }&gt;;\n      }&gt;(\"/api/library/scenes\", {\n        page: 1,\n        per_page: 5,\n      });\n\n      // Get second page\n      const page2 = await adminClient.post&lt;{\n        scenes: Array&lt;{ id: string }&gt;;\n      }&gt;(\"/api/library/scenes\", {\n        page: 2,\n        per_page: 5,\n      });\n\n      expect(page1.ok).toBe(true);\n      expect(page2.ok).toBe(true);\n\n      // Pages should have different scenes (unless there are fewer than 6 total)\n      if (page1.data.scenes.length === 5 &amp;&amp; page2.data.scenes.length &gt; 0) {\n        const page1Ids = page1.data.scenes.map((s) =&gt; s.id);\n        const page2Ids = page2.data.scenes.map((s) =&gt; s.id);\n\n        // No overlap between pages\n        for (const id of page2Ids) {\n          expect(page1Ids).not.toContain(id);\n        }\n      }\n    });\n  });\n\n  describe(\"GET /api/library/scenes/:id/similar\", () =&gt; {\n    it(\"returns similar scenes\", async () =&gt; {\n      const response = await adminClient.get&lt;{\n        scenes: Array&lt;{ id: string; title: string }&gt;;\n      }&gt;(`/api/library/scenes/${TEST_ENTITIES.sceneWithRelations}/similar`);\n\n      expect(response.ok).toBe(true);\n      expect(response.data.scenes).toBeDefined();\n      expect(Array.isArray(response.data.scenes)).toBe(true);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run the integration tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass (some may fail if they reveal actual bugs - investigate those!)</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/scenes.integration.test.ts\ngit commit -m \"feat(tests): add scene API integration tests\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-7-add-performer-api-integration-tests","title":"Task 7: Add Performer API Integration Tests","text":"<p>Files: - Create: <code>server/integration/api/performers.integration.test.ts</code></p> <p>Step 1: Create performer API tests</p> <p>Create <code>server/integration/api/performers.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Performer API\", () =&gt; {\n  describe(\"POST /api/library/performers\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/performers\", {});\n\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns performers with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        performers: Array&lt;{ id: string; name: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/performers\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.performers).toBeDefined();\n      expect(Array.isArray(response.data.performers)).toBe(true);\n      expect(response.data.performers.length).toBeLessThanOrEqual(10);\n      expect(response.data.count).toBeGreaterThan(0);\n    });\n\n    it(\"returns performer by ID\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        performers: Array&lt;{\n          id: string;\n          name: string;\n          scene_count?: number;\n        }&gt;;\n      }&gt;(\"/api/library/performers\", {\n        ids: [TEST_ENTITIES.performerWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.performers).toHaveLength(1);\n\n      const performer = response.data.performers[0];\n      expect(performer.id).toBe(TEST_ENTITIES.performerWithScenes);\n      expect(performer.name).toBeDefined();\n    });\n\n    it(\"filters performers by tag\", async () =&gt; {\n      // This test may not return results if no performers have the tag\n      const response = await adminClient.post&lt;{\n        performers: Array&lt;{\n          id: string;\n          tags?: Array&lt;{ id: string }&gt;;\n        }&gt;;\n        count: number;\n      }&gt;(\"/api/library/performers\", {\n        tags: {\n          value: [TEST_ENTITIES.tagWithEntities],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 50,\n      });\n\n      expect(response.ok).toBe(true);\n      // If performers have this tag, verify the filter works\n      if (response.data.count &gt; 0) {\n        for (const performer of response.data.performers) {\n          if (performer.tags) {\n            const tagIds = performer.tags.map((t) =&gt; t.id);\n            expect(tagIds).toContain(TEST_ENTITIES.tagWithEntities);\n          }\n        }\n      }\n    });\n  });\n\n  describe(\"POST /api/library/performers/minimal\", () =&gt; {\n    it(\"returns minimal performer data for dropdowns\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        performers: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/performers/minimal\", {});\n\n      expect(response.ok).toBe(true);\n      expect(response.data.performers).toBeDefined();\n      expect(Array.isArray(response.data.performers)).toBe(true);\n\n      // Minimal should only have id and name\n      if (response.data.performers.length &gt; 0) {\n        const performer = response.data.performers[0];\n        expect(performer.id).toBeDefined();\n        expect(performer.name).toBeDefined();\n      }\n    });\n  });\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/performers.integration.test.ts\ngit commit -m \"feat(tests): add performer API integration tests\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-8-add-remaining-entity-api-tests-studios-tags-groups-galleries-images","title":"Task 8: Add Remaining Entity API Tests (Studios, Tags, Groups, Galleries, Images)","text":"<p>Files: - Create: <code>server/integration/api/studios.integration.test.ts</code> - Create: <code>server/integration/api/tags.integration.test.ts</code> - Create: <code>server/integration/api/groups.integration.test.ts</code> - Create: <code>server/integration/api/galleries.integration.test.ts</code> - Create: <code>server/integration/api/images.integration.test.ts</code></p> <p>Step 1: Create studios tests</p> <p>Create <code>server/integration/api/studios.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Studio API\", () =&gt; {\n  describe(\"POST /api/library/studios\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/studios\", {});\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns studios with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        studios: Array&lt;{ id: string; name: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/studios\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.studios).toBeDefined();\n      expect(Array.isArray(response.data.studios)).toBe(true);\n      expect(response.data.count).toBeGreaterThan(0);\n    });\n\n    it(\"returns studio by ID\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        studios: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/studios\", {\n        ids: [TEST_ENTITIES.studioWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.studios).toHaveLength(1);\n      expect(response.data.studios[0].id).toBe(TEST_ENTITIES.studioWithScenes);\n    });\n  });\n\n  describe(\"POST /api/library/studios/minimal\", () =&gt; {\n    it(\"returns minimal studio data\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        studios: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/studios/minimal\", {});\n\n      expect(response.ok).toBe(true);\n      expect(response.data.studios).toBeDefined();\n    });\n  });\n});\n</code></pre> <p>Step 2: Create tags tests</p> <p>Create <code>server/integration/api/tags.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Tag API\", () =&gt; {\n  describe(\"POST /api/library/tags\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/tags\", {});\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns tags with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        tags: Array&lt;{ id: string; name: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/tags\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.tags).toBeDefined();\n      expect(Array.isArray(response.data.tags)).toBe(true);\n      expect(response.data.count).toBeGreaterThan(0);\n    });\n\n    it(\"returns tag by ID\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        tags: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/tags\", {\n        ids: [TEST_ENTITIES.tagWithEntities],\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.tags).toHaveLength(1);\n      expect(response.data.tags[0].id).toBe(TEST_ENTITIES.tagWithEntities);\n    });\n  });\n\n  describe(\"POST /api/library/tags/minimal\", () =&gt; {\n    it(\"returns minimal tag data\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        tags: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/tags/minimal\", {});\n\n      expect(response.ok).toBe(true);\n      expect(response.data.tags).toBeDefined();\n    });\n  });\n});\n</code></pre> <p>Step 3: Create groups tests</p> <p>Create <code>server/integration/api/groups.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Group API\", () =&gt; {\n  describe(\"POST /api/library/groups\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/groups\", {});\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns groups with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        groups: Array&lt;{ id: string; name: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/groups\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.groups).toBeDefined();\n      expect(Array.isArray(response.data.groups)).toBe(true);\n    });\n\n    it(\"returns group by ID\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        groups: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/groups\", {\n        ids: [TEST_ENTITIES.groupWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      if (response.data.groups.length &gt; 0) {\n        expect(response.data.groups[0].id).toBe(TEST_ENTITIES.groupWithScenes);\n      }\n    });\n  });\n\n  describe(\"POST /api/library/groups/minimal\", () =&gt; {\n    it(\"returns minimal group data\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        groups: Array&lt;{ id: string; name: string }&gt;;\n      }&gt;(\"/api/library/groups/minimal\", {});\n\n      expect(response.ok).toBe(true);\n      expect(response.data.groups).toBeDefined();\n    });\n  });\n});\n</code></pre> <p>Step 4: Create galleries tests</p> <p>Create <code>server/integration/api/galleries.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Gallery API\", () =&gt; {\n  describe(\"POST /api/library/galleries\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/galleries\", {});\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns galleries with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        galleries: Array&lt;{ id: string; title?: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/galleries\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.galleries).toBeDefined();\n      expect(Array.isArray(response.data.galleries)).toBe(true);\n    });\n\n    it(\"returns gallery by ID with images\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        galleries: Array&lt;{ id: string; image_count?: number }&gt;;\n      }&gt;(\"/api/library/galleries\", {\n        ids: [TEST_ENTITIES.galleryWithImages],\n      });\n\n      expect(response.ok).toBe(true);\n      if (response.data.galleries.length &gt; 0) {\n        expect(response.data.galleries[0].id).toBe(TEST_ENTITIES.galleryWithImages);\n      }\n    });\n  });\n\n  describe(\"GET /api/library/galleries/:id/images\", () =&gt; {\n    it(\"returns paginated images from gallery\", async () =&gt; {\n      const response = await adminClient.get&lt;{\n        images: Array&lt;{ id: string }&gt;;\n        count: number;\n      }&gt;(`/api/library/galleries/${TEST_ENTITIES.galleryWithImages}/images?page=1&amp;per_page=10`);\n\n      expect(response.ok).toBe(true);\n      expect(response.data.images).toBeDefined();\n      expect(Array.isArray(response.data.images)).toBe(true);\n    });\n  });\n});\n</code></pre> <p>Step 5: Create images tests</p> <p>Create <code>server/integration/api/images.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\n\ndescribe(\"Image API\", () =&gt; {\n  describe(\"POST /api/library/images\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.post(\"/api/library/images\", {});\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns images with pagination\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        images: Array&lt;{ id: string }&gt;;\n        count: number;\n      }&gt;(\"/api/library/images\", {\n        page: 1,\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.images).toBeDefined();\n      expect(Array.isArray(response.data.images)).toBe(true);\n    });\n  });\n});\n</code></pre> <p>Step 6: Run all integration tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass</p> <p>Step 7: Commit</p> <pre><code>git add server/integration/api/\ngit commit -m \"feat(tests): add integration tests for all entity APIs\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-9-add-authentication-integration-tests","title":"Task 9: Add Authentication Integration Tests","text":"<p>Files: - Create: <code>server/integration/api/auth.integration.test.ts</code></p> <p>Step 1: Create auth tests</p> <p>Create <code>server/integration/api/auth.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach } from \"vitest\";\nimport { TestClient } from \"../helpers/testClient.js\";\nimport { TEST_ADMIN } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Auth API\", () =&gt; {\n  let client: TestClient;\n\n  beforeEach(() =&gt; {\n    client = new TestClient();\n  });\n\n  describe(\"POST /api/auth/login\", () =&gt; {\n    it(\"returns success with valid credentials\", async () =&gt; {\n      const response = await client.post&lt;{\n        success: boolean;\n        user: { id: number; username: string };\n      }&gt;(\"/api/auth/login\", {\n        username: TEST_ADMIN.username,\n        password: TEST_ADMIN.password,\n      });\n\n      expect(response.ok).toBe(true);\n      expect(response.data.success).toBe(true);\n      expect(response.data.user.username).toBe(TEST_ADMIN.username);\n    });\n\n    it(\"returns 401 with invalid password\", async () =&gt; {\n      const response = await client.post(\"/api/auth/login\", {\n        username: TEST_ADMIN.username,\n        password: \"wrong_password\",\n      });\n\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns 401 with non-existent user\", async () =&gt; {\n      const response = await client.post(\"/api/auth/login\", {\n        username: \"nonexistent_user\",\n        password: \"any_password\",\n      });\n\n      expect(response.status).toBe(401);\n    });\n  });\n\n  describe(\"GET /api/auth/check\", () =&gt; {\n    it(\"returns authenticated=true when logged in\", async () =&gt; {\n      await client.login(TEST_ADMIN.username, TEST_ADMIN.password);\n\n      const response = await client.get&lt;{\n        authenticated: boolean;\n        user: { username: string };\n      }&gt;(\"/api/auth/check\");\n\n      expect(response.ok).toBe(true);\n      expect(response.data.authenticated).toBe(true);\n      expect(response.data.user.username).toBe(TEST_ADMIN.username);\n    });\n\n    it(\"returns 401 when not logged in\", async () =&gt; {\n      const response = await client.get(\"/api/auth/check\");\n      expect(response.status).toBe(401);\n    });\n  });\n\n  describe(\"GET /api/auth/me\", () =&gt; {\n    it(\"returns current user info when logged in\", async () =&gt; {\n      await client.login(TEST_ADMIN.username, TEST_ADMIN.password);\n\n      const response = await client.get&lt;{\n        user: { id: number; username: string; role: string };\n      }&gt;(\"/api/auth/me\");\n\n      expect(response.ok).toBe(true);\n      expect(response.data.user.username).toBe(TEST_ADMIN.username);\n    });\n  });\n\n  describe(\"POST /api/auth/logout\", () =&gt; {\n    it(\"clears session and returns success\", async () =&gt; {\n      await client.login(TEST_ADMIN.username, TEST_ADMIN.password);\n\n      const logoutResponse = await client.post&lt;{ success: boolean }&gt;(\"/api/auth/logout\");\n      expect(logoutResponse.ok).toBe(true);\n      expect(logoutResponse.data.success).toBe(true);\n\n      // After logout, auth check should fail\n      client.clearToken();\n      const checkResponse = await client.get(\"/api/auth/check\");\n      expect(checkResponse.status).toBe(401);\n    });\n  });\n});\n</code></pre> <p>Step 2: Update testEntities.example.ts to export TEST_ADMIN</p> <p>The TEST_ADMIN is already in the example file from Task 1.</p> <p>Step 3: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass</p> <p>Step 4: Commit</p> <pre><code>git add server/integration/api/auth.integration.test.ts\ngit commit -m \"feat(tests): add authentication integration tests\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-10-add-content-restrictions-integration-tests","title":"Task 10: Add Content Restrictions Integration Tests","text":"<p>Files: - Create: <code>server/integration/api/contentRestrictions.integration.test.ts</code></p> <p>Step 1: Create content restrictions tests</p> <p>Create <code>server/integration/api/contentRestrictions.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeAll, afterAll } from \"vitest\";\nimport { adminClient, TestClient } from \"../helpers/testClient.js\";\nimport { TEST_ENTITIES, TEST_ADMIN } from \"../fixtures/testEntities.js\";\n\ndescribe(\"Content Restrictions\", () =&gt; {\n  let restrictedUserClient: TestClient;\n  const testUsername = \"restriction_test_user\";\n  const testPassword = \"test_password_123\";\n  let testUserId: number;\n\n  beforeAll(async () =&gt; {\n    // Create a test user with content restrictions\n    const createUserResponse = await adminClient.post&lt;{\n      user: { id: number };\n    }&gt;(\"/api/user/create\", {\n      username: testUsername,\n      password: testPassword,\n      role: \"user\",\n    });\n\n    if (!createUserResponse.ok) {\n      // User might already exist from previous run, try to get their ID\n      const usersResponse = await adminClient.get&lt;{\n        users: Array&lt;{ id: number; username: string }&gt;;\n      }&gt;(\"/api/user/list\");\n\n      const existingUser = usersResponse.data.users?.find(\n        (u) =&gt; u.username === testUsername\n      );\n      if (existingUser) {\n        testUserId = existingUser.id;\n      } else {\n        throw new Error(\"Failed to create or find test user\");\n      }\n    } else {\n      testUserId = createUserResponse.data.user.id;\n    }\n\n    // Add content restriction - exclude scenes with restrictableTag\n    await adminClient.post(\"/api/user/restrictions\", {\n      userId: testUserId,\n      restrictions: [\n        {\n          entityType: \"tags\",\n          mode: \"EXCLUDE\",\n          entityIds: [TEST_ENTITIES.restrictableTag],\n        },\n      ],\n    });\n\n    // Login as the restricted user\n    restrictedUserClient = new TestClient();\n    await restrictedUserClient.login(testUsername, testPassword);\n  });\n\n  afterAll(async () =&gt; {\n    // Clean up: remove the test user\n    if (testUserId) {\n      await adminClient.delete(`/api/user/${testUserId}`);\n    }\n  });\n\n  describe(\"Scene filtering with restrictions\", () =&gt; {\n    it(\"admin sees all scenes\", async () =&gt; {\n      const response = await adminClient.post&lt;{\n        scenes: Array&lt;{ id: string; tags: Array&lt;{ id: string }&gt; }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        tags: {\n          value: [TEST_ENTITIES.restrictableTag],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 10,\n      });\n\n      expect(response.ok).toBe(true);\n      // Admin should see scenes with the restricted tag\n      expect(response.data.count).toBeGreaterThan(0);\n    });\n\n    it(\"restricted user does not see excluded scenes\", async () =&gt; {\n      // First verify admin sees scenes with this tag\n      const adminResponse = await adminClient.post&lt;{\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        tags: {\n          value: [TEST_ENTITIES.restrictableTag],\n          modifier: \"INCLUDES\",\n        },\n      });\n\n      // Skip test if no scenes have this tag\n      if (adminResponse.data.count === 0) {\n        console.log(\"Skipping: No scenes with restrictableTag\");\n        return;\n      }\n\n      // Restricted user should not see these scenes\n      const restrictedResponse = await restrictedUserClient.post&lt;{\n        scenes: Array&lt;{ id: string; tags: Array&lt;{ id: string }&gt; }&gt;;\n        count: number;\n      }&gt;(\"/api/library/scenes\", {\n        tags: {\n          value: [TEST_ENTITIES.restrictableTag],\n          modifier: \"INCLUDES\",\n        },\n        per_page: 10,\n      });\n\n      expect(restrictedResponse.ok).toBe(true);\n      // Restricted user should see fewer or no scenes\n      expect(restrictedResponse.data.count).toBeLessThan(adminResponse.data.count);\n    });\n\n    it(\"restricted user scene count reflects exclusions\", async () =&gt; {\n      // Get total scene count for admin\n      const adminResponse = await adminClient.post&lt;{ count: number }&gt;(\n        \"/api/library/scenes\",\n        {}\n      );\n\n      // Get total scene count for restricted user\n      const restrictedResponse = await restrictedUserClient.post&lt;{ count: number }&gt;(\n        \"/api/library/scenes\",\n        {}\n      );\n\n      expect(adminResponse.ok).toBe(true);\n      expect(restrictedResponse.ok).toBe(true);\n\n      // Restricted user should have same or fewer scenes\n      expect(restrictedResponse.data.count).toBeLessThanOrEqual(\n        adminResponse.data.count\n      );\n    });\n  });\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: Tests pass (or reveal bugs in content restriction system)</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/contentRestrictions.integration.test.ts\ngit commit -m \"feat(tests): add content restrictions integration tests\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-11-add-pre-release-skill","title":"Task 11: Add Pre-Release Skill","text":"<p>Files: - Create: <code>.claude/skills/pre-release.md</code> - Modify: <code>CLAUDE.md</code> (add integration testing docs)</p> <p>Step 1: Create pre-release skill</p> <p>Create <code>.claude/skills/pre-release.md</code>:</p> <pre><code>---\nname: pre-release\ndescription: Run all validation checks before tagging a new release\n---\n\n# Pre-Release Checks\n\nRun this before tagging a new version to ensure everything works.\n\n## Checklist\n\n1. **Server Unit Tests**\n   ```bash\n   cd server &amp;&amp; npm test\n   ```\n   Expected: All tests pass\n\n2. **Server Linter**\n   ```bash\n   cd server &amp;&amp; npm run lint\n   ```\n   Expected: No errors (warnings OK)\n\n3. **Client Unit Tests**\n   ```bash\n   cd client &amp;&amp; npm test\n   ```\n   Expected: All tests pass\n\n4. **Client Linter**\n   ```bash\n   cd client &amp;&amp; npm run lint\n   ```\n   Expected: No errors (warnings OK)\n\n5. **Integration Tests**\n   ```bash\n   cd server &amp;&amp; npm run test:integration\n   ```\n   Expected: All tests pass\n   Note: Requires testEntities.ts to be configured\n\n6. **Client Build**\n   ```bash\n   cd client &amp;&amp; npm run build\n   ```\n   Expected: Build succeeds without errors\n\n7. **Docker Build**\n   ```bash\n   docker build -f Dockerfile.production -t peek:test .\n   ```\n   Expected: Image builds successfully\n\n## After All Checks Pass\n\nReport summary:\n- Unit tests: X passed\n- Integration tests: X passed\n- Linter: Clean\n- Build: Success\n\nReady to proceed with release tagging.\n</code></pre> <p>Step 2: Update CLAUDE.md with integration testing docs</p> <p>Add to <code>CLAUDE.md</code> after the existing content:</p> <pre><code>### Integration Testing\n\nIntegration tests run against a real Stash server to validate API functionality.\n\n**Setup (first time):**\n1. Ensure `.env` has `STASH_URL` and `STASH_API_KEY`\n2. Copy `server/integration/fixtures/testEntities.example.ts` to `testEntities.ts`\n3. Fill in entity IDs from your Stash library\n\n**Running tests:**\n- `cd server &amp;&amp; npm run test:integration` - Run against persistent test DB\n- `cd server &amp;&amp; npm run test:integration:fresh` - Reset DB and test setup flow\n- `cd server &amp;&amp; npm run test:integration:watch` - Watch mode for development\n\n**Pre-release validation:**\nRun `/pre-release` to execute all checks before tagging a release.\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add .claude/skills/pre-release.md CLAUDE.md\ngit commit -m \"feat: add pre-release skill and integration testing documentation\"\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#task-12-final-verification-and-cleanup","title":"Task 12: Final Verification and Cleanup","text":"<p>Step 1: Run all integration tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code> Expected: All tests pass</p> <p>Step 2: Run TypeScript compilation</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Run linter</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors (warnings OK)</p> <p>Step 4: Verify unit tests still pass</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All 500+ unit tests still pass</p> <p>Step 5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address any issues found during final verification\"\n</code></pre> <p>Step 6: Push branch</p> <pre><code>git push -u origin feature/integration-testing-infrastructure\n</code></pre>"},{"location":"plans/2026-01-04-integration-testing-implementation/#summary","title":"Summary","text":"<p>After completing all tasks, you will have:</p> <ol> <li>Integration test infrastructure in <code>server/integration/</code></li> <li>Vitest config for running integration tests separately from unit tests</li> <li>Test HTTP client with authentication support</li> <li>Global setup/teardown that starts/stops the Express server</li> <li>Test database that persists between runs (with fresh option)</li> <li>Integration tests for:</li> <li>Health/version endpoints</li> <li>All entity APIs (scenes, performers, studios, tags, groups, galleries, images)</li> <li>Authentication flow</li> <li>Content restrictions</li> <li>Pre-release skill for running all validation checks</li> <li>Documentation in CLAUDE.md for running tests</li> </ol> <p>NPM scripts added: - <code>npm run test:integration</code> - Run integration tests - <code>npm run test:integration:watch</code> - Watch mode - <code>npm run test:integration:fresh</code> - Fresh database run</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/","title":"UI Component Refactor for 3.2.0","text":"<p>Date: 2026-01-05 Status: In Design Goal: Improved UI consistency, maintainable/composable/DRY component structure, enhanced UI customization</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#overview","title":"Overview","text":"<p>Refactor peek's card and grid components to support: 1. UI Consistency - Fix existing visual inconsistencies and bugs 2. DRY Components - Consolidate duplicated patterns 3. Layout Flexibility - Support multiple display modes per entity type (grid, list, compact) 4. User Customization - Per-entity card anatomy settings (show/hide elements)</p> <p>Scope: All searchable entities will support alternative layouts and customization: - Scenes - Performers - Galleries - Groups (Collections) - Studios - Tags - Images</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#current-architecture-audit","title":"Current Architecture Audit","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#component-hierarchy","title":"Component Hierarchy","text":"<pre><code>UI Display Components:\n\u251c\u2500\u2500 Base Components (Foundation)\n\u2502   \u251c\u2500\u2500 BaseCard.jsx - Composable card with render slots\n\u2502   \u251c\u2500\u2500 BaseGrid.jsx - Layout, pagination, loading/empty states\n\u2502   \u251c\u2500\u2500 EntitySearch.jsx - BaseGrid + search controls + data fetching\n\u2502   \u2514\u2500\u2500 CardComponents.jsx - Shared primitives\n\u2502       \u251c\u2500\u2500 CardContainer\n\u2502       \u251c\u2500\u2500 CardImage (with lazy loading)\n\u2502       \u251c\u2500\u2500 CardTitle\n\u2502       \u251c\u2500\u2500 CardDescription\n\u2502       \u251c\u2500\u2500 CardIndicators\n\u2502       \u2514\u2500\u2500 CardRatingRow\n\u2502\n\u251c\u2500\u2500 Entity Cards (7 types)\n\u2502   \u251c\u2500\u2500 SceneCard.jsx - \u26a0\ufe0f Doesn't use BaseCard (special case)\n\u2502   \u251c\u2500\u2500 GalleryCard.jsx - Uses BaseCard\n\u2502   \u251c\u2500\u2500 GroupCard.jsx - Uses BaseCard\n\u2502   \u251c\u2500\u2500 PerformerCard.jsx - Uses BaseCard\n\u2502   \u251c\u2500\u2500 StudioCard.jsx - Uses BaseCard\n\u2502   \u251c\u2500\u2500 TagCard.jsx - Uses BaseCard\n\u2502   \u2514\u2500\u2500 ImageCard.jsx - Uses BaseCard\n\u2502\n\u251c\u2500\u2500 Entity Grids (7 types)\n\u2502   \u251c\u2500\u2500 SceneGrid.jsx - Custom implementation (selection, TV navigation)\n\u2502   \u251c\u2500\u2500 GalleryGrid.jsx - Thin wrapper around EntitySearch\n\u2502   \u251c\u2500\u2500 GroupGrid.jsx - Thin wrapper around EntitySearch\n\u2502   \u251c\u2500\u2500 PerformerGrid.jsx - Thin wrapper around EntitySearch\n\u2502   \u251c\u2500\u2500 StudioGrid.jsx - Thin wrapper around EntitySearch\n\u2502   \u251c\u2500\u2500 TagGrid.jsx - Thin wrapper around EntitySearch\n\u2502   \u2514\u2500\u2500 ImageGrid.jsx - Thin wrapper around EntitySearch\n\u2502\n\u2514\u2500\u2500 Special Display Patterns\n    \u251c\u2500\u2500 SceneListItem.jsx - Row-based layout (playlists, watch history)\n    \u251c\u2500\u2500 PaginatedImageGrid.jsx - Compact grid with lightbox\n    \u251c\u2500\u2500 HiddenItemsPage.jsx - Custom card display\n    \u2514\u2500\u2500 PlaylistStatusCard.jsx - Thumbnail strip navigation\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#data-flow-pattern","title":"Data Flow Pattern","text":"<pre><code>EntitySearch (data fetching)\n    \u2193\nBaseGrid (layout + states)\n    \u2193\nEntity Grid Component (thin wrapper)\n    \u2193\nEntity Card Component (visual display)\n    \u2193\nBaseCard + CardComponents (primitives)\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#whats-working-well","title":"What's Working Well","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#1-basecard-architecture","title":"1. BaseCard Architecture \u2705","text":"<ul> <li>Composable design with render slots (<code>renderOverlay</code>, <code>renderImageContent</code>, <code>renderAfterTitle</code>)</li> <li>Flexible display options (<code>hideDescription</code>, <code>hideSubtitle</code>, <code>maxTitleLines</code>, etc.)</li> <li>Consistent prop interface across all entity cards (except SceneCard)</li> <li>Good separation of concerns - BaseCard handles layout, entity cards provide data mapping</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#2-entitysearch-pattern","title":"2. EntitySearch Pattern \u2705","text":"<ul> <li>Consistent search/filter/pagination across all entity types</li> <li>Centralized data fetching via libraryApi</li> <li>URL state sync for shareable links</li> <li>Locked filters support for nested grids</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#3-cardcomponents-primitives","title":"3. CardComponents Primitives \u2705","text":"<ul> <li>Lazy loading built into CardImage with IntersectionObserver</li> <li>Fixed heights on CardTitle, CardDescription, CardIndicators for consistent card sizing</li> <li>Tooltip integration for truncated text</li> <li>CardRatingRow handles all interactive rating/favorite/O-counter logic</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#4-grid-system","title":"4. Grid System \u2705","text":"<ul> <li>Responsive column calculations via <code>useGridColumns</code> hook</li> <li>Two grid types - <code>scene</code> (wider, 16:9) and <code>standard</code> (taller, 2:3)</li> <li>Consistent class names in <code>constants/grids.js</code></li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#issues-identified","title":"Issues Identified","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#1-scenecard-inconsistency","title":"1. SceneCard Inconsistency \u26a0\ufe0f","text":"<p>Problem: SceneCard doesn't use BaseCard - it reimplements CardComponents inline.</p> <p>Current Implementation: <pre><code>// SceneCard.jsx - Lines 290-450\n&lt;div className=\"...card-styles...\"&gt;\n  &lt;CardImage&gt;...&lt;/CardImage&gt;\n  &lt;CardTitle&gt;...&lt;/CardTitle&gt;\n  &lt;CardDescription&gt;...&lt;/CardDescription&gt;\n  &lt;CardIndicators&gt;...&lt;/CardIndicators&gt;\n  &lt;CardRatingRow&gt;...&lt;/CardRatingRow&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Issues: - Duplicates CardContainer logic (styling, hover, focus) - Has to manually manage selection state UI - Can't benefit from BaseCard improvements - Different prop interface than other cards</p> <p>Why it exists: SceneCard has unique features: - Selection checkbox overlay - Video preview with sprite cycling - Watch progress bar overlay - Long-press gesture detection - Inherited tags computation</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#2-rating-controls-props-variance","title":"2. Rating Controls Props Variance \u26a0\ufe0f","text":"<p>Problem: Inconsistent prop passing to <code>ratingControlsProps</code>.</p> <p>Examples: <pre><code>// GalleryCard - Missing initialOCounter\nratingControlsProps={{\n  entityId: gallery.id,\n  initialRating: gallery.rating100,\n  initialFavorite: gallery.favorite || false,\n  onHideSuccess,\n}}\n\n// PerformerCard - Includes initialOCounter\nratingControlsProps={{\n  entityId: performer.id,\n  initialRating: performer.rating,\n  initialFavorite: performer.favorite || false,\n  initialOCounter: performer.o_counter,\n  onHideSuccess,\n}}\n\n// ImageCard - Conditional rendering\nratingControlsProps={\n  image.rating100 !== undefined || image.favorite !== undefined || image.oCounter !== undefined\n    ? { ... }\n    : undefined\n}\n</code></pre></p> <p>Issues: - Some entities support O counter, some don't (based on server data availability) - Inconsistent null checks - Some use <code>rating</code>, others <code>rating100</code></p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#3-indicator-structure-differences","title":"3. Indicator Structure Differences \u26a0\ufe0f","text":"<p>Problem: Scenes have rich tooltips, other entities simpler.</p> <p>Scene Example: <pre><code>indicators={[{\n  type: \"PERFORMERS\",\n  count: scene.performers?.length,\n  tooltipContent: &lt;TooltipEntityGrid entities={scene.performers} /&gt;,\n  onClick: () =&gt; navigate(`/performers?sceneId=${scene.id}`)\n}]}\n</code></pre></p> <p>Other Entity Example: <pre><code>indicators={[{\n  type: \"SCENES\",\n  count: studio.scene_count,\n  onClick: studio.scene_count &gt; 0\n    ? () =&gt; navigate(`/scenes?studioId=${studio.id}`)\n    : undefined\n}]}\n</code></pre></p> <p>Difference: Scenes render full entity grids in tooltips, others just show count text.</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#4-date-formatting-inconsistency","title":"4. Date Formatting Inconsistency \u26a0\ufe0f","text":"<p>Problem: Different date handling patterns.</p> <pre><code>// GalleryCard - Formats date\nconst galleryDate = gallery.date\n  ? new Date(gallery.date).toLocaleDateString()\n  : null;\n\n// GroupCard - Uses raw date string\nconst subtitle = group.studio &amp;&amp; group.date\n  ? `${group.studio.name} \u2022 ${group.date}`\n  : ...\n\n// SceneCard - Uses formatRelativeTime utility\nconst date = scene.date ? formatRelativeTime(scene.date) : null;\n</code></pre> <p>Should be: Consistent date formatting utility across all cards.</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#5-image-path-variance","title":"5. Image Path Variance \u26a0\ufe0f","text":"<p>Problem: Different image path patterns per entity.</p> <pre><code>// Scenes\nscene.paths?.screenshot\n\n// Performers\nperformer.image_path\n\n// Galleries\ngallery.paths?.cover\n\n// Groups\ngroup.front_image_path || group.back_image_path\n\n// Images\nimage.paths?.thumbnail || image.paths?.image\n\n// Studios\nstudio.image_path\n</code></pre> <p>Cause: Server API returns different structures per entity type (from Stash GraphQL schema).</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#6-scenelistitem-for-playlistshistory","title":"6. SceneListItem for Playlists/History \u26a0\ufe0f","text":"<p>Problem: Separate row-based component for scenes only.</p> <p>Current State: - Used in <code>WatchHistory</code> and <code>PlaylistDetail</code> pages - Shows horizontal layout: thumbnail | metadata - Includes watch history stats, resume time, play count - No equivalent for other entity types</p> <p>Future Need: If we want list view for all entities, need unified solution.</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#technical-constraints","title":"Technical Constraints","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#server-api-types","title":"Server API Types","text":"<p>Located in <code>server/types/</code>: - <code>entities.ts</code> - Entity type definitions (Normalized types with Peek user data) - <code>api/library.ts</code> - API response shapes - <code>filters.ts</code> - Filter parameter types</p> <p>Entity Type Structure (from entities.ts):</p> <p>All entities extend base Stash types with Peek user data:</p> <pre><code>// Common fields across ALL entities:\n- rating: number | null        // 1-5 star rating\n- favorite: boolean            // Favorite flag\n\n// Scenes, Performers, Studios, Tags (aggregated metrics):\n- o_counter: number           // Orgasm counter (scenes: direct, others: aggregated)\n- play_count: number          // Play count (scenes: direct, others: aggregated)\n\n// Scenes only (watch history):\n- rating100: number | null    // 0-100 rating scale\n- play_duration: number       // Total watch time\n- resume_time: number         // Last playback position\n- play_history: string[]      // Play timestamps\n- o_history: Date[]          // Orgasm timestamps\n- last_played_at: string | null\n- last_o_at: string | null\n- inheritedTagIds: string[]   // Tags from performers/studios\n- inheritedTags: Tag[]        // Hydrated inherited tags\n\n// Images only:\n- rating100: number | null    // 0-100 rating scale\n- oCounter: number           // Orgasm counter\n- viewCount: number          // View count\n- lastViewedAt: string | null\n\n// Performers only (aggregated from scenes):\n- last_played_at: string | null\n- last_o_at: string | null\n</code></pre> <p>Key Points: - Integration tests exist for all entity routes - TypeScript types on route controllers ensure API contract - Data shapes are stable and well-defined - Rating systems: Scenes/Images use <code>rating100</code>, others use <code>rating</code> - O counters: Only Scenes, Images, Performers, Studios, Tags support them - Galleries/Groups: Simplest entities (rating + favorite only)</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#entity-specific-behaviors","title":"Entity-Specific Behaviors","text":"<p>Scenes: - Video preview (sprite cycling) - Watch progress tracking - Resume time - Inherited tags from performers - Selection mode for bulk actions</p> <p>Images: - Lightbox integration - Gallery inheritance (metadata from parent galleries) - Click handler for lightbox vs. navigation</p> <p>Performers: - Gender icon - Physical stats (height, weight, measurements) - O counter aggregation</p> <p>All Entities: - Rating (scenes/images use 100-point, others may vary) - Favorite flag - Hidden entities support - Tag associations</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#current-component-features","title":"Current Component Features","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#basecard-props-interface","title":"BaseCard Props Interface","text":"<pre><code>{\n  // Data\n  entityType: string\n  imagePath: string\n  title: string | ReactNode\n  subtitle: string\n  description: string\n  linkTo: string\n\n  // Indicators &amp; Rating\n  indicators: Array&lt;{\n    type: string\n    count?: number\n    label?: string\n    tooltipContent?: ReactNode | string\n    onClick?: () =&gt; void\n  }&gt;\n  ratingControlsProps: {\n    entityType: string\n    entityId: string\n    initialRating: number\n    initialFavorite: boolean\n    initialOCounter?: number\n    entityTitle: string\n    onHideSuccess?: (id, type) =&gt; void\n    onOCounterChange?: (id, count) =&gt; void\n    onRatingChange?: (id, rating) =&gt; void\n    onFavoriteChange?: (id, favorite) =&gt; void\n  }\n\n  // Display options\n  hideDescription: boolean\n  hideSubtitle: boolean\n  maxTitleLines: number (default: 2)\n  maxDescriptionLines: number (default: 3)\n  objectFit: 'cover' | 'contain' (default: 'contain')\n\n  // Customization slots\n  renderOverlay: () =&gt; ReactNode\n  renderImageContent: () =&gt; ReactNode\n  renderAfterTitle: () =&gt; ReactNode\n\n  // Events &amp; behavior\n  onClick: (e) =&gt; void\n  className: string\n  referrerUrl: string\n  tabIndex: number\n  style: object\n}\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#cardcomponents-features","title":"CardComponents Features","text":"<p>CardImage: - Lazy loading via IntersectionObserver - Aspect ratio support - Placeholder icons per entity type - Loading shimmer - Error handling - Children rendered as overlay</p> <p>CardTitle: - Line clamping (configurable) - Fixed height based on line count - Tooltip for long titles - Optional subtitle with reserved space</p> <p>CardDescription: - Line clamping (configurable) - Fixed height (maintains card consistency) - Tooltip for long descriptions - Returns empty div if no description (preserves layout)</p> <p>CardIndicators: - Fixed height container (3.5rem) - Renders <code>CardCountIndicators</code> component - Supports tooltips (text or rich ReactNode) - Supports onClick navigation - Icon + count display</p> <p>CardRatingRow: - Fixed height (2rem) - Rating badge (clickable to open slider dialog) - O Counter button (interactive for scenes/images) - Favorite button - EntityMenu (hide option) - Handles all state management internally - Callbacks for parent state updates</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#next-steps","title":"Next Steps","text":"<ol> <li>\u2705 Complete audit</li> <li>\u2705 Document findings</li> <li>\u23f3 Identify visual bugs</li> <li>\u23f3 Research API types in detail</li> <li>\u23f3 Design composable architecture for multiple layouts</li> <li>\u23f3 Create implementation plan</li> </ol>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#design-decisions","title":"Design Decisions","text":"<ol> <li>\u2705 Layout scope: All searchable entities will support alternative layouts</li> <li>\u2705 Layout types:</li> <li>Phase 1 (This branch): Grid only, but build extensibility for future layouts</li> <li>Future layouts: Compact Grid, List, entity-specific views (e.g., Tag hierarchy)</li> <li>Architecture: Pluggable layout system where entities can have custom layouts</li> <li>\u2705 Storage: User settings database (synced across devices)</li> <li>\u2705 Customization granularity (Phase 1):</li> <li>Show/hide description (per entity type)</li> <li>Future: subtitle, indicators, density presets</li> <li>\u2705 SceneCard migration: Migrate to BaseCard architecture</li> <li>Use render slots for selection checkbox, video preview, progress bar</li> <li>Maintain all existing features (long-press, keyboard nav, etc.)</li> <li>Unified card system across all entities</li> </ol>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#proposed-component-architecture","title":"Proposed Component Architecture","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#overview_1","title":"Overview","text":"<p>Build a flexible, composable card system that supports: 1. Multiple layout modes (grid, list, compact, custom) via pluggable renderers 2. Per-entity UI customization (stored in user settings) 3. Consistent visual treatment across all entity types 4. Entity-specific features without breaking abstraction</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#architecture-philosophy","title":"Architecture Philosophy","text":"<p>Separation of Concerns: - Data fetching - EntitySearch (knows about API, filtering, pagination) - Layout rendering - LayoutRenderer (knows about spacing, columns, arrangement) - Entity presentation - Entity Cards (know about entity structure, not layout) - Visual primitives - CardComponents (know about UI, not entities) - User preferences - Zustand store + database (persisted state)</p> <p>Component Layering Strategy: <pre><code>Page Component (e.g., Scenes.jsx)\n    \u2514\u2500\u2500 EntityGrid (e.g., SceneGrid.jsx) - Entity-specific wrapper\n            \u2514\u2500\u2500 EntitySearch - Data fetching + search/filter UI\n                    \u2514\u2500\u2500 SearchResults - Layout mode controller (NEW)\n                            \u2514\u2500\u2500 LayoutRenderer - Grid/List/Compact renderer (NEW)\n                                    \u2514\u2500\u2500 Entity Card (e.g., SceneCard.jsx)\n                                            \u2514\u2500\u2500 BaseCard - Shared card structure\n                                                    \u2514\u2500\u2500 CardComponents - Primitives\n</code></pre></p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#component-flow-diagram","title":"Component Flow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User Settings Layer (Global State)                              \u2502\n\u2502                                                                  \u2502\n\u2502  useEntityDisplayPreferences('scene')                            \u2502\n\u2502      \u2193                                                           \u2502\n\u2502  Zustand Store { scene: { showDescription: false } }            \u2502\n\u2502      \u2193                                                           \u2502\n\u2502  Database EntityDisplayPreferences table                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 preferences object\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Page Layer (e.g., /scenes)                                       \u2502\n\u2502                                                                  \u2502\n\u2502  &lt;SceneGrid /&gt;  // Thin wrapper, just passes entity type         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Data Layer (EntitySearch)                                      \u2502\n\u2502                                                                  \u2502\n\u2502  Responsibilities:                                               \u2502\n\u2502  \u2022 API calls via libraryApi.findScenes()                         \u2502\n\u2502  \u2022 Filter/sort state management                                  \u2502\n\u2502  \u2022 Pagination logic                                              \u2502\n\u2502  \u2022 URL sync (query params)                                       \u2502\n\u2502  \u2022 Loading/error states                                          \u2502\n\u2502                                                                  \u2502\n\u2502  Passes down:                                                    \u2502\n\u2502  \u2022 items[] - fetched entities                                    \u2502\n\u2502  \u2022 onHideSuccess - callback to remove from local state           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 renderItem prop\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Layout Controller (SearchResults) - NEW COMPONENT                \u2502\n\u2502                                                                  \u2502\n\u2502  const { layoutType } = useEntityDisplayPreferences(entityType) \u2502\n\u2502                                                                  \u2502\n\u2502  return (                                                        \u2502\n\u2502    &lt;LayoutRenderer                                               \u2502\n\u2502      layoutType={layoutType}  // 'grid' | 'list' | 'compact'    \u2502\n\u2502      items={items}                                               \u2502\n\u2502      renderItem={(item) =&gt; &lt;SceneCard scene={item} ... /&gt;}       \u2502\n\u2502    /&gt;                                                            \u2502\n\u2502  )                                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 layoutType switch\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Layout Renderer (NEW COMPONENT)                                  \u2502\n\u2502                                                                  \u2502\n\u2502  switch (layoutType) {                                           \u2502\n\u2502    case 'grid':                                                  \u2502\n\u2502      return &lt;GridLayout items={items} renderItem={renderItem} /&gt;\u2502\n\u2502    case 'list':                                                  \u2502\n\u2502      return &lt;ListLayout items={items} renderItem={renderItem} /&gt;\u2502\n\u2502    case 'compact':                                               \u2502\n\u2502      return &lt;CompactLayout ... /&gt;                               \u2502\n\u2502  }                                                               \u2502\n\u2502                                                                  \u2502\n\u2502  Each layout knows ONLY about spacing/columns/arrangement        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 calls renderItem(item)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Entity Card Layer (SceneCard, PerformerCard, etc.)               \u2502\n\u2502                                                                  \u2502\n\u2502  const { preferences } = useEntityDisplayPreferences('scene')    \u2502\n\u2502                                                                  \u2502\n\u2502  Responsibilities:                                               \u2502\n\u2502  \u2022 Map entity data to card props (title, subtitle, indicators)  \u2502\n\u2502  \u2022 Entity-specific behavior (scene selection, gestures)         \u2502\n\u2502  \u2022 Compute derived data (allTags, indicators)                   \u2502\n\u2502  \u2022 Build render slot content (overlays, previews)               \u2502\n\u2502                                                                  \u2502\n\u2502  return (                                                        \u2502\n\u2502    &lt;BaseCard                                                     \u2502\n\u2502      title={getSceneTitle(scene)}                               \u2502\n\u2502      displayPreferences={preferences}                            \u2502\n\u2502      renderOverlay={() =&gt; &lt;SelectionCheckbox /&gt;}                 \u2502\n\u2502      renderImageContent={() =&gt; &lt;VideoPreview /&gt;}                 \u2502\n\u2502    /&gt;                                                            \u2502\n\u2502  )                                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Base Card (Shared Structure)                                     \u2502\n\u2502                                                                  \u2502\n\u2502  Responsibilities:                                               \u2502\n\u2502  \u2022 Consistent card anatomy (image \u2192 title \u2192 desc \u2192 indicators)  \u2502\n\u2502  \u2022 Respect display preferences (conditionally render sections)  \u2502\n\u2502  \u2022 Provide render slots for entity-specific content             \u2502\n\u2502  \u2022 Backwards compatible with existing hideDescription prop      \u2502\n\u2502                                                                  \u2502\n\u2502  const shouldShow = hideDescription ? false :                    \u2502\n\u2502                     displayPreferences.showDescription ?? true   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Card Primitives (CardComponents.jsx)                             \u2502\n\u2502                                                                  \u2502\n\u2502  \u2022 CardContainer - wrapper, hover, focus, link behavior          \u2502\n\u2502  \u2022 CardImage - lazy loading, aspect ratio, placeholders          \u2502\n\u2502  \u2022 CardTitle - line clamping, tooltips, fixed height             \u2502\n\u2502  \u2022 CardDescription - line clamping, tooltips, fixed height       \u2502\n\u2502  \u2022 CardIndicators - count badges with tooltips                   \u2502\n\u2502  \u2022 CardRatingRow - rating, favorite, O counter, hide menu        \u2502\n\u2502                                                                  \u2502\n\u2502  Pure presentational, no entity logic                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#detailed-component-implementations","title":"Detailed Component Implementations","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#searchresults-component-new","title":"SearchResults Component (NEW)","text":"<p>Location: <code>client/src/components/ui/SearchResults.jsx</code></p> <p>This component replaces the current BaseGrid. It's layout-agnostic and delegates rendering to LayoutRenderer.</p> <pre><code>import { LayoutRenderer } from './LayoutRenderer.jsx';\nimport { useEntityDisplayPreferences } from '../../hooks/useEntityDisplayPreferences.js';\nimport EmptyState from './EmptyState.jsx';\nimport Pagination from './Pagination.jsx';\n\n/**\n * SearchResults - Layout-agnostic results renderer\n *\n * Responsibilities:\n * - Read user's layout preference\n * - Handle loading/empty/error states\n * - Delegate actual rendering to LayoutRenderer\n * - Manage pagination UI\n *\n * @param {Object} props\n * @param {string} props.entityType - Entity type for preferences lookup\n * @param {Array} props.items - Items to render\n * @param {Function} props.renderItem - Function to render each item\n * @param {boolean} props.loading - Loading state\n * @param {Error} props.error - Error object\n * @param {string} props.emptyMessage - Empty state message\n * @param {number} props.currentPage - Current page\n * @param {number} props.totalPages - Total pages\n * @param {Function} props.onPageChange - Page change handler\n * @param {Function} props.renderSkeleton - Custom skeleton renderer\n * @param {number} props.skeletonCount - Skeleton count while loading\n */\nexport const SearchResults = ({\n  entityType,\n  items,\n  renderItem,\n  loading = false,\n  error,\n  emptyMessage = \"No items found\",\n  emptyDescription,\n  currentPage,\n  totalPages,\n  onPageChange,\n  renderSkeleton,\n  skeletonCount = 24,\n}) =&gt; {\n  // Get user's layout preference for this entity type\n  const { preferences } = useEntityDisplayPreferences(entityType);\n  const layoutType = preferences.layoutType || 'grid'; // default to grid\n\n  // Loading state - LayoutRenderer handles skeleton rendering\n  if (loading) {\n    return (\n      &lt;LayoutRenderer\n        layoutType={layoutType}\n        entityType={entityType}\n        items={[]} // empty, will render skeletons\n        renderItem={renderItem}\n        renderSkeleton={renderSkeleton}\n        skeletonCount={skeletonCount}\n        loading={true}\n      /&gt;\n    );\n  }\n\n  // Error state\n  if (error) {\n    return (\n      &lt;EmptyState\n        title=\"Error loading items\"\n        description={error.message || \"An error occurred\"}\n      /&gt;\n    );\n  }\n\n  // Empty state\n  if (!items || items.length === 0) {\n    return &lt;EmptyState title={emptyMessage} description={emptyDescription} /&gt;;\n  }\n\n  // Results\n  return (\n    &lt;&gt;\n      &lt;LayoutRenderer\n        layoutType={layoutType}\n        entityType={entityType}\n        items={items}\n        renderItem={renderItem}\n        loading={false}\n      /&gt;\n\n      {/* Pagination - common across all layouts */}\n      {totalPages &gt; 1 &amp;&amp; onPageChange &amp;&amp; (\n        &lt;nav role=\"navigation\" aria-label=\"Pagination\" className=\"mt-6\"&gt;\n          &lt;Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            onPageChange={onPageChange}\n          /&gt;\n        &lt;/nav&gt;\n      )}\n    &lt;/&gt;\n  );\n};\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#layoutrenderer-component-new","title":"LayoutRenderer Component (NEW)","text":"<p>Location: <code>client/src/components/ui/LayoutRenderer.jsx</code></p> <p>Pure layout component - doesn't know about entities, just spacing and arrangement.</p> <pre><code>import { GridLayout } from './layouts/GridLayout.jsx';\nimport { ListLayout } from './layouts/ListLayout.jsx';\nimport { CompactGridLayout } from './layouts/CompactGridLayout.jsx';\n\n/**\n * LayoutRenderer - Pluggable layout system\n *\n * Responsibilities:\n * - Route to correct layout based on layoutType\n * - Each layout is pure - only knows about spacing/columns\n * - Extensible - easy to add new layouts\n *\n * @param {Object} props\n * @param {'grid'|'list'|'compact'} props.layoutType - Layout mode\n * @param {string} props.entityType - For grid type selection ('scene' vs 'standard')\n * @param {Array} props.items - Items to render\n * @param {Function} props.renderItem - Render function for each item\n * @param {boolean} props.loading - Loading state\n * @param {Function} props.renderSkeleton - Custom skeleton renderer\n * @param {number} props.skeletonCount - Number of skeletons\n */\nexport const LayoutRenderer = ({\n  layoutType,\n  entityType,\n  items,\n  renderItem,\n  loading = false,\n  renderSkeleton,\n  skeletonCount = 24,\n}) =&gt; {\n  // Route to appropriate layout\n  switch (layoutType) {\n    case 'list':\n      return (\n        &lt;ListLayout\n          items={items}\n          renderItem={renderItem}\n          loading={loading}\n          renderSkeleton={renderSkeleton}\n          skeletonCount={skeletonCount}\n        /&gt;\n      );\n\n    case 'compact':\n      return (\n        &lt;CompactGridLayout\n          items={items}\n          renderItem={renderItem}\n          loading={loading}\n          renderSkeleton={renderSkeleton}\n          skeletonCount={skeletonCount}\n        /&gt;\n      );\n\n    case 'grid':\n    default:\n      return (\n        &lt;GridLayout\n          entityType={entityType}\n          items={items}\n          renderItem={renderItem}\n          loading={loading}\n          renderSkeleton={renderSkeleton}\n          skeletonCount={skeletonCount}\n        /&gt;\n      );\n  }\n};\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#gridlayout-component-new","title":"GridLayout Component (NEW)","text":"<p>Location: <code>client/src/components/ui/layouts/GridLayout.jsx</code></p> <p>Extracted from current BaseGrid - pure layout logic.</p> <pre><code>import { SCENE_GRID_CONTAINER_CLASSNAMES, STANDARD_GRID_CONTAINER_CLASSNAMES } from '../../../constants/grids.js';\n\n/**\n * GridLayout - Responsive grid layout\n *\n * Pure layout component - only knows about:\n * - Grid classes (responsive columns)\n * - Skeleton rendering while loading\n *\n * Doesn't know about:\n * - Entities\n * - Data fetching\n * - Pagination (handled by SearchResults)\n */\nexport const GridLayout = ({\n  entityType,\n  items,\n  renderItem,\n  loading = false,\n  renderSkeleton,\n  skeletonCount = 24,\n}) =&gt; {\n  // Determine grid type based on entity\n  const gridClasses = entityType === 'scene'\n    ? SCENE_GRID_CONTAINER_CLASSNAMES\n    : STANDARD_GRID_CONTAINER_CLASSNAMES;\n\n  // Default skeleton renderer\n  const defaultRenderSkeleton = () =&gt; (\n    &lt;div\n      className=\"rounded-lg animate-pulse\"\n      style={{\n        backgroundColor: \"var(--bg-tertiary)\",\n        height: entityType === 'scene' ? \"20rem\" : \"24rem\",\n      }}\n    /&gt;\n  );\n\n  const skeletonRenderer = renderSkeleton || defaultRenderSkeleton;\n\n  // Loading state - render skeletons\n  if (loading) {\n    return (\n      &lt;div className={gridClasses}&gt;\n        {[...Array(skeletonCount)].map((_, i) =&gt; (\n          &lt;div key={i}&gt;{skeletonRenderer()}&lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  // Render actual items\n  return (\n    &lt;div className={gridClasses}&gt;\n      {items.map((item, index) =&gt; renderItem(item, index))}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#listlayout-component-new-future","title":"ListLayout Component (NEW - Future)","text":"<p>Location: <code>client/src/components/ui/layouts/ListLayout.jsx</code></p> <pre><code>/**\n * ListLayout - Horizontal row layout\n *\n * Similar to current SceneListItem, but generic for all entities.\n * Each item is a full-width row: [thumbnail | metadata | actions]\n */\nexport const ListLayout = ({\n  items,\n  renderItem,\n  loading = false,\n  renderSkeleton,\n  skeletonCount = 12,\n}) =&gt; {\n  if (loading) {\n    return (\n      &lt;div className=\"space-y-3\"&gt;\n        {[...Array(skeletonCount)].map((_, i) =&gt; (\n          &lt;div\n            key={i}\n            className=\"h-32 rounded-lg animate-pulse\"\n            style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n          /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"space-y-3\"&gt;\n      {items.map((item, index) =&gt; (\n        &lt;div key={item.id || index}&gt;\n          {renderItem(item, index)}\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#how-entitysearch-changes","title":"How EntitySearch Changes","text":"<p>Current EntitySearch: <pre><code>// Currently returns BaseGrid directly\nreturn (\n  &lt;SearchControls ...&gt;\n    &lt;BaseGrid\n      items={data}\n      renderItem={(item, index) =&gt; renderItem(item, index, { onHideSuccess })}\n      gridType={gridType}\n      loading={isLoading}\n      error={error}\n      ...\n    /&gt;\n  &lt;/SearchControls&gt;\n);\n</code></pre></p> <p>New EntitySearch (Phase 1 - Grid only): <pre><code>// Phase 1: Use SearchResults instead of BaseGrid\nreturn (\n  &lt;SearchControls ...&gt;\n    &lt;SearchResults\n      entityType={entityType}  // NEW - needed for preferences\n      items={data}\n      renderItem={(item, index) =&gt; renderItem(item, index, { onHideSuccess })}\n      loading={isLoading}\n      error={error}\n      currentPage={currentPage}\n      totalPages={totalPages}\n      onPageChange={onPageChange}\n      ...\n    /&gt;\n  &lt;/SearchControls&gt;\n);\n</code></pre></p> <p>Future EntitySearch (Phase 2 - Multiple layouts): <pre><code>// Phase 2: SearchResults reads layoutType preference and renders accordingly\n// No code changes needed - SearchResults handles it internally\nreturn (\n  &lt;SearchControls ...&gt;\n    &lt;SearchResults\n      entityType={entityType}\n      items={data}\n      renderItem={(item, index) =&gt; renderItem(item, index, { onHideSuccess })}\n      // ... SearchResults now switches between grid/list/compact automatically\n    /&gt;\n  &lt;/SearchControls&gt;\n);\n</code></pre></p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#code-sharing-dry-principles","title":"Code Sharing &amp; DRY Principles","text":"<p>1. All Entity Cards Share BaseCard <pre><code>// SceneCard, PerformerCard, GalleryCard, etc. all do this:\nreturn (\n  &lt;BaseCard\n    entityType=\"scene\"\n    imagePath={...}\n    title={...}\n    displayPreferences={preferences}  // All read from same hook\n    // Entity-specific customization via render slots\n    renderOverlay={() =&gt; &lt;SceneSpecificOverlay /&gt;}\n  /&gt;\n);\n</code></pre></p> <p>2. All Grids Share EntitySearch <pre><code>// PerformerGrid.jsx - minimal wrapper\nconst PerformerGrid = (props) =&gt; (\n  &lt;EntitySearch\n    entityType=\"performer\"\n    renderItem={(performer, _, { onHideSuccess }) =&gt; (\n      &lt;PerformerCard performer={performer} onHideSuccess={onHideSuccess} /&gt;\n    )}\n    {...props}\n  /&gt;\n);\n</code></pre></p> <p>3. Layout Logic Extracted - GridLayout = ONLY grid classes + skeleton rendering - ListLayout = ONLY row spacing + skeleton rendering - No entity knowledge, no data fetching, no preferences</p> <p>4. Preferences Centralized - One Zustand store for ALL entity preferences - One database table for ALL entity preferences - One hook <code>useEntityDisplayPreferences(entityType)</code> for ALL entities</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#migration-path-phase-1","title":"Migration Path (Phase 1)","text":"<p>Step 1: Replace BaseGrid with SearchResults (grid-only) <pre><code>// Before\n&lt;BaseGrid items={items} renderItem={renderItem} gridType=\"scene\" /&gt;\n\n// After\n&lt;SearchResults\n  entityType=\"scene\"\n  items={items}\n  renderItem={renderItem}\n  // SearchResults internally uses GridLayout only (for now)\n/&gt;\n</code></pre></p> <p>Step 2: Add display preferences to cards <pre><code>// Before\n&lt;SceneCard scene={scene} hideDescription={false} /&gt;\n\n// After\nconst { preferences } = useEntityDisplayPreferences('scene');\n&lt;SceneCard scene={scene} displayPreferences={preferences} /&gt;\n</code></pre></p> <p>Why This Works: - SearchResults defaults to <code>layoutType='grid'</code> if not in preferences - BaseCard defaults to <code>showDescription=true</code> if not in preferences - Existing <code>hideDescription</code> prop overrides preferences (backwards compat) - Zero visual changes until user changes preferences</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#new-components-services","title":"New Components &amp; Services","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#1-user-display-preferences-database-schema","title":"1. User Display Preferences (Database Schema)","text":"<p>New Prisma Model: <pre><code>model EntityDisplayPreferences {\n  id          String   @id @default(cuid())\n  userId      String\n  entityType  String   // 'scene' | 'performer' | 'gallery' | etc.\n\n  // Phase 1 settings\n  showDescription Boolean @default(true)\n\n  // Future settings (add in later phases)\n  // showSubtitle    Boolean @default(true)\n  // layoutType      String  @default(\"grid\") // 'grid' | 'list' | 'compact'\n  // cardDensity     String  @default(\"normal\") // 'compact' | 'normal' | 'detailed'\n\n  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n  @@index([userId])\n}\n</code></pre></p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#2-react-hook-useentitydisplaypreferences","title":"2. React Hook: <code>useEntityDisplayPreferences</code>","text":"<p>Location: <code>client/src/hooks/useEntityDisplayPreferences.js</code></p> <pre><code>import { create } from 'zustand';\nimport { apiGet, apiPost } from '../services/api';\n\n// Zustand store for caching preferences\nconst usePreferencesStore = create((set) =&gt; ({\n  preferences: {}, // { scene: { showDescription: true }, performer: { ... } }\n  isLoaded: false,\n\n  setPreferences: (prefs) =&gt; set({ preferences: prefs, isLoaded: true }),\n\n  updatePreference: (entityType, updates) =&gt; set((state) =&gt; ({\n    preferences: {\n      ...state.preferences,\n      [entityType]: { ...state.preferences[entityType], ...updates }\n    }\n  }))\n}));\n\nexport const useEntityDisplayPreferences = (entityType) =&gt; {\n  const { preferences, isLoaded, updatePreference } = usePreferencesStore();\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Load preferences on mount\n  useEffect(() =&gt; {\n    if (!isLoaded) {\n      loadPreferences();\n    }\n  }, [isLoaded]);\n\n  const loadPreferences = async () =&gt; {\n    try {\n      const data = await apiGet('/api/display-preferences');\n      usePreferencesStore.getState().setPreferences(data);\n    } catch (error) {\n      console.error('Failed to load display preferences:', error);\n    }\n  };\n\n  const updatePreferences = async (updates) =&gt; {\n    setIsSaving(true);\n    try {\n      await apiPost(`/api/display-preferences/${entityType}`, updates);\n      updatePreference(entityType, updates);\n    } catch (error) {\n      console.error('Failed to save display preferences:', error);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  // Default preferences if not set\n  const defaultPrefs = {\n    showDescription: true\n  };\n\n  return {\n    preferences: preferences[entityType] || defaultPrefs,\n    updatePreferences,\n    isSaving,\n    isLoaded\n  };\n};\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#3-enhanced-basecard","title":"3. Enhanced BaseCard","text":"<p>Changes to <code>client/src/components/ui/BaseCard.jsx</code>:</p> <pre><code>export const BaseCard = forwardRef((\n  {\n    // Data\n    entityType,\n    imagePath,\n    title,\n    subtitle,\n    description,\n    linkTo,\n\n    // Display preferences (NEW)\n    displayPreferences = {},\n\n    // Indicators &amp; Rating\n    indicators = [],\n    ratingControlsProps,\n\n    // Display options (keep for backwards compat)\n    hideDescription = false,\n    hideSubtitle = false,\n    maxTitleLines = 2,\n    maxDescriptionLines = 3,\n    objectFit = \"contain\",\n\n    // Customization slots\n    renderOverlay,\n    renderImageContent,\n    renderAfterTitle,\n\n    // Events &amp; behavior\n    onClick,\n    className = \"\",\n    referrerUrl,\n    tabIndex,\n    style,\n    ...rest\n  },\n  ref\n) =&gt; {\n  const aspectRatio = useEntityImageAspectRatio(entityType);\n\n  // Merge display preferences with explicit props (props take precedence)\n  const shouldShowDescription = hideDescription === true\n    ? false\n    : (displayPreferences.showDescription ?? true);\n\n  return (\n    &lt;CardContainer\n      ref={ref}\n      entityType={entityType}\n      linkTo={linkTo}\n      onClick={onClick}\n      referrerUrl={referrerUrl}\n      className={className}\n      tabIndex={tabIndex}\n      style={style}\n      {...rest}\n    &gt;\n      {/* Image Section */}\n      &lt;CardImage\n        src={imagePath}\n        alt={typeof title === \"string\" ? title : \"\"}\n        aspectRatio={aspectRatio}\n        entityType={entityType}\n        objectFit={objectFit}\n      &gt;\n        {renderImageContent?.()}\n        {renderOverlay?.()}\n      &lt;/CardImage&gt;\n\n      {/* Title Section */}\n      &lt;CardTitle\n        title={title}\n        subtitle={hideSubtitle ? null : subtitle}\n        maxTitleLines={maxTitleLines}\n      /&gt;\n\n      {/* After Title Slot */}\n      {renderAfterTitle?.()}\n\n      {/* Description - now respects display preferences */}\n      {shouldShowDescription &amp;&amp; (\n        &lt;CardDescription\n          description={description}\n          maxLines={maxDescriptionLines}\n        /&gt;\n      )}\n\n      {/* Indicators */}\n      {indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators indicators={indicators} /&gt;}\n\n      {/* Rating Controls */}\n      {ratingControlsProps &amp;&amp; (\n        &lt;CardRatingRow entityType={entityType} {...ratingControlsProps} /&gt;\n      )}\n    &lt;/CardContainer&gt;\n  );\n});\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#4-migrate-scenecard-to-basecard","title":"4. Migrate SceneCard to BaseCard","text":"<p>New implementation of <code>client/src/components/ui/SceneCard.jsx</code>:</p> <pre><code>const SceneCard = forwardRef((\n  {\n    scene,\n    onClick,\n    onFocus,\n    tabIndex = -1,\n    className = \"\",\n    isSelected = false,\n    onToggleSelect,\n    selectionMode = false,\n    autoplayOnScroll = false,\n    hideRatingControls = false,\n    onHideSuccess,\n    displayPreferences = {}, // NEW: from useEntityDisplayPreferences\n  },\n  ref\n) =&gt; {\n  const { isTVMode } = useTVMode();\n  const navigate = useNavigate();\n  const aspectRatio = useEntityImageAspectRatio(\"scene\");\n\n  // All existing state and handlers...\n  const [isLongPressing, setIsLongPressing] = useState(false);\n  // ... (keep all gesture detection logic)\n\n  const title = getSceneTitle(scene);\n  const description = getSceneDescription(scene);\n  const subtitle = buildSceneSubtitle(scene); // Extract to utility\n  const allTags = computeAllTags(scene); // Extract to utility\n  const indicators = buildSceneIndicators(scene, allTags, navigate); // Extract to utility\n\n  // Selection checkbox overlay\n  const renderOverlay = () =&gt; (\n    &lt;div className=\"absolute top-2 left-2 z-20\"&gt;\n      &lt;button\n        onClick={handleCheckboxClick}\n        className=\"w-8 h-8 sm:w-6 sm:h-6 rounded border-2 flex items-center justify-center transition-all\"\n        style={{\n          backgroundColor: isSelected ? \"var(--selection-color)\" : \"rgba(0, 0, 0, 0.5)\",\n          borderColor: isSelected ? \"var(--selection-color)\" : \"rgba(255, 255, 255, 0.7)\",\n        }}\n        aria-label={isSelected ? \"Deselect scene\" : \"Select scene\"}\n      &gt;\n        {isSelected &amp;&amp; &lt;CheckmarkIcon /&gt;}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n\n  // Video preview + progress bar\n  const renderImageContent = () =&gt; (\n    &lt;&gt;\n      &lt;SceneCardPreview\n        scene={scene}\n        autoplayOnScroll={autoplayOnScroll}\n        cycleInterval={600}\n        spriteCount={10}\n        duration={duration}\n        resolution={resolution}\n      /&gt;\n      &lt;div className=\"absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent pointer-events-none\" /&gt;\n\n      {/* Watch progress bar */}\n      {scene.resumeTime &amp;&amp; scene.files?.[0]?.duration &amp;&amp; (\n        &lt;div className=\"absolute bottom-0 left-0 right-0 h-1 bg-black/50 pointer-events-none\"&gt;\n          &lt;div\n            className=\"h-full transition-all pointer-events-none\"\n            style={{\n              width: `${Math.min(100, (scene.resumeTime / scene.files[0].duration) * 100)}%`,\n              backgroundColor: \"var(--status-success)\",\n            }}\n          /&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/&gt;\n  );\n\n  return (\n    &lt;BaseCard\n      ref={ref}\n      entityType=\"scene\"\n      imagePath={scene.paths?.screenshot}\n      title={title}\n      subtitle={subtitle}\n      description={description}\n      indicators={indicators}\n      displayPreferences={displayPreferences} // NEW\n\n      // Scene-specific render slots\n      renderOverlay={renderOverlay}\n      renderImageContent={renderImageContent}\n\n      // Rating controls\n      ratingControlsProps={!hideRatingControls &amp;&amp; {\n        entityType: \"scene\",\n        entityId: scene.id,\n        initialRating: scene.rating,\n        initialFavorite: scene.favorite || false,\n        initialOCounter: scene.o_counter,\n        entityTitle: title,\n        onHideSuccess,\n      }}\n\n      // Custom styling for selection\n      className={`${isSelected ? \"scene-card-selected\" : \"\"} ${className}`}\n      style={{\n        borderColor: isSelected ? \"var(--selection-color)\" : \"var(--border-color)\",\n        borderWidth: isSelected ? \"2px\" : \"1px\",\n      }}\n\n      // Events - wrapped to handle selection mode\n      onClick={(e) =&gt; {\n        // ... existing click handling logic\n      }}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseLeave={handleMouseUp}\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n      onTouchCancel={handleTouchEnd}\n      onKeyDown={handleKeyDown}\n      onFocus={onFocus}\n      tabIndex={isTVMode ? tabIndex : -1}\n    /&gt;\n  );\n});\n</code></pre>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#refactoring-plan","title":"Refactoring Plan","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#phase-1-foundation-this-branch","title":"Phase 1: Foundation (This Branch)","text":"<p>1. Database &amp; API - [ ] Add <code>EntityDisplayPreferences</code> Prisma model - [ ] Create migration - [ ] Add API endpoints (<code>GET /api/display-preferences</code>, <code>POST /api/display-preferences/:entityType</code>) - [ ] Add integration tests</p> <p>2. Client Hooks &amp; State - [ ] Create <code>useEntityDisplayPreferences</code> hook with Zustand store - [ ] Add API service methods</p> <p>3. BaseCard Enhancement - [ ] Add <code>displayPreferences</code> prop to BaseCard - [ ] Update description rendering logic to respect preferences - [ ] Ensure backwards compatibility (existing hideDescription prop)</p> <p>4. Entity Card Updates - [ ] Update each entity card to pass <code>displayPreferences</code> to BaseCard - [ ] Add <code>useEntityDisplayPreferences</code> to each grid component</p> <p>5. SceneCard Migration - [ ] Extract utilities: <code>buildSceneSubtitle</code>, <code>computeAllTags</code>, <code>buildSceneIndicators</code> - [ ] Rewrite SceneCard to use BaseCard - [ ] Test all scene-specific features (selection, gestures, preview, progress) - [ ] Update tests</p> <p>6. Settings UI - [ ] Add \"Display Preferences\" section to user settings - [ ] Per-entity toggles for \"Show descriptions\" - [ ] Save/load from API</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#phase-2-extended-customization-future","title":"Phase 2: Extended Customization (Future)","text":"<p>7. Additional Preferences - [ ] Show/hide subtitle - [ ] Show/hide specific indicators - [ ] Card density presets</p> <p>8. Alternative Layouts - [ ] Layout renderer abstraction - [ ] List layout implementation - [ ] Compact grid layout - [ ] Entity-specific layouts (tag hierarchy, etc.)</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#benefits-of-this-approach","title":"Benefits of This Approach","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#1-dry-maintainable","title":"1. DRY &amp; Maintainable","text":"<ul> <li>Single source of truth: BaseCard for all entity cards</li> <li>No duplication: SceneCard no longer reimplements CardComponents</li> <li>Consistent behavior: Rating, favorite, hide all work identically</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#2-extensible","title":"2. Extensible","text":"<ul> <li>Pluggable layouts: Easy to add list/compact/custom layouts</li> <li>Flexible preferences: Database schema ready for future settings</li> <li>Entity-specific features: Render slots allow customization without breaking abstraction</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#3-user-friendly","title":"3. User-Friendly","text":"<ul> <li>Personalization: Per-entity display preferences</li> <li>Synced across devices: Database storage</li> <li>Discoverable: Settings UI makes customization obvious</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#4-performance","title":"4. Performance","text":"<ul> <li>Cached preferences: Zustand store prevents repeated API calls</li> <li>Lazy loading: Existing CardImage lazy loading preserved</li> <li>Optimistic updates: UI updates immediately, API saves in background</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#5-type-safe","title":"5. Type-Safe","text":"<ul> <li>Server types: Prisma schema generates TypeScript types</li> <li>API contract: Integration tests ensure correctness</li> <li>Component props: Clear interfaces for all cards</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#migration-strategy","title":"Migration Strategy","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#backwards-compatibility","title":"Backwards Compatibility","text":"<p>During migration, ensure: 1. Existing cards continue to work - <code>hideDescription</code> prop still respected 2. No visual changes - Default preferences match current behavior 3. Progressive enhancement - Preferences optional, graceful degradation</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#testing-strategy","title":"Testing Strategy","text":"<p>Unit Tests: - BaseCard with displayPreferences prop - useEntityDisplayPreferences hook - API endpoints</p> <p>Integration Tests: - Full preference save/load flow - Multiple entity types - Preference changes reflected in UI</p> <p>Manual Testing: - SceneCard selection mode - SceneCard gestures (long-press, touch) - SceneCard keyboard navigation - Video preview autoplay - All entity card types render correctly</p>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#file-changes-summary","title":"File Changes Summary","text":""},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#new-files","title":"New Files","text":"<ul> <li><code>server/prisma/migrations/YYYYMMDD_add_entity_display_preferences.sql</code></li> <li><code>server/controllers/displayPreferences.ts</code></li> <li><code>server/routes/displayPreferences.ts</code></li> <li><code>client/src/hooks/useEntityDisplayPreferences.js</code></li> <li><code>client/src/components/settings/DisplayPreferencesSection.jsx</code></li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#modified-files","title":"Modified Files","text":"<ul> <li><code>server/types/api/displayPreferences.ts</code> (new)</li> <li><code>client/src/components/ui/BaseCard.jsx</code> (add displayPreferences prop)</li> <li><code>client/src/components/ui/SceneCard.jsx</code> (major refactor to use BaseCard)</li> <li><code>client/src/components/cards/*.jsx</code> (all 6 entity cards - pass displayPreferences)</li> <li><code>client/src/components/grids/*.jsx</code> (all 6 grids - use hook)</li> <li><code>client/src/components/scene-search/SceneGrid.jsx</code> (use hook)</li> <li><code>client/src/components/pages/Settings.jsx</code> (add display preferences section)</li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#utilities-to-extract","title":"Utilities to Extract","text":"<ul> <li><code>client/src/utils/sceneCard.js</code> - Scene-specific card utilities</li> <li><code>buildSceneSubtitle(scene)</code></li> <li><code>computeAllTags(scene)</code></li> <li><code>buildSceneIndicators(scene, allTags, navigate)</code></li> </ul>"},{"location":"plans/2026-01-05-ui-component-refactor-3.2.0/#revision-history","title":"Revision History","text":"<ul> <li>2026-01-05: Complete design document with detailed architecture</li> <li>Completed component inventory (7 entity types, special patterns)</li> <li>Identified 6 major inconsistencies with code examples</li> <li>Documented current architecture and data flow</li> <li>Established scope (all searchable entities)</li> <li>Designed pluggable layout system (SearchResults \u2192 LayoutRenderer \u2192 GridLayout/ListLayout)</li> <li>Created detailed component implementations with React patterns</li> <li>Designed user preferences system (Zustand + database)</li> <li>Created implementation plan with detailed checklist (6 phases)</li> <li>Explained code sharing and DRY principles</li> <li>Ready for implementation</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/","title":"Unified Settings Navigation - Design Document","text":"<p>Date: 2026-01-05 Version: 3.2.0 Status: Approved</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#overview","title":"Overview","text":"<p>Consolidate User Settings and Server Settings into a single Settings page with mobile-friendly sub-navigation, accessible to all users. This reorganization prepares for upcoming features like card anatomy customization and custom field display names.</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#motivation","title":"Motivation","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#current-problems","title":"Current Problems","text":"<ol> <li>User Settings hidden in UserMenu dropdown (low discoverability)</li> <li>Server Settings top-level for admins only (inconsistent access patterns)</li> <li>Flat settings page structure doesn't scale for planned features</li> <li>No clear organization for upcoming customization options</li> </ol>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#goals","title":"Goals","text":"<ol> <li>Unified Settings entry point for all users</li> <li>Scalable tab-based organization</li> <li>Mobile-friendly navigation across all screen sizes</li> <li>Maintain existing functionality during reorganization</li> <li>Support future settings categories (card anatomy, field customization)</li> </ol>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#navigation-changes","title":"Navigation Changes","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#settings-button-replacement","title":"Settings Button Replacement","text":"<p>Current State: - Admin-only \"Server Settings\" wrench icon in bottom navigation section - Users access \"My Settings\" via UserMenu dropdown</p> <p>New State: - Universal \"Settings\" button (gear/cog icon) for all users - Appears in same location as current Server Settings button - Visible in all three layout versions</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#three-layout-implementations","title":"Three Layout Implementations","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#1-mobile-topbar-lg-breakpoint","title":"1. Mobile TopBar (&lt; lg breakpoint)","text":"<ul> <li>Settings item in hamburger menu</li> <li>Icon + \"Settings\" text</li> <li>Replaces admin-only Server Settings entry</li> <li>File: <code>client/src/components/ui/TopBar.jsx</code></li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#2-collapsed-sidebar-lg-xl-breakpoint","title":"2. Collapsed Sidebar (lg - xl breakpoint)","text":"<ul> <li>Settings icon button with tooltip</li> <li>64px wide sidebar section</li> <li>Icon only (gear/cog)</li> <li>File: <code>client/src/components/ui/Sidebar.jsx</code></li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#3-expanded-sidebar-xl-breakpoint","title":"3. Expanded Sidebar (xl+ breakpoint)","text":"<ul> <li>Settings icon + \"Settings\" text</li> <li>240px wide sidebar section</li> <li>Full button layout</li> <li>File: <code>client/src/components/ui/Sidebar.jsx</code></li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#new-settings-page-structure","title":"New Settings Page Structure","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#route-settings","title":"Route: <code>/settings</code>","text":"<p>URL Pattern: <code>/settings?section={user|server}&amp;tab={tabName}</code></p> <p>Examples: - <code>/settings</code> \u2192 Defaults to User Settings, Theme tab - <code>/settings?section=user&amp;tab=playback</code> \u2192 User Settings, Playback tab - <code>/settings?section=server&amp;tab=user-management</code> \u2192 Server Settings, User Management tab (admin only)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#page-layout","title":"Page Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Settings                                                    \u2502\n\u2502 Manage your preferences and server configuration           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n\u2502 \u2502 User Settings\u2502 Server Settings   \u2502  \u2190 Top-level sections \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n\u2502        \u25bc                                                    \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502 \u2502Theme\u2502Playback\u2502Customization \u2502Content  \u2502Account  \u2502 \u2190 Tabs\u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502 [Active tab content appears here]                          \u2502\n\u2502                                                             \u2502\n\u2502 [Form fields, components, etc.]                            \u2502\n\u2502                                                             \u2502\n\u2502 [Save button if applicable]                                \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#top-level-sections","title":"Top-Level Sections","text":"<p>User Settings (visible to all users) - 5 tabs: Theme, Playback, Customization, Content, Account</p> <p>Server Settings (admin only) - 2 tabs: User Management, Server Configuration - Non-admins: Section not shown in UI - Direct URL access blocked with redirect</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#sub-navigation-pattern","title":"Sub-Navigation Pattern","text":"<p>Horizontal Scrollable Tabs: - Desktop: Horizontal tabs below section selector - Mobile: Horizontally scrollable with fade indicators - Active tab auto-scrolls into view - Smooth scroll behavior with touch support - Material Design tab pattern (bottom border for active state)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-tabs","title":"User Settings Tabs","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#1-theme-tab","title":"1. Theme Tab","text":"<p>Content: - Built-in Themes (selection grid) - Custom Themes (Custom Theme Manager component) - UI Examples (collapsible, existing functionality)</p> <p>Current Source: - Lines 206-237: Built-in theme selection - Lines 941-945: Custom theme manager - Maintains live theme preview functionality</p> <p>Data/API: - No separate save button (theme changes apply immediately) - Custom themes have their own save/delete actions</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#2-playback-tab","title":"2. Playback Tab","text":"<p>Content: - Preferred Quality (auto, 1080p, 720p, 480p, 360p) - Scene Card Preview Quality (sprite, webp, mp4) - Preferred Playback Mode (auto, direct, transcode) - Enable Chromecast/AirPlay (checkbox) - Minimum Play Percent (0-100%, 5% increments)</p> <p>Current Source: - Lines 948-1172 from Settings.jsx - Remove \"Measurement Units\" field (moved to Customization tab)</p> <p>Data/API: - Single save button at bottom - PUT <code>/api/user/settings</code> with playback fields - Form validation for percentage range</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#3-customization-tab","title":"3. Customization Tab","text":"<p>Content: - Navigation Settings (reorder/toggle nav items) - Carousel Settings (reorder/toggle carousels) - Measurement Units (metric/imperial dropdown) - (Future: Card anatomy visibility toggles) - (Future: Custom field display names)</p> <p>Current Source: - Lines 1186-1192: NavigationSettings component - Lines 1176-1182: CarouselSettings component - Lines 1128-1157: Measurement units dropdown</p> <p>Data/API: - Navigation: Separate save (triggers page reload) - Carousel: Separate save - Measurement units: Part of general settings save - Each subsection has its own save button</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#4-content-tab","title":"4. Content Tab","text":"<p>Content: - Hidden Items management   - Link to <code>/hidden-items</code> page with count   - \"View Hidden Items\" button - Hide confirmation toggle   - Checkbox: \"Don't ask for confirmation when hiding items\"</p> <p>Current Source: - Lines 1196-1234 from Settings.jsx - Maintains link to dedicated hidden items page</p> <p>Data/API: - Hide confirmation toggle saves immediately via context - No separate save button needed</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#5-account-tab","title":"5. Account Tab","text":"<p>Content: - Change Password form   - Current Password (required, type=password, min 6 chars)   - New Password (required, type=password, min 6 chars)   - Confirm New Password (required, type=password, min 6 chars)</p> <p>Current Source: - Lines 1237-1326 from Settings.jsx - Client-side validation (passwords match, min length)</p> <p>Data/API: - Separate \"Change Password\" button - POST <code>/api/user/change-password</code> - Clears form on success - Shows error/success toast</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#server-settings-tabs-admin-only","title":"Server Settings Tabs (Admin Only)","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#1-user-management-tab","title":"1. User Management Tab","text":"<p>Content: - User list table (username, role, created date, actions) - Create new user button/form - Edit user modal/form - Delete user confirmation - Role management (admin/user)</p> <p>Current Source: - Wraps existing <code>UserManagementSection</code> component - From ServerSettings.jsx line 109</p> <p>Data/API: - GET <code>/api/user/all</code> - Load users - POST <code>/api/user/create</code> - Create user - PUT <code>/api/user/:id</code> - Update user - DELETE <code>/api/user/:id</code> - Delete user</p> <p>Permissions: - Admin only access - Cannot delete self - Cannot demote self if last admin</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#2-server-configuration-tab","title":"2. Server Configuration Tab","text":"<p>Content: - Stash Instance configuration   - URL, API key, connection test - Server Statistics   - Uptime, memory, database stats - Version Information   - Client version, server version, build info</p> <p>Current Source: - Wraps existing sections from ServerSettings.jsx:   - Line 119: StashInstanceSection   - Line 122: ServerStatsSection   - Line 125: VersionInfoSection</p> <p>Data/API: - Various endpoints for each subsection - Each subsection has its own save/update logic</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#url-redirects","title":"URL Redirects","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#legacy-routes-new-routes","title":"Legacy Routes \u2192 New Routes","text":"Old Route New Route Method <code>/my-settings</code> <code>/settings?section=user&amp;tab=theme</code> Replace <code>/server-settings</code> <code>/settings?section=server&amp;tab=user-management</code> Replace <p>Implementation: - Add <code>&lt;Route&gt;</code> redirects in App.jsx using <code>&lt;Navigate replace /&gt;</code> - Preserves browser history (back button works) - Handles existing bookmarks - Old routes eventually removed after deprecation period</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#usermenu-changes","title":"UserMenu Changes","text":"<p>Remove from UserMenu dropdown: - \"My Settings\" link (lines 122-138 in UserMenu.jsx)</p> <p>Keep in UserMenu: - Watch History - TV Mode toggle - Sign Out</p> <p>Rationale: - Settings now top-level navigation item - Reduces UserMenu clutter - Consistent with Settings visibility for all users</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#mobile-behavior","title":"Mobile Behavior","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#tab-scrolling-mechanics","title":"Tab Scrolling Mechanics","text":"<p>CSS Implementation: <pre><code>.settings-tabs {\n  overflow-x: auto;\n  -webkit-overflow-scrolling: touch;\n  scroll-behavior: smooth;\n  scrollbar-width: none; /* Firefox */\n}\n\n.settings-tabs::-webkit-scrollbar {\n  display: none; /* Chrome/Safari */\n}\n</code></pre></p> <p>Visual Indicators: - Gradient fade on left edge (when scrolled right) - Gradient fade on right edge (when scrolled left) - JavaScript detection of scroll position - Active tab scrolls into view on mount/change</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#responsive-breakpoints","title":"Responsive Breakpoints","text":"Breakpoint Width Behavior Mobile &lt; 768px Full vertical stacking, scrollable tabs Tablet 768-1024px Horizontal layout, may scroll tabs Desktop 1024px+ Full horizontal, tabs rarely scroll"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#component-architecture","title":"Component Architecture","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#new-components","title":"New Components","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#settingspagejsx","title":"<code>SettingsPage.jsx</code>","text":"<p>Location: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Responsibilities: - Main settings page component - Parse URL parameters (section, tab) - Manage section/tab state - Render SectionSelector and SettingsLayout - Handle role-based access (admin check for server section) - Redirect non-admins from server section</p> <p>Props: None (uses URL params and auth context)</p> <p>State: - <code>activeSection</code>: 'user' | 'server' - <code>activeTab</code>: string (tab identifier)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#settingslayoutjsx","title":"<code>SettingsLayout.jsx</code>","text":"<p>Location: <code>client/src/components/settings/SettingsLayout.jsx</code></p> <p>Responsibilities: - Reusable layout wrapper for settings tabs - Horizontal tab navigation rendering - Mobile scroll behavior - URL parameter updates on tab change - Active tab detection and styling</p> <p>Props: <pre><code>{\n  tabs: Array&lt;{ id: string, label: string, icon?: string }&gt;,\n  activeTab: string,\n  onTabChange: (tabId: string) =&gt; void,\n  children: ReactNode\n}\n</code></pre></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#sectionselectorjsx","title":"<code>SectionSelector.jsx</code>","text":"<p>Location: <code>client/src/components/settings/SectionSelector.jsx</code></p> <p>Responsibilities: - Top-level User/Server section switcher - Segmented control style (two-button toggle) - Shows Server option only for admins - Updates URL parameter on change</p> <p>Props: <pre><code>{\n  activeSection: 'user' | 'server',\n  onSectionChange: (section: string) =&gt; void,\n  isAdmin: boolean\n}\n</code></pre></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#tab-content-components","title":"Tab Content Components","text":"Component Location Wraps/Reuses <code>ThemeTab.jsx</code> <code>components/settings/tabs/ThemeTab.jsx</code> Existing theme UI <code>PlaybackTab.jsx</code> <code>components/settings/tabs/PlaybackTab.jsx</code> Existing playback form <code>CustomizationTab.jsx</code> <code>components/settings/tabs/CustomizationTab.jsx</code> Nav/Carousel/Units <code>ContentTab.jsx</code> <code>components/settings/tabs/ContentTab.jsx</code> Hidden items section <code>AccountTab.jsx</code> <code>components/settings/tabs/AccountTab.jsx</code> Password change form <code>UserManagementTab.jsx</code> <code>components/settings/tabs/UserManagementTab.jsx</code> UserManagementSection <code>ServerConfigTab.jsx</code> <code>components/settings/tabs/ServerConfigTab.jsx</code> Multiple sections <p>Pattern: - Each tab is a self-contained component - Manages its own form state - Handles its own API calls - Shows loading/error states - Displays success/error toasts</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#modified-components","title":"Modified Components","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#sidebarjsx","title":"<code>Sidebar.jsx</code>","text":"<p>Changes: - Line ~280-309: Server Settings section - Replace <code>user.role === \"ADMIN\"</code> check with universal Settings button - Change icon from \"wrench\" to \"settings\" - Update link from <code>/server-settings</code> to <code>/settings</code> - Update aria-label and tooltip to \"Settings\"</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#topbarjsx","title":"<code>TopBar.jsx</code>","text":"<p>Changes: - Line ~159-180: Server Settings in hamburger menu - Replace admin-only conditional with universal Settings - Update link from <code>/server-settings</code> to <code>/settings</code> - Change icon from \"wrench\" to \"settings\" - Update display text to \"Settings\"</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#usermenujsx","title":"<code>UserMenu.jsx</code>","text":"<p>Changes: - Remove lines 122-138: \"My Settings\" link - Keep Watch History, TV Mode, Sign Out - Adjust spacing/styling if needed</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#appjsx","title":"<code>App.jsx</code>","text":"<p>Changes: - Add <code>/settings</code> route with SettingsPage component - Add redirect routes for <code>/my-settings</code> and <code>/server-settings</code> - Remove old routes after deprecation period</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#state-management","title":"State Management","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#url-parameters","title":"URL Parameters","text":"<p>Schema: <pre><code>{\n  section: 'user' | 'server',  // Default: 'user'\n  tab: string                   // Default: first tab of section\n}\n</code></pre></p> <p>Default Tabs: - User section: 'theme' - Server section: 'user-management'</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#url-update-logic","title":"URL Update Logic","text":"<p>On Tab Change: <pre><code>const handleTabChange = (newTab) =&gt; {\n  const params = new URLSearchParams(location.search);\n  params.set('tab', newTab);\n  navigate(`/settings?${params.toString()}`, { replace: true });\n};\n</code></pre></p> <p>On Section Change: <pre><code>const handleSectionChange = (newSection) =&gt; {\n  const defaultTab = newSection === 'user' ? 'theme' : 'user-management';\n  navigate(`/settings?section=${newSection}&amp;tab=${defaultTab}`, { replace: true });\n};\n</code></pre></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#default-behavior","title":"Default Behavior","text":"Scenario Behavior Landing on <code>/settings</code> User Settings, Theme tab Admin landing on <code>/settings</code> User Settings, Theme tab Non-admin accessing <code>?section=server</code> Redirect to User Settings, Theme tab Invalid tab name Default to first tab of section Back/forward navigation Respects URL params Refresh Maintains current section/tab"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#tab-persistence","title":"Tab Persistence","text":"<ul> <li>URL updates when switching tabs (no page reload)</li> <li>Browser back/forward navigation works</li> <li>Shareable links to specific tabs</li> <li>Refresh maintains current tab</li> <li>Deep linking supported</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#visual-design","title":"Visual Design","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#section-selector-userserver","title":"Section Selector (User/Server)","text":"<p>Style: Segmented control</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 User Settings  \u2502 Server Settings   \u2502\n\u2502   (selected)   \u2502   (unselected)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Specifications: - Two buttons side-by-side - Active button: <code>background: var(--accent-primary)</code>, <code>color: white</code> - Inactive button: <code>background: var(--bg-secondary)</code>, <code>color: var(--text-primary)</code> - Border radius: <code>0.5rem</code> - Height: <code>2.5rem</code> (40px) - Transition: <code>all 0.2s ease</code> - Mobile: Full width, centered - Desktop: Max-width 400px, centered</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#tab-navigation","title":"Tab Navigation","text":"<p>Style: Horizontal scrollable tabs (Material Design pattern)</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Theme\u2502Playback \u2502Customization \u2502Content  \u2502Account  \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2514\u2500 Active indicator (accent color bottom border)\n</code></pre> <p>Specifications: - Active tab:   - Bottom border: <code>3px solid var(--accent-primary)</code>   - Font weight: <code>600</code>   - Color: <code>var(--accent-primary)</code> - Inactive tabs:   - No bottom border   - Font weight: <code>500</code>   - Color: <code>var(--text-secondary)</code>   - Hover: <code>background: var(--bg-secondary)</code> - Tab spacing: <code>1rem</code> gap between tabs - Font size: <code>14px</code> - Padding: <code>0.75rem 1rem</code> - Minimum tap target: <code>44px</code> height (mobile)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#tab-content-area","title":"Tab Content Area","text":"<p>Style: Paper component pattern</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                     \u2502\n\u2502  [Tab content rendered here]        \u2502\n\u2502                                     \u2502\n\u2502  [Forms, settings, etc.]            \u2502\n\u2502                                     \u2502\n\u2502                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502                 \u2502 Save Button  \u2502    \u2502\n\u2502                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Specifications: - Background: <code>var(--bg-card)</code> - Border: <code>1px solid var(--border-color)</code> - Border radius: <code>0.5rem</code> - Padding: <code>1.5rem</code> - Shadow: <code>var(--shadow-md)</code> - Min height: <code>400px</code></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#mobile-scroll-indicators","title":"Mobile Scroll Indicators","text":"<p>Left/Right Fade Gradients: <pre><code>.tab-scroll-container {\n  position: relative;\n}\n\n.tab-scroll-container::before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  width: 2rem;\n  background: linear-gradient(to right, var(--bg-secondary), transparent);\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.tab-scroll-container.scrolled-right::before {\n  opacity: 1;\n}\n</code></pre></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#accessibility","title":"Accessibility","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#keyboard-navigation","title":"Keyboard Navigation","text":"<p>Tab Navigation: - <code>Tab</code> key: Navigate through section selector, tabs, and form fields - <code>Enter</code>/<code>Space</code>: Activate selected tab - <code>Arrow Left</code>/<code>Right</code>: Move between tabs when tab list is focused - Focus indicators: Visible outline on all interactive elements</p> <p>Focus Order: 1. Section selector (if admin) 2. Tab navigation 3. Tab content (forms, buttons)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#aria-attributes","title":"ARIA Attributes","text":"<p>Tab List: <pre><code>&lt;div role=\"tablist\" aria-label=\"Settings sections\"&gt;\n  &lt;button\n    role=\"tab\"\n    aria-selected=\"true\"\n    aria-controls=\"theme-panel\"\n    id=\"theme-tab\"\n  &gt;\n    Theme\n  &lt;/button&gt;\n  &lt;!-- ... more tabs ... --&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Tab Panel: <pre><code>&lt;div\n  role=\"tabpanel\"\n  id=\"theme-panel\"\n  aria-labelledby=\"theme-tab\"\n&gt;\n  &lt;!-- Tab content --&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Section Selector: <pre><code>&lt;div role=\"radiogroup\" aria-label=\"Settings section\"&gt;\n  &lt;button role=\"radio\" aria-checked=\"true\"&gt;User Settings&lt;/button&gt;\n  &lt;button role=\"radio\" aria-checked=\"false\"&gt;Server Settings&lt;/button&gt;\n&lt;/div&gt;\n</code></pre></p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#screen-reader-announcements","title":"Screen Reader Announcements","text":"<p>On Tab Change: - Announce: \"Theme tab selected\" (or current tab name) - Tab panel content becomes focus target</p> <p>On Section Change: - Announce: \"User Settings section selected\" - First tab in section announced</p> <p>Form Validation: - Error messages associated with inputs via <code>aria-describedby</code> - Error summary at top of form if multiple errors - Success/error toasts announced as alerts</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#phase-1-core-structure","title":"Phase 1: Core Structure","text":"<p>Goal: Create foundational components and routing</p> <p>Tasks: 1. Create <code>SettingsPage.jsx</code> with URL parameter handling 2. Create <code>SettingsLayout.jsx</code> with tab navigation 3. Create <code>SectionSelector.jsx</code> component 4. Add <code>/settings</code> route to App.jsx 5. Implement horizontal scrollable tabs with mobile support 6. Add URL parameter state management</p> <p>Validation: - <code>/settings</code> route renders - URL parameters control section/tab - Tab navigation works - Mobile scrolling works</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#phase-2-user-settings-migration","title":"Phase 2: User Settings Migration","text":"<p>Goal: Migrate all User Settings tabs</p> <p>Tasks: 1. Create <code>ThemeTab.jsx</code> - Move theme selection UI 2. Create <code>PlaybackTab.jsx</code> - Move playback form (remove units) 3. Create <code>CustomizationTab.jsx</code> - Combine nav/carousel/units 4. Create <code>ContentTab.jsx</code> - Move hidden items section 5. Create <code>AccountTab.jsx</code> - Move password change form 6. Test each tab's save functionality 7. Verify all API calls work correctly</p> <p>Validation: - All tabs render correctly - Forms submit and save data - Validation works - Toasts show on success/error</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#phase-3-server-settings-migration","title":"Phase 3: Server Settings Migration","text":"<p>Goal: Migrate Server Settings with admin permissions</p> <p>Tasks: 1. Create <code>UserManagementTab.jsx</code> wrapping existing section 2. Create <code>ServerConfigTab.jsx</code> wrapping existing sections 3. Implement admin-only section visibility 4. Add redirect for non-admin accessing server section 5. Test all server settings functionality</p> <p>Validation: - Admin sees both sections - Non-admin only sees User Settings - Non-admin redirected from <code>?section=server</code> - All server settings work</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#phase-4-navigation-updates","title":"Phase 4: Navigation Updates","text":"<p>Goal: Update all navigation components</p> <p>Tasks: 1. Update <code>Sidebar.jsx</code> - Replace Server Settings with universal Settings    - Icon-only collapsed view (lg-xl)    - Icon+text expanded view (xl+) 2. Update <code>TopBar.jsx</code> - Replace Server Settings in hamburger menu 3. Update <code>UserMenu.jsx</code> - Remove \"My Settings\" link 4. Test Settings button in all three layout versions 5. Verify TV mode keyboard navigation still works</p> <p>Validation: - Settings button shows for all users - All three layouts work (mobile, collapsed, expanded) - Button navigates to <code>/settings</code> - UserMenu no longer has My Settings</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#phase-5-redirects-cleanup","title":"Phase 5: Redirects &amp; Cleanup","text":"<p>Goal: Handle legacy routes and cleanup</p> <p>Tasks: 1. Add redirects in App.jsx:    - <code>/my-settings</code> \u2192 <code>/settings?section=user&amp;tab=theme</code>    - <code>/server-settings</code> \u2192 <code>/settings?section=server&amp;tab=user-management</code> 2. Remove old <code>Settings.jsx</code> and <code>ServerSettings.jsx</code> pages 3. Update any internal links pointing to old routes 4. Test bookmark compatibility 5. Update documentation</p> <p>Validation: - Old URLs redirect correctly - Browser history works with redirects - No broken internal links - Bookmarks redirect properly</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#testing-checklist","title":"Testing Checklist","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#navigation","title":"Navigation","text":"<ul> <li> Settings button appears in collapsed sidebar (lg-xl)</li> <li> Settings button appears in expanded sidebar (xl+)</li> <li> Settings button appears in mobile hamburger menu</li> <li> Settings button works for admin users</li> <li> Settings button works for non-admin users</li> <li> Settings button navigates to <code>/settings</code></li> <li> UserMenu no longer shows \"My Settings\" link</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#url-routing","title":"URL &amp; Routing","text":"<ul> <li> <code>/settings</code> defaults to User Settings, Theme tab</li> <li> URL parameters correctly control section/tab</li> <li> Back/forward browser navigation works</li> <li> Refresh maintains current section/tab</li> <li> <code>/my-settings</code> redirects to new route</li> <li> <code>/server-settings</code> redirects to new route</li> <li> Invalid tab names default gracefully</li> <li> Deep linking to specific tabs works</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#permissions","title":"Permissions","text":"<ul> <li> Admin sees User Settings section</li> <li> Admin sees Server Settings section</li> <li> Non-admin sees User Settings section only</li> <li> Non-admin does NOT see Server Settings selector</li> <li> Non-admin accessing <code>?section=server</code> via URL is redirected</li> <li> All permission checks use <code>user.role === \"ADMIN\"</code></li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-theme-tab","title":"User Settings - Theme Tab","text":"<ul> <li> Built-in themes display correctly</li> <li> Theme selection applies immediately</li> <li> Custom Theme Manager renders</li> <li> Custom theme create/edit/delete works</li> <li> UI Examples expand/collapse works</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-playback-tab","title":"User Settings - Playback Tab","text":"<ul> <li> All form fields render</li> <li> Form validation works</li> <li> Save button submits data</li> <li> API call succeeds</li> <li> Success toast shows</li> <li> Error toast shows on failure</li> <li> Measurement Units NOT in this tab</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-customization-tab","title":"User Settings - Customization Tab","text":"<ul> <li> Navigation Settings component renders</li> <li> Carousel Settings component renders</li> <li> Measurement Units dropdown renders</li> <li> Navigation save triggers page reload</li> <li> Carousel save shows success</li> <li> Units save works correctly</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-content-tab","title":"User Settings - Content Tab","text":"<ul> <li> Hidden items link appears</li> <li> Link navigates to <code>/hidden-items</code></li> <li> Hide confirmation toggle renders</li> <li> Toggle saves immediately</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#user-settings-account-tab","title":"User Settings - Account Tab","text":"<ul> <li> Password form renders</li> <li> Current password validation works</li> <li> New password min length validation works</li> <li> Confirm password match validation works</li> <li> Change password API call succeeds</li> <li> Form clears on success</li> <li> Error shows on failure</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#server-settings-user-management-tab-admin","title":"Server Settings - User Management Tab (Admin)","text":"<ul> <li> User list displays</li> <li> Create user form works</li> <li> Edit user works</li> <li> Delete user works</li> <li> Role management works</li> <li> Cannot delete self</li> <li> Cannot demote self if last admin</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#server-settings-server-config-tab-admin","title":"Server Settings - Server Config Tab (Admin)","text":"<ul> <li> Stash instance section renders</li> <li> Server stats section renders</li> <li> Version info section renders</li> <li> All subsection functionality works</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#mobile-behavior_1","title":"Mobile Behavior","text":"<ul> <li> Tab navigation scrolls horizontally on small screens</li> <li> Active tab scrolls into view on mount</li> <li> Touch scrolling works smoothly</li> <li> Scroll indicators (fades) appear when needed</li> <li> Tab content is readable on mobile</li> <li> Forms are usable on mobile</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#accessibility_1","title":"Accessibility","text":"<ul> <li> Tab key navigates through sections and tabs</li> <li> Enter/Space activates tabs</li> <li> Arrow keys move between tabs</li> <li> Focus indicators visible</li> <li> ARIA labels present on tab elements</li> <li> Screen reader announces tab changes</li> <li> Form errors announced to screen readers</li> <li> Keyboard navigation works without mouse</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#visual-design_1","title":"Visual Design","text":"<ul> <li> Section selector styled correctly</li> <li> Active section has accent background</li> <li> Tab navigation uses bottom border for active state</li> <li> Tabs have proper spacing and sizing</li> <li> Tab content area has proper padding/shadow</li> <li> Matches existing Paper component style</li> <li> Responsive at all breakpoints</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#performance","title":"Performance","text":"<ul> <li> No unnecessary re-renders</li> <li> Tab switching is instant</li> <li> Form data persists when switching tabs</li> <li> Large lists (users) render efficiently</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#risks-mitigation","title":"Risks &amp; Mitigation","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#risk-breaking-existing-settings-functionality","title":"Risk: Breaking existing settings functionality","text":"<p>Mitigation: - Migrate components incrementally - Maintain existing API contracts - Test each tab thoroughly before moving to next - Keep old routes as redirects initially</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#risk-mobile-tab-scrolling-doesnt-work-on-all-devices","title":"Risk: Mobile tab scrolling doesn't work on all devices","text":"<p>Mitigation: - Test on iOS Safari, Chrome Android, Firefox Mobile - Use standard overflow-x: auto with -webkit-overflow-scrolling: touch - Provide fallback for browsers without smooth scrolling</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#risk-admin-users-confused-by-moved-server-settings","title":"Risk: Admin users confused by moved Server Settings","text":"<p>Mitigation: - Add redirect from <code>/server-settings</code> - Server Settings section prominently visible for admins - Consider adding a \"What's New\" announcement or tooltip</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#risk-url-complexity-confuses-users","title":"Risk: URL complexity confuses users","text":"<p>Mitigation: - Make URLs optional (defaults work) - Keep URL structure simple and readable - Document URL parameters for support</p>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#future-enhancements","title":"Future Enhancements","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#card-anatomy-customization-v33","title":"Card Anatomy Customization (v3.3+)","text":"<ul> <li>Add new tab or section under Customization</li> <li>Toggles for showing/hiding card elements (O-counter, play count, description, etc.)</li> <li>Per-user preferences stored in user settings</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#custom-field-display-names-v33","title":"Custom Field Display Names (v3.3+)","text":"<ul> <li>Add new tab or section under Customization</li> <li>Rename field labels (e.g., \"O-Counter\" \u2192 \"Rating\")</li> <li>Per-user preferences</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#settings-search-v34","title":"Settings Search (v3.4+)","text":"<ul> <li>Add search bar at top of settings page</li> <li>Filter tabs/sections by keyword</li> <li>Jump to relevant setting</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#settings-importexport-v34","title":"Settings Import/Export (v3.4+)","text":"<ul> <li>Export user settings as JSON</li> <li>Import settings from file</li> <li>Useful for backup or sharing configurations</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#references","title":"References","text":""},{"location":"plans/2026-01-05-unified-settings-navigation-design/#design-patterns","title":"Design Patterns","text":"<ul> <li>Material Design Tabs: https://m3.material.io/components/tabs</li> <li>Horizontal scrolling: https://ishadeed.com/article/horizontal-scrolling/</li> <li>Segmented controls: https://developer.apple.com/design/human-interface-guidelines/segmented-controls</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#current-code-references","title":"Current Code References","text":"<ul> <li><code>client/src/components/pages/Settings.jsx</code> - Current User Settings</li> <li><code>client/src/components/pages/ServerSettings.jsx</code> - Current Server Settings</li> <li><code>client/src/components/ui/Sidebar.jsx</code> - Sidebar navigation</li> <li><code>client/src/components/ui/TopBar.jsx</code> - Mobile top bar</li> <li><code>client/src/components/ui/UserMenu.jsx</code> - User menu dropdown</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#api-endpoints","title":"API Endpoints","text":"<ul> <li><code>GET /api/user/settings</code> - Load user settings</li> <li><code>PUT /api/user/settings</code> - Save user settings</li> <li><code>POST /api/user/change-password</code> - Change password</li> <li><code>GET /api/user/all</code> - Load all users (admin)</li> <li><code>POST /api/user/create</code> - Create user (admin)</li> <li><code>PUT /api/user/:id</code> - Update user (admin)</li> <li><code>DELETE /api/user/:id</code> - Delete user (admin)</li> </ul>"},{"location":"plans/2026-01-05-unified-settings-navigation-design/#appendix-component-file-structure","title":"Appendix: Component File Structure","text":"<pre><code>client/src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 pages/\n\u2502   \u2502   \u251c\u2500\u2500 SettingsPage.jsx              [NEW]\n\u2502   \u2502   \u251c\u2500\u2500 Settings.jsx                  [DELETE after migration]\n\u2502   \u2502   \u2514\u2500\u2500 ServerSettings.jsx            [DELETE after migration]\n\u2502   \u251c\u2500\u2500 settings/\n\u2502   \u2502   \u251c\u2500\u2500 SettingsLayout.jsx            [NEW]\n\u2502   \u2502   \u251c\u2500\u2500 SectionSelector.jsx           [NEW]\n\u2502   \u2502   \u251c\u2500\u2500 tabs/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ThemeTab.jsx              [NEW]\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 PlaybackTab.jsx           [NEW]\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 CustomizationTab.jsx      [NEW]\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ContentTab.jsx            [NEW]\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AccountTab.jsx            [NEW]\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 UserManagementTab.jsx     [NEW]\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ServerConfigTab.jsx       [NEW]\n\u2502   \u2502   \u251c\u2500\u2500 CarouselSettings.jsx          [EXISTING - reused]\n\u2502   \u2502   \u251c\u2500\u2500 NavigationSettings.jsx        [EXISTING - reused]\n\u2502   \u2502   \u251c\u2500\u2500 CustomThemeManager.jsx        [EXISTING - reused]\n\u2502   \u2502   \u251c\u2500\u2500 UserManagementSection.jsx     [EXISTING - reused]\n\u2502   \u2502   \u251c\u2500\u2500 StashInstanceSection.jsx      [EXISTING - reused]\n\u2502   \u2502   \u251c\u2500\u2500 ServerStatsSection.jsx        [EXISTING - reused]\n\u2502   \u2502   \u2514\u2500\u2500 VersionInfoSection.jsx        [EXISTING - reused]\n\u2502   \u2514\u2500\u2500 ui/\n\u2502       \u251c\u2500\u2500 Sidebar.jsx                    [MODIFIED]\n\u2502       \u251c\u2500\u2500 TopBar.jsx                     [MODIFIED]\n\u2502       \u2514\u2500\u2500 UserMenu.jsx                   [MODIFIED]\n\u2514\u2500\u2500 App.jsx                                [MODIFIED]\n</code></pre> <p>End of Design Document</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/","title":"Unified Settings Navigation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Consolidate User Settings and Server Settings into a single unified Settings page with mobile-friendly tabbed navigation accessible to all users.</p> <p>Architecture: Create a new <code>/settings</code> page with URL-based section/tab routing. Build reusable layout components (SectionSelector, SettingsLayout) and migrate existing settings UI into organized tabs. Replace admin-only Server Settings navigation button with universal Settings button in all three layout versions (mobile, collapsed sidebar, expanded sidebar).</p> <p>Tech Stack: React, React Router (useSearchParams, useNavigate), Tailwind CSS, existing UI components (Paper, Button, etc.)</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#phase-1-core-infrastructure","title":"Phase 1: Core Infrastructure","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-1-create-sectionselector-component","title":"Task 1: Create SectionSelector Component","text":"<p>Files: - Create: <code>client/src/components/settings/SectionSelector.jsx</code></p> <p>Step 1: Create the SectionSelector component file</p> <pre><code>import PropTypes from \"prop-types\";\n\n/**\n * SectionSelector - Segmented control for switching between User/Server settings\n * Two-button toggle with accent styling for active section\n */\nconst SectionSelector = ({ activeSection, onSectionChange, isAdmin }) =&gt; {\n  return (\n    &lt;div className=\"flex justify-center mb-6\"&gt;\n      &lt;div\n        className=\"inline-flex rounded-lg p-1\"\n        style={{\n          backgroundColor: \"var(--bg-secondary)\",\n        }}\n        role=\"radiogroup\"\n        aria-label=\"Settings section\"\n      &gt;\n        {/* User Settings Button */}\n        &lt;button\n          onClick={() =&gt; onSectionChange(\"user\")}\n          className=\"px-6 py-2 rounded-md text-sm font-medium transition-all duration-200\"\n          style={{\n            backgroundColor:\n              activeSection === \"user\" ? \"var(--accent-primary)\" : \"transparent\",\n            color: activeSection === \"user\" ? \"white\" : \"var(--text-primary)\",\n          }}\n          role=\"radio\"\n          aria-checked={activeSection === \"user\"}\n        &gt;\n          User Settings\n        &lt;/button&gt;\n\n        {/* Server Settings Button (admin only) */}\n        {isAdmin &amp;&amp; (\n          &lt;button\n            onClick={() =&gt; onSectionChange(\"server\")}\n            className=\"px-6 py-2 rounded-md text-sm font-medium transition-all duration-200\"\n            style={{\n              backgroundColor:\n                activeSection === \"server\"\n                  ? \"var(--accent-primary)\"\n                  : \"transparent\",\n              color:\n                activeSection === \"server\" ? \"white\" : \"var(--text-primary)\",\n            }}\n            role=\"radio\"\n            aria-checked={activeSection === \"server\"}\n          &gt;\n            Server Settings\n          &lt;/button&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nSectionSelector.propTypes = {\n  activeSection: PropTypes.oneOf([\"user\", \"server\"]).isRequired,\n  onSectionChange: PropTypes.func.isRequired,\n  isAdmin: PropTypes.bool.isRequired,\n};\n\nexport default SectionSelector;\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd peek-stash-browser\ngit add client/src/components/settings/SectionSelector.jsx\ngit commit -m \"feat: add SectionSelector component for settings sections\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-2-create-settingslayout-component","title":"Task 2: Create SettingsLayout Component","text":"<p>Files: - Create: <code>client/src/components/settings/SettingsLayout.jsx</code></p> <p>Step 1: Create the SettingsLayout component with horizontal tabs</p> <pre><code>import { useEffect, useRef, useState } from \"prop-types\";\nimport PropTypes from \"prop-types\";\n\n/**\n * SettingsLayout - Reusable layout for settings with horizontal tab navigation\n * Handles mobile scrolling, active tab indication, and tab content rendering\n */\nconst SettingsLayout = ({ tabs, activeTab, onTabChange, children }) =&gt; {\n  const tabContainerRef = useRef(null);\n  const [showLeftFade, setShowLeftFade] = useState(false);\n  const [showRightFade, setShowRightFade] = useState(false);\n\n  // Check scroll position to show/hide fade indicators\n  const checkScroll = () =&gt; {\n    const container = tabContainerRef.current;\n    if (!container) return;\n\n    setShowLeftFade(container.scrollLeft &gt; 0);\n    setShowRightFade(\n      container.scrollLeft &lt; container.scrollWidth - container.clientWidth - 1\n    );\n  };\n\n  // Scroll active tab into view\n  useEffect(() =&gt; {\n    const container = tabContainerRef.current;\n    if (!container) return;\n\n    const activeTabElement = container.querySelector(\n      `[data-tab-id=\"${activeTab}\"]`\n    );\n    if (activeTabElement) {\n      activeTabElement.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"nearest\",\n        inline: \"center\",\n      });\n    }\n\n    checkScroll();\n  }, [activeTab]);\n\n  // Add scroll listener\n  useEffect(() =&gt; {\n    const container = tabContainerRef.current;\n    if (!container) return;\n\n    container.addEventListener(\"scroll\", checkScroll);\n    window.addEventListener(\"resize\", checkScroll);\n\n    checkScroll();\n\n    return () =&gt; {\n      container.removeEventListener(\"scroll\", checkScroll);\n      window.removeEventListener(\"resize\", checkScroll);\n    };\n  }, []);\n\n  return (\n    &lt;div&gt;\n      {/* Tab Navigation */}\n      &lt;div className=\"relative mb-6\"&gt;\n        {/* Left fade indicator */}\n        {showLeftFade &amp;&amp; (\n          &lt;div\n            className=\"absolute left-0 top-0 bottom-0 w-8 pointer-events-none z-10\"\n            style={{\n              background: `linear-gradient(to right, var(--bg-primary), transparent)`,\n            }}\n          /&gt;\n        )}\n\n        {/* Tab container */}\n        &lt;div\n          ref={tabContainerRef}\n          className=\"flex gap-4 overflow-x-auto pb-2\"\n          style={{\n            scrollbarWidth: \"none\",\n            WebkitOverflowScrolling: \"touch\",\n            scrollBehavior: \"smooth\",\n          }}\n          role=\"tablist\"\n          aria-label=\"Settings tabs\"\n        &gt;\n          {tabs.map((tab) =&gt; {\n            const isActive = tab.id === activeTab;\n            return (\n              &lt;button\n                key={tab.id}\n                data-tab-id={tab.id}\n                onClick={() =&gt; onTabChange(tab.id)}\n                className=\"flex-shrink-0 px-4 py-3 text-sm font-medium transition-all duration-200 whitespace-nowrap\"\n                style={{\n                  color: isActive\n                    ? \"var(--accent-primary)\"\n                    : \"var(--text-secondary)\",\n                  fontWeight: isActive ? \"600\" : \"500\",\n                  borderBottom: isActive\n                    ? \"3px solid var(--accent-primary)\"\n                    : \"3px solid transparent\",\n                  backgroundColor: !isActive\n                    ? \"transparent\"\n                    : \"transparent\",\n                }}\n                onMouseEnter={(e) =&gt; {\n                  if (!isActive) {\n                    e.currentTarget.style.backgroundColor = \"var(--bg-secondary)\";\n                  }\n                }}\n                onMouseLeave={(e) =&gt; {\n                  if (!isActive) {\n                    e.currentTarget.style.backgroundColor = \"transparent\";\n                  }\n                }}\n                role=\"tab\"\n                aria-selected={isActive}\n                aria-controls={`${tab.id}-panel`}\n                id={`${tab.id}-tab`}\n              &gt;\n                {tab.label}\n              &lt;/button&gt;\n            );\n          })}\n        &lt;/div&gt;\n\n        {/* Right fade indicator */}\n        {showRightFade &amp;&amp; (\n          &lt;div\n            className=\"absolute right-0 top-0 bottom-0 w-8 pointer-events-none z-10\"\n            style={{\n              background: `linear-gradient(to left, var(--bg-primary), transparent)`,\n            }}\n          /&gt;\n        )}\n\n        {/* Hide scrollbar */}\n        &lt;style jsx&gt;{`\n          div::-webkit-scrollbar {\n            display: none;\n          }\n        `}&lt;/style&gt;\n      &lt;/div&gt;\n\n      {/* Tab Content */}\n      &lt;div\n        role=\"tabpanel\"\n        id={`${activeTab}-panel`}\n        aria-labelledby={`${activeTab}-tab`}\n      &gt;\n        {children}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nSettingsLayout.propTypes = {\n  tabs: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      label: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n  activeTab: PropTypes.string.isRequired,\n  onTabChange: PropTypes.func.isRequired,\n  children: PropTypes.node.isRequired,\n};\n\nexport default SettingsLayout;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/SettingsLayout.jsx\ngit commit -m \"feat: add SettingsLayout component with horizontal tabs\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-3-create-settingspage-component-with-url-routing","title":"Task 3: Create SettingsPage Component with URL Routing","text":"<p>Files: - Create: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Create the main SettingsPage component</p> <pre><code>import { useEffect } from \"react\";\nimport { useNavigate, useSearchParams } from \"react-router-dom\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { usePageTitle } from \"../../hooks/usePageTitle.js\";\nimport SectionSelector from \"../settings/SectionSelector.jsx\";\nimport SettingsLayout from \"../settings/SettingsLayout.jsx\";\nimport { PageHeader, PageLayout } from \"../ui/index.js\";\n\n// Tab definitions\nconst USER_TABS = [\n  { id: \"theme\", label: \"Theme\" },\n  { id: \"playback\", label: \"Playback\" },\n  { id: \"customization\", label: \"Customization\" },\n  { id: \"content\", label: \"Content\" },\n  { id: \"account\", label: \"Account\" },\n];\n\nconst SERVER_TABS = [\n  { id: \"user-management\", label: \"User Management\" },\n  { id: \"server-config\", label: \"Server Configuration\" },\n];\n\nconst SettingsPage = () =&gt; {\n  usePageTitle(\"Settings\");\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const { user } = useAuth();\n\n  // Parse URL parameters\n  const sectionParam = searchParams.get(\"section\") || \"user\";\n  const tabParam = searchParams.get(\"tab\");\n\n  // Determine active section (redirect non-admins from server section)\n  const isAdmin = user?.role === \"ADMIN\";\n  const activeSection = sectionParam === \"server\" &amp;&amp; !isAdmin ? \"user\" : sectionParam;\n\n  // Redirect if non-admin tries to access server section\n  useEffect(() =&gt; {\n    if (sectionParam === \"server\" &amp;&amp; !isAdmin) {\n      navigate(\"/settings?section=user&amp;tab=theme\", { replace: true });\n    }\n  }, [sectionParam, isAdmin, navigate]);\n\n  // Determine active tab (default to first tab of section if invalid)\n  const tabs = activeSection === \"user\" ? USER_TABS : SERVER_TABS;\n  const defaultTab = tabs[0].id;\n  const activeTab = tabParam &amp;&amp; tabs.some((t) =&gt; t.id === tabParam) ? tabParam : defaultTab;\n\n  // Sync URL if tab param is missing or invalid\n  useEffect(() =&gt; {\n    if (!tabParam || !tabs.some((t) =&gt; t.id === tabParam)) {\n      const params = new URLSearchParams();\n      params.set(\"section\", activeSection);\n      params.set(\"tab\", defaultTab);\n      navigate(`/settings?${params.toString()}`, { replace: true });\n    }\n  }, [tabParam, activeSection, defaultTab, tabs, navigate]);\n\n  // Handle section change\n  const handleSectionChange = (newSection) =&gt; {\n    const newDefaultTab = newSection === \"user\" ? USER_TABS[0].id : SERVER_TABS[0].id;\n    navigate(`/settings?section=${newSection}&amp;tab=${newDefaultTab}`, { replace: true });\n  };\n\n  // Handle tab change\n  const handleTabChange = (newTab) =&gt; {\n    const params = new URLSearchParams(searchParams);\n    params.set(\"tab\", newTab);\n    navigate(`/settings?${params.toString()}`, { replace: true });\n  };\n\n  return (\n    &lt;PageLayout&gt;\n      &lt;div className=\"max-w-6xl mx-auto\"&gt;\n        &lt;PageHeader\n          title=\"Settings\"\n          subtitle=\"Manage your preferences and server configuration\"\n        /&gt;\n\n        {/* Section Selector (User/Server) */}\n        &lt;SectionSelector\n          activeSection={activeSection}\n          onSectionChange={handleSectionChange}\n          isAdmin={isAdmin}\n        /&gt;\n\n        {/* Tab Navigation and Content */}\n        &lt;SettingsLayout\n          tabs={tabs}\n          activeTab={activeTab}\n          onTabChange={handleTabChange}\n        &gt;\n          {/* Placeholder for tab content */}\n          &lt;div\n            className=\"p-6 rounded-lg border\"\n            style={{\n              backgroundColor: \"var(--bg-card)\",\n              borderColor: \"var(--border-color)\",\n              minHeight: \"400px\",\n            }}\n          &gt;\n            &lt;p style={{ color: \"var(--text-primary)\" }}&gt;\n              {activeSection === \"user\" ? \"User\" : \"Server\"} Settings - {activeTab} tab\n            &lt;/p&gt;\n            &lt;p style={{ color: \"var(--text-muted)\", marginTop: \"1rem\" }}&gt;\n              Tab content will be implemented in next phase\n            &lt;/p&gt;\n          &lt;/div&gt;\n        &lt;/SettingsLayout&gt;\n      &lt;/div&gt;\n    &lt;/PageLayout&gt;\n  );\n};\n\nexport default SettingsPage;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/pages/SettingsPage.jsx\ngit commit -m \"feat: add SettingsPage with section/tab routing\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-4-add-settings-route-to-appjsx","title":"Task 4: Add Settings Route to App.jsx","text":"<p>Files: - Modify: <code>client/src/App.jsx</code></p> <p>Step 1: Import SettingsPage component</p> <p>At the top of App.jsx, add the lazy import after the existing lazy imports (around line 42):</p> <pre><code>const SettingsPage = lazy(() =&gt; import(\"./components/pages/SettingsPage.jsx\"));\n</code></pre> <p>Step 2: Add the /settings route</p> <p>In the Routes section, add the new route after the <code>/server-settings</code> route (around line 302):</p> <pre><code>&lt;Route\n  path=\"/settings\"\n  element={\n    &lt;ProtectedRoute setupStatus={safeSetupStatus} checkingSetup={checkingSetup}&gt;\n      &lt;GlobalLayout&gt;\n        &lt;SettingsPage /&gt;\n      &lt;/GlobalLayout&gt;\n    &lt;/ProtectedRoute&gt;\n  }\n/&gt;\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/App.jsx\ngit commit -m \"feat: add /settings route to App\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-5-test-core-infrastructure","title":"Task 5: Test Core Infrastructure","text":"<p>Step 1: Start the development server</p> <p>Run: <code>cd peek-stash-browser/client &amp;&amp; npm run dev</code></p> <p>Step 2: Manually test in browser</p> <ol> <li>Navigate to <code>http://localhost:5173/settings</code></li> <li>Verify page loads with \"Settings\" header</li> <li>Verify section selector shows \"User Settings\" and \"Server Settings\" (if admin)</li> <li>Verify tabs render horizontally</li> <li>Click different tabs and verify URL updates</li> <li>Click section toggle (if admin) and verify URL updates</li> <li>Test back/forward browser navigation</li> <li>Test on mobile viewport (&lt; 768px) - tabs should scroll horizontally</li> </ol> <p>Expected: All navigation works, URL updates correctly, no console errors</p> <p>Step 3: Commit checkpoint</p> <pre><code>git add -A\ngit commit -m \"chore: phase 1 complete - core infrastructure tested\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#phase-2-user-settings-tabs","title":"Phase 2: User Settings Tabs","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-6-create-themetab-component","title":"Task 6: Create ThemeTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/ThemeTab.jsx</code> - Reference: <code>client/src/components/pages/Settings.jsx</code> (lines 206-937)</p> <p>Step 1: Create the ThemeTab component</p> <pre><code>import { useState } from \"react\";\nimport { ChevronDown } from \"lucide-react\";\nimport { useTheme } from \"../../../themes/useTheme.js\";\nimport CustomThemeManager from \"../CustomThemeManager.jsx\";\nimport { Button } from \"../../ui/index.js\";\n\nconst ThemeTab = () =&gt; {\n  const { changeTheme, availableThemes, currentTheme } = useTheme();\n  const [uiExamplesExpanded, setUiExamplesExpanded] = useState(false);\n\n  return (\n    &lt;div className=\"space-y-6\"&gt;\n      {/* Built-in Themes */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;h3\n          className=\"text-lg font-semibold mb-4\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          Built-in Themes\n        &lt;/h3&gt;\n        &lt;div className=\"space-y-2\"&gt;\n          {availableThemes\n            .filter((theme) =&gt; !theme.isCustom)\n            .map((theme) =&gt; (\n              &lt;Button\n                key={theme.key}\n                type=\"button\"\n                onClick={() =&gt; changeTheme(theme.key)}\n                variant={currentTheme === theme.key ? \"primary\" : \"secondary\"}\n                fullWidth\n                className=\"text-left px-4 py-3 text-sm flex items-center justify-between\"\n              &gt;\n                &lt;span&gt;{theme.name}&lt;/span&gt;\n                {currentTheme === theme.key &amp;&amp; &lt;span className=\"text-sm\"&gt;\u2713&lt;/span&gt;}\n              &lt;/Button&gt;\n            ))}\n        &lt;/div&gt;\n        &lt;p className=\"text-sm mt-2\" style={{ color: \"var(--text-muted)\" }}&gt;\n          Choose from our built-in color themes (changes apply immediately)\n        &lt;/p&gt;\n\n        {/* UI Examples (collapsible) */}\n        &lt;div\n          className=\"mt-8 pt-6 border-t\"\n          style={{ borderColor: \"var(--border-color)\" }}\n        &gt;\n          &lt;button\n            onClick={() =&gt; setUiExamplesExpanded(!uiExamplesExpanded)}\n            className=\"w-full flex items-center justify-between text-left mb-6 hover:opacity-70 transition-opacity\"\n          &gt;\n            &lt;h3\n              className=\"text-lg font-semibold\"\n              style={{ color: \"var(--text-primary)\" }}\n            &gt;\n              UI Examples\n            &lt;/h3&gt;\n            &lt;ChevronDown\n              size={20}\n              style={{\n                color: \"var(--text-secondary)\",\n                transform: uiExamplesExpanded ? \"rotate(180deg)\" : \"rotate(0deg)\",\n                transition: \"transform 0.2s\",\n              }}\n            /&gt;\n          &lt;/button&gt;\n\n          {uiExamplesExpanded &amp;&amp; (\n            &lt;div\n              className=\"p-6 rounded-lg\"\n              style={{ backgroundColor: \"var(--bg-primary)\" }}\n            &gt;\n              &lt;p style={{ color: \"var(--text-secondary)\" }}&gt;\n                UI examples from original Settings page will be added here\n                (typography, colors, buttons, etc.)\n              &lt;/p&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Custom Themes */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;CustomThemeManager /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ThemeTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/ThemeTab.jsx\ngit commit -m \"feat: add ThemeTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-7-create-playbacktab-component","title":"Task 7: Create PlaybackTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/PlaybackTab.jsx</code> - Reference: <code>client/src/components/pages/Settings.jsx</code> (lines 948-1172, excluding units)</p> <p>Step 1: Create the PlaybackTab component</p> <pre><code>import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport { showError, showSuccess } from \"../../../utils/toast.jsx\";\nimport { Button } from \"../../ui/index.js\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst PlaybackTab = () =&gt; {\n  const [loading, setLoading] = useState(true);\n  const [saving, setSaving] = useState(false);\n  const [preferredQuality, setPreferredQuality] = useState(\"auto\");\n  const [preferredPlaybackMode, setPreferredPlaybackMode] = useState(\"auto\");\n  const [preferredPreviewQuality, setPreferredPreviewQuality] = useState(\"sprite\");\n  const [enableCast, setEnableCast] = useState(true);\n  const [minimumPlayPercent, setMinimumPlayPercent] = useState(20);\n\n  // Load settings on mount\n  useEffect(() =&gt; {\n    const loadSettings = async () =&gt; {\n      try {\n        setLoading(true);\n        const response = await api.get(\"/user/settings\");\n        const { settings } = response.data;\n\n        setPreferredQuality(settings.preferredQuality || \"auto\");\n        setPreferredPlaybackMode(settings.preferredPlaybackMode || \"auto\");\n        setPreferredPreviewQuality(settings.preferredPreviewQuality || \"sprite\");\n        setEnableCast(settings.enableCast !== false);\n        setMinimumPlayPercent(settings.minimumPlayPercent ?? 20);\n      } catch {\n        showError(\"Failed to load playback settings\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadSettings();\n  }, []);\n\n  const saveSettings = async (e) =&gt; {\n    e.preventDefault();\n    try {\n      setSaving(true);\n\n      await api.put(\"/user/settings\", {\n        preferredQuality,\n        preferredPlaybackMode,\n        preferredPreviewQuality,\n        enableCast,\n        minimumPlayPercent,\n      });\n\n      showSuccess(\"Playback settings saved successfully!\");\n    } catch (err) {\n      showError(err.response?.data?.error || \"Failed to save settings\");\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  if (loading) {\n    return (\n      &lt;div\n        className=\"flex items-center justify-center p-12\"\n        style={{ backgroundColor: \"var(--bg-card)\" }}\n      &gt;\n        &lt;div className=\"animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;form onSubmit={saveSettings}&gt;\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;div className=\"space-y-6\"&gt;\n          {/* Preferred Quality */}\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"preferredQuality\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Preferred Quality\n            &lt;/label&gt;\n            &lt;select\n              id=\"preferredQuality\"\n              value={preferredQuality}\n              onChange={(e) =&gt; setPreferredQuality(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"auto\"&gt;Auto (Recommended)&lt;/option&gt;\n              &lt;option value=\"1080p\"&gt;1080p&lt;/option&gt;\n              &lt;option value=\"720p\"&gt;720p&lt;/option&gt;\n              &lt;option value=\"480p\"&gt;480p&lt;/option&gt;\n              &lt;option value=\"360p\"&gt;360p&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n              Default quality for video playback. Auto selects the best quality based on\n              your connection.\n            &lt;/p&gt;\n          &lt;/div&gt;\n\n          {/* Preferred Preview Quality */}\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"preferredPreviewQuality\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Scene Card Preview Quality\n            &lt;/label&gt;\n            &lt;select\n              id=\"preferredPreviewQuality\"\n              value={preferredPreviewQuality}\n              onChange={(e) =&gt; setPreferredPreviewQuality(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"sprite\"&gt;Low Quality - Sprite (Default)&lt;/option&gt;\n              &lt;option value=\"webp\"&gt;High Quality - WebP Animation&lt;/option&gt;\n              &lt;option value=\"mp4\"&gt;High Quality - MP4 Video&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n              Quality of preview animations shown when hovering over scene cards. Low\n              quality (sprite) uses less bandwidth.\n            &lt;/p&gt;\n          &lt;/div&gt;\n\n          {/* Preferred Playback Mode */}\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"preferredPlaybackMode\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Preferred Playback Mode\n            &lt;/label&gt;\n            &lt;select\n              id=\"preferredPlaybackMode\"\n              value={preferredPlaybackMode}\n              onChange={(e) =&gt; setPreferredPlaybackMode(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"auto\"&gt;Auto (Recommended)&lt;/option&gt;\n              &lt;option value=\"direct\"&gt;Direct Play&lt;/option&gt;\n              &lt;option value=\"transcode\"&gt;Force Transcode&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n              Auto uses direct play when supported, otherwise transcodes. Direct play\n              offers best quality but limited codec support.\n            &lt;/p&gt;\n          &lt;/div&gt;\n\n          {/* Enable Cast */}\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"enableCast\"\n              className=\"flex items-center justify-between cursor-pointer\"\n            &gt;\n              &lt;div&gt;\n                &lt;span\n                  className=\"block text-sm font-medium mb-1\"\n                  style={{ color: \"var(--text-secondary)\" }}\n                &gt;\n                  Enable Chromecast/AirPlay\n                &lt;/span&gt;\n                &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n                  Allow casting videos to Chromecast devices and AirPlay. Disable if you\n                  don't use these features or experience playback issues.\n                &lt;/p&gt;\n              &lt;/div&gt;\n              &lt;input\n                id=\"enableCast\"\n                type=\"checkbox\"\n                checked={enableCast}\n                onChange={(e) =&gt; setEnableCast(e.target.checked)}\n                className=\"ml-4 w-5 h-5 cursor-pointer\"\n                style={{\n                  accentColor: \"var(--accent-primary)\",\n                }}\n              /&gt;\n            &lt;/label&gt;\n          &lt;/div&gt;\n\n          {/* Minimum Play Percent */}\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"minimumPlayPercent\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Minimum Play Percent: {minimumPlayPercent}%\n            &lt;/label&gt;\n            &lt;input\n              id=\"minimumPlayPercent\"\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              step=\"5\"\n              value={minimumPlayPercent}\n              onChange={(e) =&gt; setMinimumPlayPercent(parseInt(e.target.value))}\n              className=\"range-slider w-full\"\n              style={{\n                background: `linear-gradient(to right, var(--status-info) 0%, var(--status-info) ${minimumPlayPercent}%, var(--border-color) ${minimumPlayPercent}%, var(--border-color) 100%)`,\n              }}\n            /&gt;\n            &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n              Percentage of video to watch before counting as \"played\". This determines\n              when the play count increments during watch sessions.\n            &lt;/p&gt;\n          &lt;/div&gt;\n\n          {/* Save Button */}\n          &lt;div className=\"flex justify-end pt-4 border-t\" style={{ borderColor: \"var(--border-color)\" }}&gt;\n            &lt;Button type=\"submit\" disabled={saving} variant=\"primary\" loading={saving}&gt;\n              Save Settings\n            &lt;/Button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/form&gt;\n  );\n};\n\nexport default PlaybackTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/PlaybackTab.jsx\ngit commit -m \"feat: add PlaybackTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-8-create-customizationtab-component","title":"Task 8: Create CustomizationTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/CustomizationTab.jsx</code> - Reference: <code>client/src/components/pages/Settings.jsx</code> (lines 1176-1192, 1186-1192, 1128-1157)</p> <p>Step 1: Create the CustomizationTab component</p> <pre><code>import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport { useUnitPreference } from \"../../../contexts/UnitPreferenceContext.js\";\nimport { migrateCarouselPreferences } from \"../../../constants/carousels.js\";\nimport { migrateNavPreferences } from \"../../../constants/navigation.js\";\nimport { showError, showSuccess } from \"../../../utils/toast.jsx\";\nimport CarouselSettings from \"../CarouselSettings.jsx\";\nimport NavigationSettings from \"../NavigationSettings.jsx\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst CustomizationTab = () =&gt; {\n  const [loading, setLoading] = useState(true);\n  const { unitPreference, setUnitPreference } = useUnitPreference();\n  const [carouselPreferences, setCarouselPreferences] = useState([]);\n  const [navPreferences, setNavPreferences] = useState([]);\n\n  // Load settings on mount\n  useEffect(() =&gt; {\n    const loadSettings = async () =&gt; {\n      try {\n        setLoading(true);\n        const response = await api.get(\"/user/settings\");\n        const { settings } = response.data;\n\n        const migratedCarouselPrefs = migrateCarouselPreferences(\n          settings.carouselPreferences\n        );\n        setCarouselPreferences(migratedCarouselPrefs);\n\n        const migratedNavPrefs = migrateNavPreferences(settings.navPreferences);\n        setNavPreferences(migratedNavPrefs);\n      } catch {\n        showError(\"Failed to load customization settings\");\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadSettings();\n  }, []);\n\n  const saveCarouselPreferences = async (newPreferences) =&gt; {\n    try {\n      await api.put(\"/user/settings\", {\n        carouselPreferences: newPreferences,\n      });\n\n      setCarouselPreferences(newPreferences);\n      showSuccess(\"Carousel preferences saved successfully!\");\n    } catch (err) {\n      showError(err.response?.data?.error || \"Failed to save carousel preferences\");\n    }\n  };\n\n  const saveNavPreferences = async (newPreferences) =&gt; {\n    try {\n      await api.put(\"/user/settings\", {\n        navPreferences: newPreferences,\n      });\n\n      setNavPreferences(newPreferences);\n      showSuccess(\"Navigation preferences saved successfully!\");\n\n      // Reload the page to apply nav changes immediately\n      window.location.reload();\n    } catch (err) {\n      showError(err.response?.data?.error || \"Failed to save navigation preferences\");\n    }\n  };\n\n  if (loading) {\n    return (\n      &lt;div\n        className=\"flex items-center justify-center p-12\"\n        style={{ backgroundColor: \"var(--bg-card)\" }}\n      &gt;\n        &lt;div className=\"animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"space-y-6\"&gt;\n      {/* Navigation Settings */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;NavigationSettings\n          navPreferences={navPreferences}\n          onSave={saveNavPreferences}\n        /&gt;\n      &lt;/div&gt;\n\n      {/* Carousel Settings */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;CarouselSettings\n          carouselPreferences={carouselPreferences}\n          onSave={saveCarouselPreferences}\n        /&gt;\n      &lt;/div&gt;\n\n      {/* Measurement Units */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;h3\n          className=\"text-lg font-semibold mb-4\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          Measurement Units\n        &lt;/h3&gt;\n        &lt;div&gt;\n          &lt;label\n            htmlFor=\"unitPreference\"\n            className=\"block text-sm font-medium mb-2\"\n            style={{ color: \"var(--text-secondary)\" }}\n          &gt;\n            Measurement Units\n          &lt;/label&gt;\n          &lt;select\n            id=\"unitPreference\"\n            value={unitPreference}\n            onChange={(e) =&gt; setUnitPreference(e.target.value)}\n            className=\"w-full px-4 py-2 rounded-lg\"\n            style={{\n              backgroundColor: \"var(--bg-secondary)\",\n              border: \"1px solid var(--border-color)\",\n              color: \"var(--text-primary)\",\n            }}\n          &gt;\n            &lt;option value=\"metric\"&gt;Metric (cm, kg)&lt;/option&gt;\n            &lt;option value=\"imperial\"&gt;Imperial (ft/in, lbs)&lt;/option&gt;\n          &lt;/select&gt;\n          &lt;p className=\"text-sm mt-1\" style={{ color: \"var(--text-muted)\" }}&gt;\n            Display performer height, weight, and measurements in your preferred unit\n            system.\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CustomizationTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/CustomizationTab.jsx\ngit commit -m \"feat: add CustomizationTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-9-create-contenttab-component","title":"Task 9: Create ContentTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/ContentTab.jsx</code> - Reference: <code>client/src/components/pages/Settings.jsx</code> (lines 1196-1234)</p> <p>Step 1: Create the ContentTab component</p> <pre><code>import { Eye } from \"lucide-react\";\nimport { Link } from \"react-router-dom\";\nimport { useHiddenEntities } from \"../../../hooks/useHiddenEntities.js\";\nimport { Button } from \"../../ui/index.js\";\n\nconst ContentTab = () =&gt; {\n  const { hideConfirmationDisabled, updateHideConfirmation } = useHiddenEntities();\n\n  return (\n    &lt;div\n      className=\"p-6 rounded-lg border\"\n      style={{\n        backgroundColor: \"var(--bg-card)\",\n        borderColor: \"var(--border-color)\",\n      }}\n    &gt;\n      &lt;h3\n        className=\"text-lg font-semibold mb-4\"\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        Hidden Items\n      &lt;/h3&gt;\n\n      &lt;div className=\"space-y-4\"&gt;\n        &lt;p style={{ color: \"var(--text-secondary)\" }}&gt;\n          Manage items you've hidden from your library. Hidden items will not appear in\n          any views or searches.\n        &lt;/p&gt;\n\n        {/* Link to Hidden Items page */}\n        &lt;Link to=\"/hidden-items\"&gt;\n          &lt;Button variant=\"primary\" icon={&lt;Eye size={18} /&gt;}&gt;\n            View Hidden Items\n          &lt;/Button&gt;\n        &lt;/Link&gt;\n\n        {/* Hide confirmation toggle */}\n        &lt;div\n          className=\"pt-4 border-t\"\n          style={{ borderColor: \"var(--border-color)\" }}\n        &gt;\n          &lt;label className=\"flex items-center gap-3 cursor-pointer\"&gt;\n            &lt;input\n              type=\"checkbox\"\n              checked={hideConfirmationDisabled}\n              onChange={(e) =&gt; updateHideConfirmation(e.target.checked)}\n              className=\"w-5 h-5 cursor-pointer\"\n              style={{ accentColor: \"var(--accent-color)\" }}\n            /&gt;\n            &lt;div&gt;\n              &lt;div style={{ color: \"var(--text-primary)\" }}&gt;\n                Don't ask for confirmation when hiding items\n              &lt;/div&gt;\n              &lt;div\n                className=\"text-sm\"\n                style={{ color: \"var(--text-secondary)\" }}\n              &gt;\n                Skip the confirmation dialog when hiding entities\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/label&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ContentTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/ContentTab.jsx\ngit commit -m \"feat: add ContentTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-10-create-accounttab-component","title":"Task 10: Create AccountTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/AccountTab.jsx</code> - Reference: <code>client/src/components/pages/Settings.jsx</code> (lines 1237-1326)</p> <p>Step 1: Create the AccountTab component</p> <pre><code>import { useState } from \"react\";\nimport axios from \"axios\";\nimport { showError, showSuccess } from \"../../../utils/toast.jsx\";\nimport { Button } from \"../../ui/index.js\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst AccountTab = () =&gt; {\n  const [currentPassword, setCurrentPassword] = useState(\"\");\n  const [newPassword, setNewPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [passwordChanging, setPasswordChanging] = useState(false);\n\n  const changePassword = async (e) =&gt; {\n    e.preventDefault();\n\n    if (newPassword !== confirmPassword) {\n      showError(\"New passwords do not match\");\n      return;\n    }\n\n    if (newPassword.length &lt; 6) {\n      showError(\"Password must be at least 6 characters\");\n      return;\n    }\n\n    try {\n      setPasswordChanging(true);\n\n      await api.post(\"/user/change-password\", {\n        currentPassword,\n        newPassword,\n      });\n\n      showSuccess(\"Password changed successfully!\");\n      setCurrentPassword(\"\");\n      setNewPassword(\"\");\n      setConfirmPassword(\"\");\n    } catch (err) {\n      showError(err.response?.data?.error || \"Failed to change password\");\n    } finally {\n      setPasswordChanging(false);\n    }\n  };\n\n  return (\n    &lt;form onSubmit={changePassword}&gt;\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;h3\n          className=\"text-lg font-semibold mb-4\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          Change Password\n        &lt;/h3&gt;\n\n        &lt;div className=\"space-y-4\"&gt;\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"currentPassword\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Current Password\n            &lt;/label&gt;\n            &lt;input\n              type=\"password\"\n              id=\"currentPassword\"\n              value={currentPassword}\n              onChange={(e) =&gt; setCurrentPassword(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n              required\n            /&gt;\n          &lt;/div&gt;\n\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"newPassword\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              New Password\n            &lt;/label&gt;\n            &lt;input\n              type=\"password\"\n              id=\"newPassword\"\n              value={newPassword}\n              onChange={(e) =&gt; setNewPassword(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n              required\n              minLength={6}\n            /&gt;\n          &lt;/div&gt;\n\n          &lt;div&gt;\n            &lt;label\n              htmlFor=\"confirmPassword\"\n              className=\"block text-sm font-medium mb-2\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              Confirm New Password\n            &lt;/label&gt;\n            &lt;input\n              type=\"password\"\n              id=\"confirmPassword\"\n              value={confirmPassword}\n              onChange={(e) =&gt; setConfirmPassword(e.target.value)}\n              className=\"w-full px-4 py-2 rounded-lg\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n              required\n              minLength={6}\n            /&gt;\n          &lt;/div&gt;\n\n          &lt;div className=\"flex justify-end pt-4 border-t\" style={{ borderColor: \"var(--border-color)\" }}&gt;\n            &lt;Button\n              type=\"submit\"\n              disabled={passwordChanging}\n              variant=\"primary\"\n              loading={passwordChanging}\n            &gt;\n              Change Password\n            &lt;/Button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/form&gt;\n  );\n};\n\nexport default AccountTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/AccountTab.jsx\ngit commit -m \"feat: add AccountTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-11-integrate-user-settings-tabs-into-settingspage","title":"Task 11: Integrate User Settings Tabs into SettingsPage","text":"<p>Files: - Modify: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Add imports for tab components</p> <p>Add these imports at the top of the file:</p> <pre><code>import ThemeTab from \"../settings/tabs/ThemeTab.jsx\";\nimport PlaybackTab from \"../settings/tabs/PlaybackTab.jsx\";\nimport CustomizationTab from \"../settings/tabs/CustomizationTab.jsx\";\nimport ContentTab from \"../settings/tabs/ContentTab.jsx\";\nimport AccountTab from \"../settings/tabs/AccountTab.jsx\";\n</code></pre> <p>Step 2: Replace placeholder content with actual tab components</p> <p>Replace the placeholder div (around line 88-99) with:</p> <pre><code>{/* Render active tab content */}\n{activeSection === \"user\" &amp;&amp; (\n  &lt;&gt;\n    {activeTab === \"theme\" &amp;&amp; &lt;ThemeTab /&gt;}\n    {activeTab === \"playback\" &amp;&amp; &lt;PlaybackTab /&gt;}\n    {activeTab === \"customization\" &amp;&amp; &lt;CustomizationTab /&gt;}\n    {activeTab === \"content\" &amp;&amp; &lt;ContentTab /&gt;}\n    {activeTab === \"account\" &amp;&amp; &lt;AccountTab /&gt;}\n  &lt;/&gt;\n)}\n\n{activeSection === \"server\" &amp;&amp; (\n  &lt;div\n    className=\"p-6 rounded-lg border\"\n    style={{\n      backgroundColor: \"var(--bg-card)\",\n      borderColor: \"var(--border-color)\",\n      minHeight: \"400px\",\n    }}\n  &gt;\n    &lt;p style={{ color: \"var(--text-primary)\" }}&gt;\n      Server Settings - {activeTab} tab\n    &lt;/p&gt;\n    &lt;p style={{ color: \"var(--text-muted)\", marginTop: \"1rem\" }}&gt;\n      Server tabs will be implemented in Phase 3\n    &lt;/p&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/SettingsPage.jsx\ngit commit -m \"feat: integrate user settings tabs into SettingsPage\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-12-test-user-settings-tabs","title":"Task 12: Test User Settings Tabs","text":"<p>Step 1: Test in browser</p> <ol> <li>Navigate to <code>http://localhost:5173/settings</code></li> <li>Test Theme tab:</li> <li>Switch themes and verify changes apply immediately</li> <li>Test custom theme manager</li> <li>Test Playback tab:</li> <li>Change settings and save</li> <li>Verify toast notification</li> <li>Refresh and verify settings persisted</li> <li>Test Customization tab:</li> <li>Reorder navigation items and save</li> <li>Reorder carousels and save</li> <li>Change measurement units</li> <li>Test Content tab:</li> <li>Click \"View Hidden Items\" button</li> <li>Toggle confirmation checkbox</li> <li>Test Account tab:</li> <li>Enter invalid passwords and verify validation</li> <li>Change password successfully</li> </ol> <p>Expected: All tabs work, data saves correctly, toasts show</p> <p>Step 2: Commit checkpoint</p> <pre><code>git add -A\ngit commit -m \"chore: phase 2 complete - user settings tabs tested\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#phase-3-server-settings-tabs","title":"Phase 3: Server Settings Tabs","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-13-create-usermanagementtab-component","title":"Task 13: Create UserManagementTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/UserManagementTab.jsx</code> - Reference: <code>client/src/components/pages/ServerSettings.jsx</code></p> <p>Step 1: Create the UserManagementTab component</p> <pre><code>import { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport { useAuth } from \"../../../hooks/useAuth.js\";\nimport UserManagementSection from \"../UserManagementSection.jsx\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst UserManagementTab = () =&gt; {\n  const { user: currentUser } = useAuth();\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [message, setMessage] = useState(null);\n\n  useEffect(() =&gt; {\n    loadUsers();\n  }, []);\n\n  const loadUsers = async () =&gt; {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await api.get(\"/user/all\");\n      setUsers(response.data.users || []);\n    } catch (err) {\n      setError(err.response?.data?.error || \"Failed to load users\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const showMessage = (msg) =&gt; {\n    setMessage(msg);\n    setTimeout(() =&gt; setMessage(null), 3000);\n  };\n\n  const showError = (err) =&gt; {\n    setError(err);\n    setTimeout(() =&gt; setError(null), 5000);\n  };\n\n  if (loading) {\n    return (\n      &lt;div\n        className=\"flex items-center justify-center p-12\"\n        style={{ backgroundColor: \"var(--bg-card)\" }}\n      &gt;\n        &lt;div className=\"animate-spin w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div&gt;\n      {/* Messages */}\n      {message &amp;&amp; (\n        &lt;div\n          className=\"mb-6 p-4 rounded-lg\"\n          style={{\n            backgroundColor: \"rgba(34, 197, 94, 0.1)\",\n            border: \"1px solid rgba(34, 197, 94, 0.3)\",\n            color: \"rgb(34, 197, 94)\",\n          }}\n        &gt;\n          {message}\n        &lt;/div&gt;\n      )}\n\n      {error &amp;&amp; (\n        &lt;div\n          className=\"mb-6 p-4 rounded-lg\"\n          style={{\n            backgroundColor: \"rgba(239, 68, 68, 0.1)\",\n            border: \"1px solid rgba(239, 68, 68, 0.3)\",\n            color: \"rgb(239, 68, 68)\",\n          }}\n        &gt;\n          {error}\n        &lt;/div&gt;\n      )}\n\n      {/* User Management Section */}\n      &lt;UserManagementSection\n        users={users}\n        currentUser={currentUser}\n        onUsersChanged={loadUsers}\n        onMessage={showMessage}\n        onError={showError}\n        api={api}\n      /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserManagementTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/UserManagementTab.jsx\ngit commit -m \"feat: add UserManagementTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-14-create-serverconfigtab-component","title":"Task 14: Create ServerConfigTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/ServerConfigTab.jsx</code> - Reference: <code>client/src/components/pages/ServerSettings.jsx</code></p> <p>Step 1: Create the ServerConfigTab component</p> <pre><code>import axios from \"axios\";\nimport packageJson from \"../../../../package.json\";\nimport ServerStatsSection from \"../ServerStatsSection.jsx\";\nimport StashInstanceSection from \"../StashInstanceSection.jsx\";\nimport VersionInfoSection from \"../VersionInfoSection.jsx\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst ServerConfigTab = () =&gt; {\n  const CLIENT_VERSION = packageJson.version;\n\n  return (\n    &lt;div className=\"space-y-6\"&gt;\n      {/* Stash Instance Section */}\n      &lt;StashInstanceSection api={api} /&gt;\n\n      {/* Server Statistics Section */}\n      &lt;ServerStatsSection /&gt;\n\n      {/* Version Information Section */}\n      &lt;VersionInfoSection clientVersion={CLIENT_VERSION} api={api} /&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ServerConfigTab;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/tabs/ServerConfigTab.jsx\ngit commit -m \"feat: add ServerConfigTab component\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-15-integrate-server-settings-tabs-into-settingspage","title":"Task 15: Integrate Server Settings Tabs into SettingsPage","text":"<p>Files: - Modify: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Add imports for server tab components</p> <p>Add these imports:</p> <pre><code>import UserManagementTab from \"../settings/tabs/UserManagementTab.jsx\";\nimport ServerConfigTab from \"../settings/tabs/ServerConfigTab.jsx\";\n</code></pre> <p>Step 2: Replace server section placeholder</p> <p>Replace the server section placeholder with:</p> <pre><code>{activeSection === \"server\" &amp;&amp; (\n  &lt;&gt;\n    {activeTab === \"user-management\" &amp;&amp; &lt;UserManagementTab /&gt;}\n    {activeTab === \"server-config\" &amp;&amp; &lt;ServerConfigTab /&gt;}\n  &lt;/&gt;\n)}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/SettingsPage.jsx\ngit commit -m \"feat: integrate server settings tabs into SettingsPage\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-16-test-server-settings-tabs-admin-only","title":"Task 16: Test Server Settings Tabs (Admin Only)","text":"<p>Step 1: Test as admin user</p> <ol> <li>Log in as admin user</li> <li>Navigate to <code>/settings</code></li> <li>Click \"Server Settings\" section</li> <li>Test User Management tab:</li> <li>View user list</li> <li>Create new user</li> <li>Edit user</li> <li>Delete user</li> <li>Test Server Configuration tab:</li> <li>View Stash instance config</li> <li>View server stats</li> <li>View version info</li> </ol> <p>Expected: All server settings work correctly</p> <p>Step 2: Test as non-admin user</p> <ol> <li>Log in as non-admin user</li> <li>Navigate to <code>/settings</code></li> <li>Verify \"Server Settings\" section is NOT visible</li> <li>Navigate to <code>/settings?section=server&amp;tab=user-management</code> directly</li> <li>Verify redirect to <code>/settings?section=user&amp;tab=theme</code></li> </ol> <p>Expected: Non-admin cannot access server settings</p> <p>Step 3: Commit checkpoint</p> <pre><code>git add -A\ngit commit -m \"chore: phase 3 complete - server settings tabs tested\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#phase-4-navigation-updates","title":"Phase 4: Navigation Updates","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-17-update-sidebarjsx-replace-server-settings-with-universal-settings","title":"Task 17: Update Sidebar.jsx - Replace Server Settings with Universal Settings","text":"<p>Files: - Modify: <code>client/src/components/ui/Sidebar.jsx</code></p> <p>Step 1: Update Server Settings button for all users (collapsed view)</p> <p>Find the Server Settings section around line 280-309 and replace it with:</p> <pre><code>{/* Settings button (all users) */}\n{(() =&gt; {\n  const itemIndex = navItems.length + 1;\n  const isFocused = isTVMode &amp;&amp; isMainNavActive &amp;&amp; focusedIndex === itemIndex;\n  return (\n    &lt;&gt;\n      &lt;div className=\"xl:hidden\"&gt;\n        &lt;Tooltip content=\"Settings\" position=\"right\"&gt;\n          &lt;Link\n            ref={(el) =&gt; (itemRefs.current[itemIndex] = el)}\n            to=\"/settings\"\n            className={`flex items-center justify-center h-12 w-12 rounded-lg transition-colors duration-200 ${isFocused ? \"keyboard-focus\" : \"nav-link\"}`}\n            aria-label=\"Settings\"\n            tabIndex={isFocused ? 0 : -1}\n          &gt;\n            &lt;ThemedIcon name=\"settings\" size={20} /&gt;\n          &lt;/Link&gt;\n        &lt;/Tooltip&gt;\n      &lt;/div&gt;\n      &lt;Link\n        ref={(el) =&gt; (itemRefs.current[itemIndex] = el)}\n        to=\"/settings\"\n        className={`hidden xl:flex items-center gap-3 px-4 py-3 rounded-lg transition-colors duration-200 ${isFocused ? \"keyboard-focus\" : \"nav-link\"}`}\n        tabIndex={isFocused ? 0 : -1}\n      &gt;\n        &lt;ThemedIcon name=\"settings\" size={20} /&gt;\n        &lt;span className=\"text-sm font-medium\"&gt;Settings&lt;/span&gt;\n      &lt;/Link&gt;\n    &lt;/&gt;\n  );\n})()}\n</code></pre> <p>Step 2: Update allNavItems to include Settings instead of Server Settings</p> <p>Find the <code>allNavItems</code> construction around line 49-71 and update:</p> <pre><code>const allNavItems = useMemo(() =&gt; {\n  const bottomItems = [\n    { name: \"Help\", path: null, isButton: true, icon: \"questionCircle\" },\n  ];\n\n  // Settings button for all users (was Server Settings for admin only)\n  bottomItems.push({ name: \"Settings\", path: \"/settings\", icon: \"settings\" });\n\n  // User menu parent item\n  bottomItems.push({\n    name: \"User Menu\",\n    path: null,\n    isUserMenu: true,\n    icon: \"circle-user-round\",\n  });\n\n  // If user menu is expanded, add sub-items to navigation list\n  if (isUserMenuExpanded) {\n    bottomItems.push(...userMenuSubItems);\n  }\n\n  return [...navItems, ...bottomItems];\n}, [navItems, isUserMenuExpanded, userMenuSubItems]);\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/Sidebar.jsx\ngit commit -m \"feat: replace Server Settings with universal Settings in Sidebar\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-18-update-topbarjsx-replace-server-settings-in-mobile-menu","title":"Task 18: Update TopBar.jsx - Replace Server Settings in Mobile Menu","text":"<p>Files: - Modify: <code>client/src/components/ui/TopBar.jsx</code></p> <p>Step 1: Replace Server Settings with Settings in hamburger menu</p> <p>Find the Server Settings section around line 159-180 and replace it with:</p> <pre><code>{/* Settings (all users) - with divider */}\n&lt;&gt;\n  &lt;div\n    className=\"my-2 border-t\"\n    style={{ borderColor: \"var(--border-color)\" }}\n  /&gt;\n  &lt;ul className=\"flex flex-col space-y-2\"&gt;\n    &lt;li&gt;\n      &lt;Link\n        to=\"/settings\"\n        className=\"nav-link block text-base font-medium transition-colors duration-200 px-3 py-2 rounded\"\n        onClick={() =&gt; setIsMobileMenuOpen(false)}\n      &gt;\n        &lt;div className=\"flex items-center gap-2\"&gt;\n          &lt;ThemedIcon name=\"settings\" size={18} /&gt;\n          Settings\n        &lt;/div&gt;\n      &lt;/Link&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/&gt;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/ui/TopBar.jsx\ngit commit -m \"feat: replace Server Settings with universal Settings in TopBar\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-19-update-usermenujsx-remove-my-settings-link","title":"Task 19: Update UserMenu.jsx - Remove My Settings Link","text":"<p>Files: - Modify: <code>client/src/components/ui/UserMenu.jsx</code></p> <p>Step 1: Remove \"My Settings\" link from UserMenu</p> <p>Find and delete the \"My Settings\" Link block around lines 122-138:</p> <pre><code>// DELETE THIS BLOCK:\n&lt;Link\n  to=\"/my-settings\"\n  onClick={() =&gt; setIsOpen(false)}\n  className=\"w-full flex items-center gap-3 px-3 py-2 text-sm rounded transition-colors duration-200\"\n  style={{\n    color: \"var(--text-primary)\",\n  }}\n  onMouseEnter={(e) =&gt; {\n    e.currentTarget.style.backgroundColor = \"var(--bg-secondary)\";\n  }}\n  onMouseLeave={(e) =&gt; {\n    e.currentTarget.style.backgroundColor = \"transparent\";\n  }}\n&gt;\n  &lt;ThemedIcon name=\"settings\" size={16} /&gt;\n  &lt;span&gt;My Settings&lt;/span&gt;\n&lt;/Link&gt;\n</code></pre> <p>Step 2: Remove unused margin from Watch History link</p> <p>Update the Watch History link to remove <code>mb-1</code> class since it's now the first item:</p> <pre><code>&lt;Link\n  to=\"/watch-history\"\n  onClick={() =&gt; setIsOpen(false)}\n  className=\"w-full flex items-center gap-3 px-3 py-2 text-sm rounded transition-colors duration-200\"\n  // ... rest of the link\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/UserMenu.jsx\ngit commit -m \"feat: remove My Settings link from UserMenu\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-20-update-sidebarjsx-user-menu-flyout-remove-my-settings","title":"Task 20: Update Sidebar.jsx User Menu Flyout - Remove My Settings","text":"<p>Files: - Modify: <code>client/src/components/ui/Sidebar.jsx</code></p> <p>Step 1: Remove My Settings from collapsed sidebar flyout</p> <p>Find the Tooltip content in the collapsed view (around line 324-360) and remove the My Settings link:</p> <pre><code>// DELETE THIS BLOCK (around line 335-341):\n&lt;Link\n  to=\"/my-settings\"\n  className=\"flex items-center gap-3 px-3 py-2 text-sm rounded transition-colors duration-200 nav-link\"\n&gt;\n  &lt;ThemedIcon name=\"settings\" size={16} /&gt;\n  &lt;span&gt;My Settings&lt;/span&gt;\n&lt;/Link&gt;\n</code></pre> <p>Step 2: Update userMenuSubItems definition</p> <p>Find the <code>userMenuSubItems</code> definition around line 39-44 and remove My Settings:</p> <pre><code>const userMenuSubItems = useMemo(() =&gt; [\n  { name: \"Watch History\", path: \"/watch-history\", icon: \"history\", isSubItem: true },\n  // REMOVE: { name: \"My Settings\", path: \"/my-settings\", icon: \"settings\", isSubItem: true },\n  { name: \"TV Mode\", path: null, isToggle: true, icon: \"tv\", isSubItem: true },\n  { name: \"Sign Out\", path: null, isButton: true, icon: \"logout\", isSubItem: true },\n], []);\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/Sidebar.jsx\ngit commit -m \"feat: remove My Settings from Sidebar user menu\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-21-test-navigation-updates-in-all-three-layouts","title":"Task 21: Test Navigation Updates in All Three Layouts","text":"<p>Step 1: Test collapsed sidebar (lg-xl viewport)</p> <ol> <li>Resize browser to 1024px - 1280px width</li> <li>Verify Settings icon appears in bottom section</li> <li>Hover over Settings icon and verify tooltip says \"Settings\"</li> <li>Click Settings icon and verify navigation to <code>/settings</code></li> <li>Verify Settings icon is visible for non-admin users too</li> </ol> <p>Expected: Settings button works in collapsed sidebar</p> <p>Step 2: Test expanded sidebar (xl+ viewport)</p> <ol> <li>Resize browser to 1280px+ width</li> <li>Verify Settings button with icon + text appears</li> <li>Verify text says \"Settings\" not \"Server Settings\"</li> <li>Click Settings and verify navigation</li> <li>Verify button visible for all users</li> </ol> <p>Expected: Settings button works in expanded sidebar</p> <p>Step 3: Test mobile TopBar (&lt; lg viewport)</p> <ol> <li>Resize browser to &lt; 1024px width</li> <li>Click hamburger menu</li> <li>Verify \"Settings\" appears in menu below divider</li> <li>Click Settings and verify navigation</li> <li>Verify Settings visible for all users</li> </ol> <p>Expected: Settings works in mobile menu</p> <p>Step 4: Test UserMenu</p> <ol> <li>Click user menu button</li> <li>Verify \"My Settings\" link is GONE</li> <li>Verify Watch History, TV Mode, Sign Out remain</li> <li>Test on both desktop sidebar and mobile TopBar</li> </ol> <p>Expected: My Settings removed, other items remain</p> <p>Step 5: Test TV mode keyboard navigation (if applicable)</p> <ol> <li>Enable TV mode</li> <li>Use arrow keys to navigate</li> <li>Verify Settings button is focusable</li> <li>Press Enter on Settings</li> <li>Verify navigation works</li> </ol> <p>Expected: Keyboard navigation works</p> <p>Step 6: Commit checkpoint</p> <pre><code>git add -A\ngit commit -m \"chore: phase 4 complete - navigation updates tested\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#phase-5-redirects-cleanup","title":"Phase 5: Redirects &amp; Cleanup","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-22-add-redirects-for-legacy-routes","title":"Task 22: Add Redirects for Legacy Routes","text":"<p>Files: - Modify: <code>client/src/App.jsx</code></p> <p>Step 1: Add redirect routes</p> <p>After the <code>/settings</code> route (around line 310), add redirect routes:</p> <pre><code>{/* Redirects from legacy routes */}\n&lt;Route\n  path=\"/my-settings\"\n  element={&lt;Navigate to=\"/settings?section=user&amp;tab=theme\" replace /&gt;}\n/&gt;\n&lt;Route\n  path=\"/server-settings\"\n  element={&lt;Navigate to=\"/settings?section=server&amp;tab=user-management\" replace /&gt;}\n/&gt;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/App.jsx\ngit commit -m \"feat: add redirects for legacy settings routes\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-23-test-redirects","title":"Task 23: Test Redirects","text":"<p>Step 1: Test /my-settings redirect</p> <ol> <li>Navigate to <code>http://localhost:5173/my-settings</code></li> <li>Verify redirect to <code>/settings?section=user&amp;tab=theme</code></li> <li>Verify URL in address bar shows new route</li> <li>Press back button</li> <li>Verify browser history works correctly</li> </ol> <p>Expected: Redirect works, maintains history</p> <p>Step 2: Test /server-settings redirect (as admin)</p> <ol> <li>Log in as admin</li> <li>Navigate to <code>http://localhost:5173/server-settings</code></li> <li>Verify redirect to <code>/settings?section=server&amp;tab=user-management</code></li> <li>Verify server section loads</li> <li>Press back button and verify history</li> </ol> <p>Expected: Redirect works for admin</p> <p>Step 3: Test /server-settings redirect (as non-admin)</p> <ol> <li>Log in as non-admin user</li> <li>Navigate to <code>http://localhost:5173/server-settings</code></li> <li>Verify double redirect:</li> <li>First to <code>/settings?section=server&amp;tab=user-management</code></li> <li>Then to <code>/settings?section=user&amp;tab=theme</code> (permission check)</li> </ol> <p>Expected: Non-admin ends up at user settings</p> <p>Step 4: Test bookmarks</p> <ol> <li>Create browser bookmark for <code>/my-settings</code></li> <li>Click bookmark</li> <li>Verify redirect works from bookmark</li> <li>Create bookmark for <code>/server-settings</code></li> <li>Test same way</li> </ol> <p>Expected: Bookmarks redirect correctly</p> <p>Step 5: Commit checkpoint</p> <pre><code>git commit -m \"chore: redirects tested and working\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-24-remove-old-settings-components-optional-cleanup","title":"Task 24: Remove Old Settings Components (Optional Cleanup)","text":"<p>Files: - Delete: <code>client/src/components/pages/Settings.jsx</code> - Delete: <code>client/src/components/pages/ServerSettings.jsx</code></p> <p>Note: Only perform this step after thorough testing confirms all functionality has been migrated.</p> <p>Step 1: Remove old Settings page</p> <pre><code>git rm client/src/components/pages/Settings.jsx\n</code></pre> <p>Step 2: Remove old ServerSettings page</p> <pre><code>git rm client/src/components/pages/ServerSettings.jsx\n</code></pre> <p>Step 3: Remove old route imports from App.jsx</p> <p>In App.jsx, remove the lazy imports:</p> <pre><code>// DELETE THESE LINES:\nconst Settings = lazy(() =&gt; import(\"./components/pages/Settings.jsx\"));\nconst ServerSettings = lazy(() =&gt; import(\"./components/pages/ServerSettings.jsx\"));\n</code></pre> <p>Step 4: Remove old routes from App.jsx</p> <p>Delete the old <code>/my-settings</code> and <code>/server-settings</code> route definitions (keep only the redirect routes):</p> <pre><code>// DELETE THIS BLOCK (around line 263-272):\n&lt;Route\n  path=\"/my-settings\"\n  element={\n    &lt;ProtectedRoute setupStatus={safeSetupStatus} checkingSetup={checkingSetup}&gt;\n      &lt;GlobalLayout&gt;\n        &lt;Settings /&gt;\n      &lt;/GlobalLayout&gt;\n    &lt;/ProtectedRoute&gt;\n  }\n/&gt;\n\n// DELETE THIS BLOCK (around line 294-303):\n&lt;Route\n  path=\"/server-settings\"\n  element={\n    &lt;ProtectedRoute setupStatus={safeSetupStatus} checkingSetup={checkingSetup}&gt;\n      &lt;GlobalLayout&gt;\n        &lt;ServerSettings /&gt;\n      &lt;/GlobalLayout&gt;\n    &lt;/ProtectedRoute&gt;\n  }\n/&gt;\n</code></pre> <p>Step 5: Verify no broken imports</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Expected: Build succeeds with no errors</p> <p>Step 6: Commit cleanup</p> <pre><code>git add -A\ngit commit -m \"chore: remove old Settings and ServerSettings components\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-25-final-end-to-end-testing","title":"Task 25: Final End-to-End Testing","text":"<p>Step 1: Full user flow test (non-admin)</p> <ol> <li>Log in as regular user</li> <li>Navigate to Settings via:</li> <li>Collapsed sidebar button (icon only)</li> <li>Expanded sidebar button (icon + text)</li> <li>Mobile hamburger menu</li> <li>Test all 5 user settings tabs:</li> <li>Theme: Switch themes, manage custom themes</li> <li>Playback: Change settings and save</li> <li>Customization: Reorder nav/carousels, change units</li> <li>Content: View hidden items, toggle confirmation</li> <li>Account: Change password</li> <li>Test URL navigation:</li> <li>Copy URL and open in new tab</li> <li>Verify correct tab loads</li> <li>Test browser navigation:</li> <li>Use back/forward buttons</li> <li>Refresh page</li> </ol> <p>Expected: Everything works for non-admin</p> <p>Step 2: Full admin flow test</p> <ol> <li>Log in as admin user</li> <li>Repeat step 1 for user settings</li> <li>Switch to Server Settings section</li> <li>Test User Management tab:</li> <li>Create user</li> <li>Edit user</li> <li>Delete user</li> <li>Test Server Configuration tab:</li> <li>View all subsections</li> <li>Test URL navigation and browser buttons</li> </ol> <p>Expected: Everything works for admin</p> <p>Step 3: Accessibility test</p> <ol> <li>Tab through all interactive elements</li> <li>Verify focus indicators visible</li> <li>Use Enter/Space to activate tabs</li> <li>Use arrow keys to navigate tabs (if implemented)</li> <li>Test with screen reader (optional but recommended)</li> </ol> <p>Expected: Keyboard navigation works</p> <p>Step 4: Mobile responsiveness test</p> <ol> <li>Test on actual mobile device or Chrome DevTools device mode</li> <li>Verify tabs scroll horizontally on small screens</li> <li>Verify touch scrolling works smoothly</li> <li>Verify fade indicators appear</li> <li>Test form inputs on mobile</li> </ol> <p>Expected: Mobile experience is good</p> <p>Step 5: Performance test</p> <ol> <li>Open Chrome DevTools Performance tab</li> <li>Record while switching tabs</li> <li>Verify no excessive re-renders</li> <li>Check Network tab for unnecessary API calls</li> <li>Verify large user lists render efficiently</li> </ol> <p>Expected: No performance issues</p> <p>Step 6: Commit final checkpoint</p> <pre><code>git add -A\ngit commit -m \"chore: phase 5 complete - all testing passed\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#final-steps","title":"Final Steps","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#task-26-update-documentation-optional","title":"Task 26: Update Documentation (Optional)","text":"<p>Files: - Create or modify: <code>docs/features/settings-page.md</code> (if docs exist)</p> <p>Step 1: Document new settings structure</p> <p>Create user-facing documentation about the new unified settings page, URL structure, and how to navigate it.</p> <p>Step 2: Commit documentation</p> <pre><code>git add docs/\ngit commit -m \"docs: add settings page documentation\"\n</code></pre>"},{"location":"plans/2026-01-05-unified-settings-navigation/#task-27-merge-feature-branch","title":"Task 27: Merge Feature Branch","text":"<p>Step 1: Ensure all changes committed</p> <p>Run: <code>git status</code></p> <p>Expected: \"nothing to commit, working tree clean\"</p> <p>Step 2: Run final checks</p> <pre><code>cd client\nnpm run lint\nnpm run build\n</code></pre> <p>Expected: No errors</p> <p>Step 3: Push feature branch</p> <pre><code>git push origin feature/unified-settings-navigation\n</code></pre> <p>Step 4: Create pull request or merge to main</p> <p>Follow your project's merge workflow (create PR on GitHub, or merge directly to main if solo developer)</p> <p>Step 5: Celebrate!</p> <p>The unified settings navigation feature is complete!</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"plans/2026-01-05-unified-settings-navigation/#issue-tabs-not-scrolling-on-mobile","title":"Issue: Tabs not scrolling on mobile","text":"<p>Solution: - Check that <code>overflow-x: auto</code> is applied to tab container - Verify <code>-webkit-overflow-scrolling: touch</code> is set - Ensure tabs have <code>flex-shrink-0</code> to prevent compression</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#issue-url-parameters-not-updating","title":"Issue: URL parameters not updating","text":"<p>Solution: - Verify <code>useSearchParams</code> hook is used correctly - Check that <code>navigate()</code> is called with <code>{ replace: true }</code> - Ensure params are set with <code>URLSearchParams.set()</code></p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#issue-non-admin-can-access-server-settings-via-url","title":"Issue: Non-admin can access server settings via URL","text":"<p>Solution: - Verify <code>useEffect</code> redirect is in place in SettingsPage - Check that <code>user.role === \"ADMIN\"</code> check is correct - Ensure redirect happens before rendering server content</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#issue-old-settings-components-still-being-used","title":"Issue: Old settings components still being used","text":"<p>Solution: - Verify old routes are removed from App.jsx - Check that redirect routes are in place - Clear browser cache and restart dev server</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#issue-theme-changes-not-applying-immediately","title":"Issue: Theme changes not applying immediately","text":"<p>Solution: - Verify <code>useTheme</code> hook is being called correctly - Check that <code>changeTheme()</code> is called on button click - Ensure theme context is wrapping the app</p>"},{"location":"plans/2026-01-05-unified-settings-navigation/#success-criteria","title":"Success Criteria","text":"<ul> <li> <code>/settings</code> route works for all users</li> <li> Section selector shows User/Server (admin only)</li> <li> All 5 user settings tabs functional</li> <li> All 2 server settings tabs functional (admin)</li> <li> Settings button appears in all 3 navigation layouts</li> <li> Settings button works for all users (not just admin)</li> <li> UserMenu no longer has My Settings</li> <li> URL parameters control section/tab</li> <li> Browser back/forward navigation works</li> <li> Redirects from <code>/my-settings</code> and <code>/server-settings</code> work</li> <li> Non-admin cannot access server settings</li> <li> Mobile tab scrolling works smoothly</li> <li> All form submissions work correctly</li> <li> Toast notifications appear on success/error</li> <li> No console errors or warnings</li> <li> Keyboard navigation accessible</li> <li> Passes linting and builds successfully</li> </ul> <p>End of Implementation Plan</p>"},{"location":"plans/2026-01-06-scalability-500k-fixes/","title":"500k+ Scene Scalability Fixes Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix critical scalability issues blocking users with 500k+ scene libraries</p> <p>Architecture: Paginated fetching + bulk database operations for sync; database queries replacing dead in-memory cache; search-only mode for client dropdowns</p> <p>Tech Stack: TypeScript, Prisma with SQLite, React</p>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#phase-1-critical-fixes-blocks-500k-users","title":"Phase 1: Critical Fixes (Blocks 500k Users)","text":""},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-1-fix-include-mode-restrictions-bug","title":"Task 1: Fix INCLUDE Mode Restrictions Bug","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts:796-810</code> - Test: <code>server/integration/api/content-restrictions-include-mode.integration.test.ts</code> (new)</p> <p>Step 1: Write the failing integration test</p> <p>Create <code>server/integration/api/content-restrictions-include-mode.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeAll, afterAll } from \"vitest\";\nimport { TestClient } from \"../helpers/TestClient.js\";\nimport { setupIntegrationTest, cleanupIntegrationTest } from \"../helpers/setup.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\ndescribe(\"Content Restrictions - INCLUDE Mode\", () =&gt; {\n  let adminClient: TestClient;\n  let testUserId: number;\n  let tag1Id: string;\n  let tag2Id: string;\n  let tag3Id: string;\n\n  beforeAll(async () =&gt; {\n    await setupIntegrationTest();\n    adminClient = new TestClient({ role: \"ADMIN\" });\n\n    // Create test user\n    const userResponse = await adminClient.post&lt;{ user: { id: number } }&gt;(\"/api/admin/users\", {\n      username: \"include-test-user\",\n      password: \"test123\",\n      role: \"USER\",\n    });\n    testUserId = userResponse.data.user.id;\n\n    // Get some existing tag IDs from the test database\n    const tags = await prisma.stashTag.findMany({ take: 3, select: { id: true } });\n    expect(tags.length).toBeGreaterThanOrEqual(3);\n    tag1Id = tags[0].id;\n    tag2Id = tags[1].id;\n    tag3Id = tags[2].id;\n  });\n\n  afterAll(async () =&gt; {\n    await cleanupIntegrationTest();\n  });\n\n  it(\"INCLUDE mode restriction should exclude tags NOT in the allowed list\", async () =&gt; {\n    // Set INCLUDE restriction: only allow tag1 and tag2\n    await adminClient.put(`/api/user/${testUserId}/restrictions`, {\n      restrictions: [\n        {\n          entityType: \"tags\",\n          mode: \"INCLUDE\",\n          entityIds: [tag1Id, tag2Id],\n          restrictEmpty: false,\n        },\n      ],\n    });\n\n    // Trigger exclusion recomputation\n    await adminClient.post(`/api/admin/users/${testUserId}/recompute-exclusions`);\n\n    // Check that tag3 IS excluded (it's not in the INCLUDE list)\n    const exclusions = await prisma.userExcludedEntity.findMany({\n      where: { userId: testUserId, entityType: \"tag\" },\n    });\n\n    const excludedTagIds = exclusions.map((e) =&gt; e.entityId);\n\n    // tag3 should be excluded\n    expect(excludedTagIds).toContain(tag3Id);\n\n    // tag1 and tag2 should NOT be excluded\n    expect(excludedTagIds).not.toContain(tag1Id);\n    expect(excludedTagIds).not.toContain(tag2Id);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- content-restrictions-include-mode</code> Expected: FAIL - tag3Id not in excludedTagIds (because getAllEntityIds returns [])</p> <p>Step 3: Fix getAllEntityIds to query database</p> <p>Modify <code>server/services/ExclusionComputationService.ts</code>:</p> <pre><code>// Replace the synchronous getAllEntityIds method (around line 796) with:\n\n/**\n * Get all entity IDs for a given entity type from the database.\n * Used for INCLUDE mode inversion.\n */\nprivate async getAllEntityIds(entityType: string): Promise&lt;string[]&gt; {\n  switch (entityType) {\n    case \"tags\": {\n      const tags = await prisma.stashTag.findMany({\n        where: { deletedAt: null },\n        select: { id: true },\n      });\n      return tags.map((t) =&gt; t.id);\n    }\n    case \"studios\": {\n      const studios = await prisma.stashStudio.findMany({\n        where: { deletedAt: null },\n        select: { id: true },\n      });\n      return studios.map((s) =&gt; s.id);\n    }\n    case \"groups\": {\n      const groups = await prisma.stashGroup.findMany({\n        where: { deletedAt: null },\n        select: { id: true },\n      });\n      return groups.map((g) =&gt; g.id);\n    }\n    case \"galleries\": {\n      const galleries = await prisma.stashGallery.findMany({\n        where: { deletedAt: null },\n        select: { id: true },\n      });\n      return galleries.map((g) =&gt; g.id);\n    }\n    default:\n      logger.warn(\"Unknown entity type for getAllEntityIds\", { entityType });\n      return [];\n  }\n}\n</code></pre> <p>Step 4: Update caller to await the async method</p> <p>In the same file, find where <code>getAllEntityIds</code> is called (around line 225) and update:</p> <pre><code>// Before:\nconst allEntityIds = this.getAllEntityIds(restriction.entityType);\n\n// After:\nconst allEntityIds = await this.getAllEntityIds(restriction.entityType);\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- content-restrictions-include-mode</code> Expected: PASS</p> <p>Step 6: Run full test suite to catch regressions</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 7: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/integration/api/content-restrictions-include-mode.integration.test.ts\ngit commit -m \"fix: INCLUDE mode restrictions now correctly filter entities\n\nPreviously getAllEntityIds() called StashCacheManager which was never\ninitialized, returning empty arrays. Now queries database directly.\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-2-delete-dead-stashcachemanager-code","title":"Task 2: Delete Dead StashCacheManager Code","text":"<p>Files: - Delete: <code>server/services/StashCacheManager.ts</code> - Modify: <code>server/services/ExclusionComputationService.ts</code> (remove import) - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code> (remove mock)</p> <p>Step 1: Remove import from ExclusionComputationService</p> <p>In <code>server/services/ExclusionComputationService.ts</code>, delete line 19:</p> <pre><code>// DELETE THIS LINE:\nimport { stashCacheManager } from \"./StashCacheManager.js\";\n</code></pre> <p>Step 2: Remove mock from unit test</p> <p>In <code>server/services/__tests__/ExclusionComputationService.test.ts</code>, delete lines 78-86:</p> <pre><code>// DELETE THIS BLOCK:\n// Mock StashCacheManager for INCLUDE mode inversion\nvi.mock(\"../StashCacheManager.js\", () =&gt; ({\n  stashCacheManager: {\n    getAllTags: vi.fn(() =&gt; []),\n    getAllStudios: vi.fn(() =&gt; []),\n    getAllGroups: vi.fn(() =&gt; []),\n    getAllGalleries: vi.fn(() =&gt; []),\n  },\n}));\n</code></pre> <p>Step 3: Delete StashCacheManager.ts</p> <p>Run: <code>rm server/services/StashCacheManager.ts</code></p> <p>Step 4: Run tests to verify nothing breaks</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: delete dead StashCacheManager code (~600 lines)\n\nStashCacheManager.initialize() was never called, so all Maps were\nalways empty. The only consumer was ExclusionComputationService\nwhich now queries the database directly.\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-3-refactor-sync-from-stash-paginated-fetching","title":"Task 3: Refactor Sync from Stash - Paginated Fetching","text":"<p>Files: - Modify: <code>server/controllers/user.ts:987-1419</code> - Test: Run manually with Docker logs</p> <p>Step 1: Add helper constants and types at top of syncFromStash</p> <p>Find the <code>syncFromStash</code> function and add after the stats initialization:</p> <pre><code>// Pagination settings - match StashSyncService.PAGE_SIZE\nconst PAGE_SIZE = 1000;\n\n// Helper to fetch paginated results\nasync function fetchPaginated&lt;T&gt;(\n  fetchFn: (page: number) =&gt; Promise&lt;{ items: T[]; count: number }&gt;,\n  filter: (item: T) =&gt; boolean = () =&gt; true\n): Promise&lt;T[]&gt; {\n  const results: T[] = [];\n  let page = 1;\n  let totalCount = 0;\n\n  while (true) {\n    const { items, count } = await fetchFn(page);\n    totalCount = count;\n\n    const filtered = items.filter(filter);\n    results.push(...filtered);\n\n    if (results.length &gt;= totalCount || items.length === 0) break;\n    page++;\n  }\n\n  return results;\n}\n</code></pre> <p>Step 2: Replace scene fetching with paginated version</p> <p>Replace the scene fetching block (lines ~1002-1022):</p> <pre><code>// Before:\nconst scenesData = await stash.findScenes({\n  filter: { per_page: -1 },\n  scene_filter: Object.keys(sceneFilter).length &gt; 0 ? sceneFilter : undefined,\n});\nconst scenes = scenesData.findScenes.scenes;\n\n// After:\nconst scenes = await fetchPaginated(\n  async (page) =&gt; {\n    const result = await stash.findScenes({\n      filter: { page, per_page: PAGE_SIZE },\n      scene_filter: Object.keys(sceneFilter).length &gt; 0 ? sceneFilter : undefined,\n    });\n    return { items: result.findScenes.scenes, count: result.findScenes.count };\n  }\n);\n</code></pre> <p>Step 3: Apply same pattern to performers, studios, tags, galleries, groups</p> <p>Apply the same <code>fetchPaginated</code> pattern to each entity type's fetch block.</p> <p>Step 4: Test locally</p> <p>Run: Start Docker container, trigger \"Sync from Stash\" in UI, check logs for paginated fetches</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/user.ts\ngit commit -m \"fix: syncFromStash uses paginated fetching\n\nPrevents OOM crash on 500k+ scene libraries by fetching in\nPAGE_SIZE batches instead of per_page: -1\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-4-refactor-sync-from-stash-bulk-upserts","title":"Task 4: Refactor Sync from Stash - Bulk Upserts","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> (continue from Task 3)</p> <p>Step 1: Replace N+1 scene rating upserts with bulk operation</p> <p>Replace the scene loop (lines ~1029-1115) with batched operations:</p> <pre><code>// Process scenes in batches for bulk upsert\nconst BATCH_SIZE = 500;\n\nfor (let i = 0; i &lt; filteredScenes.length; i += BATCH_SIZE) {\n  const batch = filteredScenes.slice(i, i + BATCH_SIZE);\n\n  // Collect all existing records in one query\n  const sceneIds = batch.map((s) =&gt; s.id);\n\n  const [existingRatings, existingWatchHistory] = await Promise.all([\n    syncOptions.scenes.rating\n      ? prisma.sceneRating.findMany({\n          where: { userId: targetUserId, sceneId: { in: sceneIds } },\n        })\n      : Promise.resolve([]),\n    syncOptions.scenes.oCounter\n      ? prisma.watchHistory.findMany({\n          where: { userId: targetUserId, sceneId: { in: sceneIds } },\n        })\n      : Promise.resolve([]),\n  ]);\n\n  const existingRatingMap = new Map(existingRatings.map((r) =&gt; [r.sceneId, r]));\n  const existingWatchMap = new Map(existingWatchHistory.map((w) =&gt; [w.sceneId, w]));\n\n  // Build bulk operations\n  const ratingUpserts: Parameters&lt;typeof prisma.sceneRating.upsert&gt;[0][] = [];\n  const watchUpserts: Parameters&lt;typeof prisma.watchHistory.upsert&gt;[0][] = [];\n\n  for (const scene of batch) {\n    // Rating sync\n    if (syncOptions.scenes.rating &amp;&amp; scene.rating100 &amp;&amp; scene.rating100 &gt; 0) {\n      const existing = existingRatingMap.get(scene.id);\n      ratingUpserts.push({\n        where: { userId_sceneId: { userId: targetUserId, sceneId: scene.id } },\n        update: { rating: scene.rating100 },\n        create: {\n          userId: targetUserId,\n          sceneId: scene.id,\n          rating: scene.rating100,\n          favorite: false,\n        },\n      });\n\n      if (!existing) {\n        stats.scenes.created++;\n      } else if (existing.rating !== scene.rating100) {\n        stats.scenes.updated++;\n      }\n    }\n\n    // O-counter sync\n    if (syncOptions.scenes.oCounter &amp;&amp; scene.o_counter &amp;&amp; scene.o_counter &gt; 0) {\n      const existing = existingWatchMap.get(scene.id);\n      watchUpserts.push({\n        where: { userId_sceneId: { userId: targetUserId, sceneId: scene.id } },\n        update: { oCount: scene.o_counter },\n        create: {\n          userId: targetUserId,\n          sceneId: scene.id,\n          oCount: scene.o_counter,\n          oHistory: [],\n          playCount: 0,\n          playDuration: 0,\n          playHistory: [],\n        },\n      });\n\n      if (!existing) {\n        stats.scenes.created++;\n      } else if (existing.oCount !== scene.o_counter) {\n        stats.scenes.updated++;\n      }\n    }\n  }\n\n  // Execute upserts in transaction\n  await prisma.$transaction([\n    ...ratingUpserts.map((u) =&gt; prisma.sceneRating.upsert(u)),\n    ...watchUpserts.map((u) =&gt; prisma.watchHistory.upsert(u)),\n  ]);\n\n  stats.scenes.checked += batch.length;\n}\n</code></pre> <p>Step 2: Apply same batch pattern to performers, studios, tags, galleries, groups</p> <p>Each entity type should follow the same pattern: 1. Process in BATCH_SIZE chunks 2. Fetch all existing records with <code>findMany</code> + <code>{ in: ids }</code> 3. Build Map for O(1) lookup 4. Execute upserts in <code>$transaction</code></p> <p>Step 3: Test locally with timing</p> <p>Run: Docker container, trigger sync, compare timing with previous implementation</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/user.ts\ngit commit -m \"perf: syncFromStash uses bulk upserts\n\nReplaces N+1 individual upserts with batched transactions.\nFor 500k scenes: ~2M ops -&gt; ~1k transactions\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#phase-2-performance-improvements","title":"Phase 2: Performance Improvements","text":""},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-5-add-performance-logging-to-unlisted-endpoints","title":"Task 5: Add Performance Logging to Unlisted Endpoints","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/studios.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/galleries.ts</code> - Modify: <code>server/controllers/library/groups.ts</code></p> <p>Step 1: Create timing helper</p> <p>Add to each file or create shared utility:</p> <pre><code>// In each controller, wrap the main function body:\nconst startTime = Date.now();\n// ... existing code ...\nlogger.info(\"findPerformers completed\", {\n  totalTime: `${Date.now() - startTime}ms`,\n  totalCount: total,\n  returnedCount: paginatedPerformers.length,\n  page,\n  perPage,\n});\n</code></pre> <p>Step 2: Test by browsing app and checking Docker logs</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/*.ts\ngit commit -m \"feat: add performance logging to entity endpoints\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-6-fix-searchableselect-client-side-loading","title":"Task 6: Fix SearchableSelect Client-Side Loading","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx:176</code></p> <p>Step 1: Change default to search-only mode</p> <pre><code>// Before:\nconst filter = search\n  ? { per_page: 50 }\n  : { per_page: -1, sort: \"name\", direction: \"ASC\" };\n\n// After:\nconst filter = {\n  per_page: 50,\n  sort: \"name\",\n  direction: \"ASC\",\n  ...(search ? { q: search } : {}),\n};\n</code></pre> <p>Step 2: Add placeholder text indicating search is required</p> <p>Update the input placeholder to say \"Type to search...\"</p> <p>Step 3: Test in UI</p> <p>Verify dropdowns no longer freeze on open</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx\ngit commit -m \"fix: SearchableSelect uses search-only mode\n\nPrevents loading all entities on dropdown open. Users must\ntype to search instead.\"\n</code></pre>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#phase-3-future-optimizations-not-blocking","title":"Phase 3: Future Optimizations (Not Blocking)","text":""},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-7-pre-compute-tag-performer-scene-counts-deferred","title":"Task 7: Pre-compute Tag Performer Scene Counts (Deferred)","text":"<p>Issue: Tags endpoint loads all scenes + performers to compute counts Status: Requires schema change, defer to separate PR</p>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-8-sql-based-similarrecommended-scenes-deferred","title":"Task 8: SQL-based Similar/Recommended Scenes (Deferred)","text":"<p>Issue: Scores all scenes in memory Status: Complex optimization, defer to separate PR</p>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#task-9-entity-query-builders-deferred","title":"Task 9: Entity Query Builders (Deferred)","text":"<p>Issue: Performers/Studios/etc load all then filter Status: Large refactor, defer to separate PR</p>"},{"location":"plans/2026-01-06-scalability-500k-fixes/#verification-checklist","title":"Verification Checklist","text":"<p>Before merging:</p> <ul> <li> All tests pass: <code>cd server &amp;&amp; npm test</code></li> <li> Linting passes: <code>cd server &amp;&amp; npm run lint</code></li> <li> Client builds: <code>cd client &amp;&amp; npm run build</code></li> <li> Manual test: Sync from Stash with 20k+ scenes</li> <li> Manual test: INCLUDE mode restriction filters correctly</li> <li> Manual test: SearchableSelect dropdowns don't freeze</li> <li> Check Docker logs for new performance timing</li> </ul>"},{"location":"plans/2026-01-06-scalability-phase-2/","title":"Scalability Phase 2 Implementation Plan","text":"<p>For Claude: Discuss each task with user before implementation. Update audit doc after each completion.</p> <p>Goal: Continue scalability improvements from Phase 1, focusing on remaining performance bottlenecks</p> <p>Branch: <code>feature/scalability-phase-2</code></p>"},{"location":"plans/2026-01-06-scalability-phase-2/#task-order","title":"Task Order","text":"# Task Effort Value Status 1 Entity Exclusion Helper - Request-scoped caching Low Low Pending 2 StashSyncService Cleanup - Paginated fetching Low Medium Pending 3 Tags Endpoint - Pre-compute counts during sync Medium High Pending 4 Similar/Recommended Scenes - SQL candidate filtering Medium High Pending 5 Performance Logging - All affected operations Medium High Pending 6 Entity Query Builders High High DEFERRED to Phase 3"},{"location":"plans/2026-01-06-scalability-phase-2/#task-1-entity-exclusion-helper-request-scoped-caching","title":"Task 1: Entity Exclusion Helper - Request-Scoped Caching","text":"<p>File: <code>server/services/EntityExclusionHelper.ts</code></p> <p>Problem: <code>filterExcluded()</code> queries database on EVERY call, multiple times per request.</p> <p>Solution: Request-scoped cache - compute exclusion sets once per request, pass through context.</p> <p>Approach: 1. Add optional <code>excludedIds?: Set&lt;string&gt;</code> parameter to <code>filterExcluded()</code> 2. Create helper to fetch all exclusion types at request start 3. Pass pre-fetched sets to avoid redundant queries</p> <p>Memory Impact: Zero persistent memory - lives only for request duration.</p> <p>Tests: Unit test for caching behavior.</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#task-2-stashsyncservice-cleanup-paginated-fetching","title":"Task 2: StashSyncService Cleanup - Paginated Fetching","text":"<p>File: <code>server/services/StashSyncService.ts:1071-1150</code></p> <p>Problem: <code>cleanupDeletedEntities</code> fetches ALL IDs with <code>per_page: -1</code>.</p> <p>Solution: Paginated fetching (same pattern as Phase 1).</p> <pre><code>const PAGE_SIZE = 5000; // IDs are small\nlet allStashIds: string[] = [];\nlet page = 1;\nwhile (true) {\n  const result = await stash.findSceneIDs({ filter: { per_page: PAGE_SIZE, page } });\n  allStashIds.push(...result.findScenes.scenes.map(s =&gt; s.id));\n  if (allStashIds.length &gt;= result.findScenes.count) break;\n  page++;\n}\n</code></pre> <p>Memory Impact: ~10MB for 500k IDs (strings only) - acceptable.</p> <p>Tests: Integration test for cleanup with pagination.</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#task-3-tags-endpoint-pre-compute-counts-during-sync","title":"Task 3: Tags Endpoint - Pre-compute Counts During Sync","text":"<p>Files: - <code>prisma/schema.prisma</code> - Add column - <code>server/services/StashSyncService.ts</code> - Compute during sync - <code>server/controllers/library/tags.ts</code> - Use pre-computed value</p> <p>Problem: <code>enhanceTagsWithPerformerScenes()</code> loads ALL scenes + ALL performers on EVERY tag list request.</p> <p>Solution: Pre-compute <code>sceneCountViaPerformers</code> during sync, store in database.</p> <p>Schema Change: <pre><code>model StashTag {\n  // ... existing fields\n  sceneCountViaPerformers Int @default(0)\n}\n</code></pre></p> <p>Sync Computation (SQL): <pre><code>UPDATE StashTag SET sceneCountViaPerformers = (\n  SELECT COUNT(DISTINCT st.sceneId)\n  FROM SceneTag st\n  JOIN StashScene s ON s.id = st.sceneId AND s.deletedAt IS NULL\n  JOIN ScenePerformer sp ON sp.sceneId = s.id\n  JOIN PerformerTag pt ON pt.performerId = sp.performerId\n  WHERE pt.tagId = StashTag.id\n)\n</code></pre></p> <p>Memory Impact: Zero at read time - value stored in DB.</p> <p>Tests: - Unit test for sync computation - Integration test for tag endpoint using pre-computed value</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#task-4-similarrecommended-scenes-sql-candidate-filtering","title":"Task 4: Similar/Recommended Scenes - SQL Candidate Filtering","text":"<p>Files: - <code>server/controllers/library/scenes.ts:1274-1408</code> (Similar) - <code>server/controllers/library/scenes.ts:1418-1619</code> (Recommended) - <code>client/src/pages/SceneDetail.jsx</code> (or similar) - Frontend pagination</p> <p>Problem: Scores ALL scenes in memory using <code>getScenesForScoring()</code>.</p> <p>Solution: SQL-based candidate pre-filtering + proper pagination.</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#backend-changes","title":"Backend Changes","text":"<p>Candidate Selection Query: <pre><code>-- Get candidate scene IDs (scenes sharing performers, tags, or studio)\nWITH candidates AS (\n  -- Scenes sharing performers (highest weight)\n  SELECT DISTINCT sp2.sceneId, 3 as weight\n  FROM ScenePerformer sp1\n  JOIN ScenePerformer sp2 ON sp2.performerId = sp1.performerId\n  WHERE sp1.sceneId = :currentSceneId AND sp2.sceneId != :currentSceneId\n\n  UNION ALL\n\n  -- Scenes sharing tags\n  SELECT DISTINCT st2.sceneId, 1 as weight\n  FROM SceneTag st1\n  JOIN SceneTag st2 ON st2.tagId = st1.tagId\n  WHERE st1.sceneId = :currentSceneId AND st2.sceneId != :currentSceneId\n\n  UNION ALL\n\n  -- Scenes from same studio\n  SELECT DISTINCT s2.id, 2 as weight\n  FROM StashScene s1\n  JOIN StashScene s2 ON s2.studioId = s1.studioId\n  WHERE s1.id = :currentSceneId AND s2.id != :currentSceneId AND s1.studioId IS NOT NULL\n)\nSELECT sceneId, SUM(weight) as totalWeight\nFROM candidates\nGROUP BY sceneId\nORDER BY totalWeight DESC\nLIMIT 500\n</code></pre></p> <p>Key Design Decisions: 1. Smart sorting: Candidates ordered by weighted overlap (performers &gt; studio &gt; tags) 2. Maximum 500 results: Both similar and recommended capped at 500 3. Full pagination: Standard page/perPage parameters, not \"Load More\" 4. Apply exclusions: Filter out excluded scenes from candidates</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#frontend-changes","title":"Frontend Changes","text":"<p>Current: Uses \"Load More\" button pattern for similar scenes.</p> <p>Target: Standard pagination using existing components: - Reuse <code>Pagination</code> component from other list views - Match pattern used by scene browse, performer browse, etc. - Remove infinite scroll / load more pattern</p> <p>Files to update: - Scene detail page similar scenes section - Any component using the old load-more pattern for similar/recommended</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#api-changes","title":"API Changes","text":"<p>Before: <pre><code>GET /api/library/scenes/:id/similar?limit=20&amp;offset=0\n</code></pre></p> <p>After: <pre><code>GET /api/library/scenes/:id/similar?page=1&amp;per_page=20\n// Returns: { scenes: [...], total: number, page: number, per_page: number }\n</code></pre></p> <p>Memory Impact: Only load ~500 candidate scenes instead of 500k.</p> <p>Tests: - Unit test for candidate selection query - Unit test for scoring within candidates - Integration test for pagination - Frontend component tests for pagination UI</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#task-5-performance-logging-all-affected-operations","title":"Task 5: Performance Logging - All Affected Operations","text":"<p>Goal: Add comprehensive performance logging to enable scalability monitoring.</p> <p>Operations to Instrument:</p> Operation File Metrics to Log Exclusion computation <code>ExclusionComputationService.ts</code> totalTime, userId, exclusionCount Full sync <code>StashSyncService.ts</code> totalTime, entityCounts, pagesProcessed Incremental sync <code>StashSyncService.ts</code> totalTime, changedEntities Sync from Stash <code>user.ts</code> totalTime, entityCounts, batchesProcessed Cleanup deleted entities <code>StashSyncService.ts</code> totalTime, deletedCounts Similar scenes <code>scenes.ts</code> totalTime, candidateCount, resultCount Recommended scenes <code>scenes.ts</code> totalTime, candidateCount, resultCount Tag list (after fix) <code>tags.ts</code> totalTime, tagCount <p>Log Format: <pre><code>logger.info(\"operationName completed\", {\n  totalTime: `${Date.now() - startTime}ms`,\n  // operation-specific metrics\n});\n</code></pre></p> <p>Deliverable: Checklist for manual testing + log parsing guide.</p>"},{"location":"plans/2026-01-06-scalability-phase-2/#manual-testing-checklist","title":"Manual Testing Checklist","text":"<p>After implementation, perform these actions and capture Docker logs:</p> <ol> <li>Trigger full sync: Settings &gt; Sync &gt; Force Full Sync</li> <li>Trigger incremental sync: Wait for scheduled sync or trigger manually</li> <li>Run \"Sync from Stash\": User Management &gt; Sync from Stash</li> <li>Browse tags: Navigate to Tags page, apply filters</li> <li>View similar scenes: Open a scene, scroll to Similar Scenes</li> <li>View recommended scenes: Go to Recommended page</li> <li>Change user restrictions: Add/remove content restrictions</li> </ol>"},{"location":"plans/2026-01-06-scalability-phase-2/#log-analysis","title":"Log Analysis","text":"<p>After testing, search Docker logs for: <pre><code>docker logs peek-server 2&gt;&amp;1 | grep -E \"(completed|totalTime)\"\n</code></pre></p> <p>Expected output format: <pre><code>[INFO] syncFromStash completed {\"totalTime\":\"45000ms\",\"scenes\":{\"checked\":20000,\"created\":500}}\n[INFO] findSimilarScenes completed {\"totalTime\":\"150ms\",\"candidateCount\":1200,\"resultCount\":20}\n[INFO] recomputeForUser completed {\"totalTime\":\"800ms\",\"userId\":1,\"exclusionCount\":500}\n</code></pre></p>"},{"location":"plans/2026-01-06-scalability-phase-2/#phase-3-deferred-items","title":"Phase 3: Deferred Items","text":""},{"location":"plans/2026-01-06-scalability-phase-2/#entity-query-builders-high-value-high-effort","title":"Entity Query Builders (High Value, High Effort)","text":"<p>Problem: Performers, studios, tags, galleries, groups all use \"load all then filter\" pattern.</p> <p>Solution: SQL query builders like <code>SceneQueryBuilder</code>.</p> <p>Why Deferred: - Large refactor (5 entity types) - Current performance acceptable for &lt;100k entities - Phase 2 items have higher impact-to-effort ratio</p> <p>Branch: <code>feature/scalability-phase-3</code></p>"},{"location":"plans/2026-01-06-scalability-phase-2/#verification-checklist","title":"Verification Checklist","text":"<p>Before merging Phase 2:</p> <ul> <li> All unit tests pass</li> <li> All integration tests pass</li> <li> TypeScript compiles</li> <li> Linting passes</li> <li> Schema migration tested</li> <li> Manual testing with performance log analysis</li> <li> Frontend pagination works correctly</li> <li> Audit doc updated with completion status</li> </ul>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/","title":"Minimal Endpoints Count Filter Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add count-based filtering to minimal endpoints so dropdowns only show entities with relevant content (e.g., performer dropdown in scene search only shows performers with scenes).</p> <p>Architecture: Filter in-memory after loading from cache, using existing count fields from Stash entities.</p> <p>Tech Stack: TypeScript, Express, React</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#api-design","title":"API Design","text":""},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#new-type-minimalcountfilter","title":"New Type: MinimalCountFilter","text":"<pre><code>// server/types/api/common.ts\nexport interface MinimalCountFilter {\n  min_scene_count?: number;\n  min_gallery_count?: number;\n  min_image_count?: number;\n  min_performer_count?: number;\n  min_group_count?: number;\n}\n</code></pre>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#updated-request-types","title":"Updated Request Types","text":"<p>Each minimal endpoint adds optional <code>count_filter</code>:</p> <pre><code>export interface FindPerformersMinimalRequest {\n  filter?: PaginationFilter;\n  count_filter?: MinimalCountFilter;\n}\n// Same for Studios, Tags, Galleries, Groups\n</code></pre>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#available-filters-by-entity","title":"Available Filters by Entity","text":"Entity Available count filters Performer scene, gallery, image, group Studio scene, gallery, image, performer, group Tag scene, gallery, image, performer, group Gallery image Group scene, performer"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#filter-logic","title":"Filter Logic","text":"<ul> <li>Multiple filters use OR logic (pass if ANY condition is true)</li> <li>Applied after exclusion filtering, before search/sort</li> <li>No filter = return all (backward compatible)</li> </ul>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#tasks","title":"Tasks","text":""},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-1-add-minimalcountfilter-type","title":"Task 1: Add MinimalCountFilter type","text":"<p>Files: - Modify: <code>server/types/api/common.ts</code> - Modify: <code>server/types/api/library.ts</code></p> <p>Steps: 1. Add <code>MinimalCountFilter</code> interface to common.ts 2. Update all 5 minimal request types to include <code>count_filter?: MinimalCountFilter</code> 3. Export the new type from index.ts</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-2-update-findperformersminimal","title":"Task 2: Update findPerformersMinimal","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code></p> <p>Steps: 1. Destructure <code>count_filter</code> from request body 2. After exclusion filtering, before search, add count filter logic 3. Filter performers where scene_count/gallery_count/image_count/group_count &gt;= min values 4. Use OR logic if multiple filters provided</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-3-update-findstudiosminimal","title":"Task 3: Update findStudiosMinimal","text":"<p>Files: - Modify: <code>server/controllers/library/studios.ts</code></p> <p>Steps: Same pattern as Task 2, but for studios (includes performer_count).</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-4-update-findtagsminimal","title":"Task 4: Update findTagsMinimal","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts</code></p> <p>Steps: Same pattern as Task 2, but for tags (includes performer_count, studio_count).</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-5-update-findgalleriesminimal","title":"Task 5: Update findGalleriesMinimal","text":"<p>Files: - Modify: <code>server/controllers/library/galleries.ts</code></p> <p>Steps: Same pattern as Task 2, but galleries only have image_count.</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-6-update-findgroupsminimal","title":"Task 6: Update findGroupsMinimal","text":"<p>Files: - Modify: <code>server/controllers/library/groups.ts</code></p> <p>Steps: Same pattern as Task 2, but groups have scene_count and performer_count.</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-7-add-integration-tests","title":"Task 7: Add integration tests","text":"<p>Files: - Create: <code>server/integration/api/minimal-endpoints-count-filter.integration.test.ts</code></p> <p>Steps: 1. Test each minimal endpoint with count_filter 2. Verify filtering works correctly 3. Verify backward compatibility (no filter = all results) 4. Verify OR logic for multiple filters</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-8-update-searchableselect-component","title":"Task 8: Update SearchableSelect component","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx</code></p> <p>Steps: 1. Add <code>countFilterContext</code> prop 2. Build count_filter based on context 3. Pass to API call</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-9-update-filter-components-to-use-countfiltercontext","title":"Task 9: Update filter components to use countFilterContext","text":"<p>Files: - Modify: Scene filter components - Modify: Performer filter components - Modify: Other entity filter components as needed</p> <p>Steps: 1. Identify all SearchableSelect usages in filter contexts 2. Add appropriate countFilterContext prop 3. Test each dropdown shows filtered results</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#task-10-run-tests-and-verify","title":"Task 10: Run tests and verify","text":"<p>Steps: 1. Run unit tests 2. Run integration tests 3. Run TypeScript compilation 4. Manual verification of dropdowns</p>"},{"location":"plans/2026-01-07-minimal-endpoints-count-filter/#verification-checklist","title":"Verification Checklist","text":"<ul> <li> TypeScript compiles without errors</li> <li> Unit tests pass</li> <li> Integration tests pass</li> <li> Scene filters \u2192 performer dropdown shows only performers with scenes</li> <li> Scene filters \u2192 studio dropdown shows only studios with scenes</li> <li> Scene filters \u2192 tag dropdown shows only tags with scenes</li> <li> Performer filters \u2192 tag dropdown shows only tags with performers</li> <li> Backward compatibility: no count_filter returns all entities</li> </ul>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/","title":"Rich Tooltip Indicators Design","text":"<p>Date: 2026-01-07 Branch: feature/ui-relationship-consistency Status: In Progress</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#problem-statement","title":"Problem Statement","text":"<p>Card indicators (performer count, tag count, etc.) have inconsistent behavior: - SceneCard, ImageCard, GalleryCard have rich tooltips showing entity previews - PerformerCard, TagCard, StudioCard, GroupCard only show counts or navigation links - Users can't preview related entities without clicking through</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#goal","title":"Goal","text":"<p>Make indicator tooltips consistent across all card types, with a configuration system that can later be user-customizable.</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#design-decisions","title":"Design Decisions","text":""},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#1-indicator-behavior-types","title":"1. Indicator Behavior Types","text":"<p>Three behaviors for indicators: - <code>rich</code> - Shows TooltipEntityGrid with entity previews (id, name, image) - <code>nav</code> - Count only, clicking navigates to filtered list - <code>count</code> - Count only, no interaction (for N/A relationships)</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#2-entity-specific-rules","title":"2. Entity-Specific Rules","text":"<p>Always <code>nav</code> (too many items for tooltip): - Scenes indicators - Images indicators</p> <p>Default <code>rich</code> (reasonable counts, valuable preview): - Performers indicators - Tags indicators - Studios indicators - Groups indicators - Galleries indicators</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#3-indicator-behavior-config","title":"3. Indicator Behavior Config","text":"<pre><code>// client/src/config/indicatorBehaviors.js\n\n/**\n * Indicator behavior configuration\n *\n * Future: This will be sourced from user settings in the database.\n * Users will be able to customize behavior per card type per relationship.\n *\n * Behaviors:\n * - 'rich': Show TooltipEntityGrid with entity previews\n * - 'nav': Count + click navigates to filtered list\n * - 'count': Count only, no interaction\n */\n\nexport const INDICATOR_BEHAVIORS = {\n  // SceneCard indicators\n  scene: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'count',  // N/A\n    images: 'count',  // N/A\n  },\n\n  // ImageCard indicators\n  image: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'count',  // N/A\n    images: 'count',  // N/A\n  },\n\n  // GalleryCard indicators\n  gallery: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'count',  // N/A\n    scenes: 'nav',       // Too many\n    images: 'nav',       // Too many\n  },\n\n  // PerformerCard indicators\n  performer: {\n    performers: 'count',  // N/A - no performer-to-performer\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',        // Too many\n    images: 'nav',        // Too many\n  },\n\n  // TagCard indicators\n  tag: {\n    performers: 'rich',\n    tags: 'count',        // N/A - no tag-to-tag on cards\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',        // Too many\n    images: 'nav',        // Too many\n  },\n\n  // StudioCard indicators\n  studio: {\n    performers: 'nav',    // Too many for tooltip preview\n    tags: 'rich',\n    studios: 'count',     // N/A - parent/child handled separately\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',        // Too many\n    images: 'nav',        // Too many\n  },\n\n  // GroupCard indicators\n  group: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',       // Sub-groups\n    galleries: 'rich',\n    scenes: 'nav',        // Too many\n    images: 'nav',        // Too many\n  },\n};\n\n/**\n * Get indicator behavior for a card type and relationship\n */\nexport function getIndicatorBehavior(cardType, relationshipType) {\n  return INDICATOR_BEHAVIORS[cardType]?.[relationshipType] ?? 'count';\n}\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#4-tooltipentitygrid-data-requirements","title":"4. TooltipEntityGrid Data Requirements","text":"<p>For rich tooltips, each entity type needs minimal fields:</p> Entity Type Required Fields Image Field performer id, name image_path tag id, name image_path studio id, name image_path group id, name front_image_path gallery id, title cover"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#5-api-response-changes","title":"5. API Response Changes","text":"<p>PerformerQueryBuilder - Add to response: <pre><code>// Currently returns:\ntags: [{id, name}]  // Missing image_path\n\n// Need to add:\ntags: [{id, name, image_path}]\ngroups: [{id, name, front_image_path}]\ngalleries: [{id, title, cover}]\nstudios: [{id, name, image_path}]  // Studios performer has appeared with\n</code></pre></p> <p>TagQueryBuilder - Add to response: <pre><code>performers: [{id, name, image_path}]\nstudios: [{id, name, image_path}]\ngroups: [{id, name, front_image_path}]\ngalleries: [{id, title, cover}]\n</code></pre></p> <p>StudioQueryBuilder - Add to response: <pre><code>performers: [{id, name, image_path}]\ntags: [{id, name, image_path}]\ngroups: [{id, name, front_image_path}]\ngalleries: [{id, title, cover}]\n</code></pre></p> <p>GroupQueryBuilder - Add to response: <pre><code>performers: [{id, name, image_path}]\ntags: [{id, name, image_path}]\nstudios: [{id, name, image_path}]\ngalleries: [{id, title, cover}]\n</code></pre></p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#6-current-state-analysis","title":"6. Current State Analysis","text":"<p>Cards with rich tooltips (already working): - SceneCard: performers, groups, tags, galleries - ImageCard: performers, tags, galleries (via inheritance) - GalleryCard: performers, tags, scenes</p> <p>Cards needing updates: - PerformerCard: All 6 indicators are count-only - TagCard: All 7 indicators are nav-only or count - StudioCard: All 6 indicators are nav-only or count - GroupCard: All 4 indicators are nav-only</p> <p>Existing indicators by card:</p> Card Indicators Present SceneCard PLAY_COUNT, PERFORMERS, GROUPS, GALLERIES, TAGS ImageCard PERFORMERS, TAGS, GALLERIES, resolution GalleryCard PERFORMERS, TAGS, SCENES, IMAGES PerformerCard PLAY_COUNT, SCENES, GROUPS, IMAGES, GALLERIES, TAGS TagCard PLAY_COUNT, SCENES, IMAGES, GALLERIES, GROUPS, STUDIOS, PERFORMERS StudioCard PLAY_COUNT, SCENES, IMAGES, GALLERIES, PERFORMERS, TAGS GroupCard SCENES, GROUPS, PERFORMERS, TAGS"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#phase-1-tests-first","title":"Phase 1: Tests First","text":"<ol> <li>Write integration tests that verify API responses include required fields for rich tooltips</li> <li>Tests should check: performers have tags with image_path, groups, galleries, studios</li> <li>Tests should check: tags have performers, studios, groups, galleries</li> <li>Tests should check: studios have performers, tags, groups, galleries</li> <li>Tests should check: groups have performers, tags, studios, galleries</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#phase-2-server-changes","title":"Phase 2: Server Changes","text":"<ol> <li>Update PerformerQueryBuilder.populateRelations() to include image_path on tags</li> <li>Add groups, galleries, studios relations to performer response</li> <li>Update TagQueryBuilder to include performers, studios, groups, galleries</li> <li>Update StudioQueryBuilder to include performers, tags, groups, galleries</li> <li>Update GroupQueryBuilder to include performers, tags, studios, galleries</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#phase-3-client-config","title":"Phase 3: Client Config","text":"<ol> <li>Create indicatorBehaviors.js config file</li> <li>Export getIndicatorBehavior() helper function</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#phase-4-client-card-updates","title":"Phase 4: Client Card Updates","text":"<ol> <li>Update PerformerCard to use config and TooltipEntityGrid</li> <li>Update TagCard to use config and TooltipEntityGrid</li> <li>Update StudioCard to use config and TooltipEntityGrid</li> <li>Update GroupCard to use config and TooltipEntityGrid</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#phase-5-verification","title":"Phase 5: Verification","text":"<ol> <li>Run all integration tests</li> <li>Run client unit tests</li> <li>Manual verification of tooltip behavior on each card type</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#future-enhancement-user-settings","title":"Future Enhancement: User Settings","text":"<p>When implementing user settings:</p> <ol> <li>Add database table for user indicator preferences</li> <li>API endpoint to get/set preferences</li> <li>Replace hardcoded INDICATOR_BEHAVIORS with user settings</li> <li>Add settings UI for customization</li> <li>Settings structure mirrors config: cardType -&gt; relationshipType -&gt; behavior</li> </ol>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-design/#files-to-modify","title":"Files to Modify","text":"<p>Server: - server/services/PerformerQueryBuilder.ts - server/services/TagQueryBuilder.ts - server/services/StudioQueryBuilder.ts - server/services/GroupQueryBuilder.ts - server/integration/api/performers.integration.test.ts - server/integration/api/tags.integration.test.ts - server/integration/api/studios.integration.test.ts - server/integration/api/groups.integration.test.ts</p> <p>Client: - client/src/config/indicatorBehaviors.js (new) - client/src/components/cards/PerformerCard.jsx - client/src/components/cards/TagCard.jsx - client/src/components/cards/StudioCard.jsx - client/src/components/cards/GroupCard.jsx</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/","title":"Rich Tooltip Indicators Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Make indicator tooltips consistent across all card types by adding rich entity data to API responses and using TooltipEntityGrid.</p> <p>Architecture: Extend QueryBuilder.populateRelations() methods to include additional entity relationships with minimal fields (id, name, image). Create client-side config for indicator behavior (rich/nav/count) that can later be user-customizable.</p> <p>Tech Stack: TypeScript (server), React/JSX (client), Prisma, Vitest</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-1-create-client-indicator-behavior-config","title":"Task 1: Create Client Indicator Behavior Config","text":"<p>Files: - Create: <code>client/src/config/indicatorBehaviors.js</code></p> <p>Step 1: Create the config file</p> <pre><code>/**\n * Indicator behavior configuration\n *\n * Future: This will be sourced from user settings in the database.\n * Users will be able to customize behavior per card type per relationship.\n *\n * Behaviors:\n * - 'rich': Show TooltipEntityGrid with entity previews\n * - 'nav': Count + click navigates to filtered list\n * - 'count': Count only, no interaction\n */\n\nexport const INDICATOR_BEHAVIORS = {\n  scene: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'count',\n    images: 'count',\n  },\n  image: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'count',\n    images: 'count',\n  },\n  gallery: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'count',\n    scenes: 'nav',\n    images: 'nav',\n  },\n  performer: {\n    performers: 'count',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',\n    images: 'nav',\n  },\n  tag: {\n    performers: 'rich',\n    tags: 'count',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',\n    images: 'nav',\n  },\n  studio: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'count',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',\n    images: 'nav',\n  },\n  group: {\n    performers: 'rich',\n    tags: 'rich',\n    studios: 'rich',\n    groups: 'rich',\n    galleries: 'rich',\n    scenes: 'nav',\n    images: 'nav',\n  },\n};\n\n/**\n * Get indicator behavior for a card type and relationship\n * @param {string} cardType - The card type (scene, performer, tag, etc.)\n * @param {string} relationshipType - The relationship (performers, tags, etc.)\n * @returns {'rich'|'nav'|'count'} The behavior for this indicator\n */\nexport function getIndicatorBehavior(cardType, relationshipType) {\n  return INDICATOR_BEHAVIORS[cardType]?.[relationshipType] ?? 'count';\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/config/indicatorBehaviors.js\ngit commit -m \"feat: add indicator behavior config for rich tooltips\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-2-write-integration-tests-for-performer-tooltip-data","title":"Task 2: Write Integration Tests for Performer Tooltip Data","text":"<p>Files: - Modify: <code>server/integration/api/performers.integration.test.ts</code></p> <p>Step 1: Add test for tooltip entity data</p> <p>Add this test after the existing \"returns performer by ID\" test (around line 50):</p> <pre><code>    it(\"returns performer with tooltip entity data (tags, groups, galleries, studios)\", async () =&gt; {\n      const response = await adminClient.post&lt;FindPerformersResponse&gt;(\"/api/library/performers\", {\n        ids: [TEST_ENTITIES.performerWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      const performer = response.data.findPerformers.performers[0];\n\n      // Tags should have image_path for TooltipEntityGrid\n      if (performer.tags &amp;&amp; performer.tags.length &gt; 0) {\n        expect(performer.tags[0]).toHaveProperty('id');\n        expect(performer.tags[0]).toHaveProperty('name');\n        expect(performer.tags[0]).toHaveProperty('image_path');\n      }\n\n      // Groups should exist with tooltip data\n      expect(performer).toHaveProperty('groups');\n      if (performer.groups &amp;&amp; performer.groups.length &gt; 0) {\n        expect(performer.groups[0]).toHaveProperty('id');\n        expect(performer.groups[0]).toHaveProperty('name');\n        expect(performer.groups[0]).toHaveProperty('front_image_path');\n      }\n\n      // Galleries should exist with tooltip data\n      expect(performer).toHaveProperty('galleries');\n      if (performer.galleries &amp;&amp; performer.galleries.length &gt; 0) {\n        expect(performer.galleries[0]).toHaveProperty('id');\n        expect(performer.galleries[0]).toHaveProperty('title');\n        expect(performer.galleries[0]).toHaveProperty('cover');\n      }\n\n      // Studios should exist with tooltip data\n      expect(performer).toHaveProperty('studios');\n      if (performer.studios &amp;&amp; performer.studios.length &gt; 0) {\n        expect(performer.studios[0]).toHaveProperty('id');\n        expect(performer.studios[0]).toHaveProperty('name');\n        expect(performer.studios[0]).toHaveProperty('image_path');\n      }\n    });\n</code></pre> <p>Step 2: Update response type</p> <p>Update the FindPerformersResponse interface at the top of the file:</p> <pre><code>interface FindPerformersResponse {\n  findPerformers: {\n    performers: Array&lt;{\n      id: string;\n      name: string;\n      tags?: Array&lt;{ id: string; name: string; image_path: string | null }&gt;;\n      groups?: Array&lt;{ id: string; name: string; front_image_path: string | null }&gt;;\n      galleries?: Array&lt;{ id: string; title: string; cover: string | null }&gt;;\n      studios?: Array&lt;{ id: string; name: string; image_path: string | null }&gt;;\n    }&gt;;\n    count: number;\n  };\n}\n</code></pre> <p>Step 3: Run test to verify it fails</p> <pre><code>cd server &amp;&amp; npm run test:integration -- performers.integration.test.ts -v\n</code></pre> <p>Expected: FAIL - performer doesn't have groups, galleries, studios properties yet</p> <p>Step 4: Commit failing test</p> <pre><code>git add server/integration/api/performers.integration.test.ts\ngit commit -m \"test: add integration test for performer tooltip entity data\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-3-add-tooltip-entity-data-to-performerquerybuilder","title":"Task 3: Add Tooltip Entity Data to PerformerQueryBuilder","text":"<p>Files: - Modify: <code>server/services/PerformerQueryBuilder.ts:1025-1069</code></p> <p>Step 1: Update populateRelations to add groups, galleries, studios</p> <p>Replace the entire <code>populateRelations</code> method (lines 1025-1069):</p> <pre><code>  /**\n   * Populate performer relations (tags, groups, galleries, studios)\n   * Includes minimal data for TooltipEntityGrid: id, name, image_path/cover\n   */\n  async populateRelations(performers: NormalizedPerformer[]): Promise&lt;void&gt; {\n    if (performers.length === 0) return;\n\n    const performerIds = performers.map((p) =&gt; p.id);\n\n    // Load all junctions in parallel\n    const [tagJunctions, scenePerformers] = await Promise.all([\n      prisma.performerTag.findMany({\n        where: { performerId: { in: performerIds } },\n      }),\n      // Get scenes this performer appears in to derive groups, galleries, studios\n      prisma.scenePerformer.findMany({\n        where: { performerId: { in: performerIds } },\n        select: { performerId: true, sceneId: true },\n      }),\n    ]);\n\n    // Get scene IDs for this performer\n    const sceneIds = [...new Set(scenePerformers.map((sp) =&gt; sp.sceneId))];\n\n    // Load related entities from scenes\n    const [sceneGroups, sceneGalleries, scenes] = await Promise.all([\n      sceneIds.length &gt; 0\n        ? prisma.sceneGroup.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, groupId: true },\n          })\n        : [],\n      sceneIds.length &gt; 0\n        ? prisma.sceneGallery.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, galleryId: true },\n          })\n        : [],\n      sceneIds.length &gt; 0\n        ? prisma.stashScene.findMany({\n            where: { id: { in: sceneIds } },\n            select: { id: true, studioId: true },\n          })\n        : [],\n    ]);\n\n    // Get unique entity IDs\n    const tagIds = [...new Set(tagJunctions.map((j) =&gt; j.tagId))];\n    const groupIds = [...new Set(sceneGroups.map((sg) =&gt; sg.groupId))];\n    const galleryIds = [...new Set(sceneGalleries.map((sg) =&gt; sg.galleryId))];\n    const studioIds = [...new Set(scenes.map((s) =&gt; s.studioId).filter((id): id is string =&gt; !!id))];\n\n    // Load all entities in parallel\n    const [tags, groups, galleries, studios] = await Promise.all([\n      tagIds.length &gt; 0\n        ? prisma.stashTag.findMany({ where: { id: { in: tagIds } } })\n        : [],\n      groupIds.length &gt; 0\n        ? prisma.stashGroup.findMany({ where: { id: { in: groupIds } } })\n        : [],\n      galleryIds.length &gt; 0\n        ? prisma.stashGallery.findMany({ where: { id: { in: galleryIds } } })\n        : [],\n      studioIds.length &gt; 0\n        ? prisma.stashStudio.findMany({ where: { id: { in: studioIds } } })\n        : [],\n    ]);\n\n    // Build lookup maps with minimal tooltip data\n    const tagsById = new Map(tags.map((t) =&gt; [t.id, {\n      id: t.id,\n      name: t.name,\n      image_path: this.transformUrl(t.imagePath),\n    }]));\n\n    const groupsById = new Map(groups.map((g) =&gt; [g.id, {\n      id: g.id,\n      name: g.name,\n      front_image_path: this.transformUrl(g.frontImagePath),\n    }]));\n\n    const galleriesById = new Map(galleries.map((g) =&gt; [g.id, {\n      id: g.id,\n      title: g.title,\n      cover: this.transformUrl(g.coverPath),\n    }]));\n\n    const studiosById = new Map(studios.map((s) =&gt; [s.id, {\n      id: s.id,\n      name: s.name,\n      image_path: this.transformUrl(s.imagePath),\n    }]));\n\n    // Build performer -&gt; scene mapping\n    const scenesByPerformer = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sp of scenePerformers) {\n      const set = scenesByPerformer.get(sp.performerId) || new Set();\n      set.add(sp.sceneId);\n      scenesByPerformer.set(sp.performerId, set);\n    }\n\n    // Build scene -&gt; entities mappings\n    const groupsByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sg of sceneGroups) {\n      const set = groupsByScene.get(sg.sceneId) || new Set();\n      set.add(sg.groupId);\n      groupsByScene.set(sg.sceneId, set);\n    }\n\n    const galleriesByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sg of sceneGalleries) {\n      const set = galleriesByScene.get(sg.sceneId) || new Set();\n      set.add(sg.galleryId);\n      galleriesByScene.set(sg.sceneId, set);\n    }\n\n    const studioByScene = new Map&lt;string, string&gt;();\n    for (const s of scenes) {\n      if (s.studioId) studioByScene.set(s.id, s.studioId);\n    }\n\n    // Build performer -&gt; tags map\n    const tagsByPerformer = new Map&lt;string, any[]&gt;();\n    for (const junction of tagJunctions) {\n      const tag = tagsById.get(junction.tagId);\n      if (!tag) continue;\n      const list = tagsByPerformer.get(junction.performerId) || [];\n      list.push(tag);\n      tagsByPerformer.set(junction.performerId, list);\n    }\n\n    // Populate performers with all relations\n    for (const performer of performers) {\n      performer.tags = tagsByPerformer.get(performer.id) || [];\n\n      // Derive groups, galleries, studios from performer's scenes\n      const performerSceneIds = scenesByPerformer.get(performer.id) || new Set();\n\n      const performerGroupIds = new Set&lt;string&gt;();\n      const performerGalleryIds = new Set&lt;string&gt;();\n      const performerStudioIds = new Set&lt;string&gt;();\n\n      for (const sceneId of performerSceneIds) {\n        for (const gid of groupsByScene.get(sceneId) || []) performerGroupIds.add(gid);\n        for (const gid of galleriesByScene.get(sceneId) || []) performerGalleryIds.add(gid);\n        const sid = studioByScene.get(sceneId);\n        if (sid) performerStudioIds.add(sid);\n      }\n\n      (performer as any).groups = [...performerGroupIds].map((id) =&gt; groupsById.get(id)).filter(Boolean);\n      (performer as any).galleries = [...performerGalleryIds].map((id) =&gt; galleriesById.get(id)).filter(Boolean);\n      (performer as any).studios = [...performerStudioIds].map((id) =&gt; studiosById.get(id)).filter(Boolean);\n    }\n  }\n</code></pre> <p>Step 2: Run test to verify it passes</p> <pre><code>cd server &amp;&amp; npm run test:integration -- performers.integration.test.ts -v\n</code></pre> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/services/PerformerQueryBuilder.ts\ngit commit -m \"feat: add groups, galleries, studios relations to performer response\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-4-write-integration-tests-for-tag-tooltip-data","title":"Task 4: Write Integration Tests for Tag Tooltip Data","text":"<p>Files: - Modify: <code>server/integration/api/tags.integration.test.ts</code></p> <p>Step 1: Add test for tooltip entity data</p> <p>Add after existing tests:</p> <pre><code>    it(\"returns tag with tooltip entity data (performers, studios, groups, galleries)\", async () =&gt; {\n      const response = await adminClient.post&lt;FindTagsResponse&gt;(\"/api/library/tags\", {\n        ids: [TEST_ENTITIES.tagWithEntities],\n      });\n\n      expect(response.ok).toBe(true);\n      const tag = response.data.findTags.tags[0];\n\n      // Performers should exist with tooltip data\n      expect(tag).toHaveProperty('performers');\n      if (tag.performers &amp;&amp; tag.performers.length &gt; 0) {\n        expect(tag.performers[0]).toHaveProperty('id');\n        expect(tag.performers[0]).toHaveProperty('name');\n        expect(tag.performers[0]).toHaveProperty('image_path');\n      }\n\n      // Studios should exist with tooltip data\n      expect(tag).toHaveProperty('studios');\n      if (tag.studios &amp;&amp; tag.studios.length &gt; 0) {\n        expect(tag.studios[0]).toHaveProperty('id');\n        expect(tag.studios[0]).toHaveProperty('name');\n        expect(tag.studios[0]).toHaveProperty('image_path');\n      }\n\n      // Groups should exist with tooltip data\n      expect(tag).toHaveProperty('groups');\n      if (tag.groups &amp;&amp; tag.groups.length &gt; 0) {\n        expect(tag.groups[0]).toHaveProperty('id');\n        expect(tag.groups[0]).toHaveProperty('name');\n        expect(tag.groups[0]).toHaveProperty('front_image_path');\n      }\n\n      // Galleries should exist with tooltip data\n      expect(tag).toHaveProperty('galleries');\n      if (tag.galleries &amp;&amp; tag.galleries.length &gt; 0) {\n        expect(tag.galleries[0]).toHaveProperty('id');\n        expect(tag.galleries[0]).toHaveProperty('title');\n        expect(tag.galleries[0]).toHaveProperty('cover');\n      }\n    });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <pre><code>cd server &amp;&amp; npm run test:integration -- tags.integration.test.ts -v\n</code></pre> <p>Expected: FAIL</p> <p>Step 3: Commit failing test</p> <pre><code>git add server/integration/api/tags.integration.test.ts\ngit commit -m \"test: add integration test for tag tooltip entity data\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-5-add-tooltip-entity-data-to-tagquerybuilder","title":"Task 5: Add Tooltip Entity Data to TagQueryBuilder","text":"<p>Files: - Modify: <code>server/services/TagQueryBuilder.ts</code></p> <p>Step 1: Add populateRelations method after transformRow (around line 736)</p> <pre><code>  /**\n   * Populate tag relations (performers, studios, groups, galleries)\n   * Includes minimal data for TooltipEntityGrid: id, name, image_path/cover\n   */\n  async populateRelations(tags: NormalizedTag[]): Promise&lt;void&gt; {\n    if (tags.length === 0) return;\n\n    const tagIds = tags.map((t) =&gt; t.id);\n\n    // Load all junctions in parallel\n    const [performerTags, studioTags, groupTags, galleryTags] = await Promise.all([\n      prisma.performerTag.findMany({\n        where: { tagId: { in: tagIds } },\n        select: { tagId: true, performerId: true },\n      }),\n      prisma.studioTag.findMany({\n        where: { tagId: { in: tagIds } },\n        select: { tagId: true, studioId: true },\n      }),\n      prisma.groupTag.findMany({\n        where: { tagId: { in: tagIds } },\n        select: { tagId: true, groupId: true },\n      }),\n      prisma.galleryTag.findMany({\n        where: { tagId: { in: tagIds } },\n        select: { tagId: true, galleryId: true },\n      }),\n    ]);\n\n    // Get unique entity IDs\n    const performerIds = [...new Set(performerTags.map((pt) =&gt; pt.performerId))];\n    const studioIds = [...new Set(studioTags.map((st) =&gt; st.studioId))];\n    const groupIds = [...new Set(groupTags.map((gt) =&gt; gt.groupId))];\n    const galleryIds = [...new Set(galleryTags.map((gt) =&gt; gt.galleryId))];\n\n    // Load all entities in parallel\n    const [performers, studios, groups, galleries] = await Promise.all([\n      performerIds.length &gt; 0\n        ? prisma.stashPerformer.findMany({ where: { id: { in: performerIds } } })\n        : [],\n      studioIds.length &gt; 0\n        ? prisma.stashStudio.findMany({ where: { id: { in: studioIds } } })\n        : [],\n      groupIds.length &gt; 0\n        ? prisma.stashGroup.findMany({ where: { id: { in: groupIds } } })\n        : [],\n      galleryIds.length &gt; 0\n        ? prisma.stashGallery.findMany({ where: { id: { in: galleryIds } } })\n        : [],\n    ]);\n\n    // Build lookup maps with minimal tooltip data\n    const performersById = new Map(performers.map((p) =&gt; [p.id, {\n      id: p.id,\n      name: p.name,\n      image_path: this.transformUrl(p.imagePath),\n    }]));\n\n    const studiosById = new Map(studios.map((s) =&gt; [s.id, {\n      id: s.id,\n      name: s.name,\n      image_path: this.transformUrl(s.imagePath),\n    }]));\n\n    const groupsById = new Map(groups.map((g) =&gt; [g.id, {\n      id: g.id,\n      name: g.name,\n      front_image_path: this.transformUrl(g.frontImagePath),\n    }]));\n\n    const galleriesById = new Map(galleries.map((g) =&gt; [g.id, {\n      id: g.id,\n      title: g.title,\n      cover: this.transformUrl(g.coverPath),\n    }]));\n\n    // Build tag -&gt; entities maps\n    const performersByTag = new Map&lt;string, any[]&gt;();\n    for (const pt of performerTags) {\n      const performer = performersById.get(pt.performerId);\n      if (!performer) continue;\n      const list = performersByTag.get(pt.tagId) || [];\n      list.push(performer);\n      performersByTag.set(pt.tagId, list);\n    }\n\n    const studiosByTag = new Map&lt;string, any[]&gt;();\n    for (const st of studioTags) {\n      const studio = studiosById.get(st.studioId);\n      if (!studio) continue;\n      const list = studiosByTag.get(st.tagId) || [];\n      list.push(studio);\n      studiosByTag.set(st.tagId, list);\n    }\n\n    const groupsByTag = new Map&lt;string, any[]&gt;();\n    for (const gt of groupTags) {\n      const group = groupsById.get(gt.groupId);\n      if (!group) continue;\n      const list = groupsByTag.get(gt.tagId) || [];\n      list.push(group);\n      groupsByTag.set(gt.tagId, list);\n    }\n\n    const galleriesByTag = new Map&lt;string, any[]&gt;();\n    for (const gt of galleryTags) {\n      const gallery = galleriesById.get(gt.galleryId);\n      if (!gallery) continue;\n      const list = galleriesByTag.get(gt.tagId) || [];\n      list.push(gallery);\n      galleriesByTag.set(gt.tagId, list);\n    }\n\n    // Populate tags with all relations\n    for (const tag of tags) {\n      (tag as any).performers = performersByTag.get(tag.id) || [];\n      (tag as any).studios = studiosByTag.get(tag.id) || [];\n      (tag as any).groups = groupsByTag.get(tag.id) || [];\n      (tag as any).galleries = galleriesByTag.get(tag.id) || [];\n    }\n  }\n</code></pre> <p>Step 2: Call populateRelations in execute method</p> <p>Find the execute method (around line 677) and add after <code>const tags = rows.map(...)</code>:</p> <pre><code>    const tags = rows.map((row) =&gt; this.transformRow(row));\n\n    // Populate relations for tooltip data\n    await this.populateRelations(tags);\n</code></pre> <p>Step 3: Run test to verify it passes</p> <pre><code>cd server &amp;&amp; npm run test:integration -- tags.integration.test.ts -v\n</code></pre> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/services/TagQueryBuilder.ts\ngit commit -m \"feat: add performers, studios, groups, galleries relations to tag response\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-6-write-integration-tests-for-studio-tooltip-data","title":"Task 6: Write Integration Tests for Studio Tooltip Data","text":"<p>Files: - Modify: <code>server/integration/api/studios.integration.test.ts</code></p> <p>Step 1: Add test for tooltip entity data</p> <pre><code>    it(\"returns studio with tooltip entity data (performers, groups, galleries)\", async () =&gt; {\n      const response = await adminClient.post&lt;FindStudiosResponse&gt;(\"/api/library/studios\", {\n        ids: [TEST_ENTITIES.studioWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      const studio = response.data.findStudios.studios[0];\n\n      // Tags should have image_path (already exists)\n      if (studio.tags &amp;&amp; studio.tags.length &gt; 0) {\n        expect(studio.tags[0]).toHaveProperty('id');\n        expect(studio.tags[0]).toHaveProperty('name');\n        expect(studio.tags[0]).toHaveProperty('image_path');\n      }\n\n      // Performers should exist with tooltip data\n      expect(studio).toHaveProperty('performers');\n      if (studio.performers &amp;&amp; studio.performers.length &gt; 0) {\n        expect(studio.performers[0]).toHaveProperty('id');\n        expect(studio.performers[0]).toHaveProperty('name');\n        expect(studio.performers[0]).toHaveProperty('image_path');\n      }\n\n      // Groups should exist with tooltip data\n      expect(studio).toHaveProperty('groups');\n      if (studio.groups &amp;&amp; studio.groups.length &gt; 0) {\n        expect(studio.groups[0]).toHaveProperty('id');\n        expect(studio.groups[0]).toHaveProperty('name');\n        expect(studio.groups[0]).toHaveProperty('front_image_path');\n      }\n\n      // Galleries should exist with tooltip data\n      expect(studio).toHaveProperty('galleries');\n      if (studio.galleries &amp;&amp; studio.galleries.length &gt; 0) {\n        expect(studio.galleries[0]).toHaveProperty('id');\n        expect(studio.galleries[0]).toHaveProperty('title');\n        expect(studio.galleries[0]).toHaveProperty('cover');\n      }\n    });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <pre><code>cd server &amp;&amp; npm run test:integration -- studios.integration.test.ts -v\n</code></pre> <p>Step 3: Commit failing test</p> <pre><code>git add server/integration/api/studios.integration.test.ts\ngit commit -m \"test: add integration test for studio tooltip entity data\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-7-add-tooltip-entity-data-to-studioquerybuilder","title":"Task 7: Add Tooltip Entity Data to StudioQueryBuilder","text":"<p>Files: - Modify: <code>server/services/StudioQueryBuilder.ts:571-615</code></p> <p>Step 1: Replace populateRelations method</p> <pre><code>  /**\n   * Populate studio relations (tags, performers, groups, galleries)\n   * Includes minimal data for TooltipEntityGrid\n   */\n  async populateRelations(studios: NormalizedStudio[]): Promise&lt;void&gt; {\n    if (studios.length === 0) return;\n\n    const studioIds = studios.map((s) =&gt; s.id);\n\n    // Load tag junctions and scenes for this studio\n    const [tagJunctions, scenes] = await Promise.all([\n      prisma.studioTag.findMany({\n        where: { studioId: { in: studioIds } },\n      }),\n      prisma.stashScene.findMany({\n        where: { studioId: { in: studioIds } },\n        select: { id: true, studioId: true },\n      }),\n    ]);\n\n    const sceneIds = scenes.map((s) =&gt; s.id);\n\n    // Load scene relationships\n    const [scenePerformers, sceneGroups, sceneGalleries] = await Promise.all([\n      sceneIds.length &gt; 0\n        ? prisma.scenePerformer.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, performerId: true },\n          })\n        : [],\n      sceneIds.length &gt; 0\n        ? prisma.sceneGroup.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, groupId: true },\n          })\n        : [],\n      sceneIds.length &gt; 0\n        ? prisma.sceneGallery.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, galleryId: true },\n          })\n        : [],\n    ]);\n\n    // Get unique entity IDs\n    const tagIds = [...new Set(tagJunctions.map((j) =&gt; j.tagId))];\n    const performerIds = [...new Set(scenePerformers.map((sp) =&gt; sp.performerId))];\n    const groupIds = [...new Set(sceneGroups.map((sg) =&gt; sg.groupId))];\n    const galleryIds = [...new Set(sceneGalleries.map((sg) =&gt; sg.galleryId))];\n\n    // Load all entities in parallel\n    const [tags, performers, groups, galleries] = await Promise.all([\n      tagIds.length &gt; 0 ? prisma.stashTag.findMany({ where: { id: { in: tagIds } } }) : [],\n      performerIds.length &gt; 0 ? prisma.stashPerformer.findMany({ where: { id: { in: performerIds } } }) : [],\n      groupIds.length &gt; 0 ? prisma.stashGroup.findMany({ where: { id: { in: groupIds } } }) : [],\n      galleryIds.length &gt; 0 ? prisma.stashGallery.findMany({ where: { id: { in: galleryIds } } }) : [],\n    ]);\n\n    // Build lookup maps\n    const tagsById = new Map(tags.map((t) =&gt; [t.id, {\n      id: t.id,\n      name: t.name,\n      image_path: this.transformUrl(t.imagePath),\n    }]));\n\n    const performersById = new Map(performers.map((p) =&gt; [p.id, {\n      id: p.id,\n      name: p.name,\n      image_path: this.transformUrl(p.imagePath),\n    }]));\n\n    const groupsById = new Map(groups.map((g) =&gt; [g.id, {\n      id: g.id,\n      name: g.name,\n      front_image_path: this.transformUrl(g.frontImagePath),\n    }]));\n\n    const galleriesById = new Map(galleries.map((g) =&gt; [g.id, {\n      id: g.id,\n      title: g.title,\n      cover: this.transformUrl(g.coverPath),\n    }]));\n\n    // Build scene -&gt; studio mapping\n    const studioByScene = new Map(scenes.map((s) =&gt; [s.id, s.studioId]));\n\n    // Build studio -&gt; entities maps\n    const tagsByStudio = new Map&lt;string, any[]&gt;();\n    for (const junction of tagJunctions) {\n      const tag = tagsById.get(junction.tagId);\n      if (!tag) continue;\n      const list = tagsByStudio.get(junction.studioId) || [];\n      list.push(tag);\n      tagsByStudio.set(junction.studioId, list);\n    }\n\n    const performersByStudio = new Map&lt;string, Set&lt;string&gt;&gt;();\n    const groupsByStudio = new Map&lt;string, Set&lt;string&gt;&gt;();\n    const galleriesByStudio = new Map&lt;string, Set&lt;string&gt;&gt;();\n\n    for (const sp of scenePerformers) {\n      const studioId = studioByScene.get(sp.sceneId);\n      if (!studioId) continue;\n      const set = performersByStudio.get(studioId) || new Set();\n      set.add(sp.performerId);\n      performersByStudio.set(studioId, set);\n    }\n\n    for (const sg of sceneGroups) {\n      const studioId = studioByScene.get(sg.sceneId);\n      if (!studioId) continue;\n      const set = groupsByStudio.get(studioId) || new Set();\n      set.add(sg.groupId);\n      groupsByStudio.set(studioId, set);\n    }\n\n    for (const sg of sceneGalleries) {\n      const studioId = studioByScene.get(sg.sceneId);\n      if (!studioId) continue;\n      const set = galleriesByStudio.get(studioId) || new Set();\n      set.add(sg.galleryId);\n      galleriesByStudio.set(studioId, set);\n    }\n\n    // Populate studios\n    for (const studio of studios) {\n      studio.tags = tagsByStudio.get(studio.id) || [];\n      (studio as any).performers = [...(performersByStudio.get(studio.id) || [])].map((id) =&gt; performersById.get(id)).filter(Boolean);\n      (studio as any).groups = [...(groupsByStudio.get(studio.id) || [])].map((id) =&gt; groupsById.get(id)).filter(Boolean);\n      (studio as any).galleries = [...(galleriesByStudio.get(studio.id) || [])].map((id) =&gt; galleriesById.get(id)).filter(Boolean);\n    }\n  }\n</code></pre> <p>Step 2: Run test to verify it passes</p> <pre><code>cd server &amp;&amp; npm run test:integration -- studios.integration.test.ts -v\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/StudioQueryBuilder.ts\ngit commit -m \"feat: add performers, groups, galleries relations to studio response\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-8-write-integration-tests-for-group-tooltip-data","title":"Task 8: Write Integration Tests for Group Tooltip Data","text":"<p>Files: - Modify: <code>server/integration/api/groups.integration.test.ts</code></p> <p>Step 1: Add test for tooltip entity data</p> <pre><code>    it(\"returns group with tooltip entity data (performers, galleries)\", async () =&gt; {\n      const response = await adminClient.post&lt;FindGroupsResponse&gt;(\"/api/library/groups\", {\n        ids: [TEST_ENTITIES.groupWithScenes],\n      });\n\n      expect(response.ok).toBe(true);\n      const group = response.data.findGroups.groups[0];\n\n      // Tags should have image_path (already exists)\n      if (group.tags &amp;&amp; group.tags.length &gt; 0) {\n        expect(group.tags[0]).toHaveProperty('id');\n        expect(group.tags[0]).toHaveProperty('name');\n        expect(group.tags[0]).toHaveProperty('image_path');\n      }\n\n      // Studio should have image_path (already exists)\n      if (group.studio) {\n        expect(group.studio).toHaveProperty('id');\n        expect(group.studio).toHaveProperty('name');\n        expect(group.studio).toHaveProperty('image_path');\n      }\n\n      // Performers should exist with tooltip data\n      expect(group).toHaveProperty('performers');\n      if (group.performers &amp;&amp; group.performers.length &gt; 0) {\n        expect(group.performers[0]).toHaveProperty('id');\n        expect(group.performers[0]).toHaveProperty('name');\n        expect(group.performers[0]).toHaveProperty('image_path');\n      }\n\n      // Galleries should exist with tooltip data\n      expect(group).toHaveProperty('galleries');\n      if (group.galleries &amp;&amp; group.galleries.length &gt; 0) {\n        expect(group.galleries[0]).toHaveProperty('id');\n        expect(group.galleries[0]).toHaveProperty('title');\n        expect(group.galleries[0]).toHaveProperty('cover');\n      }\n    });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <pre><code>cd server &amp;&amp; npm run test:integration -- groups.integration.test.ts -v\n</code></pre> <p>Step 3: Commit failing test</p> <pre><code>git add server/integration/api/groups.integration.test.ts\ngit commit -m \"test: add integration test for group tooltip entity data\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-9-add-tooltip-entity-data-to-groupquerybuilder","title":"Task 9: Add Tooltip Entity Data to GroupQueryBuilder","text":"<p>Files: - Modify: <code>server/services/GroupQueryBuilder.ts:741-810</code></p> <p>Step 1: Replace populateRelations method</p> <pre><code>  /**\n   * Populate group relations (tags, studio, performers, galleries)\n   * Includes minimal data for TooltipEntityGrid\n   */\n  async populateRelations(groups: NormalizedGroup[]): Promise&lt;void&gt; {\n    if (groups.length === 0) return;\n\n    const groupIds = groups.map((g) =&gt; g.id);\n\n    // Load tag junctions and scene groups\n    const [tagJunctions, sceneGroups] = await Promise.all([\n      prisma.groupTag.findMany({\n        where: { groupId: { in: groupIds } },\n      }),\n      prisma.sceneGroup.findMany({\n        where: { groupId: { in: groupIds } },\n        select: { groupId: true, sceneId: true },\n      }),\n    ]);\n\n    const sceneIds = [...new Set(sceneGroups.map((sg) =&gt; sg.sceneId))];\n\n    // Load scene relationships\n    const [scenePerformers, sceneGalleries] = await Promise.all([\n      sceneIds.length &gt; 0\n        ? prisma.scenePerformer.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, performerId: true },\n          })\n        : [],\n      sceneIds.length &gt; 0\n        ? prisma.sceneGallery.findMany({\n            where: { sceneId: { in: sceneIds } },\n            select: { sceneId: true, galleryId: true },\n          })\n        : [],\n    ]);\n\n    // Get unique IDs\n    const tagIds = [...new Set(tagJunctions.map((j) =&gt; j.tagId))];\n    const studioIds = [...new Set(groups.map((g) =&gt; g.studio?.id).filter((id): id is string =&gt; !!id))];\n    const performerIds = [...new Set(scenePerformers.map((sp) =&gt; sp.performerId))];\n    const galleryIds = [...new Set(sceneGalleries.map((sg) =&gt; sg.galleryId))];\n\n    // Load all entities in parallel\n    const [tags, studios, performers, galleries] = await Promise.all([\n      tagIds.length &gt; 0 ? prisma.stashTag.findMany({ where: { id: { in: tagIds } } }) : [],\n      studioIds.length &gt; 0 ? prisma.stashStudio.findMany({ where: { id: { in: studioIds } } }) : [],\n      performerIds.length &gt; 0 ? prisma.stashPerformer.findMany({ where: { id: { in: performerIds } } }) : [],\n      galleryIds.length &gt; 0 ? prisma.stashGallery.findMany({ where: { id: { in: galleryIds } } }) : [],\n    ]);\n\n    // Build lookup maps\n    const tagsById = new Map(tags.map((t) =&gt; [t.id, {\n      id: t.id,\n      name: t.name,\n      image_path: this.transformUrl(t.imagePath),\n    }]));\n\n    const studiosById = new Map(studios.map((s) =&gt; [s.id, {\n      id: s.id,\n      name: s.name,\n      image_path: this.transformUrl(s.imagePath),\n    }]));\n\n    const performersById = new Map(performers.map((p) =&gt; [p.id, {\n      id: p.id,\n      name: p.name,\n      image_path: this.transformUrl(p.imagePath),\n    }]));\n\n    const galleriesById = new Map(galleries.map((g) =&gt; [g.id, {\n      id: g.id,\n      title: g.title,\n      cover: this.transformUrl(g.coverPath),\n    }]));\n\n    // Build group -&gt; tags map\n    const tagsByGroup = new Map&lt;string, any[]&gt;();\n    for (const junction of tagJunctions) {\n      const tag = tagsById.get(junction.tagId);\n      if (!tag) continue;\n      const list = tagsByGroup.get(junction.groupId) || [];\n      list.push(tag);\n      tagsByGroup.set(junction.groupId, list);\n    }\n\n    // Build group -&gt; scene mapping\n    const scenesByGroup = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sg of sceneGroups) {\n      const set = scenesByGroup.get(sg.groupId) || new Set();\n      set.add(sg.sceneId);\n      scenesByGroup.set(sg.groupId, set);\n    }\n\n    // Build scene -&gt; entities mappings\n    const performersByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sp of scenePerformers) {\n      const set = performersByScene.get(sp.sceneId) || new Set();\n      set.add(sp.performerId);\n      performersByScene.set(sp.sceneId, set);\n    }\n\n    const galleriesByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const sg of sceneGalleries) {\n      const set = galleriesByScene.get(sg.sceneId) || new Set();\n      set.add(sg.galleryId);\n      galleriesByScene.set(sg.sceneId, set);\n    }\n\n    // Populate groups\n    for (const group of groups) {\n      group.tags = tagsByGroup.get(group.id) || [];\n\n      // Hydrate studio with full data\n      if (group.studio?.id) {\n        const fullStudio = studiosById.get(group.studio.id);\n        if (fullStudio) {\n          group.studio = fullStudio;\n        }\n      }\n\n      // Derive performers and galleries from group's scenes\n      const groupSceneIds = scenesByGroup.get(group.id) || new Set();\n\n      const groupPerformerIds = new Set&lt;string&gt;();\n      const groupGalleryIds = new Set&lt;string&gt;();\n\n      for (const sceneId of groupSceneIds) {\n        for (const pid of performersByScene.get(sceneId) || []) groupPerformerIds.add(pid);\n        for (const gid of galleriesByScene.get(sceneId) || []) groupGalleryIds.add(gid);\n      }\n\n      (group as any).performers = [...groupPerformerIds].map((id) =&gt; performersById.get(id)).filter(Boolean);\n      (group as any).galleries = [...groupGalleryIds].map((id) =&gt; galleriesById.get(id)).filter(Boolean);\n    }\n  }\n</code></pre> <p>Step 2: Run test to verify it passes</p> <pre><code>cd server &amp;&amp; npm run test:integration -- groups.integration.test.ts -v\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/GroupQueryBuilder.ts\ngit commit -m \"feat: add performers, galleries relations to group response\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-10-run-full-integration-test-suite","title":"Task 10: Run Full Integration Test Suite","text":"<p>Step 1: Run all integration tests</p> <pre><code>cd server &amp;&amp; npm run test:integration\n</code></pre> <p>Expected: All tests pass</p> <p>Step 2: Commit if any cleanup needed</p>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-11-update-performercard-to-use-rich-tooltips","title":"Task 11: Update PerformerCard to Use Rich Tooltips","text":"<p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Step 1: Import dependencies and config</p> <p>Add at the top after existing imports:</p> <pre><code>import { useMemo } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport TooltipEntityGrid from \"../ui/TooltipEntityGrid.jsx\";\nimport { getIndicatorBehavior } from \"../../config/indicatorBehaviors.js\";\n</code></pre> <p>Step 2: Replace the indicators array and component body</p> <pre><code>const PerformerCard = forwardRef(\n  ({ performer, referrerUrl, isTVMode, tabIndex, onHideSuccess, displayPreferences, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = useMemo(() =&gt; {\n      const tagsTooltip = getIndicatorBehavior('performer', 'tags') === 'rich' &amp;&amp;\n        performer.tags?.length &gt; 0 &amp;&amp; (\n          &lt;TooltipEntityGrid entityType=\"tag\" entities={performer.tags} title=\"Tags\" /&gt;\n        );\n\n      const groupsTooltip = getIndicatorBehavior('performer', 'groups') === 'rich' &amp;&amp;\n        performer.groups?.length &gt; 0 &amp;&amp; (\n          &lt;TooltipEntityGrid entityType=\"group\" entities={performer.groups} title=\"Collections\" /&gt;\n        );\n\n      const galleriesTooltoip = getIndicatorBehavior('performer', 'galleries') === 'rich' &amp;&amp;\n        performer.galleries?.length &gt; 0 &amp;&amp; (\n          &lt;TooltipEntityGrid entityType=\"gallery\" entities={performer.galleries} title=\"Galleries\" /&gt;\n        );\n\n      const studiosTooltip = getIndicatorBehavior('performer', 'studios') === 'rich' &amp;&amp;\n        performer.studios?.length &gt; 0 &amp;&amp; (\n          &lt;TooltipEntityGrid entityType=\"studio\" entities={performer.studios} title=\"Studios\" /&gt;\n        );\n\n      return [\n        { type: \"PLAY_COUNT\", count: performer.play_count },\n        {\n          type: \"SCENES\",\n          count: performer.scene_count,\n          onClick: performer.scene_count &gt; 0 ? () =&gt; navigate(`/scenes?performerId=${performer.id}`) : undefined,\n        },\n        {\n          type: \"GROUPS\",\n          count: performer.groups?.length || performer.group_count || 0,\n          tooltipContent: groupsTooltip,\n          onClick: (performer.groups?.length || performer.group_count) &gt; 0 ? () =&gt; navigate(`/collections?performerId=${performer.id}`) : undefined,\n        },\n        {\n          type: \"IMAGES\",\n          count: performer.image_count,\n          onClick: performer.image_count &gt; 0 ? () =&gt; navigate(`/images?performerId=${performer.id}`) : undefined,\n        },\n        {\n          type: \"GALLERIES\",\n          count: performer.galleries?.length || performer.gallery_count || 0,\n          tooltipContent: galleriesTooltoip,\n          onClick: (performer.galleries?.length || performer.gallery_count) &gt; 0 ? () =&gt; navigate(`/galleries?performerId=${performer.id}`) : undefined,\n        },\n        {\n          type: \"TAGS\",\n          count: performer.tags?.length || 0,\n          tooltipContent: tagsTooltip,\n          onClick: performer.tags?.length &gt; 0 ? () =&gt; navigate(`/tags?performerId=${performer.id}`) : undefined,\n        },\n        {\n          type: \"STUDIOS\",\n          count: performer.studios?.length || 0,\n          tooltipContent: studiosTooltip,\n          onClick: performer.studios?.length &gt; 0 ? () =&gt; navigate(`/studios?performerId=${performer.id}`) : undefined,\n        },\n      ];\n    }, [performer, navigate]);\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"performer\"\n        imagePath={performer.image_path}\n        title={\n          &lt;div className=\"flex items-center justify-center gap-2\"&gt;\n            {performer.name}\n            &lt;GenderIcon gender={performer.gender} size={16} /&gt;\n          &lt;/div&gt;\n        }\n        linkTo={`/performer/${performer.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={isTVMode ? tabIndex : -1}\n        hideDescription\n        hideSubtitle\n        indicators={indicators}\n        displayPreferences={displayPreferences}\n        ratingControlsProps={{\n          entityId: performer.id,\n          initialRating: performer.rating,\n          initialFavorite: performer.favorite || false,\n          initialOCounter: performer.o_counter,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n</code></pre> <p>Step 3: Run client tests</p> <pre><code>cd client &amp;&amp; npm test -- PerformerCard.test.jsx\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add client/src/components/cards/PerformerCard.jsx\ngit commit -m \"feat: add rich tooltip indicators to PerformerCard\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-12-update-tagcard-to-use-rich-tooltips","title":"Task 12: Update TagCard to Use Rich Tooltips","text":"<p>Files: - Modify: <code>client/src/components/cards/TagCard.jsx</code></p> <p>Similar pattern to PerformerCard - add imports, use <code>useMemo</code> for indicators with <code>TooltipEntityGrid</code> and <code>getIndicatorBehavior</code>.</p> <p>Step 1: Update TagCard.jsx</p> <p>(Full code similar to PerformerCard pattern)</p> <p>Step 2: Commit</p> <pre><code>git add client/src/components/cards/TagCard.jsx\ngit commit -m \"feat: add rich tooltip indicators to TagCard\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-13-update-studiocard-to-use-rich-tooltips","title":"Task 13: Update StudioCard to Use Rich Tooltips","text":"<p>Files: - Modify: <code>client/src/components/cards/StudioCard.jsx</code></p> <p>Similar pattern.</p> <p>Step 1: Update StudioCard.jsx</p> <p>Step 2: Commit</p> <pre><code>git add client/src/components/cards/StudioCard.jsx\ngit commit -m \"feat: add rich tooltip indicators to StudioCard\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-14-update-groupcard-to-use-rich-tooltips","title":"Task 14: Update GroupCard to Use Rich Tooltips","text":"<p>Files: - Modify: <code>client/src/components/cards/GroupCard.jsx</code></p> <p>Similar pattern.</p> <p>Step 1: Update GroupCard.jsx</p> <p>Step 2: Commit</p> <pre><code>git add client/src/components/cards/GroupCard.jsx\ngit commit -m \"feat: add rich tooltip indicators to GroupCard\"\n</code></pre>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#task-15-final-verification","title":"Task 15: Final Verification","text":"<p>Step 1: Run all server tests</p> <pre><code>cd server &amp;&amp; npm run test:integration\n</code></pre> <p>Step 2: Run all client tests</p> <pre><code>cd client &amp;&amp; npm test\n</code></pre> <p>Step 3: Run linting</p> <pre><code>cd server &amp;&amp; npm run lint\ncd client &amp;&amp; npm run lint\n</code></pre> <p>Step 4: Manual verification</p> <ul> <li>Browse to Performers page, hover over tag/group/gallery/studio indicators</li> <li>Browse to Tags page, hover over performer/studio/group/gallery indicators</li> <li>Browse to Studios page, hover over performer/tag/group/gallery indicators</li> <li>Browse to Collections page, hover over performer/tag/studio/gallery indicators</li> <li>Verify rich tooltips show entity previews with images and names</li> </ul>"},{"location":"plans/2026-01-07-rich-tooltip-indicators-implementation/#summary","title":"Summary","text":"<p>This plan adds rich tooltip entity data to: - PerformerCard: tags (with image), groups, galleries, studios - TagCard: performers, studios, groups, galleries - StudioCard: performers, groups, galleries (tags already had image_path) - GroupCard: performers, galleries (tags and studio already had image_path)</p> <p>All indicators use the centralized <code>indicatorBehaviors.js</code> config for determining behavior, making it easy to add user settings later.</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/","title":"Card Interaction Improvements Design","text":""},{"location":"plans/2026-01-08-card-interaction-improvements-design/#problem","title":"Problem","text":"<p>Current card interactions rely heavily on hover behaviors that are: 1. Mobile-unfriendly - Hover doesn't exist on touch devices 2. Accidentally triggered - Mouse movement while browsing causes unwanted tooltip popups 3. Not discoverable - No visual indication that indicators are interactive</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#solution","title":"Solution","text":"<p>Replace hover-based interactions with click/tap-only patterns across all cards.</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#changes","title":"Changes","text":""},{"location":"plans/2026-01-08-card-interaction-improvements-design/#1-indicator-tooltips-click-only-popovers","title":"1. Indicator Tooltips \u2192 Click-Only Popovers","text":"<p>Current behavior: - Hover shows rich tooltip (entity grid) - Click also works (via <code>clickable</code> prop) - Both behaviors active simultaneously</p> <p>New behavior: - Remove hover entirely - Click/tap opens popover with entity grid - Tap outside to dismiss - No additional visual affordance (users discover by tapping)</p> <p>Implementation: - Modify <code>Tooltip</code> component to support a <code>hoverDisabled</code> prop (or rename <code>clickable</code> to be clearer) - Update <code>CardCountIndicators</code> to disable hover for rich tooltips - Keep simple text tooltips (e.g., \"3 scenes\") as-is since they're not intrusive</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#2-description-tooltips-inline-more-link","title":"2. Description Tooltips \u2192 Inline \"more\" Link","text":"<p>Current behavior: - Truncated description with hover tooltip showing full text</p> <p>New behavior: - Truncated description with inline \"more\" link at end of text - \"more\" link only visible when text is actually truncated - Clicking \"more\" opens popover with full description - Tap outside to dismiss</p> <p>Implementation: - Modify <code>CardDescription</code> component:   - Detect text truncation (compare scrollHeight vs clientHeight)   - Render \"...more\" at end of truncated text   - On click, show popover with full description - Remove hover tooltip from descriptions</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#affected-components","title":"Affected Components","text":"Component Change <code>Tooltip.jsx</code> Add <code>hoverDisabled</code> prop to skip hover handlers <code>CardCountIndicators.jsx</code> Pass <code>hoverDisabled</code> for rich tooltips <code>CardDescription</code> (in <code>CardComponents.jsx</code>) Replace tooltip with truncation detection + \"more\" link + popover"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#cards-affected","title":"Cards Affected","text":"<p>All cards use <code>BaseCard</code> which uses <code>CardDescription</code> and <code>CardIndicators</code>: - GalleryCard - GroupCard - ImageCard - PerformerCard - StudioCard - TagCard - SceneCard (if it uses BaseCard pattern)</p>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Title tooltips (only show for very long titles, less intrusive)</li> <li>Indicator navigation clicks (already work correctly)</li> <li>Any layout changes to cards</li> </ul>"},{"location":"plans/2026-01-08-card-interaction-improvements-design/#testing","title":"Testing","text":"<ol> <li>Verify indicators no longer show tooltip on hover</li> <li>Verify indicators show popover on click</li> <li>Verify \"more\" link appears only when description is truncated</li> <li>Verify \"more\" popover shows full description</li> <li>Verify tap-outside dismisses popovers</li> <li>Test on mobile/touch device</li> </ol>"},{"location":"plans/2026-01-08-card-interaction-improvements/","title":"Card Interaction Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace hover-based card interactions with click-only patterns for better mobile UX and to eliminate accidental tooltip popups.</p> <p>Architecture: Modify <code>Tooltip</code> component to support hover-disabled mode. Update <code>CardCountIndicators</code> to use click-only for rich tooltips. Refactor <code>CardDescription</code> to detect truncation and show inline \"...more\" link that opens a popover.</p> <p>Tech Stack: React, Vitest, happy-dom</p>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-1-add-hoverdisabled-prop-to-tooltip-component","title":"Task 1: Add <code>hoverDisabled</code> prop to Tooltip component","text":"<p>Files: - Modify: <code>client/src/components/ui/Tooltip.jsx</code> - Create: <code>client/src/components/ui/__tests__/Tooltip.test.jsx</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>client/src/components/ui/__tests__/Tooltip.test.jsx</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport Tooltip from \"../Tooltip\";\n\ndescribe(\"Tooltip\", () =&gt; {\n  it(\"is a React component function\", () =&gt; {\n    expect(typeof Tooltip).toBe(\"function\");\n  });\n\n  it(\"accepts hoverDisabled prop in signature\", () =&gt; {\n    const funcString = Tooltip.toString();\n    expect(funcString).toContain(\"hoverDisabled\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/Tooltip.test.jsx</code> Expected: FAIL - \"hoverDisabled\" not found in function string</p> <p>Step 3: Add hoverDisabled prop to Tooltip</p> <p>In <code>client/src/components/ui/Tooltip.jsx</code>, update the component signature (around line 8):</p> <pre><code>const Tooltip = ({\n  children,\n  content,\n  position = \"top\",\n  className = \"\",\n  disabled = false,\n  clickable = false,\n  hoverDisabled = false, // ADD THIS LINE\n}) =&gt; {\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/Tooltip.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/components/ui/Tooltip.jsx src/components/ui/__tests__/Tooltip.test.jsx\ngit commit -m \"feat: add hoverDisabled prop to Tooltip component\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-2-implement-hoverdisabled-behavior-in-tooltip","title":"Task 2: Implement hoverDisabled behavior in Tooltip","text":"<p>Files: - Modify: <code>client/src/components/ui/Tooltip.jsx</code> - Modify: <code>client/src/components/ui/__tests__/Tooltip.test.jsx</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>client/src/components/ui/__tests__/Tooltip.test.jsx</code>:</p> <pre><code>describe(\"Tooltip hoverDisabled behavior\", () =&gt; {\n  it(\"has handleMouseEnter that checks hoverDisabled\", () =&gt; {\n    // The function body should reference hoverDisabled in mouse handlers\n    const funcString = Tooltip.toString();\n    // When hoverDisabled is true, hover shouldn't trigger visibility\n    expect(funcString).toContain(\"hoverDisabled\");\n    // The mouse enter handler should exist and be conditional\n    expect(funcString).toContain(\"handleMouseEnter\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify current state</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/Tooltip.test.jsx</code> Expected: May pass already since prop exists, but behavior not implemented</p> <p>Step 3: Update mouse handlers to respect hoverDisabled</p> <p>In <code>client/src/components/ui/Tooltip.jsx</code>, modify the <code>handleMouseEnter</code> function (around line 199):</p> <pre><code>  const handleMouseEnter = () =&gt; {\n    if (hoverDisabled) return; // ADD THIS LINE\n    // Clear any pending hide timeout\n    if (hideTimeoutRef.current) {\n      clearTimeout(hideTimeoutRef.current);\n      hideTimeoutRef.current = null;\n    }\n    setIsVisible(true);\n  };\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/Tooltip.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/components/ui/Tooltip.jsx src/components/ui/__tests__/Tooltip.test.jsx\ngit commit -m \"feat: implement hoverDisabled behavior in Tooltip\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-3-update-cardcountindicators-to-use-hoverdisabled-for-rich-tooltips","title":"Task 3: Update CardCountIndicators to use hoverDisabled for rich tooltips","text":"<p>Files: - Modify: <code>client/src/components/ui/CardCountIndicators.jsx</code> - Create: <code>client/src/components/ui/__tests__/CardCountIndicators.test.jsx</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>client/src/components/ui/__tests__/CardCountIndicators.test.jsx</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { CardCountIndicators } from \"../CardCountIndicators\";\n\ndescribe(\"CardCountIndicators\", () =&gt; {\n  it(\"is a React component function\", () =&gt; {\n    expect(typeof CardCountIndicators).toBe(\"function\");\n  });\n});\n\ndescribe(\"CardCountIndicator hoverDisabled\", () =&gt; {\n  it(\"passes hoverDisabled to Tooltip for rich content\", () =&gt; {\n    // The component should pass hoverDisabled={true} when tooltipContent is rich (not string)\n    const funcString = CardCountIndicators.toString();\n    expect(funcString).toContain(\"hoverDisabled\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/CardCountIndicators.test.jsx</code> Expected: FAIL - \"hoverDisabled\" not found</p> <p>Step 3: Update CardCountIndicator to pass hoverDisabled</p> <p>In <code>client/src/components/ui/CardCountIndicators.jsx</code>, modify the Tooltip usage in <code>CardCountIndicator</code> (around line 152-155):</p> <pre><code>  // Use rich tooltipContent if provided, otherwise use simple label text\n  const effectiveTooltip = tooltipContent || (label ? label(count) : null);\n  // Disable hover for rich tooltips (React elements), keep hover for simple text\n  const isRichTooltip = tooltipContent &amp;&amp; typeof tooltipContent !== \"string\";\n\n  return effectiveTooltip ? (\n    &lt;Tooltip\n      content={effectiveTooltip}\n      clickable={!!tooltipContent}\n      hoverDisabled={isRichTooltip}\n    &gt;\n      {guts}\n    &lt;/Tooltip&gt;\n  ) : (\n    guts\n  );\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/CardCountIndicators.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/components/ui/CardCountIndicators.jsx src/components/ui/__tests__/CardCountIndicators.test.jsx\ngit commit -m \"feat: disable hover for rich indicator tooltips\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-4-create-usetruncationdetection-hook","title":"Task 4: Create useTruncationDetection hook","text":"<p>Files: - Create: <code>client/src/hooks/useTruncationDetection.js</code> - Create: <code>client/src/hooks/__tests__/useTruncationDetection.test.js</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>client/src/hooks/__tests__/useTruncationDetection.test.js</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { useTruncationDetection } from \"../useTruncationDetection\";\n\ndescribe(\"useTruncationDetection\", () =&gt; {\n  it(\"is a function\", () =&gt; {\n    expect(typeof useTruncationDetection).toBe(\"function\");\n  });\n\n  it(\"returns ref and isTruncated state\", () =&gt; {\n    // Hook should return [ref, isTruncated]\n    const funcString = useTruncationDetection.toString();\n    expect(funcString).toContain(\"useRef\");\n    expect(funcString).toContain(\"useState\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useTruncationDetection.test.js</code> Expected: FAIL - module not found</p> <p>Step 3: Create the hook</p> <p>Create <code>client/src/hooks/useTruncationDetection.js</code>:</p> <pre><code>import { useEffect, useRef, useState } from \"react\";\n\n/**\n * Hook to detect if text content is truncated (via CSS line-clamp or overflow)\n * @returns {[React.RefObject, boolean]} - [ref to attach to element, whether content is truncated]\n */\nexport const useTruncationDetection = () =&gt; {\n  const ref = useRef(null);\n  const [isTruncated, setIsTruncated] = useState(false);\n\n  useEffect(() =&gt; {\n    const element = ref.current;\n    if (!element) return;\n\n    const checkTruncation = () =&gt; {\n      // Element is truncated if scrollHeight &gt; clientHeight\n      const truncated = element.scrollHeight &gt; element.clientHeight;\n      setIsTruncated(truncated);\n    };\n\n    // Check on mount\n    checkTruncation();\n\n    // Re-check on resize\n    const resizeObserver = new ResizeObserver(checkTruncation);\n    resizeObserver.observe(element);\n\n    return () =&gt; resizeObserver.disconnect();\n  }, []);\n\n  return [ref, isTruncated];\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useTruncationDetection.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/hooks/useTruncationDetection.js src/hooks/__tests__/useTruncationDetection.test.js\ngit commit -m \"feat: add useTruncationDetection hook\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-5-create-expandabledescription-component","title":"Task 5: Create ExpandableDescription component","text":"<p>Files: - Create: <code>client/src/components/ui/ExpandableDescription.jsx</code> - Create: <code>client/src/components/ui/__tests__/ExpandableDescription.test.jsx</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>client/src/components/ui/__tests__/ExpandableDescription.test.jsx</code>:</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { ExpandableDescription } from \"../ExpandableDescription\";\n\ndescribe(\"ExpandableDescription\", () =&gt; {\n  it(\"is a React component function\", () =&gt; {\n    expect(typeof ExpandableDescription).toBe(\"function\");\n  });\n\n  it(\"accepts description and maxLines props\", () =&gt; {\n    const funcString = ExpandableDescription.toString();\n    expect(funcString).toContain(\"description\");\n    expect(funcString).toContain(\"maxLines\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/ExpandableDescription.test.jsx</code> Expected: FAIL - module not found</p> <p>Step 3: Create the component</p> <p>Create <code>client/src/components/ui/ExpandableDescription.jsx</code>:</p> <pre><code>import { useMemo, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { useTruncationDetection } from \"../../hooks/useTruncationDetection\";\n\n/**\n * Description text with inline \"...more\" link when truncated\n * Clicking \"more\" opens a popover with full description\n */\nexport const ExpandableDescription = ({ description, maxLines = 3 }) =&gt; {\n  const [ref, isTruncated] = useTruncationDetection();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [popoverPosition, setPopoverPosition] = useState({ top: 0, left: 0 });\n\n  const descriptionHeight = useMemo(() =&gt; {\n    return `${maxLines * 1.5}rem`;\n  }, [maxLines]);\n\n  if (!description) {\n    return (\n      &lt;div\n        className=\"text-sm my-1 w-full\"\n        style={{ height: descriptionHeight }}\n      /&gt;\n    );\n  }\n\n  const handleMoreClick = (e) =&gt; {\n    e.stopPropagation();\n    e.preventDefault();\n\n    const rect = e.currentTarget.getBoundingClientRect();\n    setPopoverPosition({\n      top: rect.bottom + 8,\n      left: Math.max(16, rect.left - 100),\n    });\n    setIsExpanded(true);\n  };\n\n  const handleClose = () =&gt; {\n    setIsExpanded(false);\n  };\n\n  // Handle click outside\n  const handleBackdropClick = (e) =&gt; {\n    if (e.target === e.currentTarget) {\n      handleClose();\n    }\n  };\n\n  return (\n    &lt;&gt;\n      &lt;div className=\"relative w-full my-1\" style={{ height: descriptionHeight }}&gt;\n        &lt;p\n          ref={ref}\n          className=\"text-sm leading-relaxed\"\n          style={{\n            color: \"var(--text-muted)\",\n            height: descriptionHeight,\n            display: \"-webkit-box\",\n            WebkitLineClamp: maxLines,\n            WebkitBoxOrient: \"vertical\",\n            overflow: \"hidden\",\n            textOverflow: \"ellipsis\",\n          }}\n        &gt;\n          {description}\n        &lt;/p&gt;\n        {isTruncated &amp;&amp; (\n          &lt;button\n            onClick={handleMoreClick}\n            className=\"absolute bottom-0 right-0 text-sm px-1 hover:underline\"\n            style={{\n              color: \"var(--accent-primary)\",\n              backgroundColor: \"var(--bg-card)\",\n            }}\n          &gt;\n            ...more\n          &lt;/button&gt;\n        )}\n      &lt;/div&gt;\n\n      {isExpanded &amp;&amp;\n        createPortal(\n          &lt;div\n            className=\"fixed inset-0 z-[9998]\"\n            onClick={handleBackdropClick}\n          &gt;\n            &lt;div\n              className=\"fixed z-[9999] px-4 py-3 text-sm rounded-lg shadow-xl max-w-[80%] lg:max-w-[60%] max-h-[60vh] overflow-y-auto\"\n              style={{\n                backgroundColor: \"var(--bg-tertiary)\",\n                color: \"var(--text-primary)\",\n                border: \"1px solid var(--border-color)\",\n                top: `${popoverPosition.top}px`,\n                left: `${popoverPosition.left}px`,\n              }}\n              onClick={(e) =&gt; e.stopPropagation()}\n            &gt;\n              &lt;p className=\"whitespace-pre-wrap\"&gt;{description}&lt;/p&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;,\n          document.body\n        )}\n    &lt;/&gt;\n  );\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/ExpandableDescription.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/components/ui/ExpandableDescription.jsx src/components/ui/__tests__/ExpandableDescription.test.jsx\ngit commit -m \"feat: add ExpandableDescription component with inline more link\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-6-update-carddescription-to-use-expandabledescription","title":"Task 6: Update CardDescription to use ExpandableDescription","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code> - Modify: <code>client/src/components/ui/__tests__/CardComponents.test.jsx</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>client/src/components/ui/__tests__/CardComponents.test.jsx</code>:</p> <pre><code>import { CardDescription } from \"../CardComponents\";\n\ndescribe(\"CardDescription\", () =&gt; {\n  it(\"uses ExpandableDescription internally\", () =&gt; {\n    // CardDescription should delegate to ExpandableDescription\n    const funcString = CardDescription.toString();\n    expect(funcString).toContain(\"ExpandableDescription\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/CardComponents.test.jsx</code> Expected: FAIL - \"ExpandableDescription\" not found</p> <p>Step 3: Update CardDescription to use ExpandableDescription</p> <p>In <code>client/src/components/ui/CardComponents.jsx</code>:</p> <ol> <li> <p>Add import at top (around line 13): <pre><code>import { ExpandableDescription } from \"./ExpandableDescription.jsx\";\n</code></pre></p> </li> <li> <p>Replace the entire <code>CardDescription</code> component (around lines 360-394) with: <pre><code>/**\n * Card description section with expandable \"more\" link when truncated\n * @param {string} description - Description text\n * @param {number} maxLines - Maximum lines to display (default: 3)\n */\nexport const CardDescription = ({ description, maxLines = 3 }) =&gt; {\n  return (\n    &lt;ExpandableDescription description={description} maxLines={maxLines} /&gt;\n  );\n};\n</code></pre></p> </li> </ol> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/components/ui/__tests__/CardComponents.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd client &amp;&amp; git add src/components/ui/CardComponents.jsx src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"refactor: CardDescription now uses ExpandableDescription\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-7-run-full-test-suite-and-lint","title":"Task 7: Run full test suite and lint","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run all client tests</p> <p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (warnings OK)</p> <p>Step 3: Fix any issues</p> <p>If tests fail or lint errors, fix them before proceeding.</p> <p>Step 4: Commit any fixes</p> <pre><code>git add -A\ngit commit -m \"fix: address test and lint issues\"\n</code></pre>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-8-manual-testing-checklist","title":"Task 8: Manual testing checklist","text":"<p>Files: - None (manual verification)</p> <p>Step 1: Start development server</p> <p>Run: <code>cd peek-stash-browser &amp;&amp; docker-compose -f docker-compose.yml -f docker-compose.windows.yml up</code></p> <p>Step 2: Test indicator behavior</p> <ul> <li> Hover over indicator icons - NO tooltip should appear</li> <li> Click indicator with rich content (performers, tags) - popover should open</li> <li> Click outside popover - should close</li> <li> Indicators with only counts (images, play count) should still show simple hover tooltip</li> </ul> <p>Step 3: Test description behavior</p> <ul> <li> Cards with short descriptions - NO \"more\" link visible</li> <li> Cards with long truncated descriptions - \"...more\" link visible at end</li> <li> Click \"more\" - popover with full description opens</li> <li> Click outside popover - should close</li> </ul> <p>Step 4: Test on mobile/touch</p> <ul> <li> Tap indicators - popover opens</li> <li> Tap \"more\" on descriptions - popover opens</li> <li> Tap outside - popovers close</li> </ul>"},{"location":"plans/2026-01-08-card-interaction-improvements/#task-9-final-commit-and-branch-cleanup","title":"Task 9: Final commit and branch cleanup","text":"<p>Step 1: Create final commit if any uncommitted changes</p> <pre><code>git status\ngit add -A\ngit commit -m \"feat: card interaction improvements complete\"\n</code></pre> <p>Step 2: Verify branch is ready</p> <pre><code>git log --oneline -10\n</code></pre> <p>Expected: Clean commit history with feature commits</p>"},{"location":"plans/2026-01-08-card-interaction-improvements/#summary-of-changes","title":"Summary of Changes","text":"File Change <code>Tooltip.jsx</code> Added <code>hoverDisabled</code> prop <code>CardCountIndicators.jsx</code> Pass <code>hoverDisabled={true}</code> for rich tooltips <code>useTruncationDetection.js</code> New hook to detect CSS truncation <code>ExpandableDescription.jsx</code> New component with \"...more\" link and popover <code>CardComponents.jsx</code> <code>CardDescription</code> now uses <code>ExpandableDescription</code>"},{"location":"plans/2026-01-08-docker-build-optimization/","title":"Docker Build Optimization Plan","text":"<p>Date: 2026-01-08 Branch: <code>feature/docker-build-optimization</code> Goal: Reduce production Docker image size and improve build times</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#current-state","title":"Current State","text":"<ul> <li>Image size: 997MB</li> <li>Build time: ~2-3 minutes (no-cache)</li> <li>Node versions: Inconsistent (dev: 18/20, prod: 22)</li> </ul>"},{"location":"plans/2026-01-08-docker-build-optimization/#root-causes-identified","title":"Root Causes Identified","text":""},{"location":"plans/2026-01-08-docker-build-optimization/#1-dev-dependencies-leaking-into-production-120mb","title":"1. Dev dependencies leaking into production (~120MB)","text":"<p>The <code>npx prisma generate</code> command in the runtime stage auto-installs the <code>prisma</code> CLI when not found, pulling in:</p> Package Size Why it's there <code>prisma</code> CLI 67MB <code>npx</code> auto-installs it <code>effect</code> 33MB Transitive dep of <code>@prisma/config</code> <code>typescript</code> 23MB Transitive dep of prisma <p>Fix: Generate Prisma client in build stage, copy only the generated client.</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#2-non-production-files-in-image-3mb","title":"2. Non-production files in image (~3MB)","text":"File Location Size <code>stats.html</code> Frontend dist 1.2MB <code>dev.db</code> <code>/app/prisma/</code> 900KB <code>seed.ts</code> <code>/app/prisma/</code> 4KB <code>singleton.ts</code> <code>/app/prisma/</code> 4KB <code>vitest.config.js</code> <code>/app/backend/</code> 4KB <p>Fix: Selective COPY commands instead of copying entire directories.</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#3-duplicate-apt-get-operations-15s-build-time","title":"3. Duplicate apt-get operations (~15s build time)","text":"<p>Three stages all run <code>apt-get update</code> independently: - <code>frontend-build</code> (implicit in node:22-slim) - <code>backend-build</code> (explicit for python3, make, g++) - <code>production</code> (explicit for nginx, sqlite3, etc.)</p> <p>Fix: Create shared base stage or use BuildKit cache mounts.</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#4-inconsistent-node-versions-in-dev-dockerfiles","title":"4. Inconsistent Node versions in dev Dockerfiles","text":"File Node Version <code>client/Dockerfile.dev</code> 20 <code>server/Dockerfile.dev</code> 18 <code>Dockerfile.production</code> 22 <p>Fix: Standardize all on Node 22.</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2026-01-08-docker-build-optimization/#step-1-fix-prisma-generation-in-production-dockerfile","title":"Step 1: Fix Prisma generation in production Dockerfile","text":"<p>Move <code>prisma generate</code> to the backend-build stage where dev dependencies exist:</p> <pre><code># In backend-build stage (has devDeps)\nRUN npx prisma generate\n\n# In production stage\nCOPY --from=backend-build /app/server/node_modules/.prisma ./node_modules/.prisma\n</code></pre> <p>Expected savings: ~120MB</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#step-2-exclude-statshtml-from-production","title":"Step 2: Exclude stats.html from production","text":"<p>Option A: Conditional vite config (only generate in dev/CI) Option B: Delete after build in Dockerfile Option C: Add to .dockerignore pattern</p> <p>Recommend Option B for simplicity: <pre><code>RUN npm run build &amp;&amp; rm -f dist/stats.html\n</code></pre></p> <p>Expected savings: 1.2MB</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#step-3-selective-prisma-directory-copy","title":"Step 3: Selective Prisma directory copy","text":"<p>Replace: <pre><code>COPY server/prisma ./prisma\n</code></pre></p> <p>With: <pre><code>COPY server/prisma/schema.prisma ./prisma/\nCOPY server/prisma/migrations ./prisma/migrations\n</code></pre></p> <p>Expected savings: ~1MB</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#step-4-exclude-vitestconfigjs-from-backend-dist","title":"Step 4: Exclude vitest.config.js from backend dist","text":"<p>The TypeScript build copies this file. Options: - Add to tsconfig exclude - Delete after build in Dockerfile - Move test config outside src</p> <p>Recommend checking tsconfig first, then delete in Dockerfile if needed.</p> <p>Expected savings: 4KB (trivial, but cleaner)</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#step-5-standardize-node-versions-in-dev-dockerfiles","title":"Step 5: Standardize Node versions in dev Dockerfiles","text":"<p>Update both dev Dockerfiles to use Node 22: - <code>client/Dockerfile.dev</code>: 20 \u2192 22 - <code>server/Dockerfile.dev</code>: 18 \u2192 22</p> <p>Expected savings: None (consistency improvement)</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#step-6-optimize-apt-get-with-buildkit-cache-mounts-optional","title":"Step 6: Optimize apt-get with BuildKit cache mounts (optional)","text":"<pre><code>RUN --mount=type=cache,target=/var/cache/apt \\\n    --mount=type=cache,target=/var/lib/apt \\\n    apt-get update &amp;&amp; apt-get install -y ...\n</code></pre> <p>Expected savings: ~10-15s on rebuilds</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#actual-results","title":"Actual Results","text":"Metric Before After Savings Image size 997MB 719MB 278MB (28%)"},{"location":"plans/2026-01-08-docker-build-optimization/#why-not-525mb","title":"Why Not 525MB?","text":"<p>Initial testing removed the Prisma CLI entirely (achieving 525MB), but runtime migrations require the CLI. The Prisma CLI depends on <code>effect</code> which depends on <code>fast-check</code> and <code>pure-rand</code>. These are all required at runtime.</p> <p>The only removable package is <code>typescript</code> (23MB peer dependency).</p>"},{"location":"plans/2026-01-08-docker-build-optimization/#additional-changes-made","title":"Additional Changes Made","text":"<ul> <li>Removed TMP_DIR env var - Hardcoded <code>/app/data/tmp</code> path instead of relying on environment variable</li> <li>Removed duplicate <code>npx prisma generate</code> from <code>database.ts</code> (already done in <code>start.sh</code>)</li> <li>Pruned typescript - The only peer dep that's truly optional at runtime</li> </ul>"},{"location":"plans/2026-01-08-docker-build-optimization/#verification-completed","title":"Verification Completed","text":"<pre><code>$ npx prisma --version\nprisma                  : 6.17.0\n@prisma/client          : 6.17.0\n</code></pre>"},{"location":"plans/2026-01-08-docker-build-optimization/#rollback","title":"Rollback","text":"<p>If issues arise, revert the branch. No database migrations or breaking changes involved.</p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/","title":"SceneCard Navigation Issue - Current State","text":""},{"location":"plans/2026-01-08-scenecard-navigation-issue/#problem-summary","title":"Problem Summary","text":"<p>After refactoring card navigation to use explicit navigation zones (image/title as Links, rest of card as plain div), SceneCard is broken because it uses a fundamentally different pattern than other cards.</p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#the-two-patterns","title":"The Two Patterns","text":""},{"location":"plans/2026-01-08-scenecard-navigation-issue/#pattern-a-other-cards-gallery-group-performer-studio-tag-image","title":"Pattern A: Other Cards (Gallery, Group, Performer, Studio, Tag, Image)","text":"<ul> <li>Pass <code>linkTo</code> prop to BaseCard</li> <li>BaseCard passes <code>linkTo</code> to CardImage and CardTitle</li> <li>CardImage/CardTitle render as <code>&lt;Link&gt;</code> elements when <code>linkTo</code> is provided</li> <li>No custom click handling needed - React Router handles navigation</li> </ul>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#pattern-b-scenecard","title":"Pattern B: SceneCard","text":"<ul> <li>Does NOT pass <code>linkTo</code> to BaseCard</li> <li>Passes <code>onClick={handleClick}</code> instead</li> <li>Has extensive custom click handling:</li> <li>Selection mode (checkbox multi-select)</li> <li>Long press detection (for entering selection mode)</li> <li>Touch gesture handling</li> <li>Keyboard navigation (Enter/Space)</li> <li>Checks for interactive elements before navigating</li> <li>Navigation happens via <code>navigate()</code> call inside <code>handleClick</code></li> </ul>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#current-code-state","title":"Current Code State","text":""},{"location":"plans/2026-01-08-scenecard-navigation-issue/#cardcontainer-cardcomponentsjsx23-57","title":"CardContainer (CardComponents.jsx:23-57)","text":"<p>Now a plain <code>&lt;div&gt;</code> that receives <code>onClick</code> prop: <pre><code>export const CardContainer = forwardRef(({ onClick, ...others }, ref) =&gt; {\n  return (\n    &lt;div onClick={onClick} {...others}&gt;\n      {children}\n    &lt;/div&gt;\n  );\n});\n</code></pre></p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#cardimage-cardcomponentsjsx89-211","title":"CardImage (CardComponents.jsx:89-211)","text":"<p>Conditionally renders as Link OR div: <pre><code>if (linkTo) {\n  return &lt;Link to={linkTo} ...&gt;{imageContent}{children}&lt;/Link&gt;;\n}\nreturn &lt;div onClick={onClick} ...&gt;{imageContent}{children}&lt;/div&gt;;\n</code></pre></p> <p>Problem: BaseCard doesn't pass <code>onClick</code> to CardImage, only <code>linkTo</code>. So for SceneCard (no linkTo), the div has no onClick handler.</p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#cardtitle-cardcomponentsjsx296-382","title":"CardTitle (CardComponents.jsx:296-382)","text":"<p>Conditionally wraps in Link: <pre><code>const titleContent = linkTo ? (\n  &lt;Link to={linkTo} ...&gt;{titleElement}&lt;/Link&gt;\n) : (\n  titleElement\n);\n</code></pre></p> <p>Problem: Same issue - no linkTo means no Link wrapper, and no onClick passed.</p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#basecard-basecardjsx65-117","title":"BaseCard (BaseCard.jsx:65-117)","text":"<p>Passes to CardImage and CardTitle: <pre><code>&lt;CardImage\n  linkTo={linkTo}\n  referrerUrl={referrerUrl}\n  // Note: onClick is NOT passed to CardImage\n&gt;\n&lt;CardTitle\n  linkTo={linkTo}\n  referrerUrl={referrerUrl}\n  // Note: onClick is NOT passed to CardTitle\n&gt;\n</code></pre></p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#scenecard-scenecardjsx383-425","title":"SceneCard (SceneCard.jsx:383-425)","text":"<p>Passes to BaseCard: <pre><code>&lt;BaseCard\n  // Note: NO linkTo prop\n  onClick={handleClick}\n  onMouseDown={handleMouseDown}\n  onMouseUp={handleMouseUp}\n  // ... other gesture handlers\n&gt;\n</code></pre></p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#why-clicks-dont-work-on-scenecard","title":"Why Clicks Don't Work on SceneCard","text":"<ol> <li>User clicks on scene image/title area</li> <li>Click event fires on CardImage's inner <code>&lt;div&gt;</code> (no onClick handler)</li> <li>Event bubbles up to CardContainer's <code>&lt;div&gt;</code></li> <li>CardContainer has <code>onClick={handleClick}</code> from SceneCard</li> <li>BUT SceneCardPreview renders children inside CardImage with <code>pointer-events-none</code></li> <li>The preview overlays, gradient, and progress bar all have <code>pointer-events-none</code></li> <li>So clicks SHOULD bubble through to CardContainer...</li> </ol> <p>Wait - if pointer-events-none is set, clicks should bubble. Let me verify what's actually blocking.</p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#scenecardpreview-pointer-events-scenecardpreviewjsx","title":"SceneCardPreview Pointer Events (SceneCardPreview.jsx)","text":"<p>All overlay elements have <code>pointer-events-none</code>: - Line 356: <code>&lt;img className=\"... pointer-events-none\" /&gt;</code> (screenshot) - Line 366: <code>&lt;video className=\"... pointer-events-none\" /&gt;</code> (mp4 preview) - Line 382: <code>&lt;img className=\"... pointer-events-none\" /&gt;</code> (webp preview) - Line 393-397: sprite container and img both have <code>pointer-events-none</code> - Line 415, 424: duration and resolution badges have <code>pointer-events-none</code></p>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#actual-issue-to-investigate","title":"Actual Issue to Investigate","text":"<p>The click handler on CardContainer should receive bubbled clicks from anywhere inside the card (since overlays are pointer-events-none). Need to verify:</p> <ol> <li>Is something else capturing clicks?</li> <li>Is the hover detection for SceneCardPreview (<code>onMouseEnter</code>/<code>onMouseLeave</code> on line 348-349) interfering?</li> <li>Are the gesture handlers (onMouseDown, onTouchStart, etc.) causing issues?</li> </ol>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#files-involved","title":"Files Involved","text":"<ul> <li><code>client/src/components/ui/CardComponents.jsx</code> - CardContainer, CardImage, CardTitle</li> <li><code>client/src/components/ui/BaseCard.jsx</code> - Assembles card components</li> <li><code>client/src/components/ui/SceneCard.jsx</code> - Scene-specific card with custom handlers</li> <li><code>client/src/components/ui/SceneCardPreview.jsx</code> - Preview functionality</li> </ul>"},{"location":"plans/2026-01-08-scenecard-navigation-issue/#next-steps","title":"Next Steps","text":"<p>After compaction, investigate: 1. Whether clicks are actually reaching CardContainer's onClick 2. If SceneCard needs to be refactored to use the same pattern as other cards 3. How to preserve SceneCard's unique features (selection mode, long press, gestures) while aligning with the new navigation architecture</p>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/","title":"Tabs and Pagination URL Sync Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Make tabs and pagination URL-synced and consistent across all pages, fix the pagination bug where totalPages doesn't update when perPage changes.</p> <p>Architecture: Extend existing <code>useUrlState</code> hook to create a <code>useTabState</code> hook for consistent tab URL management. Fix pagination by using hook state instead of URL params for totalPages calculation. Add pagination URL sync to image grids.</p> <p>Tech Stack: React hooks, react-router-dom, existing useUrlState/useFilterState infrastructure.</p>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#summary-of-changes","title":"Summary of Changes","text":""},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#issue-1-scenejsx-tabs-use-local-state-inconsistent","title":"Issue 1: Scene.jsx tabs use local state (inconsistent)","text":"<ul> <li>Scene.jsx uses <code>useState('similar')</code> for tabs instead of URL params</li> <li>All other detail pages use <code>TabNavigation</code> component with <code>?tab=</code> URL param</li> <li>Fix: Refactor Scene.jsx to use TabNavigation component</li> </ul>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#issue-2-pagination-totalpages-calculated-from-stale-url-params","title":"Issue 2: Pagination totalPages calculated from stale URL params","text":"<ul> <li>List pages read <code>per_page</code> from URL to calculate totalPages: <code>Math.ceil(totalCount / urlPerPage)</code></li> <li>When perPage changes, URL updates happen async, so calculation uses old value</li> <li>Fix: Use <code>pagination.perPage</code> from <code>useFilterState</code> hook instead of parsing URL</li> </ul>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#issue-3-image-grid-pagination-not-url-synced","title":"Issue 3: Image grid pagination not URL-synced","text":"<ul> <li><code>usePaginatedLightbox</code> and <code>useImagesPagination</code> use internal state only</li> <li>Page changes in image grids (GalleryDetail, ImagesTab) don't persist to URL</li> <li>Fix: Add optional URL sync support to these hooks</li> </ul>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#task-1-fix-scenejsx-tabs-to-use-url-params","title":"Task 1: Fix Scene.jsx tabs to use URL params","text":"<p>Files: - Modify: <code>client/src/components/pages/Scene.jsx:77</code> (remove local state) - Modify: <code>client/src/components/pages/Scene.jsx:251-283</code> (use TabNavigation)</p> <p>Step 1: Read the current Scene.jsx implementation</p> <p>Already done in exploration. Key lines: - Line 77: <code>const [activeTab, setActiveTab] = useState('similar');</code> - Lines 251-283: Custom TabButton rendering</p> <p>Step 2: Import TabNavigation and useSearchParams</p> <p>Add to imports at top of file:</p> <pre><code>import { useLocation, useNavigate, useParams, useSearchParams } from \"react-router-dom\";\nimport TabNavigation from \"../ui/TabNavigation.jsx\";\n</code></pre> <p>Step 3: Replace local state with URL-derived state</p> <p>In <code>SceneContent</code> component, replace: <pre><code>const [activeTab, setActiveTab] = useState('similar');\n</code></pre></p> <p>With: <pre><code>const [searchParams] = useSearchParams();\nconst activeTab = searchParams.get('tab') || 'similar';\n</code></pre></p> <p>Step 4: Replace custom tab rendering with TabNavigation</p> <p>Replace the custom tab buttons (lines 252-283) with TabNavigation:</p> <pre><code>{/* Tab Navigation - URL-synced like other detail pages */}\n&lt;TabNavigation\n  tabs={[\n    { id: 'similar', label: 'Similar Scenes', count: similarScenesCount },\n    ...(scene.groups &amp;&amp; scene.groups.length &gt; 0\n      ? [{ id: 'collections', label: 'Collections', count: scene.groups.length }]\n      : []),\n    ...(scene.galleries &amp;&amp; scene.galleries.length &gt; 0\n      ? [{ id: 'galleries', label: 'Galleries', count: scene.galleries.length }]\n      : []),\n  ]}\n  defaultTab=\"similar\"\n/&gt;\n</code></pre> <p>Step 5: Remove TabButton component</p> <p>Delete the <code>TabButton</code> component definition (lines 28-55) as it's no longer needed.</p> <p>Step 6: Run tests to verify</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"Scene\" --watchAll=false</code> Expected: Tests pass (or no Scene-specific tests exist)</p> <p>Step 7: Manual verification</p> <ol> <li>Navigate to a scene page</li> <li>Click \"Collections\" tab if available</li> <li>Verify URL shows <code>?tab=collections</code></li> <li>Click back button</li> <li>Verify returns to previous tab state</li> </ol> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/Scene.jsx\ngit commit -m \"feat: sync Scene page tabs to URL params\n\nScene.jsx now uses TabNavigation component for tab management,\nconsistent with other detail pages. Tab selection persists to\nURL and supports back/forward navigation.\"\n</code></pre>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#task-2-fix-pagination-totalpages-calculation-bug","title":"Task 2: Fix pagination totalPages calculation bug","text":"<p>Files: - Modify: <code>client/src/components/pages/Galleries.jsx:40-41</code> - Modify: <code>client/src/components/pages/Groups.jsx</code> (same pattern) - Modify: <code>client/src/components/pages/Performers.jsx</code> (same pattern) - Modify: <code>client/src/components/pages/Studios.jsx</code> (same pattern) - Modify: <code>client/src/components/pages/Tags.jsx</code> (same pattern) - Modify: <code>client/src/components/pages/Images.jsx</code> (same pattern) - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code> (same pattern)</p> <p>Step 1: Understand the bug</p> <p>Current pattern in all list pages: <pre><code>const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\nconst totalPages = Math.ceil(totalCount / urlPerPage);\n</code></pre></p> <p>Problem: When user changes perPage from 24 to 48: 1. <code>setPerPageAction(48)</code> called in SearchControls 2. URL update is async via <code>setSearchParams</code> 3. Component re-renders before URL updates 4. <code>searchParams.get(\"per_page\")</code> still returns \"24\" 5. totalPages calculated incorrectly</p> <p>Fix: SearchControls already has access to <code>pagination.perPage</code> from useFilterState. Pass it down.</p> <p>Step 2: Modify SearchControls to expose perPage via render props or context</p> <p>Actually, looking at the code more carefully, SearchControls already passes <code>perPage</code> to Pagination component (line 243: <code>const perPage = pagination.perPage</code>). The issue is the parent pages calculate totalPages incorrectly.</p> <p>Better fix: Have SearchControls calculate and use totalPages internally, or pass perPage back up.</p> <p>Simplest fix: Remove redundant totalPages calculation from parent pages. SearchControls already receives totalCount as a prop and has the correct perPage. Have it calculate totalPages internally.</p> <p>Step 3: Verify SearchControls can calculate totalPages</p> <p>SearchControls already has: - <code>totalCount</code> as a prop - <code>perPage</code> from <code>pagination.perPage</code> (correct, from hook state)</p> <p>It receives <code>totalPages</code> as a prop but could calculate it itself.</p> <p>Step 4: Update SearchControls to calculate totalPages when not provided</p> <p>In SearchControls.jsx, add calculation:</p> <pre><code>// Calculate totalPages from hook state (avoids stale URL param issue)\nconst calculatedTotalPages = totalCount ? Math.ceil(totalCount / perPage) : 0;\nconst effectiveTotalPages = totalPages ?? calculatedTotalPages;\n</code></pre> <p>Then use <code>effectiveTotalPages</code> everywhere <code>totalPages</code> is used.</p> <p>Step 5: Update all list pages to remove redundant totalPages calculation</p> <p>Each page currently does: <pre><code>const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\nconst totalPages = Math.ceil(totalCount / urlPerPage);\n</code></pre></p> <p>Change to simply not pass totalPages (SearchControls will calculate it): <pre><code>// Remove: const urlPerPage = ...\n// Remove: const totalPages = ...\n\n&lt;SearchControls\n  // Remove: totalPages={totalPages}\n  totalCount={totalCount}\n  // ... other props\n/&gt;\n</code></pre></p> <p>Actually, checking the code, some pages need totalPages for TV navigation. Let's keep the prop but make SearchControls prefer its own calculation.</p> <p>Better approach: Just fix the calculation in the parent pages to use a ref or callback.</p> <p>Simplest fix: Update parent pages to not calculate totalPages at all</p> <p>Since SearchControls has all the info it needs, just remove totalPages prop from parent pages entirely.</p> <p>Step 6: Update Galleries.jsx</p> <p>Remove lines 40-41 and totalPages prop:</p> <p>Before: <pre><code>const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\nconst totalPages = Math.ceil(totalCount / urlPerPage);\n</code></pre></p> <p>After: Remove these lines entirely.</p> <p>Remove <code>totalPages={totalPages}</code> from SearchControls props (it will calculate internally).</p> <p>But wait - <code>useGridPageTVNavigation</code> also needs totalPages. Let's check that.</p> <p>Step 7: Check useGridPageTVNavigation dependency</p> <p>Looking at Galleries.jsx:44-54: <pre><code>const {\n  isTVMode,\n  _tvNavigation,\n  searchControlsProps,\n  gridItemProps,\n} = useGridPageTVNavigation({\n  items: currentGalleries,\n  columns,\n  totalPages,  // &lt;-- needs totalPages\n  onItemSelect: (gallery) =&gt; navigate(`/gallery/${gallery.id}`),\n});\n</code></pre></p> <p>So TV navigation needs totalPages too. The fix needs to provide a correctly-calculated totalPages.</p> <p>Step 8: Revised approach - use SearchControls state callback</p> <p>Add a callback to SearchControls that provides the current perPage to parent:</p> <p>Actually, the cleanest fix: have SearchControls expose its pagination state.</p> <p>Step 9: Final approach - calculate totalPages from totalCount and a fixed perPage</p> <p>Looking at this more carefully, the issue is that: 1. Parent calculates totalPages from URL (stale) 2. Parent passes totalPages to SearchControls 3. SearchControls uses that totalPages for pagination</p> <p>The fix should be: 1. Parent passes only totalCount 2. SearchControls calculates totalPages from totalCount and its own perPage state</p> <p>Step 10: Implement the fix in SearchControls.jsx</p> <p>Modify SearchControls to calculate totalPages internally:</p> <p>At line ~242, after extracting pagination values: <pre><code>const currentPage = pagination.page;\nconst perPage = pagination.perPage;\n\n// Calculate totalPages from hook state (fixes stale URL param bug)\nconst calculatedTotalPages = totalCount ? Math.ceil(totalCount / perPage) : 0;\n</code></pre></p> <p>Then in all places where <code>totalPages</code> prop is used, use <code>calculatedTotalPages</code> instead.</p> <p>Step 11: Update all list pages to remove totalPages calculation</p> <p>For each page (Galleries, Groups, Performers, Studios, Tags, Images):</p> <p>Remove: <pre><code>const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\nconst totalPages = Math.ceil(totalCount / urlPerPage);\n</code></pre></p> <p>Keep totalPages prop but calculate correctly: <pre><code>// Calculate totalPages correctly using the default perPage\n// (SearchControls will recalculate with actual perPage internally)\nconst totalPages = Math.ceil(totalCount / 24);\n</code></pre></p> <p>Or better - have SearchControls provide totalPages back via a ref or state callback.</p> <p>Step 12: Cleanest solution - provide totalPages via ref callback</p> <p>Add to SearchControls props: <pre><code>totalPagesRef, // Optional ref to receive calculated totalPages\n</code></pre></p> <p>In SearchControls, after calculating: <pre><code>useEffect(() =&gt; {\n  if (totalPagesRef) {\n    totalPagesRef.current = calculatedTotalPages;\n  }\n}, [calculatedTotalPages, totalPagesRef]);\n</code></pre></p> <p>Step 13: Implement in Galleries.jsx as example</p> <pre><code>const totalPagesRef = useRef(0);\n\n// ... later in JSX:\n&lt;SearchControls\n  totalPagesRef={totalPagesRef}\n  totalCount={totalCount}\n  // ...\n/&gt;\n\n// For TV navigation, use ref value:\nconst { ... } = useGridPageTVNavigation({\n  totalPages: totalPagesRef.current || Math.ceil(totalCount / 24),\n  // ...\n});\n</code></pre> <p>Hmm, but refs don't trigger re-renders. This won't work for TV navigation.</p> <p>Step 14: Simplest working solution</p> <p>The real fix is simple: instead of reading perPage from URL, read it from SearchControls' internal state. But SearchControls is a child, so parent can't access it.</p> <p>Option A: Lift perPage state up to parent (breaking change, lots of refactoring) Option B: Have SearchControls report its perPage back to parent via callback Option C: Accept minor delay - totalPages will be correct after next render</p> <p>Let's go with Option B - add an <code>onPerPageChange</code> callback that parents can use:</p> <pre><code>// In parent (Galleries.jsx):\nconst [effectivePerPage, setEffectivePerPage] = useState(24);\nconst totalPages = Math.ceil(totalCount / effectivePerPage);\n\n&lt;SearchControls\n  onPerPageStateChange={setEffectivePerPage}  // New callback\n  // ...\n/&gt;\n</code></pre> <p>In SearchControls, call this whenever perPage changes: <pre><code>useEffect(() =&gt; {\n  onPerPageStateChange?.(perPage);\n}, [perPage, onPerPageStateChange]);\n</code></pre></p> <p>Step 15: Implement the fix</p> <p>In SearchControls.jsx, add prop and effect:</p> <pre><code>// Add to props:\nonPerPageStateChange, // Optional callback when perPage changes\n\n// Add effect after perPage is extracted:\nuseEffect(() =&gt; {\n  if (onPerPageStateChange) {\n    onPerPageStateChange(perPage);\n  }\n}, [perPage, onPerPageStateChange]);\n</code></pre> <p>Step 16: Update Galleries.jsx</p> <pre><code>const [effectivePerPage, setEffectivePerPage] = useState(\n  parseInt(searchParams.get(\"per_page\")) || 24\n);\nconst totalPages = totalCount ? Math.ceil(totalCount / effectivePerPage) : 0;\n\n// ... in JSX:\n&lt;SearchControls\n  onPerPageStateChange={setEffectivePerPage}\n  totalCount={totalCount}\n  // ... other props (can remove totalPages prop now)\n/&gt;\n</code></pre> <p>Step 17: Apply same fix to all other list pages</p> <ul> <li>Groups.jsx</li> <li>Performers.jsx</li> <li>Studios.jsx</li> <li>Tags.jsx</li> <li>Images.jsx</li> <li>SceneSearch.jsx</li> </ul> <p>Step 18: Run tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --watchAll=false</code> Expected: All tests pass</p> <p>Step 19: Manual verification</p> <ol> <li>Navigate to /galleries with 48+ items</li> <li>Change per_page from 24 to 48</li> <li>Verify: pagination shows correct number of pages immediately</li> <li>Verify: items per page changes correctly</li> </ol> <p>Step 20: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx \\\n        client/src/components/pages/Galleries.jsx \\\n        client/src/components/pages/Groups.jsx \\\n        client/src/components/pages/Performers.jsx \\\n        client/src/components/pages/Studios.jsx \\\n        client/src/components/pages/Tags.jsx \\\n        client/src/components/pages/Images.jsx \\\n        client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"fix: pagination totalPages updates correctly when perPage changes\n\nAdded onPerPageStateChange callback to SearchControls that notifies\nparent components when perPage changes. Parents now use this to\ncalculate totalPages instead of reading stale URL params.\n\nFixes issue where pagination controls showed wrong page count after\nchanging items per page.\"\n</code></pre>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#task-3-add-url-sync-to-image-grid-pagination-optional-enhancement","title":"Task 3: Add URL sync to image grid pagination (optional enhancement)","text":"<p>Files: - Modify: <code>client/src/hooks/usePaginatedLightbox.js</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code> - Modify: <code>client/src/components/grids/ImagesTab.jsx</code> (if exists)</p> <p>Step 1: Understand current implementation</p> <p><code>usePaginatedLightbox</code> has <code>externalPage</code> and <code>onExternalPageChange</code> props for external state management. Currently used internally only.</p> <p>Step 2: Update GalleryDetail to use URL for page state</p> <p>In GalleryDetail.jsx, add URL-based page state:</p> <pre><code>const [searchParams, setSearchParams] = useSearchParams();\nconst urlPage = parseInt(searchParams.get('page')) || 1;\n\nconst handlePageChange = useCallback((newPage) =&gt; {\n  const params = new URLSearchParams(searchParams);\n  if (newPage === 1) {\n    params.delete('page');\n  } else {\n    params.set('page', String(newPage));\n  }\n  setSearchParams(params);\n}, [searchParams, setSearchParams]);\n\n// Pass to usePaginatedLightbox:\nconst lightbox = usePaginatedLightbox({\n  perPage: PER_PAGE,\n  totalCount,\n  externalPage: urlPage,\n  onExternalPageChange: handlePageChange,\n});\n</code></pre> <p>Step 3: Apply same pattern to other image grid pages</p> <p>Find and update all pages using usePaginatedLightbox or useImagesPagination.</p> <p>Step 4: Test and commit</p> <p>Run tests, manually verify, commit with appropriate message.</p>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#task-4-write-tests-for-the-fixes","title":"Task 4: Write tests for the fixes","text":"<p>Files: - Create: <code>client/src/hooks/__tests__/useFilterState.pagination.test.jsx</code> - Modify: <code>client/src/hooks/__tests__/useFilterState.test.jsx</code> (add pagination tests)</p> <p>Step 1: Add test for perPage callback</p> <pre><code>describe('onPerPageStateChange callback', () =&gt; {\n  it('calls callback when perPage changes', async () =&gt; {\n    const onPerPageStateChange = vi.fn();\n    // ... render SearchControls with callback\n    // ... change perPage\n    // ... expect callback to be called with new value\n  });\n});\n</code></pre> <p>Step 2: Add test for totalPages calculation</p> <p>Test that totalPages is calculated correctly when perPage changes.</p> <p>Step 3: Commit tests</p> <pre><code>git add client/src/hooks/__tests__/\ngit commit -m \"test: add tests for pagination perPage callback\"\n</code></pre>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#execution-checklist","title":"Execution Checklist","text":"<ul> <li> Task 1: Scene.jsx tabs \u2192 URL params (Steps 1-8)</li> <li> Task 2: Fix pagination totalPages bug (Steps 1-20)</li> <li> Task 3: Image grid pagination URL sync (Optional, Steps 1-4)</li> <li> Task 4: Add tests (Steps 1-3)</li> </ul>"},{"location":"plans/2026-01-08-tabs-pagination-url-sync/#notes","title":"Notes","text":"<ul> <li>All changes follow existing patterns in the codebase</li> <li>Tab changes use <code>push</code> (creates history entry) per the design doc</li> <li>Pagination changes already use <code>push</code> via useFilterState</li> <li>Image grid pagination enhancement is optional but recommended for consistency</li> </ul>"},{"location":"plans/2026-01-08-unified-card-architecture-design/","title":"Unified Card Architecture Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Unify SceneCard with other cards by moving selection mode and keyboard handling to BaseCard, allowing SceneCard to use <code>linkTo</code> for navigation like all other cards.</p> <p>Architecture: Extract long-press selection and keyboard navigation into a reusable hook (<code>useCardSelection</code>). BaseCard consumes this hook and passes selection-aware click handlers to CardImage/CardTitle. SceneCard becomes a thin wrapper that only provides its unique render slots (preview, overlay).</p> <p>Tech Stack: React hooks, React Router Links, existing CardComponents primitives</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#current-state","title":"Current State","text":""},{"location":"plans/2026-01-08-unified-card-architecture-design/#scenecard-complexity","title":"SceneCard Complexity","text":"<ul> <li>432 lines total</li> <li>~130 lines of gesture/selection handlers that duplicate what BaseCard should provide</li> <li>Uses <code>onClick</code> pattern instead of <code>linkTo</code></li> <li>Only truly unique parts: <code>renderImageContent</code> (SceneCardPreview) and <code>renderOverlay</code> (checkbox + progress bar)</li> </ul>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#the-problem","title":"The Problem","text":"<p>After refactoring cards to use explicit navigation zones (CardImage/CardTitle as Links), SceneCard broke because it doesn't use <code>linkTo</code>. BaseCard doesn't pass <code>onClick</code> to CardImage, so clicks on image area have no handler.</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-1-create-usecardselection-hook","title":"Task 1: Create <code>useCardSelection</code> Hook","text":"<p>Files: - Create: <code>client/src/hooks/useCardSelection.js</code> - Create: <code>client/src/hooks/__tests__/useCardSelection.test.js</code></p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-write-the-failing-test-for-long-press-detection","title":"Step 1: Write the failing test for long-press detection","text":"<pre><code>// client/src/hooks/__tests__/useCardSelection.test.js\nimport { renderHook, act } from \"@testing-library/react\";\nimport { describe, it, expect, vi, beforeEach, afterEach } from \"vitest\";\nimport { useCardSelection } from \"../useCardSelection.js\";\n\ndescribe(\"useCardSelection\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.useFakeTimers();\n  });\n\n  afterEach(() =&gt; {\n    vi.useRealTimers();\n  });\n\n  it(\"calls onToggleSelect after 500ms long-press\", () =&gt; {\n    const onToggleSelect = vi.fn();\n    const entity = { id: \"1\", name: \"Test\" };\n\n    const { result } = renderHook(() =&gt;\n      useCardSelection({\n        entity,\n        selectionMode: false,\n        onToggleSelect,\n      })\n    );\n\n    // Simulate mousedown\n    act(() =&gt; {\n      result.current.selectionHandlers.onMouseDown({ target: document.body });\n    });\n\n    // Advance 500ms\n    act(() =&gt; {\n      vi.advanceTimersByTime(500);\n    });\n\n    expect(onToggleSelect).toHaveBeenCalledWith(entity);\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-test-to-verify-it-fails","title":"Step 2: Run test to verify it fails","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardSelection</code> Expected: FAIL with \"useCardSelection is not defined\" or similar</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-write-minimal-implementation","title":"Step 3: Write minimal implementation","text":"<pre><code>// client/src/hooks/useCardSelection.js\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * Hook for card selection behavior: long-press to select, selection mode click handling\n * @param {Object} options\n * @param {Object} options.entity - The entity object (for onToggleSelect callback)\n * @param {boolean} options.selectionMode - Whether selection mode is active\n * @param {Function} options.onToggleSelect - Callback when entity should be toggled\n * @returns {Object} - { isLongPressing, selectionHandlers, handleNavigationClick }\n */\nexport const useCardSelection = ({\n  entity,\n  selectionMode = false,\n  onToggleSelect,\n}) =&gt; {\n  const longPressTimerRef = useRef(null);\n  const [isLongPressing, setIsLongPressing] = useState(false);\n  const startPosRef = useRef({ x: 0, y: 0 });\n  const hasMovedRef = useRef(false);\n\n  // Clear timer on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (longPressTimerRef.current) {\n        clearTimeout(longPressTimerRef.current);\n      }\n    };\n  }, []);\n\n  const isInteractiveElement = useCallback((target) =&gt; {\n    const closestButton = target.closest(\"button\");\n    const isButton = closestButton &amp;&amp; closestButton !== target;\n    const isLink = target.closest(\"a\");\n    const isInput = target.closest(\"input\");\n    return isButton || isLink || isInput;\n  }, []);\n\n  const handleMouseDown = useCallback(\n    (e) =&gt; {\n      if (isInteractiveElement(e.target)) return;\n\n      longPressTimerRef.current = setTimeout(() =&gt; {\n        setIsLongPressing(true);\n        onToggleSelect?.(entity);\n      }, 500);\n    },\n    [entity, onToggleSelect, isInteractiveElement]\n  );\n\n  const handleMouseUp = useCallback(() =&gt; {\n    if (longPressTimerRef.current) {\n      clearTimeout(longPressTimerRef.current);\n      longPressTimerRef.current = null;\n    }\n  }, []);\n\n  const handleTouchStart = useCallback(\n    (e) =&gt; {\n      if (isInteractiveElement(e.target)) return;\n\n      const touch = e.touches[0];\n      startPosRef.current = { x: touch.clientX, y: touch.clientY };\n      hasMovedRef.current = false;\n\n      longPressTimerRef.current = setTimeout(() =&gt; {\n        if (!hasMovedRef.current) {\n          setIsLongPressing(true);\n          onToggleSelect?.(entity);\n        }\n      }, 500);\n    },\n    [entity, onToggleSelect, isInteractiveElement]\n  );\n\n  const handleTouchMove = useCallback((e) =&gt; {\n    if (longPressTimerRef.current &amp;&amp; e.touches.length &gt; 0) {\n      const touch = e.touches[0];\n      const deltaX = Math.abs(touch.clientX - startPosRef.current.x);\n      const deltaY = Math.abs(touch.clientY - startPosRef.current.y);\n      const moveThreshold = 10;\n\n      if (deltaX &gt; moveThreshold || deltaY &gt; moveThreshold) {\n        hasMovedRef.current = true;\n        clearTimeout(longPressTimerRef.current);\n        longPressTimerRef.current = null;\n      }\n    }\n  }, []);\n\n  const handleTouchEnd = useCallback(() =&gt; {\n    if (longPressTimerRef.current) {\n      clearTimeout(longPressTimerRef.current);\n      longPressTimerRef.current = null;\n    }\n    hasMovedRef.current = false;\n  }, []);\n\n  // Click handler for navigation elements (CardImage, CardTitle)\n  // Returns a function to pass as onClick, or undefined if not needed\n  const handleNavigationClick = useCallback(\n    (e) =&gt; {\n      // If long-press just fired, block the click\n      if (isLongPressing) {\n        e.preventDefault();\n        setIsLongPressing(false);\n        return;\n      }\n\n      // In selection mode, toggle instead of navigate\n      if (selectionMode) {\n        e.preventDefault();\n        onToggleSelect?.(entity);\n      }\n      // Otherwise, let the Link navigate normally\n    },\n    [isLongPressing, selectionMode, entity, onToggleSelect]\n  );\n\n  return {\n    isLongPressing,\n    selectionHandlers: {\n      onMouseDown: handleMouseDown,\n      onMouseUp: handleMouseUp,\n      onMouseLeave: handleMouseUp,\n      onTouchStart: handleTouchStart,\n      onTouchMove: handleTouchMove,\n      onTouchEnd: handleTouchEnd,\n      onTouchCancel: handleTouchEnd,\n    },\n    handleNavigationClick: selectionMode || isLongPressing ? handleNavigationClick : undefined,\n  };\n};\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-test-to-verify-it-passes","title":"Step 4: Run test to verify it passes","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardSelection</code> Expected: PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-add-more-tests-for-edge-cases","title":"Step 5: Add more tests for edge cases","text":"<pre><code>// Add to the test file:\n\nit(\"cancels long-press on mouseup before 500ms\", () =&gt; {\n  const onToggleSelect = vi.fn();\n  const entity = { id: \"1\" };\n\n  const { result } = renderHook(() =&gt;\n    useCardSelection({ entity, selectionMode: false, onToggleSelect })\n  );\n\n  act(() =&gt; {\n    result.current.selectionHandlers.onMouseDown({ target: document.body });\n  });\n\n  act(() =&gt; {\n    vi.advanceTimersByTime(300);\n  });\n\n  act(() =&gt; {\n    result.current.selectionHandlers.onMouseUp();\n  });\n\n  act(() =&gt; {\n    vi.advanceTimersByTime(300);\n  });\n\n  expect(onToggleSelect).not.toHaveBeenCalled();\n});\n\nit(\"cancels long-press on touch move &gt; 10px\", () =&gt; {\n  const onToggleSelect = vi.fn();\n  const entity = { id: \"1\" };\n\n  const { result } = renderHook(() =&gt;\n    useCardSelection({ entity, selectionMode: false, onToggleSelect })\n  );\n\n  act(() =&gt; {\n    result.current.selectionHandlers.onTouchStart({\n      target: document.body,\n      touches: [{ clientX: 100, clientY: 100 }],\n    });\n  });\n\n  act(() =&gt; {\n    vi.advanceTimersByTime(300);\n  });\n\n  act(() =&gt; {\n    result.current.selectionHandlers.onTouchMove({\n      touches: [{ clientX: 115, clientY: 100 }],\n    });\n  });\n\n  act(() =&gt; {\n    vi.advanceTimersByTime(300);\n  });\n\n  expect(onToggleSelect).not.toHaveBeenCalled();\n});\n\nit(\"returns handleNavigationClick when in selectionMode\", () =&gt; {\n  const onToggleSelect = vi.fn();\n  const entity = { id: \"1\" };\n\n  const { result } = renderHook(() =&gt;\n    useCardSelection({ entity, selectionMode: true, onToggleSelect })\n  );\n\n  expect(result.current.handleNavigationClick).toBeDefined();\n});\n\nit(\"returns undefined handleNavigationClick when not in selectionMode\", () =&gt; {\n  const onToggleSelect = vi.fn();\n  const entity = { id: \"1\" };\n\n  const { result } = renderHook(() =&gt;\n    useCardSelection({ entity, selectionMode: false, onToggleSelect })\n  );\n\n  expect(result.current.handleNavigationClick).toBeUndefined();\n});\n\nit(\"handleNavigationClick prevents default and toggles in selection mode\", () =&gt; {\n  const onToggleSelect = vi.fn();\n  const entity = { id: \"1\" };\n  const preventDefault = vi.fn();\n\n  const { result } = renderHook(() =&gt;\n    useCardSelection({ entity, selectionMode: true, onToggleSelect })\n  );\n\n  act(() =&gt; {\n    result.current.handleNavigationClick({ preventDefault });\n  });\n\n  expect(preventDefault).toHaveBeenCalled();\n  expect(onToggleSelect).toHaveBeenCalledWith(entity);\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-6-run-all-hook-tests","title":"Step 6: Run all hook tests","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardSelection</code> Expected: All PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-7-commit","title":"Step 7: Commit","text":"<pre><code>git add client/src/hooks/useCardSelection.js client/src/hooks/__tests__/useCardSelection.test.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat: add useCardSelection hook for long-press and selection mode\n\nExtracts selection behavior from SceneCard into a reusable hook:\n- Long-press detection (500ms) for mouse and touch\n- Touch move cancellation (&gt;10px movement)\n- Selection mode click interception\n- Returns handlers for CardContainer and navigation click override\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-2-create-usecardkeyboardnav-hook","title":"Task 2: Create <code>useCardKeyboardNav</code> Hook","text":"<p>Files: - Create: <code>client/src/hooks/useCardKeyboardNav.js</code> - Create: <code>client/src/hooks/__tests__/useCardKeyboardNav.test.js</code></p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-write-the-failing-test","title":"Step 1: Write the failing test","text":"<pre><code>// client/src/hooks/__tests__/useCardKeyboardNav.test.js\nimport { renderHook } from \"@testing-library/react\";\nimport { describe, it, expect, vi } from \"vitest\";\nimport { useCardKeyboardNav } from \"../useCardKeyboardNav.js\";\nimport { useNavigate } from \"react-router-dom\";\n\nvi.mock(\"react-router-dom\", () =&gt; ({\n  useNavigate: vi.fn(),\n}));\n\ndescribe(\"useCardKeyboardNav\", () =&gt; {\n  it(\"navigates on Enter key\", () =&gt; {\n    const navigate = vi.fn();\n    useNavigate.mockReturnValue(navigate);\n\n    const { result } = renderHook(() =&gt;\n      useCardKeyboardNav({ linkTo: \"/scene/123\" })\n    );\n\n    const preventDefault = vi.fn();\n    const stopPropagation = vi.fn();\n\n    result.current.onKeyDown({\n      key: \"Enter\",\n      preventDefault,\n      stopPropagation,\n      target: document.body,\n      currentTarget: document.body,\n    });\n\n    expect(preventDefault).toHaveBeenCalled();\n    expect(navigate).toHaveBeenCalledWith(\"/scene/123\");\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-test-to-verify-it-fails_1","title":"Step 2: Run test to verify it fails","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardKeyboardNav</code> Expected: FAIL</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-write-minimal-implementation_1","title":"Step 3: Write minimal implementation","text":"<pre><code>// client/src/hooks/useCardKeyboardNav.js\nimport { useCallback } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\n/**\n * Hook for card keyboard navigation (TV mode support)\n * @param {Object} options\n * @param {string} options.linkTo - Navigation URL\n * @param {Function} options.onCustomAction - Optional override action\n * @returns {Object} - { onKeyDown }\n */\nexport const useCardKeyboardNav = ({ linkTo, onCustomAction }) =&gt; {\n  const navigate = useNavigate();\n\n  const onKeyDown = useCallback(\n    (e) =&gt; {\n      // Only handle if card (or child) is focused\n      if (\n        e.currentTarget !== document.activeElement &amp;&amp;\n        !e.currentTarget.contains(document.activeElement)\n      ) {\n        return;\n      }\n\n      // Ignore if in input field\n      const target = e.target;\n      const isInputField =\n        target.tagName === \"INPUT\" ||\n        target.tagName === \"TEXTAREA\" ||\n        target.tagName === \"SELECT\" ||\n        target.isContentEditable;\n\n      if (isInputField) return;\n\n      if (e.key === \"Enter\" || e.key === \" \") {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (onCustomAction) {\n          onCustomAction();\n        } else if (linkTo) {\n          navigate(linkTo);\n        }\n      }\n    },\n    [linkTo, onCustomAction, navigate]\n  );\n\n  return { onKeyDown };\n};\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-test-to-verify-it-passes_1","title":"Step 4: Run test to verify it passes","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardKeyboardNav</code> Expected: PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-add-more-tests","title":"Step 5: Add more tests","text":"<pre><code>// Add to test file:\n\nit(\"navigates on Space key\", () =&gt; {\n  const navigate = vi.fn();\n  useNavigate.mockReturnValue(navigate);\n\n  const { result } = renderHook(() =&gt;\n    useCardKeyboardNav({ linkTo: \"/scene/123\" })\n  );\n\n  result.current.onKeyDown({\n    key: \" \",\n    preventDefault: vi.fn(),\n    stopPropagation: vi.fn(),\n    target: document.body,\n    currentTarget: document.body,\n  });\n\n  expect(navigate).toHaveBeenCalledWith(\"/scene/123\");\n});\n\nit(\"calls onCustomAction instead of navigate when provided\", () =&gt; {\n  const navigate = vi.fn();\n  const onCustomAction = vi.fn();\n  useNavigate.mockReturnValue(navigate);\n\n  const { result } = renderHook(() =&gt;\n    useCardKeyboardNav({ linkTo: \"/scene/123\", onCustomAction })\n  );\n\n  result.current.onKeyDown({\n    key: \"Enter\",\n    preventDefault: vi.fn(),\n    stopPropagation: vi.fn(),\n    target: document.body,\n    currentTarget: document.body,\n  });\n\n  expect(onCustomAction).toHaveBeenCalled();\n  expect(navigate).not.toHaveBeenCalled();\n});\n\nit(\"ignores key events on input fields\", () =&gt; {\n  const navigate = vi.fn();\n  useNavigate.mockReturnValue(navigate);\n\n  const { result } = renderHook(() =&gt;\n    useCardKeyboardNav({ linkTo: \"/scene/123\" })\n  );\n\n  const input = document.createElement(\"input\");\n\n  result.current.onKeyDown({\n    key: \"Enter\",\n    preventDefault: vi.fn(),\n    stopPropagation: vi.fn(),\n    target: input,\n    currentTarget: document.body,\n  });\n\n  expect(navigate).not.toHaveBeenCalled();\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-6-run-all-tests","title":"Step 6: Run all tests","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run useCardKeyboardNav</code> Expected: All PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-7-commit_1","title":"Step 7: Commit","text":"<pre><code>git add client/src/hooks/useCardKeyboardNav.js client/src/hooks/__tests__/useCardKeyboardNav.test.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat: add useCardKeyboardNav hook for TV mode navigation\n\nHandles Enter/Space key navigation for cards:\n- Navigates to linkTo URL on keypress\n- Supports custom action override\n- Ignores events on input fields\n- Only activates when card is focused\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-3-update-cardimage-to-support-click-override","title":"Task 3: Update CardImage to Support Click Override","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code> (CardImage section, ~lines 89-211)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-write-failing-test","title":"Step 1: Write failing test","text":"<pre><code>// Add to client/src/components/ui/__tests__/CardComponents.test.jsx\n// (or create if doesn't exist)\n\ndescribe(\"CardImage\", () =&gt; {\n  it(\"calls onClickOverride when clicking Link\", () =&gt; {\n    const onClickOverride = vi.fn((e) =&gt; e.preventDefault());\n\n    render(\n      &lt;MemoryRouter&gt;\n        &lt;CardImage\n          src=\"/test.jpg\"\n          linkTo=\"/scene/1\"\n          onClickOverride={onClickOverride}\n        /&gt;\n      &lt;/MemoryRouter&gt;\n    );\n\n    fireEvent.click(screen.getByRole(\"link\"));\n    expect(onClickOverride).toHaveBeenCalled();\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-test-to-verify-it-fails_2","title":"Step 2: Run test to verify it fails","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run CardComponents</code> Expected: FAIL (onClickOverride not implemented)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-update-cardimage-implementation","title":"Step 3: Update CardImage implementation","text":"<p>In <code>CardComponents.jsx</code>, update the CardImage component to accept <code>onClickOverride</code>:</p> <pre><code>export const CardImage = ({\n  src,\n  alt = \"\",\n  aspectRatio = \"16/9\",\n  entityType,\n  objectFit = \"contain\",\n  children,\n  className = \"\",\n  style = {},\n  onClick,\n  linkTo,\n  referrerUrl,\n  onClickOverride,  // NEW: intercepts clicks before Link navigation\n}) =&gt; {\n  // ... existing code ...\n\n  // If linkTo provided, wrap in Link; otherwise use div with onClick\n  if (linkTo) {\n    return (\n      &lt;Link\n        ref={ref}\n        to={linkTo}\n        state={{ referrerUrl }}\n        className={containerClasses}\n        style={containerStyle}\n        onClick={onClickOverride}  // NEW: onClick on Link itself\n      &gt;\n        {imageContent}\n        {children}\n      &lt;/Link&gt;\n    );\n  }\n\n  // ... rest unchanged ...\n};\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-test-to-verify-it-passes_2","title":"Step 4: Run test to verify it passes","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run CardComponents</code> Expected: PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-commit","title":"Step 5: Commit","text":"<pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"feat(CardImage): add onClickOverride prop for selection mode\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-4-update-cardtitle-to-support-click-override","title":"Task 4: Update CardTitle to Support Click Override","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code> (CardTitle section, ~lines 296-382)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-write-failing-test_1","title":"Step 1: Write failing test","text":"<pre><code>// Add to CardComponents.test.jsx\n\ndescribe(\"CardTitle\", () =&gt; {\n  it(\"calls onClickOverride when clicking title Link\", () =&gt; {\n    const onClickOverride = vi.fn((e) =&gt; e.preventDefault());\n\n    render(\n      &lt;MemoryRouter&gt;\n        &lt;CardTitle\n          title=\"Test Title\"\n          linkTo=\"/scene/1\"\n          onClickOverride={onClickOverride}\n        /&gt;\n      &lt;/MemoryRouter&gt;\n    );\n\n    fireEvent.click(screen.getByText(\"Test Title\"));\n    expect(onClickOverride).toHaveBeenCalled();\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-test-to-verify-it-fails_3","title":"Step 2: Run test to verify it fails","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run CardComponents</code> Expected: FAIL</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-update-cardtitle-implementation","title":"Step 3: Update CardTitle implementation","text":"<pre><code>export const CardTitle = ({\n  title,\n  subtitle,\n  hideSubtitle = false,\n  maxTitleLines = 1,\n  linkTo,\n  referrerUrl,\n  onClickOverride,  // NEW\n}) =&gt; {\n  // ... existing code ...\n\n  // Wrap in Link if linkTo provided\n  const titleContent = linkTo ? (\n    &lt;Link\n      to={linkTo}\n      state={{ referrerUrl }}\n      className=\"block hover:underline cursor-pointer\"\n      onClick={onClickOverride}  // NEW\n    &gt;\n      {titleElement}\n    &lt;/Link&gt;\n  ) : (\n    titleElement\n  );\n\n  // Subtitle also gets the override\n  const subtitleContent = linkTo &amp;&amp; subtitleElement ? (\n    &lt;Link\n      to={linkTo}\n      state={{ referrerUrl }}\n      className=\"block cursor-pointer\"\n      onClick={onClickOverride}  // NEW\n    &gt;\n      {subtitleElement}\n    &lt;/Link&gt;\n  ) : (\n    subtitleElement\n  );\n\n  // ... rest unchanged ...\n};\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-test-to-verify-it-passes_3","title":"Step 4: Run test to verify it passes","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run CardComponents</code> Expected: PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-commit_1","title":"Step 5: Commit","text":"<pre><code>git add client/src/components/ui/CardComponents.jsx\ngit commit -m \"feat(CardTitle): add onClickOverride prop for selection mode\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-5-update-basecard-to-use-selection-hooks","title":"Task 5: Update BaseCard to Use Selection Hooks","text":"<p>Files: - Modify: <code>client/src/components/ui/BaseCard.jsx</code></p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-write-failing-test_2","title":"Step 1: Write failing test","text":"<pre><code>// Add to client/src/components/ui/__tests__/BaseCard.test.jsx\n\ndescribe(\"BaseCard selection mode\", () =&gt; {\n  it(\"passes selection handlers to CardContainer\", () =&gt; {\n    const onToggleSelect = vi.fn();\n    const entity = { id: \"1\" };\n\n    render(\n      &lt;MemoryRouter&gt;\n        &lt;BaseCard\n          entityType=\"scene\"\n          entity={entity}\n          linkTo=\"/scene/1\"\n          selectionMode={true}\n          onToggleSelect={onToggleSelect}\n        /&gt;\n      &lt;/MemoryRouter&gt;\n    );\n\n    // The card container should have the handlers attached\n    const card = screen.getByLabelText(\"Scene\");\n    expect(card).toBeInTheDocument();\n  });\n\n  it(\"applies selected styling when isSelected\", () =&gt; {\n    render(\n      &lt;MemoryRouter&gt;\n        &lt;BaseCard\n          entityType=\"scene\"\n          entity={{ id: \"1\" }}\n          linkTo=\"/scene/1\"\n          isSelected={true}\n        /&gt;\n      &lt;/MemoryRouter&gt;\n    );\n\n    const card = screen.getByLabelText(\"Scene\");\n    expect(card).toHaveStyle({ borderColor: \"var(--selection-color)\" });\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-test-to-verify-it-fails_4","title":"Step 2: Run test to verify it fails","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run BaseCard</code> Expected: FAIL</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-update-basecard-implementation","title":"Step 3: Update BaseCard implementation","text":"<pre><code>import { forwardRef } from \"react\";\nimport { useEntityImageAspectRatio } from \"../../hooks/useEntityImageAspectRatio.js\";\nimport { useCardSelection } from \"../../hooks/useCardSelection.js\";\nimport { useCardKeyboardNav } from \"../../hooks/useCardKeyboardNav.js\";\nimport {\n  CardContainer,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardRatingRow,\n  CardTitle,\n} from \"./CardComponents.jsx\";\n\nexport const BaseCard = forwardRef(\n  (\n    {\n      // Data\n      entityType,\n      entity,  // NEW: for selection callbacks\n      imagePath,\n      title,\n      subtitle,\n      description,\n      linkTo,\n\n      // Selection mode (NEW)\n      selectionMode = false,\n      isSelected = false,\n      onToggleSelect,\n\n      // ... rest of existing props ...\n      indicators = [],\n      ratingControlsProps,\n      displayPreferences = {},\n      hideDescription = false,\n      hideSubtitle = false,\n      maxTitleLines = 2,\n      maxDescriptionLines = 3,\n      objectFit = \"contain\",\n      renderOverlay,\n      renderImageContent,\n      renderAfterTitle,\n      onClick,\n      className = \"\",\n      referrerUrl,\n      tabIndex,\n      style,\n      onFocus,\n      ...rest\n    },\n    ref\n  ) =&gt; {\n    const aspectRatio = useEntityImageAspectRatio(entityType);\n\n    // Selection hook\n    const { selectionHandlers, handleNavigationClick } = useCardSelection({\n      entity,\n      selectionMode,\n      onToggleSelect,\n    });\n\n    // Keyboard navigation hook\n    const { onKeyDown } = useCardKeyboardNav({\n      linkTo,\n      onCustomAction: selectionMode ? () =&gt; onToggleSelect?.(entity) : undefined,\n    });\n\n    const shouldShowDescription = hideDescription === true\n      ? false\n      : (displayPreferences.showDescription ?? true);\n\n    // Selection styling\n    const selectionStyle = isSelected\n      ? {\n          borderColor: \"var(--selection-color)\",\n          borderWidth: \"2px\",\n        }\n      : {};\n\n    return (\n      &lt;CardContainer\n        ref={ref}\n        entityType={entityType}\n        onClick={onClick}\n        className={className}\n        tabIndex={tabIndex}\n        style={{ ...style, ...selectionStyle }}\n        onKeyDown={onKeyDown}\n        onFocus={onFocus}\n        {...selectionHandlers}\n        {...rest}\n      &gt;\n        &lt;CardImage\n          src={imagePath}\n          alt={typeof title === \"string\" ? title : \"\"}\n          aspectRatio={aspectRatio}\n          entityType={entityType}\n          objectFit={objectFit}\n          linkTo={linkTo}\n          referrerUrl={referrerUrl}\n          onClickOverride={handleNavigationClick}\n        &gt;\n          {renderImageContent?.()}\n          {renderOverlay?.()}\n        &lt;/CardImage&gt;\n\n        &lt;CardTitle\n          title={title}\n          subtitle={hideSubtitle ? null : subtitle}\n          maxTitleLines={maxTitleLines}\n          linkTo={linkTo}\n          referrerUrl={referrerUrl}\n          onClickOverride={handleNavigationClick}\n        /&gt;\n\n        {renderAfterTitle?.()}\n\n        {shouldShowDescription &amp;&amp; (\n          &lt;CardDescription\n            description={description}\n            maxLines={maxDescriptionLines}\n          /&gt;\n        )}\n\n        {indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators indicators={indicators} /&gt;}\n\n        {ratingControlsProps &amp;&amp; (\n          &lt;CardRatingRow entityType={entityType} {...ratingControlsProps} /&gt;\n        )}\n      &lt;/CardContainer&gt;\n    );\n  }\n);\n\nBaseCard.displayName = \"BaseCard\";\n\nexport default BaseCard;\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-tests-to-verify-they-pass","title":"Step 4: Run tests to verify they pass","text":"<p>Run: <code>cd client &amp;&amp; npm test -- --run BaseCard</code> Expected: PASS</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-run-full-test-suite","title":"Step 5: Run full test suite","text":"<p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-6-commit","title":"Step 6: Commit","text":"<pre><code>git add client/src/components/ui/BaseCard.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(BaseCard): add selection mode and keyboard navigation support\n\n- Integrates useCardSelection hook for long-press and selection\n- Integrates useCardKeyboardNav hook for TV mode\n- Passes onClickOverride to CardImage/CardTitle\n- Applies selection styling when isSelected\n- New props: entity, selectionMode, isSelected, onToggleSelect\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-6-refactor-scenecard","title":"Task 6: Refactor SceneCard","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code></p> <p>This is the major simplification. We remove all gesture handlers and let BaseCard handle them.</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-document-current-line-count","title":"Step 1: Document current line count","text":"<p>Run: <code>wc -l client/src/components/ui/SceneCard.jsx</code> Expected: ~432 lines</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-refactor-scenecard","title":"Step 2: Refactor SceneCard","text":"<p>The new SceneCard removes all gesture/keyboard handlers and uses <code>linkTo</code>:</p> <pre><code>import { forwardRef, useMemo } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { useTVMode } from \"../../hooks/useTVMode.js\";\nimport {\n  formatDurationCompact,\n  formatResolution,\n  getSceneDescription,\n  getSceneTitle,\n} from \"../../utils/format.js\";\nimport { formatRelativeTime } from \"../../utils/date.js\";\nimport BaseCard from \"./BaseCard.jsx\";\nimport { SceneCardPreview, TooltipEntityGrid } from \"./index.js\";\n\nconst buildSceneSubtitle = (scene) =&gt; {\n  const parts = [];\n  if (scene.studio) parts.push(scene.studio.name);\n  if (scene.code) parts.push(scene.code);\n  const date = scene.date ? formatRelativeTime(scene.date) : null;\n  if (date) parts.push(date);\n  return parts.length &gt; 0 ? parts.join(' \u2022 ') : null;\n};\n\nconst computeAllTags = (scene) =&gt; {\n  const tagMap = new Map();\n  if (scene.tags) scene.tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  if (scene.inheritedTags) scene.inheritedTags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  return Array.from(tagMap.values());\n};\n\nconst SceneCard = forwardRef(\n  (\n    {\n      scene,\n      onClick,\n      onFocus,\n      tabIndex = -1,\n      className = \"\",\n      isSelected = false,\n      onToggleSelect,\n      selectionMode = false,\n      autoplayOnScroll = false,\n      hideRatingControls = false,\n      onHideSuccess,\n    },\n    ref\n  ) =&gt; {\n    const { isTVMode } = useTVMode();\n    const navigate = useNavigate();\n\n    const title = getSceneTitle(scene);\n    const description = getSceneDescription(scene);\n    const subtitle = buildSceneSubtitle(scene);\n    const duration = scene.files?.[0]?.duration\n      ? formatDurationCompact(scene.files[0].duration)\n      : null;\n    const resolution =\n      scene.files?.[0]?.width &amp;&amp; scene.files?.[0]?.height\n        ? formatResolution(scene.files[0].width, scene.files[0].height)\n        : null;\n\n    const allTags = useMemo(() =&gt; computeAllTags(scene), [scene]);\n\n    const indicators = useMemo(() =&gt; {\n      const performersTooltip = scene.performers?.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid entityType=\"performer\" entities={scene.performers} title=\"Performers\" /&gt;\n      );\n      const groupsTooltip = scene.groups?.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid entityType=\"group\" entities={scene.groups} title=\"Collections\" /&gt;\n      );\n      const tagsTooltip = allTags?.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid entityType=\"tag\" entities={allTags} title=\"Tags\" /&gt;\n      );\n      const galleriesTooltip = scene.galleries?.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid entityType=\"gallery\" entities={scene.galleries} title=\"Galleries\" /&gt;\n      );\n\n      return [\n        { type: \"PLAY_COUNT\", count: scene.play_count, tooltipContent: \"Times watched\" },\n        {\n          type: \"PERFORMERS\",\n          count: scene.performers?.length,\n          tooltipContent: performersTooltip,\n          onClick: scene.performers?.length &gt; 0 ? () =&gt; navigate(`/performers?sceneId=${scene.id}`) : undefined,\n        },\n        {\n          type: \"GROUPS\",\n          count: scene.groups?.length,\n          tooltipContent: groupsTooltip,\n          onClick: scene.groups?.length &gt; 0 ? () =&gt; navigate(`/collections?sceneId=${scene.id}`) : undefined,\n        },\n        {\n          type: \"GALLERIES\",\n          count: scene.galleries?.length,\n          tooltipContent: galleriesTooltip,\n          onClick: scene.galleries?.length &gt; 0 ? () =&gt; navigate(`/galleries?sceneId=${scene.id}`) : undefined,\n        },\n        {\n          type: \"TAGS\",\n          count: allTags?.length,\n          tooltipContent: tagsTooltip,\n          onClick: allTags?.length &gt; 0 ? () =&gt; navigate(`/tags?sceneId=${scene.id}`) : undefined,\n        },\n      ];\n    }, [scene, allTags, navigate]);\n\n    const handleCheckboxClick = (e) =&gt; {\n      e.stopPropagation();\n      onToggleSelect?.(scene);\n    };\n\n    const renderOverlay = () =&gt; (\n      &lt;div className=\"absolute top-2 left-2 z-20\"&gt;\n        &lt;button\n          onClick={handleCheckboxClick}\n          className=\"w-8 h-8 sm:w-6 sm:h-6 rounded border-2 flex items-center justify-center transition-all\"\n          style={{\n            backgroundColor: isSelected ? \"var(--selection-color)\" : \"rgba(0, 0, 0, 0.5)\",\n            borderColor: isSelected ? \"var(--selection-color)\" : \"rgba(255, 255, 255, 0.7)\",\n          }}\n          onMouseEnter={(e) =&gt; { if (!isSelected) e.currentTarget.style.borderColor = \"rgba(255, 255, 255, 1)\"; }}\n          onMouseLeave={(e) =&gt; { if (!isSelected) e.currentTarget.style.borderColor = \"rgba(255, 255, 255, 0.7)\"; }}\n          aria-label={isSelected ? \"Deselect scene\" : \"Select scene\"}\n        &gt;\n          {isSelected &amp;&amp; (\n            &lt;svg className=\"w-5 h-5 sm:w-4 sm:h-4 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"&gt;\n              &lt;path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={3} d=\"M5 13l4 4L19 7\" /&gt;\n            &lt;/svg&gt;\n          )}\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n\n    const renderImageContent = () =&gt; (\n      &lt;&gt;\n        {scene.paths?.screenshot &amp;&amp; (\n          &lt;SceneCardPreview\n            scene={scene}\n            autoplayOnScroll={autoplayOnScroll}\n            cycleInterval={600}\n            spriteCount={10}\n            duration={duration}\n            resolution={resolution}\n          /&gt;\n        )}\n        &lt;div className=\"absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent pointer-events-none\" /&gt;\n        {scene.resumeTime &amp;&amp; scene.files?.[0]?.duration &amp;&amp; (\n          &lt;div className=\"absolute bottom-0 left-0 right-0 h-1 bg-black/50 pointer-events-none\"&gt;\n            &lt;div\n              className=\"h-full transition-all pointer-events-none\"\n              style={{\n                width: `${Math.min(100, (scene.resumeTime / scene.files[0].duration) * 100)}%`,\n                backgroundColor: \"var(--status-success)\",\n              }}\n            /&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/&gt;\n    );\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"scene\"\n        entity={scene}\n        linkTo={`/scene/${scene.id}`}\n        referrerUrl=\"/scenes\"\n        selectionMode={selectionMode}\n        isSelected={isSelected}\n        onToggleSelect={onToggleSelect}\n        imagePath={scene.paths?.screenshot}\n        title={title}\n        subtitle={subtitle}\n        description={description}\n        indicators={indicators}\n        ratingControlsProps={!hideRatingControls &amp;&amp; {\n          entityType: \"scene\",\n          entityId: scene.id,\n          initialRating: scene.rating,\n          initialFavorite: scene.favorite || false,\n          initialOCounter: scene.o_counter,\n          entityTitle: title,\n          onHideSuccess,\n        }}\n        renderOverlay={renderOverlay}\n        renderImageContent={renderImageContent}\n        className={`${isSelected ? \"scene-card-selected\" : \"\"} ${className}`}\n        onClick={onClick}\n        onFocus={onFocus}\n        tabIndex={isTVMode ? tabIndex : -1}\n      /&gt;\n    );\n  }\n);\n\nSceneCard.displayName = \"SceneCard\";\n\nexport default SceneCard;\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-count-new-line-count","title":"Step 3: Count new line count","text":"<p>Run: <code>wc -l client/src/components/ui/SceneCard.jsx</code> Expected: ~180-200 lines (down from 432)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-run-tests","title":"Step 4: Run tests","text":"<p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-5-manual-verification","title":"Step 5: Manual verification","text":"<p>Test in browser: 1. Scene cards navigate on click (image or title) 2. Long-press enters selection mode 3. In selection mode, clicking toggles selection 4. Checkbox works independently 5. Video preview still works on hover 6. Progress bar still shows 7. Keyboard Enter/Space navigates (in TV mode)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-6-commit_1","title":"Step 6: Commit","text":"<pre><code>git add client/src/components/ui/SceneCard.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nrefactor(SceneCard): simplify by using BaseCard selection support\n\nMajor refactoring:\n- Removed all gesture handlers (~120 lines)\n- Now uses linkTo like all other cards\n- Selection/keyboard handled by BaseCard hooks\n- Keeps only unique render slots (preview, overlay)\n\nLine count: 432 -&gt; ~190 (~56% reduction)\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#task-7-final-verification-and-cleanup","title":"Task 7: Final Verification and Cleanup","text":""},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-1-run-full-test-suite","title":"Step 1: Run full test suite","text":"<p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-2-run-linter","title":"Step 2: Run linter","text":"<p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-3-manual-smoke-test-all-card-types","title":"Step 3: Manual smoke test all card types","text":"<p>Test each card type in browser: - SceneCard: navigation, selection, preview, keyboard - PerformerCard: navigation, indicators - GalleryCard: navigation, indicators - GroupCard: navigation, indicators - StudioCard: navigation - TagCard: navigation</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#step-4-commit-any-cleanup","title":"Step 4: Commit any cleanup","text":"<pre><code>git add -A\ngit commit -m \"chore: cleanup after unified card architecture refactor\"\n</code></pre>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#summary-what-changed","title":"Summary: What Changed","text":"File Before After Change <code>SceneCard.jsx</code> 432 lines ~190 lines -242 lines (-56%) <code>useCardSelection.js</code> (new) ~100 lines +100 lines <code>useCardKeyboardNav.js</code> (new) ~40 lines +40 lines <code>BaseCard.jsx</code> ~125 lines ~145 lines +20 lines <code>CardComponents.jsx</code> - +4 lines +4 lines (onClickOverride) Net -78 lines, much DRYer"},{"location":"plans/2026-01-08-unified-card-architecture-design/#scenecard-after-refactor","title":"SceneCard After Refactor","text":"<p>SceneCard is now a thin wrapper around BaseCard: - ~40 lines: Imports and helpers (buildSceneSubtitle, computeAllTags) - ~35 lines: Indicator definitions - ~25 lines: <code>renderOverlay</code> (checkbox) - ~30 lines: <code>renderImageContent</code> (preview + gradient + progress) - ~30 lines: BaseCard call with props - ~30 lines: Component boilerplate</p> <p>Total: ~190 lines (down from 432 = 56% reduction)</p>"},{"location":"plans/2026-01-08-unified-card-architecture-design/#what-we-gained","title":"What We Gained","text":"<ol> <li>Any card can opt into selection mode - just pass <code>selectionMode</code>, <code>isSelected</code>, <code>onToggleSelect</code>, <code>entity</code></li> <li>Keyboard navigation on all cards - automatic via <code>useCardKeyboardNav</code></li> <li>Consistent architecture - all cards use <code>linkTo</code> pattern</li> <li>Testable hooks - selection and keyboard logic unit tested separately</li> <li>DRYer codebase - gesture logic centralized, ~78 net lines removed</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/","title":"URL State Management Redesign","text":""},{"location":"plans/2026-01-08-url-state-management-design/#problem-statement","title":"Problem Statement","text":"<p>URL \"sync\" and \"history\" behavior in Peek has several issues that degrade user experience:</p> <ol> <li>Back button doesn't restore state - Filter, sort, and page changes don't create browser history entries, so the back button doesn't work as expected</li> <li>Default preset filters override navigation intent - When clicking a card indicator (e.g., performers count on a scene card), the user's default preset filters get applied on top of the intended filter, polluting the results</li> <li>No centralized abstraction - URL sync logic is embedded in a 1,070-line component, making it hard to maintain consistent behavior</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#current-architecture","title":"Current Architecture","text":""},{"location":"plans/2026-01-08-url-state-management-design/#how-it-works-today","title":"How It Works Today","text":"<p>SearchControls.jsx (~1,070 lines) handles all URL state management inline:</p> <ol> <li>On mount, fetches default presets via API</li> <li>Determines if URL has params (<code>needsDefaultPreset</code> check)</li> <li>Merges URL params with default preset (both sort AND filters)</li> <li>Sets React state from merged result</li> <li>On any state change, syncs back to URL with <code>replace: true</code></li> </ol> <p>Key Files: - <code>client/src/components/ui/SearchControls.jsx</code> - Core search state management - <code>client/src/components/ui/TabNavigation.jsx</code> - Tab URL sync (separate implementation) - <code>client/src/utils/urlParams.js</code> - Serialize/deserialize filters to/from URL</p>"},{"location":"plans/2026-01-08-url-state-management-design/#root-causes","title":"Root Causes","text":"<p>Issue 1: History not preserved - Location: <code>SearchControls.jsx:416</code> - <code>setSearchParams(params, { replace: true })</code> overwrites history instead of pushing - Every filter/page/sort change replaces the current history entry</p> <p>Issue 2: Default preset filters applied incorrectly - Location: <code>SearchControls.jsx:303-327</code> - When URL has params, code creates <code>baseState</code> from default preset (sort AND filters) - Then merges URL params on top - Result: navigating to <code>/performers?sceneId=123</code> with a default preset that has <code>favorite=true</code> gives you both filters</p> <p>Issue 3: Inconsistent implementations - <code>TabNavigation</code> uses <code>setSearchParams()</code> without <code>replace: true</code> (creates history) - <code>SearchControls</code> uses <code>replace: true</code> (no history) - No shared abstraction to enforce consistency</p>"},{"location":"plans/2026-01-08-url-state-management-design/#proposed-solution","title":"Proposed Solution","text":""},{"location":"plans/2026-01-08-url-state-management-design/#architecture-overview","title":"Architecture Overview","text":"<p>Create a centralized URL state management system with clear separation of concerns:</p> <pre><code>client/src/hooks/\n  useUrlState.js          # Core hook for bidirectional URL sync\n  useFilterState.js       # High-level hook combining URL state + presets + query building\n\nclient/src/utils/\n  urlParams.js            # (existing) Keep serialization logic here\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-design/#core-principle-read-once-write-silently","title":"Core Principle: Read Once, Write Silently","text":"<p>A key goal of this redesign is to minimize and isolate URL interactions. The current implementation likely has sync issues because of too much two-way communication between React state and the URL.</p> <p>The correct pattern: - Read from URL once on component mount to initialize state - Write to URL silently as user interacts (sort, filter, paginate, tab changes) - Never read URL again after initialization - trust that state stays in sync via writes</p> <p>This is fundamentally different from a \"reactive\" approach where URL changes trigger state updates. We want:</p> <pre><code>MOUNT:\n  URL \u2500\u2500\u2500\u2500\u2500\u2500\u25ba React State (one-time read)\n\nUSER INTERACTION:\n  React State \u2500\u2500\u2500\u2500\u2500\u2500\u25ba URL (silent write, no read-back)\n\nNAVIGATION (back/forward):\n  Browser restores URL \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Component remounts \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Fresh read\n</code></pre> <p>The browser's back/forward navigation naturally handles state restoration because it triggers a component remount (or at minimum, a fresh initialization cycle), which reads the restored URL.</p>"},{"location":"plans/2026-01-08-url-state-management-design/#history-strategy","title":"History Strategy","text":"<p>Different actions warrant different history behaviors:</p> Action History Rationale Page change <code>push</code> User expects back to return to previous page Filter add/remove <code>push</code> User expects to undo filter changes Sort change <code>push</code> User expects to undo sort changes Search text (debounced) <code>replace</code> Avoid polluting history with keystrokes Tab change <code>push</code> Already works this way Initial load sync <code>replace</code> Don't create duplicate entry on mount"},{"location":"plans/2026-01-08-url-state-management-design/#default-preset-logic","title":"Default Preset Logic","text":"<p>The key insight: URL filter params represent explicit user intent. When present, they should not be overridden by preset filters. However, the user's preferred sort should still apply.</p> <pre><code>URL has filter params (excluding page/per_page)?\n  YES \u2192 Apply preset SORT only, use URL FILTERS as-is\n  NO  \u2192 Apply preset SORT and FILTERS (direct navigation)\n</code></pre> <p>This means: - Clicking <code>/performers</code> directly \u2192 uses full default preset (sort + filters) - Clicking indicator \u2192 <code>/performers?sceneId=123</code> \u2192 uses preset sort, but only <code>sceneId</code> filter</p>"},{"location":"plans/2026-01-08-url-state-management-design/#hook-api-design","title":"Hook API Design","text":""},{"location":"plans/2026-01-08-url-state-management-design/#useurlstate-low-level","title":"useUrlState (Low-level)","text":"<p>Core hook for URL parameter synchronization with configurable history behavior.</p> <pre><code>const useUrlState = (options) =&gt; {\n  // options: {\n  //   params: string[],        // Which params to manage\n  //   defaults: object,        // Default values\n  //   historyMode: 'push' | 'replace' | 'auto'  // 'auto' uses rules above\n  // }\n\n  return {\n    values,           // Current parsed values\n    setValue,         // (key, value, options?) =&gt; void\n    setValues,        // (updates, options?) =&gt; void\n    resetToDefaults,  // () =&gt; void\n  };\n};\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-design/#usefilterstate-high-level","title":"useFilterState (High-level)","text":"<p>Combines URL state with preset loading and query building.</p> <pre><code>const useFilterState = (options) =&gt; {\n  // options: {\n  //   artifactType: string,\n  //   context: string,\n  //   initialSort: string,\n  //   permanentFilters: object,\n  //   syncToUrl: boolean,\n  // }\n\n  return {\n    // State\n    filters,\n    sort: { field, direction },\n    pagination: { page, perPage },\n    searchText,\n\n    // Actions\n    setFilter,        // (key, value) =&gt; void\n    setFilters,       // (filters) =&gt; void\n    removeFilter,     // (key) =&gt; void\n    clearFilters,     // () =&gt; void\n    setSort,          // (field, direction?) =&gt; void\n    setPage,          // (page) =&gt; void\n    setPerPage,       // (perPage) =&gt; void\n    setSearchText,    // (text) =&gt; void\n    loadPreset,       // (preset) =&gt; void\n\n    // Query building\n    buildQuery,       // () =&gt; GraphQL query object\n\n    // Status\n    isInitialized,\n    isLoadingPresets,\n  };\n};\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-design/#migration-strategy","title":"Migration Strategy","text":""},{"location":"plans/2026-01-08-url-state-management-design/#phase-1-create-new-hooks-non-breaking","title":"Phase 1: Create New Hooks (Non-breaking)","text":"<ol> <li>Implement <code>useUrlState</code> with comprehensive tests</li> <li>Implement <code>useFilterState</code> using <code>useUrlState</code> internally</li> <li>Both hooks exist alongside current implementation</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#phase-2-migrate-searchcontrols","title":"Phase 2: Migrate SearchControls","text":"<ol> <li>Refactor <code>SearchControls</code> to use <code>useFilterState</code></li> <li>Remove inline URL management logic</li> <li>Verify all existing functionality preserved</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#phase-3-migrate-other-components","title":"Phase 3: Migrate Other Components","text":"<ol> <li>Update <code>TabNavigation</code> to use <code>useUrlState</code> for consistency</li> <li>Audit any other components doing URL manipulation</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#phase-4-cleanup","title":"Phase 4: Cleanup","text":"<ol> <li>Remove deprecated code paths</li> <li>Update documentation</li> <li>Add integration tests for URL behavior</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#testing-considerations","title":"Testing Considerations","text":""},{"location":"plans/2026-01-08-url-state-management-design/#unit-tests","title":"Unit Tests","text":"<ul> <li><code>useUrlState</code>: param parsing, history modes, defaults</li> <li><code>useFilterState</code>: preset logic, query building, state transitions</li> </ul>"},{"location":"plans/2026-01-08-url-state-management-design/#integration-tests","title":"Integration Tests","text":"<ul> <li>Back button behavior across different actions</li> <li>Indicator navigation with/without default presets</li> <li>Tab + filter interaction on detail pages</li> <li>Deep linking with various param combinations</li> </ul>"},{"location":"plans/2026-01-08-url-state-management-design/#manual-test-scenarios","title":"Manual Test Scenarios","text":"<ol> <li>Navigate to <code>/scenes</code>, change page to 3, click back \u2192 should return to page 1</li> <li>Set default preset with <code>favorite=true</code> filter on performers</li> <li>Click performer count indicator on scene card</li> <li>Verify: arrives at <code>/performers?sceneId=X</code> with sceneId filter only (not favorite)</li> <li>Verify: sort matches default preset preference</li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#design-decisions","title":"Design Decisions","text":"<ol> <li> <p>Search text debounce - Yes, add 500ms debounce (matching Stash) to avoid polluting history with keystrokes.</p> </li> <li> <p>Preset sort vs URL sort precedence - URL wins. Explicit params always take precedence over implicit defaults.</p> </li> <li> <p>Detail page nested searches - Confirmed no truly nested URL state needs. Tabs (<code>?tab=scenes</code>) and filter params coexist cleanly on the same URL without conflict.</p> </li> </ol>"},{"location":"plans/2026-01-08-url-state-management-design/#references","title":"References","text":"<ul> <li>Stash implementation: <code>stash/ui/v2.5/src/components/List/util.ts</code></li> <li>Stash filter model: <code>stash/ui/v2.5/src/models/list-filter/filter.ts</code></li> <li>Current Peek implementation: <code>peek-stash-browser/client/src/components/ui/SearchControls.jsx</code></li> </ul>"},{"location":"plans/2026-01-08-url-state-management-implementation/","title":"URL State Management Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Create centralized URL state management hooks that fix back-button behavior and prevent default preset filters from overriding navigation intent.</p> <p>Architecture: Two new hooks - <code>useUrlState</code> (low-level URL sync with configurable history) and <code>useFilterState</code> (high-level combining URL state + presets + query building). Read URL once on mount, write silently on changes, never read back.</p> <p>Tech Stack: React hooks, react-router-dom v6 (useSearchParams, useNavigate), Vitest for testing</p>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-1-create-useurlstate-hook-basic-structure","title":"Task 1: Create useUrlState Hook - Basic Structure","text":"<p>Files: - Create: <code>client/src/hooks/useUrlState.js</code> - Create: <code>client/src/hooks/__tests__/useUrlState.test.js</code></p> <p>Step 1: Write the failing test for initial URL parsing</p> <pre><code>// client/src/hooks/__tests__/useUrlState.test.js\nimport { renderHook } from \"@testing-library/react\";\nimport { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { MemoryRouter } from \"react-router-dom\";\nimport { useUrlState } from \"../useUrlState.js\";\n\n// Wrapper to provide router context\nconst createWrapper = (initialEntries = [\"/\"]) =&gt; {\n  return ({ children }) =&gt; (\n    &lt;MemoryRouter initialEntries={initialEntries}&gt;{children}&lt;/MemoryRouter&gt;\n  );\n};\n\ndescribe(\"useUrlState\", () =&gt; {\n  describe(\"initialization\", () =&gt; {\n    it(\"parses initial URL params on mount\", () =&gt; {\n      const { result } = renderHook(\n        () =&gt; useUrlState({ defaults: { page: 1, sort: \"date\" } }),\n        { wrapper: createWrapper([\"/?page=3&amp;sort=rating\"]) }\n      );\n\n      expect(result.current.values.page).toBe(\"3\");\n      expect(result.current.values.sort).toBe(\"rating\");\n    });\n\n    it(\"uses defaults when URL params are missing\", () =&gt; {\n      const { result } = renderHook(\n        () =&gt; useUrlState({ defaults: { page: 1, sort: \"date\" } }),\n        { wrapper: createWrapper([\"/\"]) }\n      );\n\n      expect(result.current.values.page).toBe(1);\n      expect(result.current.values.sort).toBe(\"date\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: FAIL with \"Cannot find module '../useUrlState.js'\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/hooks/useUrlState.js\nimport { useRef } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\n/**\n * Low-level hook for URL state management.\n * Reads URL once on mount, writes silently on changes.\n *\n * @param {Object} options\n * @param {Object} options.defaults - Default values when URL params missing\n * @returns {Object} { values, setValue, setValues }\n */\nexport const useUrlState = ({ defaults = {} } = {}) =&gt; {\n  const [searchParams] = useSearchParams();\n  const initializedRef = useRef(false);\n  const valuesRef = useRef(null);\n\n  // Read URL params only once on first render\n  if (!initializedRef.current) {\n    initializedRef.current = true;\n    const parsed = {};\n\n    // Start with defaults\n    Object.keys(defaults).forEach((key) =&gt; {\n      parsed[key] = defaults[key];\n    });\n\n    // Override with URL params\n    for (const [key, value] of searchParams.entries()) {\n      parsed[key] = value;\n    }\n\n    valuesRef.current = parsed;\n  }\n\n  return {\n    values: valuesRef.current,\n    setValue: () =&gt; {}, // Placeholder\n    setValues: () =&gt; {}, // Placeholder\n  };\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useUrlState.js client/src/hooks/__tests__/useUrlState.test.js\ngit commit -m \"feat: add useUrlState hook with initial URL parsing\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-2-add-setvalue-with-history-push","title":"Task 2: Add setValue with History Push","text":"<p>Files: - Modify: <code>client/src/hooks/useUrlState.js</code> - Modify: <code>client/src/hooks/__tests__/useUrlState.test.js</code></p> <p>Step 1: Write the failing test for setValue</p> <p>Add to <code>useUrlState.test.js</code>:</p> <pre><code>import { renderHook, act } from \"@testing-library/react\";\n\ndescribe(\"setValue\", () =&gt; {\n  it(\"updates URL with history push by default\", () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useUrlState({ defaults: { page: 1 } }),\n      { wrapper: createWrapper([\"/?page=1\"]) }\n    );\n\n    act(() =&gt; {\n      result.current.setValue(\"page\", 2);\n    });\n\n    // Check internal state updated\n    expect(result.current.values.page).toBe(2);\n  });\n\n  it(\"updates URL with replace when specified\", () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useUrlState({ defaults: { q: \"\" } }),\n      { wrapper: createWrapper([\"/\"]) }\n    );\n\n    act(() =&gt; {\n      result.current.setValue(\"q\", \"search\", { replace: true });\n    });\n\n    expect(result.current.values.q).toBe(\"search\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: FAIL - setValue doesn't update values</p> <p>Step 3: Implement setValue</p> <p>Update <code>useUrlState.js</code>:</p> <pre><code>import { useRef, useState, useCallback } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nexport const useUrlState = ({ defaults = {} } = {}) =&gt; {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const initializedRef = useRef(false);\n\n  // Parse initial URL only once\n  const getInitialValues = () =&gt; {\n    const parsed = { ...defaults };\n    for (const [key, value] of searchParams.entries()) {\n      parsed[key] = value;\n    }\n    return parsed;\n  };\n\n  const [values, setValuesState] = useState(() =&gt; {\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      return getInitialValues();\n    }\n    return {};\n  });\n\n  const setValue = useCallback((key, value, options = {}) =&gt; {\n    const { replace = false } = options;\n\n    // Update internal state\n    setValuesState((prev) =&gt; ({\n      ...prev,\n      [key]: value,\n    }));\n\n    // Update URL silently\n    setSearchParams((prevParams) =&gt; {\n      const newParams = new URLSearchParams(prevParams);\n      if (value === null || value === undefined || value === \"\") {\n        newParams.delete(key);\n      } else {\n        newParams.set(key, String(value));\n      }\n      return newParams;\n    }, { replace });\n  }, [setSearchParams]);\n\n  const setValues = useCallback((updates, options = {}) =&gt; {\n    const { replace = false } = options;\n\n    setValuesState((prev) =&gt; ({\n      ...prev,\n      ...updates,\n    }));\n\n    setSearchParams((prevParams) =&gt; {\n      const newParams = new URLSearchParams(prevParams);\n      Object.entries(updates).forEach(([key, value]) =&gt; {\n        if (value === null || value === undefined || value === \"\") {\n          newParams.delete(key);\n        } else {\n          newParams.set(key, String(value));\n        }\n      });\n      return newParams;\n    }, { replace });\n  }, [setSearchParams]);\n\n  return {\n    values,\n    setValue,\n    setValues,\n  };\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useUrlState.js client/src/hooks/__tests__/useUrlState.test.js\ngit commit -m \"feat: add setValue and setValues to useUrlState\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-3-add-hasurlparams-helper","title":"Task 3: Add hasUrlParams Helper","text":"<p>Files: - Modify: <code>client/src/hooks/useUrlState.js</code> - Modify: <code>client/src/hooks/__tests__/useUrlState.test.js</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>useUrlState.test.js</code>:</p> <pre><code>describe(\"hasUrlParams\", () =&gt; {\n  it(\"returns true when URL has params beyond defaults\", () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useUrlState({\n        defaults: { page: 1 },\n        ignoreKeys: [\"page\", \"per_page\"]\n      }),\n      { wrapper: createWrapper([\"/?page=1&amp;tagIds=123\"]) }\n    );\n\n    expect(result.current.hasUrlParams).toBe(true);\n  });\n\n  it(\"returns false when URL only has ignored params\", () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useUrlState({\n        defaults: { page: 1 },\n        ignoreKeys: [\"page\", \"per_page\"]\n      }),\n      { wrapper: createWrapper([\"/?page=2\"]) }\n    );\n\n    expect(result.current.hasUrlParams).toBe(false);\n  });\n\n  it(\"returns false when URL is empty\", () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useUrlState({ defaults: { page: 1 } }),\n      { wrapper: createWrapper([\"/\"]) }\n    );\n\n    expect(result.current.hasUrlParams).toBe(false);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: FAIL - hasUrlParams is undefined</p> <p>Step 3: Implement hasUrlParams</p> <p>Update <code>useUrlState.js</code> - add <code>ignoreKeys</code> option and <code>hasUrlParams</code> return value:</p> <pre><code>export const useUrlState = ({ defaults = {}, ignoreKeys = [] } = {}) =&gt; {\n  const [searchParams, setSearchParams] = useSearchParams();\n  const initializedRef = useRef(false);\n  const hadUrlParamsRef = useRef(false);\n\n  // Parse initial URL only once\n  const getInitialValues = () =&gt; {\n    const parsed = { ...defaults };\n    let hasNonIgnoredParams = false;\n\n    for (const [key, value] of searchParams.entries()) {\n      parsed[key] = value;\n      if (!ignoreKeys.includes(key)) {\n        hasNonIgnoredParams = true;\n      }\n    }\n\n    hadUrlParamsRef.current = hasNonIgnoredParams;\n    return parsed;\n  };\n\n  const [values, setValuesState] = useState(() =&gt; {\n    if (!initializedRef.current) {\n      initializedRef.current = true;\n      return getInitialValues();\n    }\n    return {};\n  });\n\n  // ... setValue and setValues unchanged ...\n\n  return {\n    values,\n    setValue,\n    setValues,\n    hasUrlParams: hadUrlParamsRef.current,\n  };\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useUrlState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useUrlState.js client/src/hooks/__tests__/useUrlState.test.js\ngit commit -m \"feat: add hasUrlParams to useUrlState for preset logic\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-4-create-usefilterstate-hook-basic-structure","title":"Task 4: Create useFilterState Hook - Basic Structure","text":"<p>Files: - Create: <code>client/src/hooks/useFilterState.js</code> - Create: <code>client/src/hooks/__tests__/useFilterState.test.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/hooks/__tests__/useFilterState.test.js\nimport { renderHook, act, waitFor } from \"@testing-library/react\";\nimport { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { MemoryRouter } from \"react-router-dom\";\nimport { useFilterState } from \"../useFilterState.js\";\n\n// Mock the API\nvi.mock(\"../../services/api.js\", () =&gt; ({\n  apiGet: vi.fn(),\n}));\n\nimport { apiGet } from \"../../services/api.js\";\n\nconst createWrapper = (initialEntries = [\"/\"]) =&gt; {\n  return ({ children }) =&gt; (\n    &lt;MemoryRouter initialEntries={initialEntries}&gt;{children}&lt;/MemoryRouter&gt;\n  );\n};\n\ndescribe(\"useFilterState\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n    // Default: no presets\n    apiGet.mockResolvedValue({ presets: {}, defaults: {} });\n  });\n\n  describe(\"initialization\", () =&gt; {\n    it(\"initializes with default values when URL is empty\", async () =&gt; {\n      const { result } = renderHook(\n        () =&gt; useFilterState({\n          artifactType: \"scene\",\n          initialSort: \"o_counter\",\n        }),\n        { wrapper: createWrapper([\"/\"]) }\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.sort.field).toBe(\"o_counter\");\n      expect(result.current.sort.direction).toBe(\"DESC\");\n      expect(result.current.pagination.page).toBe(1);\n      expect(result.current.pagination.perPage).toBe(24);\n      expect(result.current.filters).toEqual({});\n    });\n\n    it(\"parses filters from URL on mount\", async () =&gt; {\n      const { result } = renderHook(\n        () =&gt; useFilterState({\n          artifactType: \"scene\",\n          initialSort: \"o_counter\",\n          filterOptions: [\n            { key: \"favorite\", type: \"checkbox\" },\n          ],\n        }),\n        { wrapper: createWrapper([\"/?favorite=true&amp;sort=rating&amp;page=2\"]) }\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.filters.favorite).toBe(true);\n      expect(result.current.sort.field).toBe(\"rating\");\n      expect(result.current.pagination.page).toBe(2);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: FAIL with \"Cannot find module '../useFilterState.js'\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/hooks/useFilterState.js\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport { apiGet } from \"../services/api.js\";\nimport { buildSearchParams, parseSearchParams } from \"../utils/urlParams.js\";\n\n/**\n * High-level hook for filter state management with URL sync and presets.\n */\nexport const useFilterState = ({\n  artifactType = \"scene\",\n  context,\n  initialSort = \"o_counter\",\n  permanentFilters = {},\n  filterOptions = [],\n  syncToUrl = true,\n} = {}) =&gt; {\n  const effectiveContext = context || artifactType;\n  const [searchParams, setSearchParams] = useSearchParams();\n  const initializedRef = useRef(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [isLoadingPresets, setIsLoadingPresets] = useState(true);\n\n  // State\n  const [filters, setFiltersState] = useState({});\n  const [sort, setSortState] = useState({ field: initialSort, direction: \"DESC\" });\n  const [pagination, setPaginationState] = useState({ page: 1, perPage: 24 });\n  const [searchText, setSearchTextState] = useState(\"\");\n\n  // Initialize on mount\n  useEffect(() =&gt; {\n    if (initializedRef.current) return;\n    initializedRef.current = true;\n\n    const initialize = async () =&gt; {\n      try {\n        // Check if URL has filter params (not just page/per_page)\n        let hasFilterParams = false;\n        for (const [key] of searchParams.entries()) {\n          if (key !== \"page\" &amp;&amp; key !== \"per_page\") {\n            hasFilterParams = true;\n            break;\n          }\n        }\n\n        // Load presets\n        const [presetsRes, defaultsRes] = await Promise.all([\n          apiGet(\"/user/filter-presets\"),\n          apiGet(\"/user/default-presets\"),\n        ]);\n\n        const allPresets = presetsRes?.presets || {};\n        const defaults = defaultsRes?.defaults || {};\n        const defaultPresetId = defaults[effectiveContext];\n\n        const presetArtifactType = effectiveContext.startsWith(\"scene_\")\n          ? \"scene\"\n          : effectiveContext;\n        const presets = allPresets[presetArtifactType] || [];\n        const defaultPreset = presets.find((p) =&gt; p.id === defaultPresetId);\n\n        // Parse URL params\n        const urlState = parseSearchParams(searchParams, filterOptions, {\n          sortField: initialSort,\n          sortDirection: \"DESC\",\n          filters: { ...permanentFilters },\n        });\n\n        let finalState;\n\n        if (hasFilterParams) {\n          // URL has filter params: use preset SORT only, URL filters\n          finalState = {\n            filters: urlState.filters,\n            sortField: urlState.sortField || defaultPreset?.sort || initialSort,\n            sortDirection: urlState.sortDirection || defaultPreset?.direction || \"DESC\",\n            currentPage: urlState.currentPage,\n            perPage: urlState.perPage,\n            searchText: urlState.searchText,\n          };\n        } else if (defaultPreset) {\n          // No URL params: use full preset\n          finalState = {\n            filters: { ...permanentFilters, ...defaultPreset.filters },\n            sortField: defaultPreset.sort,\n            sortDirection: defaultPreset.direction,\n            currentPage: 1,\n            perPage: urlState.perPage,\n            searchText: \"\",\n          };\n        } else {\n          // No URL params, no preset: use defaults\n          finalState = {\n            filters: { ...permanentFilters },\n            sortField: initialSort,\n            sortDirection: \"DESC\",\n            currentPage: 1,\n            perPage: urlState.perPage,\n            searchText: \"\",\n          };\n        }\n\n        // Set state\n        setFiltersState(finalState.filters);\n        setSortState({ field: finalState.sortField, direction: finalState.sortDirection });\n        setPaginationState({ page: finalState.currentPage, perPage: finalState.perPage });\n        setSearchTextState(finalState.searchText);\n\n      } catch (err) {\n        console.error(\"Error loading presets:\", err);\n        // Fallback to URL/defaults\n        const urlState = parseSearchParams(searchParams, filterOptions, {\n          sortField: initialSort,\n          sortDirection: \"DESC\",\n          filters: { ...permanentFilters },\n        });\n        setFiltersState(urlState.filters);\n        setSortState({ field: urlState.sortField, direction: urlState.sortDirection });\n        setPaginationState({ page: urlState.currentPage, perPage: urlState.perPage });\n        setSearchTextState(urlState.searchText);\n      } finally {\n        setIsLoadingPresets(false);\n        setIsInitialized(true);\n      }\n    };\n\n    initialize();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    filters,\n    sort,\n    pagination,\n    searchText,\n    isInitialized,\n    isLoadingPresets,\n    // Actions (placeholders for now)\n    setFilter: () =&gt; {},\n    setFilters: () =&gt; {},\n    removeFilter: () =&gt; {},\n    clearFilters: () =&gt; {},\n    setSort: () =&gt; {},\n    setPage: () =&gt; {},\n    setPerPage: () =&gt; {},\n    setSearchText: () =&gt; {},\n    loadPreset: () =&gt; {},\n  };\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useFilterState.js client/src/hooks/__tests__/useFilterState.test.js\ngit commit -m \"feat: add useFilterState hook with initialization and preset loading\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-5-add-preset-sort-only-logic","title":"Task 5: Add Preset Sort-Only Logic","text":"<p>Files: - Modify: <code>client/src/hooks/__tests__/useFilterState.test.js</code></p> <p>Step 1: Write the failing test for sort-only preset behavior</p> <p>Add to <code>useFilterState.test.js</code>:</p> <pre><code>describe(\"preset handling\", () =&gt; {\n  it(\"applies full preset (sort + filters) when URL has no filter params\", async () =&gt; {\n    apiGet.mockImplementation((url) =&gt; {\n      if (url === \"/user/filter-presets\") {\n        return Promise.resolve({\n          presets: {\n            scene: [{ id: \"preset-1\", sort: \"rating\", direction: \"ASC\", filters: { favorite: true } }],\n          },\n        });\n      }\n      if (url === \"/user/default-presets\") {\n        return Promise.resolve({ defaults: { scene: \"preset-1\" } });\n      }\n    });\n\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"scene\",\n        initialSort: \"o_counter\",\n        filterOptions: [{ key: \"favorite\", type: \"checkbox\" }],\n      }),\n      { wrapper: createWrapper([\"/\"]) } // No URL params\n    );\n\n    await waitFor(() =&gt; {\n      expect(result.current.isInitialized).toBe(true);\n    });\n\n    // Should have preset sort AND filters\n    expect(result.current.sort.field).toBe(\"rating\");\n    expect(result.current.sort.direction).toBe(\"ASC\");\n    expect(result.current.filters.favorite).toBe(true);\n  });\n\n  it(\"applies preset sort ONLY when URL has filter params\", async () =&gt; {\n    apiGet.mockImplementation((url) =&gt; {\n      if (url === \"/user/filter-presets\") {\n        return Promise.resolve({\n          presets: {\n            performer: [{ id: \"preset-1\", sort: \"rating\", direction: \"ASC\", filters: { favorite: true } }],\n          },\n        });\n      }\n      if (url === \"/user/default-presets\") {\n        return Promise.resolve({ defaults: { performer: \"preset-1\" } });\n      }\n    });\n\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"performer\",\n        initialSort: \"o_counter\",\n        filterOptions: [\n          { key: \"favorite\", type: \"checkbox\" },\n          { key: \"sceneId\", type: \"searchable-select\" },\n        ],\n      }),\n      { wrapper: createWrapper([\"/?sceneId=123\"]) } // Has filter params\n    );\n\n    await waitFor(() =&gt; {\n      expect(result.current.isInitialized).toBe(true);\n    });\n\n    // Should have preset SORT only\n    expect(result.current.sort.field).toBe(\"rating\");\n    expect(result.current.sort.direction).toBe(\"ASC\");\n    // Should NOT have preset filters - only URL filter\n    expect(result.current.filters.favorite).toBeUndefined();\n    expect(result.current.filters.sceneId).toBe(\"123\");\n  });\n\n  it(\"URL sort takes precedence over preset sort\", async () =&gt; {\n    apiGet.mockImplementation((url) =&gt; {\n      if (url === \"/user/filter-presets\") {\n        return Promise.resolve({\n          presets: {\n            scene: [{ id: \"preset-1\", sort: \"rating\", direction: \"ASC\", filters: {} }],\n          },\n        });\n      }\n      if (url === \"/user/default-presets\") {\n        return Promise.resolve({ defaults: { scene: \"preset-1\" } });\n      }\n    });\n\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"scene\",\n        initialSort: \"o_counter\",\n        filterOptions: [],\n      }),\n      { wrapper: createWrapper([\"/?sort=date&amp;dir=DESC\"]) }\n    );\n\n    await waitFor(() =&gt; {\n      expect(result.current.isInitialized).toBe(true);\n    });\n\n    // URL sort wins over preset\n    expect(result.current.sort.field).toBe(\"date\");\n    expect(result.current.sort.direction).toBe(\"DESC\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify behavior</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: Tests should pass (implementation already handles this)</p> <p>Step 3: Commit (tests only)</p> <pre><code>git add client/src/hooks/__tests__/useFilterState.test.js\ngit commit -m \"test: add preset sort-only behavior tests\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-6-add-action-methods-with-url-sync","title":"Task 6: Add Action Methods with URL Sync","text":"<p>Files: - Modify: <code>client/src/hooks/useFilterState.js</code> - Modify: <code>client/src/hooks/__tests__/useFilterState.test.js</code></p> <p>Step 1: Write failing tests for actions</p> <p>Add to <code>useFilterState.test.js</code>:</p> <pre><code>describe(\"actions\", () =&gt; {\n  it(\"setPage updates pagination and pushes to history\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({ artifactType: \"scene\", filterOptions: [] }),\n      { wrapper: createWrapper([\"/\"]) }\n    );\n\n    await waitFor(() =&gt; expect(result.current.isInitialized).toBe(true));\n\n    act(() =&gt; {\n      result.current.setPage(3);\n    });\n\n    expect(result.current.pagination.page).toBe(3);\n  });\n\n  it(\"setSort updates sort and pushes to history\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({ artifactType: \"scene\", filterOptions: [] }),\n      { wrapper: createWrapper([\"/\"]) }\n    );\n\n    await waitFor(() =&gt; expect(result.current.isInitialized).toBe(true));\n\n    act(() =&gt; {\n      result.current.setSort(\"rating\", \"ASC\");\n    });\n\n    expect(result.current.sort.field).toBe(\"rating\");\n    expect(result.current.sort.direction).toBe(\"ASC\");\n  });\n\n  it(\"setFilter updates filters and resets page to 1\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"scene\",\n        filterOptions: [{ key: \"favorite\", type: \"checkbox\" }],\n      }),\n      { wrapper: createWrapper([\"/?page=3\"]) }\n    );\n\n    await waitFor(() =&gt; expect(result.current.isInitialized).toBe(true));\n\n    act(() =&gt; {\n      result.current.setFilter(\"favorite\", true);\n    });\n\n    expect(result.current.filters.favorite).toBe(true);\n    expect(result.current.pagination.page).toBe(1); // Reset to page 1\n  });\n\n  it(\"removeFilter removes filter and resets page to 1\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"scene\",\n        filterOptions: [{ key: \"favorite\", type: \"checkbox\" }],\n      }),\n      { wrapper: createWrapper([\"/?favorite=true&amp;page=3\"]) }\n    );\n\n    await waitFor(() =&gt; expect(result.current.isInitialized).toBe(true));\n\n    act(() =&gt; {\n      result.current.removeFilter(\"favorite\");\n    });\n\n    expect(result.current.filters.favorite).toBeUndefined();\n    expect(result.current.pagination.page).toBe(1);\n  });\n\n  it(\"clearFilters resets all filters but keeps permanent filters\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({\n        artifactType: \"scene\",\n        permanentFilters: { studioId: \"456\" },\n        filterOptions: [\n          { key: \"favorite\", type: \"checkbox\" },\n          { key: \"studioId\", type: \"searchable-select\" },\n        ],\n      }),\n      { wrapper: createWrapper([\"/?favorite=true\"]) }\n    );\n\n    await waitFor(() =&gt; expect(result.current.isInitialized).toBe(true));\n\n    act(() =&gt; {\n      result.current.clearFilters();\n    });\n\n    expect(result.current.filters.favorite).toBeUndefined();\n    expect(result.current.filters.studioId).toBe(\"456\"); // Permanent kept\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: FAIL - actions don't update state</p> <p>Step 3: Implement action methods</p> <p>Update <code>useFilterState.js</code> - replace placeholder actions:</p> <pre><code>// Inside useFilterState, after state declarations\n\n// URL sync helper - writes to URL without reading back\nconst syncToUrlParams = useCallback((state, options = {}) =&gt; {\n  if (!syncToUrl || !isInitialized) return;\n\n  const { replace = false } = options;\n  const params = buildSearchParams({\n    searchText: state.searchText,\n    sortField: state.sort.field,\n    sortDirection: state.sort.direction,\n    currentPage: state.pagination.page,\n    perPage: state.pagination.perPage,\n    filters: state.filters,\n    filterOptions,\n  });\n\n  setSearchParams(params, { replace });\n}, [syncToUrl, isInitialized, filterOptions, setSearchParams]);\n\n// Actions\nconst setPage = useCallback((page) =&gt; {\n  setPaginationState((prev) =&gt; ({ ...prev, page }));\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination: { ...pagination, page },\n    searchText,\n  });\n}, [filters, sort, pagination, searchText, syncToUrlParams]);\n\nconst setPerPage = useCallback((perPage) =&gt; {\n  setPaginationState({ page: 1, perPage });\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination: { page: 1, perPage },\n    searchText,\n  });\n}, [filters, sort, searchText, syncToUrlParams]);\n\nconst setSort = useCallback((field, direction) =&gt; {\n  const newDirection = direction || (sort.field === field &amp;&amp; sort.direction === \"DESC\" ? \"ASC\" : \"DESC\");\n  setSortState({ field, direction: newDirection });\n  syncToUrlParams({\n    filters,\n    sort: { field, direction: newDirection },\n    pagination,\n    searchText,\n  });\n}, [filters, sort, pagination, searchText, syncToUrlParams]);\n\nconst setFilter = useCallback((key, value) =&gt; {\n  const newFilters = { ...filters, [key]: value };\n  setFiltersState(newFilters);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters: newFilters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText,\n  });\n}, [filters, sort, pagination, searchText, syncToUrlParams]);\n\nconst setFilters = useCallback((newFilters) =&gt; {\n  setFiltersState(newFilters);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters: newFilters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText,\n  });\n}, [sort, pagination, searchText, syncToUrlParams]);\n\nconst removeFilter = useCallback((key) =&gt; {\n  const newFilters = { ...filters };\n  delete newFilters[key];\n  // Re-apply permanent filters\n  Object.assign(newFilters, permanentFilters);\n  setFiltersState(newFilters);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters: newFilters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText,\n  });\n}, [filters, permanentFilters, sort, pagination, searchText, syncToUrlParams]);\n\nconst clearFilters = useCallback(() =&gt; {\n  const newFilters = { ...permanentFilters };\n  setFiltersState(newFilters);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters: newFilters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText,\n  });\n}, [permanentFilters, sort, pagination, searchText, syncToUrlParams]);\n\nconst setSearchText = useCallback((text) =&gt; {\n  setSearchTextState(text);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  // Search text uses replace to avoid history pollution\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination: { ...pagination, page: 1 },\n    searchText: text,\n  }, { replace: true });\n}, [filters, sort, pagination, syncToUrlParams]);\n\nconst loadPreset = useCallback((preset) =&gt; {\n  const newFilters = { ...permanentFilters, ...preset.filters };\n  setFiltersState(newFilters);\n  setSortState({ field: preset.sort, direction: preset.direction });\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n  syncToUrlParams({\n    filters: newFilters,\n    sort: { field: preset.sort, direction: preset.direction },\n    pagination: { ...pagination, page: 1 },\n    searchText,\n  });\n}, [permanentFilters, pagination, searchText, syncToUrlParams]);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useFilterState.js client/src/hooks/__tests__/useFilterState.test.js\ngit commit -m \"feat: add action methods to useFilterState with URL sync\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-7-add-search-text-debounce","title":"Task 7: Add Search Text Debounce","text":"<p>Files: - Modify: <code>client/src/hooks/useFilterState.js</code> - Modify: <code>client/src/hooks/__tests__/useFilterState.test.js</code></p> <p>Step 1: Write failing test for debounce</p> <p>Add to <code>useFilterState.test.js</code>:</p> <pre><code>describe(\"search text debounce\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.useFakeTimers();\n  });\n\n  afterEach(() =&gt; {\n    vi.useRealTimers();\n  });\n\n  it(\"debounces search text URL updates by 500ms\", async () =&gt; {\n    const { result } = renderHook(\n      () =&gt; useFilterState({ artifactType: \"scene\", filterOptions: [] }),\n      { wrapper: createWrapper([\"/\"]) }\n    );\n\n    // Wait for initialization\n    await act(async () =&gt; {\n      await vi.runAllTimersAsync();\n    });\n\n    // Type quickly\n    act(() =&gt; {\n      result.current.setSearchText(\"a\");\n    });\n    act(() =&gt; {\n      result.current.setSearchText(\"ab\");\n    });\n    act(() =&gt; {\n      result.current.setSearchText(\"abc\");\n    });\n\n    // State updates immediately\n    expect(result.current.searchText).toBe(\"abc\");\n\n    // Advance 500ms\n    await act(async () =&gt; {\n      await vi.advanceTimersByTimeAsync(500);\n    });\n\n    // URL should now be updated (verified by state consistency)\n    expect(result.current.searchText).toBe(\"abc\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify current behavior</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: May pass or fail depending on implementation</p> <p>Step 3: Implement debounce</p> <p>Update <code>setSearchText</code> in <code>useFilterState.js</code>:</p> <pre><code>// Add debounce ref at top of hook\nconst searchDebounceRef = useRef(null);\n\n// Update setSearchText\nconst setSearchText = useCallback((text) =&gt; {\n  setSearchTextState(text);\n  setPaginationState((prev) =&gt; ({ ...prev, page: 1 }));\n\n  // Debounce URL update\n  if (searchDebounceRef.current) {\n    clearTimeout(searchDebounceRef.current);\n  }\n\n  searchDebounceRef.current = setTimeout(() =&gt; {\n    syncToUrlParams({\n      filters,\n      sort,\n      pagination: { ...pagination, page: 1 },\n      searchText: text,\n    }, { replace: true });\n  }, 500);\n}, [filters, sort, pagination, syncToUrlParams]);\n\n// Add cleanup effect\nuseEffect(() =&gt; {\n  return () =&gt; {\n    if (searchDebounceRef.current) {\n      clearTimeout(searchDebounceRef.current);\n    }\n  };\n}, []);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npx vitest run src/hooks/__tests__/useFilterState.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useFilterState.js client/src/hooks/__tests__/useFilterState.test.js\ngit commit -m \"feat: add 500ms debounce to search text URL updates\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-8-export-hooks-from-index","title":"Task 8: Export Hooks from Index","text":"<p>Files: - Modify: <code>client/src/hooks/index.js</code> (create if doesn't exist)</p> <p>Step 1: Check if index exists</p> <p>Run: <code>ls client/src/hooks/index.js 2&gt;/dev/null || echo \"needs creation\"</code></p> <p>Step 2: Create or update index file</p> <pre><code>// client/src/hooks/index.js\nexport { useUrlState } from \"./useUrlState.js\";\nexport { useFilterState } from \"./useFilterState.js\";\n// ... other existing exports\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/index.js\ngit commit -m \"feat: export URL state hooks from index\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-9-integration-test-manual-verification","title":"Task 9: Integration Test - Manual Verification","text":"<p>Files: - No code changes, manual testing</p> <p>Step 1: Start dev server</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code></p> <p>Step 2: Manual test checklist</p> <p>Open browser and test:</p> <ol> <li>Back button with pagination</li> <li>Navigate to <code>/scenes</code></li> <li>Go to page 3</li> <li>Click back button</li> <li> <p>Expected: Returns to page 1 (or previous page)</p> </li> <li> <p>Indicator navigation with preset</p> </li> <li>Create a default preset for performers with <code>favorite=true</code> filter</li> <li>Go to a scene with performers</li> <li>Click the performer count indicator</li> <li>Expected: Shows performers filtered by that scene only, NOT favorite filter</li> <li> <p>Expected: Sort matches your preset preference</p> </li> <li> <p>Search text history</p> </li> <li>Navigate to <code>/scenes</code></li> <li>Type \"test\" in search</li> <li>Type \"testing\" in search</li> <li>Click back button</li> <li>Expected: Does NOT go through each keystroke, goes to previous page state</li> </ol> <p>Step 3: Document results</p> <p>Create test results in commit message or PR description.</p>"},{"location":"plans/2026-01-08-url-state-management-implementation/#task-10-migrate-searchcontrols-to-usefilterstate","title":"Task 10: Migrate SearchControls to useFilterState","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>This is a larger refactor - break into sub-steps:</p> <p>Step 1: Import the new hook</p> <p>At top of <code>SearchControls.jsx</code>:</p> <pre><code>import { useFilterState } from \"../../hooks/useFilterState.js\";\n</code></pre> <p>Step 2: Replace state management</p> <p>Replace the inline state (<code>useState</code> for filters, sort, pagination, searchText) and the initialization <code>useEffect</code> with <code>useFilterState</code>:</p> <pre><code>const {\n  filters,\n  sort,\n  pagination,\n  searchText,\n  isInitialized,\n  isLoadingPresets,\n  setFilter,\n  setFilters,\n  removeFilter,\n  clearFilters,\n  setSort,\n  setPage,\n  setPerPage,\n  setSearchText,\n  loadPreset,\n} = useFilterState({\n  artifactType,\n  context: effectiveContext,\n  initialSort,\n  permanentFilters,\n  filterOptions,\n  syncToUrl,\n});\n</code></pre> <p>Step 3: Update handler functions</p> <p>Replace inline handlers with the hook's action methods:</p> <ul> <li><code>handlePageChange</code> \u2192 <code>setPage</code></li> <li><code>handleSortChange</code> \u2192 <code>setSort</code></li> <li><code>handleFilterChange</code> \u2192 <code>setFilter</code></li> <li><code>handleRemoveFilter</code> \u2192 <code>removeFilter</code></li> <li><code>clearFilters</code> \u2192 <code>clearFilters</code></li> <li><code>handleChangeSearchText</code> \u2192 <code>setSearchText</code></li> <li><code>handleLoadPreset</code> \u2192 <code>loadPreset</code></li> </ul> <p>Step 4: Remove deprecated code</p> <p>Remove: - <code>useState</code> for filters, sort, pagination, searchText - <code>needsDefaultPreset</code> memo - Initialization <code>useEffect</code> - URL sync <code>useEffect</code> - <code>urlState</code> memo</p> <p>Step 5: Test and commit</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code> Test manually that everything still works.</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"refactor: migrate SearchControls to useFilterState hook\"\n</code></pre>"},{"location":"plans/2026-01-08-url-state-management-implementation/#summary","title":"Summary","text":"<p>This plan creates: 1. <code>useUrlState</code> - Low-level URL sync with push/replace control 2. <code>useFilterState</code> - High-level filter management with presets 3. Proper history behavior (push for user actions, replace for search text) 4. Preset sort-only logic when URL has filter params 5. 500ms search text debounce</p> <p>After implementation: - Back button will restore previous filter/page/sort state - Indicator navigation won't be polluted by default preset filters - Search typing won't pollute browser history</p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/","title":"Auth Session Improvements Design","text":""},{"location":"plans/2026-01-09-auth-session-improvements-design/#overview","title":"Overview","text":"<p>Improve the authentication experience with two key features: 1. Sliding session expiry - Sessions refresh while actively browsing, only expiring after 4 hours of inactivity 2. Redirect preservation - When redirected to login (session expired or direct navigation), return to the original intended URL after successful login</p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#current-state","title":"Current State","text":"<ul> <li>JWT tokens with 24-hour fixed expiry</li> <li>No token refresh mechanism - users must re-login after 24 hours regardless of activity</li> <li>Login always redirects to <code>/</code> - no preservation of intended destination</li> <li>No global handling of 401/403 responses - auth failures not gracefully handled mid-session</li> </ul>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#design","title":"Design","text":""},{"location":"plans/2026-01-09-auth-session-improvements-design/#1-session-refresh-on-api-activity","title":"1. Session Refresh on API Activity","text":"<p>Approach: Server issues a fresh JWT token on authenticated API requests when the current token is aging.</p> <p>Server changes in <code>server/middleware/auth.ts</code>:</p> <p>In the <code>authenticateToken</code> middleware, after successfully verifying the token: 1. Decode the token to get its <code>iat</code> (issued-at) timestamp 2. If token was issued more than 20 hours ago, generate a new token 3. Set the new token in the response cookie with same settings as login</p> <p>Why 20 hours threshold: With 24-hour token expiry, refreshing at 20 hours means: - Active users get seamless session continuation - 4-hour inactivity window before session truly expires - Minimizes unnecessary cookie writes (not every request)</p> <p>Constants: <pre><code>const TOKEN_EXPIRY_HOURS = 24;\nconst TOKEN_REFRESH_THRESHOLD_HOURS = 20; // Refresh if older than this\n</code></pre></p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#2-client-side-auth-failure-handling","title":"2. Client-Side Auth Failure Handling","text":"<p>Approach: Global API interceptor catches 401/403 and redirects to login with URL preservation.</p> <p>Changes in <code>client/src/services/api.js</code>:</p> <p>Add response handling that: 1. Detects 401 or 403 status codes 2. Excludes auth endpoints (<code>/api/auth/login</code>, <code>/api/auth/check</code>) from redirect logic 3. Saves current URL (<code>pathname + search</code>) to sessionStorage 4. Redirects to <code>/login</code> 5. Uses a flag to prevent multiple simultaneous redirects</p> <p>Why sessionStorage: Cleared on tab close, so stale redirects don't persist. Survives page reload during redirect.</p> <p>Storage key: <code>peek_auth_redirect</code></p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#3-protectedroute-url-preservation","title":"3. ProtectedRoute URL Preservation","text":"<p>Changes in <code>client/src/components/guards/RouteGuards.jsx</code>:</p> <p>When <code>ProtectedRoute</code> redirects an unauthenticated user to <code>/login</code>: 1. Save <code>location.pathname + location.search</code> to sessionStorage 2. Then redirect to <code>/login</code></p> <p>Why here too: Catches deep links and bookmarks when user is already logged out.</p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#4-login-redirect-handling","title":"4. Login Redirect Handling","text":"<p>Changes in <code>client/src/components/pages/Login.jsx</code>:</p> <p>On successful login: 1. Check sessionStorage for <code>peek_auth_redirect</code> 2. If present: clear it, navigate to that URL 3. If absent: navigate to <code>/</code> (default)</p> <p>Changes in <code>client/src/App.jsx</code>:</p> <p>Remove the hard-coded <code>window.location.href = \"/\"</code> from <code>onLoginSuccess</code>. Let Login component handle navigation.</p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#files-to-modify","title":"Files to Modify","text":"File Changes <code>server/middleware/auth.ts</code> Add token refresh logic - check age, issue new cookie if &gt; 20 hours old <code>client/src/services/api.js</code> Add 401/403 interceptor with redirect-to-login <code>client/src/components/guards/RouteGuards.jsx</code> Save intended URL to sessionStorage before login redirect <code>client/src/components/pages/Login.jsx</code> Read redirect target, navigate there on success <code>client/src/App.jsx</code> Remove hard-coded <code>/</code> redirect from onLoginSuccess"},{"location":"plans/2026-01-09-auth-session-improvements-design/#constants","title":"Constants","text":"<p>Server: - <code>TOKEN_EXPIRY_HOURS = 24</code> - <code>TOKEN_REFRESH_THRESHOLD_HOURS = 20</code></p> <p>Client: - <code>REDIRECT_STORAGE_KEY = \"peek_auth_redirect\"</code></p>"},{"location":"plans/2026-01-09-auth-session-improvements-design/#testing","title":"Testing","text":"<p>Unit tests: - Token refresh logic: verify new token issued when token age &gt; 20 hours - Token refresh logic: verify no new token when token age &lt; 20 hours</p> <p>Integration tests: - 401 response from protected endpoint triggers redirect - Redirect URL preserved in sessionStorage - Login success navigates to preserved URL - Login without preserved URL navigates to <code>/</code></p> <p>Manual testing: - Let session expire during active browsing - Verify redirect to login preserves current URL - Verify successful login returns to original page with query params intact</p>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/","title":"Contextual Back Navigation","text":""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#problem-statement","title":"Problem Statement","text":"<p>Back buttons on detail pages have inconsistent behavior:</p> <ol> <li>Inconsistent navigation targets - Some use <code>navigate(-1)</code>, others use <code>location.state?.referrerUrl</code>, others hardcode URLs</li> <li>Generic button text - All say \"Back to {EntityType}\" regardless of where user came from</li> <li>No context preservation - User can't tell if they're returning to a filtered list, another detail page, or the base list</li> </ol>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#current-state","title":"Current State","text":"Page Navigation Target Button Text Scene <code>referrerUrl</code> OR <code>navigate(-1)</code> \"Back to Scenes\" PerformerDetail <code>referrerUrl</code> OR <code>/performers</code> \"Back to Performers\" StudioDetail <code>referrerUrl</code> OR <code>/studios</code> \"Back to Studios\" TagDetail <code>referrerUrl</code> OR <code>/tags</code> \"Back to Tags\" GalleryDetail <code>referrerUrl</code> OR <code>/galleries</code> \"Back to Galleries\" GroupDetail <code>referrerUrl</code> OR <code>/collections</code> \"Back to Collections\" PlaylistDetail <code>/playlists</code> (hardcoded) \"Back to Playlists\" HiddenItemsPage <code>/settings?section=user&amp;tab=content</code> \"Back to Settings\""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#proposed-solution","title":"Proposed Solution","text":""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#core-insight","title":"Core Insight","text":"<p>With the recent URL state management refactor (#266), <code>navigate(-1)</code> is now always correct: - If user came from a filtered list, those filters are in the URL - back restores them - If user came from a list with default preset (no URL params), back goes to base URL which re-applies preset - If user came from another detail page, back goes there</p>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#design","title":"Design","text":"<ol> <li>Standardize all back buttons to <code>navigate(-1)</code></li> <li>Store page title in navigation state when navigating away</li> <li>Back buttons read from state to show contextual text</li> <li>Graceful fallback to \"Back\" when no state available</li> </ol>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#implementation","title":"Implementation","text":""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#1-enhance-usepagetitle-to-expose-current-title","title":"1. Enhance usePageTitle to expose current title","text":"<pre><code>// Current\nexport const usePageTitle = (title = \"\") =&gt; {\n  useEffect(() =&gt; {\n    document.title = title ? `${title} - Peek` : \"Peek\";\n  }, [title]);\n};\n\n// Proposed - also store in ref for navigation to access\nexport const usePageTitle = (title = \"\") =&gt; {\n  const titleRef = useRef(title);\n\n  useEffect(() =&gt; {\n    titleRef.current = title;\n    document.title = title ? `${title} - Peek` : \"Peek\";\n  }, [title]);\n\n  return { currentTitle: titleRef };\n};\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#2-create-usenavigationstate-hook","title":"2. Create useNavigationState hook","text":"<pre><code>export const useNavigationState = () =&gt; {\n  const location = useLocation();\n  const navigate = useNavigate();\n\n  // Get the title of the page we came from\n  const fromPageTitle = location.state?.fromPageTitle;\n\n  // Navigate with current page title in state\n  const navigateWithTitle = useCallback((to, options = {}) =&gt; {\n    const currentTitle = getCurrentPageTitle(); // Read from document.title or context\n    navigate(to, {\n      ...options,\n      state: {\n        ...options.state,\n        fromPageTitle: currentTitle,\n      },\n    });\n  }, [navigate]);\n\n  // Go back with context\n  const goBack = useCallback(() =&gt; {\n    navigate(-1);\n  }, [navigate]);\n\n  // Generate back button text\n  const backButtonText = fromPageTitle\n    ? `Back to ${fromPageTitle}`\n    : \"Back\";\n\n  return {\n    fromPageTitle,\n    backButtonText,\n    navigateWithTitle,\n    goBack,\n  };\n};\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#3-update-navigation-calls-site-wide","title":"3. Update navigation calls site-wide","text":"<p>All <code>navigate()</code> calls that go to pages with back buttons need to use <code>navigateWithTitle()</code>:</p> <pre><code>// Before\nnavigate(`/performer/${id}`);\n\n// After\nnavigateWithTitle(`/performer/${id}`);\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#4-update-back-buttons","title":"4. Update back buttons","text":"<pre><code>// Before\n&lt;Button onClick={() =&gt; navigate(location.state?.referrerUrl || \"/performers\")}&gt;\n  Back to Performers\n&lt;/Button&gt;\n\n// After\nconst { goBack, backButtonText } = useNavigationState();\n&lt;Button onClick={goBack}&gt;\n  {backButtonText}\n&lt;/Button&gt;\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#page-titles-for-consistency","title":"Page Titles (for consistency)","text":"Page Type usePageTitle Value Back Button Would Show List Pages Home <code>\"Home\"</code> \"Back to Home\" Scenes <code>\"Scenes\"</code> \"Back to Scenes\" Performers <code>\"Performers\"</code> \"Back to Performers\" Tags <code>\"Tags\"</code> \"Back to Tags\" Studios <code>\"Studios\"</code> \"Back to Studios\" Galleries <code>\"Galleries\"</code> \"Back to Galleries\" Images <code>\"Images\"</code> \"Back to Images\" Groups <code>\"Collections\"</code> \"Back to Collections\" Playlists <code>\"Playlists\"</code> \"Back to Playlists\" Watch History <code>\"Watch History\"</code> \"Back to Watch History\" Recommended <code>\"Recommended\"</code> \"Back to Recommended\" Settings <code>\"Settings\"</code> \"Back to Settings\" Detail Pages Scene <code>displayTitle</code> (title OR filename OR \"Scene\") \"Back to {Scene Title}\" Performer <code>performer?.name \\|\\| \"Performer\"</code> \"Back to {Performer Name}\" Tag <code>tag?.name \\|\\| \"Tag\"</code> \"Back to {Tag Name}\" Studio <code>studio?.name \\|\\| \"Studio\"</code> \"Back to {Studio Name}\" Gallery <code>galleryTitle(gallery)</code> \"Back to {Gallery Title}\" Group <code>group?.name \\|\\| \"Collection\"</code> \"Back to {Group Name}\" Playlist <code>playlist?.name \\|\\| \"Playlist\"</code> \"Back to {Playlist Name}\""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#changes-required","title":"Changes Required","text":"<ol> <li>Update Home page - Change <code>usePageTitle()</code> to <code>usePageTitle(\"Home\")</code></li> <li>Create useNavigationState hook - New hook in <code>client/src/hooks/</code></li> <li>Update all navigate() calls - Use <code>navigateWithTitle()</code> for detail page navigation</li> <li>Update all back buttons - Use <code>goBack()</code> and <code>backButtonText</code></li> <li>Remove referrerUrl logic - No longer needed</li> </ol>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#migration-scope","title":"Migration Scope","text":"<p>Files requiring changes:</p> <p>Navigation sources (need navigateWithTitle): - <code>components/cards/*.jsx</code> - Card clicks to detail pages - <code>components/pages/*.jsx</code> - List pages with onItemSelect - <code>components/ui/SceneCard.jsx</code> - Indicator navigations - <code>components/scene-search/SceneSearch.jsx</code> - Scene navigation - <code>components/ui/ContinueWatchingCarousel.jsx</code> - Scene navigation - <code>components/ui/RecommendedSidebar.jsx</code> - Scene navigation</p> <p>Back buttons (need useNavigationState): - <code>components/pages/Scene.jsx</code> - <code>components/pages/PerformerDetail.jsx</code> - <code>components/pages/StudioDetail.jsx</code> - <code>components/pages/TagDetail.jsx</code> - <code>components/pages/GalleryDetail.jsx</code> - <code>components/pages/GroupDetail.jsx</code> - <code>components/pages/PlaylistDetail.jsx</code> - <code>components/pages/HiddenItemsPage.jsx</code></p>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#known-issue-title-fallback-inconsistency","title":"Known Issue: Title Fallback Inconsistency","text":"<p>Finding: Title/name fallback logic is handled differently across entity types:</p> Entity Fallback Location Fallback Logic Scene Frontend (<code>Scene.jsx:36</code>) <code>title \\|\\| files[0].basename \\|\\| \"Scene\"</code> Gallery Frontend (<code>utils/gallery.js</code>) <code>title \\|\\| files[0].basename \\|\\| folder.path \\|\\| \"Untitled Gallery\"</code> Performer Frontend (<code>PerformerDetail.jsx:41</code>) <code>name \\|\\| \"Performer\"</code> Tag Frontend (<code>TagDetail.jsx:53</code>) <code>name \\|\\| \"Tag\"</code> Studio Frontend (<code>StudioDetail.jsx:59</code>) <code>name \\|\\| \"Studio\"</code> Group Frontend (<code>GroupDetail.jsx:35</code>) <code>name \\|\\| \"Collection\"</code> Playlist Frontend (<code>PlaylistDetail.jsx:51</code>) <code>name \\|\\| \"Playlist\"</code> Image Server (<code>ImageQueryBuilder.ts:347</code>) <code>COALESCE(title, filePath)</code> for sorting <p>Recommendation: This inconsistency should be addressed in a follow-up branch. Options: 1. Move all fallback logic to the server (API always returns display-ready titles) 2. Create a shared frontend utility for each entity type (like <code>galleryTitle</code>) 3. Accept current state as intentional (API returns raw data, frontend formats)</p> <p>For this feature, we use whatever <code>usePageTitle</code> receives, which already handles fallbacks.</p>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#testing","title":"Testing","text":""},{"location":"plans/2026-01-09-contextual-back-navigation-design/#manual-test-scenarios","title":"Manual Test Scenarios","text":"<ol> <li>Navigate Scenes \u2192 Scene detail \u2192 Back button shows \"Back to Scenes\"</li> <li>Navigate Performer detail \u2192 Scene detail \u2192 Back button shows \"Back to {Performer Name}\"</li> <li>Navigate filtered list (/tags?favorite=true) \u2192 Tag detail \u2192 Back restores filters</li> <li>Deep link directly to detail page \u2192 Back button shows just \"Back\"</li> <li>Browser back button works identically to Back button click</li> </ol>"},{"location":"plans/2026-01-09-contextual-back-navigation-design/#unit-tests","title":"Unit Tests","text":"<ul> <li><code>useNavigationState</code> returns correct <code>backButtonText</code> with/without state</li> <li><code>navigateWithTitle</code> includes <code>fromPageTitle</code> in state</li> <li>Fallback to \"Back\" when <code>fromPageTitle</code> is missing</li> </ul>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/","title":"Contextual Back Navigation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Standardize back button navigation to use browser history with contextual \"Back to {Page Title}\" text.</p> <p>Architecture: Create a <code>useNavigationState</code> hook that reads <code>fromPageTitle</code> from location state and provides <code>goBack()</code> + <code>backButtonText</code>. Update all navigation sources to pass current page title in state. Update all back buttons to use the hook.</p> <p>Tech Stack: React, React Router v6, Vitest</p>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-1-create-usenavigationstate-hook-with-tests","title":"Task 1: Create useNavigationState Hook with Tests","text":"<p>Files: - Create: <code>client/src/hooks/useNavigationState.js</code> - Create: <code>client/src/hooks/__tests__/useNavigationState.test.jsx</code></p> <p>Step 1: Write the failing tests</p> <pre><code>// client/src/hooks/__tests__/useNavigationState.test.jsx\nimport { renderHook } from \"@testing-library/react\";\nimport { describe, it, expect } from \"vitest\";\nimport { MemoryRouter } from \"react-router-dom\";\nimport { useNavigationState } from \"../useNavigationState.js\";\n\n// Wrapper to provide router context with location state\nconst createWrapper = (initialEntries = [\"/\"], state = null) =&gt; {\n  const entries = state\n    ? [{ pathname: initialEntries[0], state }]\n    : initialEntries;\n  return ({ children }) =&gt; (\n    &lt;MemoryRouter initialEntries={entries}&gt;{children}&lt;/MemoryRouter&gt;\n  );\n};\n\ndescribe(\"useNavigationState\", () =&gt; {\n  describe(\"backButtonText\", () =&gt; {\n    it(\"returns 'Back to {title}' when fromPageTitle is present\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/performer/123\"], { fromPageTitle: \"Scenes\" }),\n      });\n\n      expect(result.current.backButtonText).toBe(\"Back to Scenes\");\n    });\n\n    it(\"returns 'Back' when fromPageTitle is missing\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/performer/123\"]),\n      });\n\n      expect(result.current.backButtonText).toBe(\"Back\");\n    });\n\n    it(\"returns 'Back' when fromPageTitle is empty string\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/performer/123\"], { fromPageTitle: \"\" }),\n      });\n\n      expect(result.current.backButtonText).toBe(\"Back\");\n    });\n\n    it(\"handles detail page names\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/scene/456\"], { fromPageTitle: \"Jane Doe\" }),\n      });\n\n      expect(result.current.backButtonText).toBe(\"Back to Jane Doe\");\n    });\n  });\n\n  describe(\"fromPageTitle\", () =&gt; {\n    it(\"exposes raw fromPageTitle from location state\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/tag/789\"], { fromPageTitle: \"Performers\" }),\n      });\n\n      expect(result.current.fromPageTitle).toBe(\"Performers\");\n    });\n\n    it(\"returns undefined when not present\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/tag/789\"]),\n      });\n\n      expect(result.current.fromPageTitle).toBeUndefined();\n    });\n  });\n\n  describe(\"goBack\", () =&gt; {\n    it(\"returns a function\", () =&gt; {\n      const { result } = renderHook(() =&gt; useNavigationState(), {\n        wrapper: createWrapper([\"/performer/123\"]),\n      });\n\n      expect(typeof result.current.goBack).toBe(\"function\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run src/hooks/__tests__/useNavigationState.test.jsx</code> Expected: FAIL with \"Cannot find module '../useNavigationState.js'\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/hooks/useNavigationState.js\nimport { useCallback } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\n/**\n * Hook for contextual back navigation.\n *\n * Reads `fromPageTitle` from location state (set by navigating pages)\n * and provides utilities for back navigation with contextual text.\n *\n * @returns {Object} { fromPageTitle, backButtonText, goBack }\n *\n * @example\n * const { goBack, backButtonText } = useNavigationState();\n * &lt;Button onClick={goBack}&gt;{backButtonText}&lt;/Button&gt;\n */\nexport const useNavigationState = () =&gt; {\n  const location = useLocation();\n  const navigate = useNavigate();\n\n  // Get the title of the page we came from\n  const fromPageTitle = location.state?.fromPageTitle;\n\n  // Generate back button text with graceful fallback\n  const backButtonText =\n    fromPageTitle &amp;&amp; fromPageTitle.trim() !== \"\"\n      ? `Back to ${fromPageTitle}`\n      : \"Back\";\n\n  // Go back using browser history\n  const goBack = useCallback(() =&gt; {\n    navigate(-1);\n  }, [navigate]);\n\n  return {\n    fromPageTitle,\n    backButtonText,\n    goBack,\n  };\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run src/hooks/__tests__/useNavigationState.test.jsx</code> Expected: PASS (all 6 tests)</p> <p>Step 5: Commit</p> <pre><code>git add client/src/hooks/useNavigationState.js client/src/hooks/__tests__/useNavigationState.test.jsx\ngit commit -m \"feat: add useNavigationState hook for contextual back navigation\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-2-update-home-page-title","title":"Task 2: Update Home Page Title","text":"<p>Files: - Modify: <code>client/src/components/pages/Home.jsx:82</code></p> <p>Step 1: Update usePageTitle call</p> <p>Change line 82 from: <pre><code>  usePageTitle(); // Sets \"Peek\"\n</code></pre></p> <p>To: <pre><code>  usePageTitle(\"Home\");\n</code></pre></p> <p>Step 2: Verify manually</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code> Check: Browser tab shows \"Home - Peek\" on home page</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/Home.jsx\ngit commit -m \"fix: set Home page title for back navigation context\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-3-update-cardcomponents-to-use-frompagetitle","title":"Task 3: Update CardComponents to Use fromPageTitle","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code></p> <p>The CardComponents use <code>referrerUrl</code> in Link state. We need to change this to <code>fromPageTitle</code>.</p> <p>Step 1: Update CardImage component</p> <p>Find the prop definition around line 74: <pre><code> * @param {string} [props.referrerUrl] - Referrer URL for navigation state\n</code></pre></p> <p>Change to: <pre><code> * @param {string} [props.fromPageTitle] - Page title for back navigation context\n</code></pre></p> <p>Find the prop destructuring around line 88: <pre><code>  referrerUrl,\n</code></pre></p> <p>Change to: <pre><code>  fromPageTitle,\n</code></pre></p> <p>Find the Link state around line 172: <pre><code>        state={{ referrerUrl }}\n</code></pre></p> <p>Change to: <pre><code>        state={{ fromPageTitle }}\n</code></pre></p> <p>Step 2: Update CardTitle component</p> <p>Find the prop definition around line 314: <pre><code> * @param {string} [props.referrerUrl] - Referrer URL for navigation state\n</code></pre></p> <p>Change to: <pre><code> * @param {string} [props.fromPageTitle] - Page title for back navigation context\n</code></pre></p> <p>Find the prop destructuring around line 323: <pre><code>  referrerUrl,\n</code></pre></p> <p>Change to: <pre><code>  fromPageTitle,\n</code></pre></p> <p>Find all Link state occurrences (lines ~356, ~388): <pre><code>      state={{ referrerUrl }}\n</code></pre></p> <p>Change each to: <pre><code>      state={{ fromPageTitle }}\n</code></pre></p> <p>Step 3: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS (no errors)</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx\ngit commit -m \"refactor: rename referrerUrl to fromPageTitle in CardComponents\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-4-update-basecard-to-use-frompagetitle","title":"Task 4: Update BaseCard to Use fromPageTitle","text":"<p>Files: - Modify: <code>client/src/components/ui/BaseCard.jsx</code></p> <p>Step 1: Update prop name</p> <p>Find around line 57: <pre><code>      referrerUrl,\n</code></pre></p> <p>Change to: <pre><code>      fromPageTitle,\n</code></pre></p> <p>Find CardImage usage around line 116: <pre><code>          referrerUrl={referrerUrl}\n</code></pre></p> <p>Change to: <pre><code>          fromPageTitle={fromPageTitle}\n</code></pre></p> <p>Find CardTitle usage around line 131: <pre><code>          referrerUrl={referrerUrl}\n</code></pre></p> <p>Change to: <pre><code>          fromPageTitle={fromPageTitle}\n</code></pre></p> <p>Step 2: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/BaseCard.jsx\ngit commit -m \"refactor: rename referrerUrl to fromPageTitle in BaseCard\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-5-update-all-card-components","title":"Task 5: Update All Card Components","text":"<p>Update each card component to pass <code>fromPageTitle</code> instead of <code>referrerUrl</code>.</p> <p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code> - Modify: <code>client/src/components/cards/TagCard.jsx</code> - Modify: <code>client/src/components/cards/StudioCard.jsx</code> - Modify: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/GroupCard.jsx</code> - Modify: <code>client/src/components/ui/SceneCard.jsx</code></p> <p>Step 1: Update PerformerCard.jsx</p> <p>Find around line 13: <pre><code>  ({ performer, referrerUrl, isTVMode, tabIndex, onHideSuccess, displayPreferences, ...rest }, ref) =&gt; {\n</code></pre></p> <p>Change to: <pre><code>  ({ performer, fromPageTitle, isTVMode, tabIndex, onHideSuccess, displayPreferences, ...rest }, ref) =&gt; {\n</code></pre></p> <p>Find around line 84: <pre><code>        referrerUrl={referrerUrl}\n</code></pre></p> <p>Change to: <pre><code>        fromPageTitle={fromPageTitle}\n</code></pre></p> <p>Step 2: Update TagCard.jsx</p> <p>Apply same pattern: rename <code>referrerUrl</code> prop to <code>fromPageTitle</code> in destructuring and BaseCard usage.</p> <p>Step 3: Update StudioCard.jsx</p> <p>Apply same pattern.</p> <p>Step 4: Update GalleryCard.jsx</p> <p>Apply same pattern.</p> <p>Step 5: Update GroupCard.jsx</p> <p>Apply same pattern.</p> <p>Step 6: Update SceneCard.jsx</p> <p>Apply same pattern.</p> <p>Step 7: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/cards/*.jsx client/src/components/ui/SceneCard.jsx\ngit commit -m \"refactor: rename referrerUrl to fromPageTitle in all card components\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-6-update-list-pages-to-pass-frompagetitle","title":"Task 6: Update List Pages to Pass fromPageTitle","text":"<p>Update all list pages that navigate to detail pages to pass the page title instead of referrer URL.</p> <p>Files: - Modify: <code>client/src/components/pages/Performers.jsx</code> - Modify: <code>client/src/components/pages/Tags.jsx</code> - Modify: <code>client/src/components/pages/Studios.jsx</code> - Modify: <code>client/src/components/pages/Galleries.jsx</code> - Modify: <code>client/src/components/pages/Groups.jsx</code> - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Update Performers.jsx</p> <p>Find around line 57-60: <pre><code>    onItemSelect: (performer) =&gt;\n      navigate(`/performer/${performer.id}`, {\n        state: { referrerUrl: `${location.pathname}${location.search}` },\n      }),\n</code></pre></p> <p>Change to: <pre><code>    onItemSelect: (performer) =&gt;\n      navigate(`/performer/${performer.id}`, {\n        state: { fromPageTitle: \"Performers\" },\n      }),\n</code></pre></p> <p>Step 2: Update Tags.jsx</p> <p>Find similar pattern and change: <pre><code>        state: { referrerUrl: `${location.pathname}${location.search}` },\n</code></pre> To: <pre><code>        state: { fromPageTitle: \"Tags\" },\n</code></pre></p> <p>Step 3: Update Studios.jsx</p> <p>Change to <code>fromPageTitle: \"Studios\"</code>.</p> <p>Step 4: Update Galleries.jsx</p> <p>Change to <code>fromPageTitle: \"Galleries\"</code>.</p> <p>Step 5: Update Groups.jsx</p> <p>Change to <code>fromPageTitle: \"Collections\"</code>.</p> <p>Step 6: Update Images.jsx</p> <p>Change to <code>fromPageTitle: \"Images\"</code>.</p> <p>Step 7: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/Performers.jsx client/src/components/pages/Tags.jsx client/src/components/pages/Studios.jsx client/src/components/pages/Galleries.jsx client/src/components/pages/Groups.jsx client/src/components/pages/Images.jsx\ngit commit -m \"refactor: update list pages to pass fromPageTitle instead of referrerUrl\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-7-update-scene-navigation-sources","title":"Task 7: Update Scene Navigation Sources","text":"<p>Update components that navigate to scene detail pages.</p> <p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code> - Modify: <code>client/src/components/pages/Home.jsx</code> - Modify: <code>client/src/components/ui/ContinueWatchingCarousel.jsx</code> - Modify: <code>client/src/components/ui/RecommendedSidebar.jsx</code></p> <p>Step 1: Update SceneSearch.jsx</p> <p>Find around line 76-81 where <code>navigationState</code> is built: <pre><code>    // Only capture referrerUrl if captureReferrer is true\n    if (captureReferrer) {\n      navigationState.referrerUrl = `${location.pathname}${location.search}`;\n    }\n</code></pre></p> <p>The <code>captureReferrer</code> prop is used to conditionally add referrer. We need to change this to use <code>fromPageTitle</code>. Check where SceneSearch is used to understand the context.</p> <p>This component is used from detail pages (PerformerDetail, TagDetail, etc.) and list pages (Scenes). The <code>captureReferrer</code> controls whether to track where we came from.</p> <p>We need to change this to accept a <code>fromPageTitle</code> prop instead. Update to: <pre><code>    // Only capture fromPageTitle if provided\n    if (fromPageTitle) {\n      navigationState.fromPageTitle = fromPageTitle;\n    }\n</code></pre></p> <p>Also update the prop from <code>captureReferrer</code> to <code>fromPageTitle</code> in the component signature.</p> <p>Step 2: Update Home.jsx scene navigation</p> <p>Find around line 127-130: <pre><code>    navigate(`/scene/${scene.id}`, {\n</code></pre></p> <p>Add fromPageTitle to the state object that's being passed. Should become: <pre><code>    navigate(`/scene/${scene.id}`, {\n      state: {\n        fromPageTitle: \"Home\",\n        // ... existing state\n      },\n    });\n</code></pre></p> <p>Step 3: Update ContinueWatchingCarousel.jsx</p> <p>Find the scene navigation and add <code>fromPageTitle: \"Home\"</code> or appropriate title.</p> <p>Step 4: Update RecommendedSidebar.jsx</p> <p>Find the scene navigation and add <code>fromPageTitle</code> based on context.</p> <p>Step 5: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx client/src/components/pages/Home.jsx client/src/components/ui/ContinueWatchingCarousel.jsx client/src/components/ui/RecommendedSidebar.jsx\ngit commit -m \"refactor: update scene navigation sources to pass fromPageTitle\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-8-update-scenesearch-consumers-to-pass-frompagetitle","title":"Task 8: Update SceneSearch Consumers to Pass fromPageTitle","text":"<p>Update all pages that use SceneSearch to pass the page title.</p> <p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/Scenes.jsx</code></p> <p>Step 1: Update PerformerDetail.jsx SceneSearch usage</p> <p>Find SceneSearch component usage and change <code>captureReferrer</code> to <code>fromPageTitle</code>: <pre><code>&lt;SceneSearch\n  fromPageTitle={performer?.name || \"Performer\"}\n  // ... other props\n/&gt;\n</code></pre></p> <p>Step 2: Update TagDetail.jsx</p> <pre><code>&lt;SceneSearch\n  fromPageTitle={tag?.name || \"Tag\"}\n  // ... other props\n/&gt;\n</code></pre> <p>Step 3: Update StudioDetail.jsx</p> <pre><code>&lt;SceneSearch\n  fromPageTitle={studio?.name || \"Studio\"}\n  // ... other props\n/&gt;\n</code></pre> <p>Step 4: Update GalleryDetail.jsx</p> <pre><code>&lt;SceneSearch\n  fromPageTitle={galleryTitle(gallery) || \"Gallery\"}\n  // ... other props\n/&gt;\n</code></pre> <p>Step 5: Update GroupDetail.jsx</p> <pre><code>&lt;SceneSearch\n  fromPageTitle={group?.name || \"Collection\"}\n  // ... other props\n/&gt;\n</code></pre> <p>Step 6: Update Scenes.jsx</p> <pre><code>&lt;SceneSearch\n  fromPageTitle=\"Scenes\"\n  // ... other props\n/&gt;\n</code></pre> <p>Step 7: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx client/src/components/pages/TagDetail.jsx client/src/components/pages/StudioDetail.jsx client/src/components/pages/GalleryDetail.jsx client/src/components/pages/GroupDetail.jsx client/src/components/pages/Scenes.jsx\ngit commit -m \"refactor: update SceneSearch consumers to pass fromPageTitle\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-9-update-detail-page-back-buttons","title":"Task 9: Update Detail Page Back Buttons","text":"<p>Update all detail pages to use <code>useNavigationState</code> hook.</p> <p>Files: - Modify: <code>client/src/components/pages/Scene.jsx</code> - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/PlaylistDetail.jsx</code> - Modify: <code>client/src/components/pages/HiddenItemsPage.jsx</code></p> <p>Step 1: Update Scene.jsx</p> <p>Add import: <pre><code>import { useNavigationState } from \"../../hooks/useNavigationState.js\";\n</code></pre></p> <p>In SceneContent component, add hook call: <pre><code>const { goBack, backButtonText } = useNavigationState();\n</code></pre></p> <p>Find the back button around lines 130-145: <pre><code>&lt;Button\n  onClick={() =&gt; {\n    // If we have a referrer URL with filters, navigate to it\n    // Otherwise use browser back\n    if (location.state?.referrerUrl) {\n      navigate(location.state.referrerUrl);\n    } else {\n      navigate(-1);\n    }\n  }}\n  variant=\"secondary\"\n  className=\"inline-flex items-center gap-2\"\n&gt;\n  &lt;span&gt;\u2190&lt;/span&gt;\n  &lt;span className=\"whitespace-nowrap\"&gt;Back to Scenes&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre></p> <p>Change to: <pre><code>&lt;Button\n  onClick={goBack}\n  variant=\"secondary\"\n  className=\"inline-flex items-center gap-2\"\n&gt;\n  &lt;span&gt;\u2190&lt;/span&gt;\n  &lt;span className=\"whitespace-nowrap\"&gt;{backButtonText}&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre></p> <p>Step 2: Update PerformerDetail.jsx</p> <p>Add import: <pre><code>import { useNavigationState } from \"../../hooks/useNavigationState.js\";\n</code></pre></p> <p>Add hook call in component: <pre><code>const { goBack, backButtonText } = useNavigationState();\n</code></pre></p> <p>Find the back button around lines 105-113: <pre><code>&lt;Button\n  onClick={() =&gt;\n    navigate(location.state?.referrerUrl || \"/performers\")\n  }\n  variant=\"secondary\"\n  icon={&lt;ArrowLeft size={16} className=\"sm:w-4 sm:h-4\" /&gt;}\n  title=\"Back to Performers\"\n&gt;\n  &lt;span className=\"hidden sm:inline\"&gt;Back to Performers&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre></p> <p>Change to: <pre><code>&lt;Button\n  onClick={goBack}\n  variant=\"secondary\"\n  icon={&lt;ArrowLeft size={16} className=\"sm:w-4 sm:h-4\" /&gt;}\n  title={backButtonText}\n&gt;\n  &lt;span className=\"hidden sm:inline\"&gt;{backButtonText}&lt;/span&gt;\n&lt;/Button&gt;\n</code></pre></p> <p>Step 3: Update TagDetail.jsx</p> <p>Apply same pattern. Note: TagDetail has TWO back buttons (lines ~119 and ~153). Update both.</p> <p>Step 4: Update StudioDetail.jsx</p> <p>Apply same pattern.</p> <p>Step 5: Update GalleryDetail.jsx</p> <p>Apply same pattern.</p> <p>Step 6: Update GroupDetail.jsx</p> <p>Apply same pattern.</p> <p>Step 7: Update PlaylistDetail.jsx</p> <p>This page has different structure. Find back buttons (around lines 303-324) and update similarly.</p> <p>Step 8: Update HiddenItemsPage.jsx</p> <p>This page navigates to Settings specifically. Change to use <code>goBack</code>: <pre><code>&lt;Button onClick={goBack}&gt;\n  {backButtonText}\n&lt;/Button&gt;\n</code></pre></p> <p>Step 9: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 10: Commit</p> <pre><code>git add client/src/components/pages/Scene.jsx client/src/components/pages/PerformerDetail.jsx client/src/components/pages/TagDetail.jsx client/src/components/pages/StudioDetail.jsx client/src/components/pages/GalleryDetail.jsx client/src/components/pages/GroupDetail.jsx client/src/components/pages/PlaylistDetail.jsx client/src/components/pages/HiddenItemsPage.jsx\ngit commit -m \"feat: update detail page back buttons to use useNavigationState\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-10-clean-up-unused-referrerurl-references","title":"Task 10: Clean Up Unused referrerUrl References","text":"<p>Search for any remaining <code>referrerUrl</code> references and clean them up.</p> <p>Files: - Various (search-based)</p> <p>Step 1: Search for remaining referrerUrl</p> <p>Run: <code>cd client &amp;&amp; grep -r \"referrerUrl\" src/</code></p> <p>Review results and update any remaining references.</p> <p>Step 2: Remove useLocation if no longer needed</p> <p>In detail pages where we removed <code>location.state?.referrerUrl</code> checks, verify if <code>useLocation</code> is still needed. If not used elsewhere, remove the import and hook call.</p> <p>Step 3: Run linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: PASS</p> <p>Step 4: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run</code> Expected: All tests pass</p> <p>Step 5: Commit</p> <pre><code>git add -A\ngit commit -m \"chore: clean up unused referrerUrl references\"\n</code></pre>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-11-manual-testing","title":"Task 11: Manual Testing","text":"<p>Step 1: Start dev server</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code></p> <p>Step 2: Test list to detail navigation</p> <ol> <li>Go to Performers page</li> <li>Click on a performer card</li> <li>Verify back button shows \"Back to Performers\"</li> <li>Click back button</li> <li>Verify returns to Performers list</li> </ol> <p>Step 3: Test detail to detail navigation</p> <ol> <li>Go to a Performer detail page</li> <li>Click on a Scene in their scenes list</li> <li>Verify back button shows \"Back to {Performer Name}\"</li> <li>Click back button</li> <li>Verify returns to that performer's page</li> </ol> <p>Step 4: Test deep link fallback</p> <ol> <li>Open browser directly to <code>/performer/123</code> (no prior navigation)</li> <li>Verify back button shows just \"Back\"</li> <li>Click back button</li> <li>Verify navigates somewhere sensible (browser history)</li> </ol> <p>Step 5: Test Home page</p> <ol> <li>Go to Home page</li> <li>Click on a scene in a carousel</li> <li>Verify back button shows \"Back to Home\"</li> <li>Click back button</li> <li>Verify returns to Home</li> </ol> <p>Step 6: Test browser back button</p> <ol> <li>Navigate: Home \u2192 Performers \u2192 Performer Detail \u2192 Scene</li> <li>Click browser back button</li> <li>Verify returns to Performer Detail with correct state</li> <li>Click browser back again</li> <li>Verify returns to Performers list</li> </ol>"},{"location":"plans/2026-01-09-contextual-back-navigation-implementation/#task-12-final-review-and-squash-optional","title":"Task 12: Final Review and Squash (Optional)","text":"<p>Step 1: Review commit history</p> <p>Run: <code>git log --oneline -15</code></p> <p>Step 2: Create PR or merge</p> <p>If all tests pass and manual testing looks good, create PR or merge to main.</p>"},{"location":"plans/2026-01-09-server-side-title-fallback/","title":"Server-Side Title Fallback Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Consolidate title/name fallback logic at the API level so the server always returns computed display titles with fallback applied.</p> <p>Architecture: Title fallbacks are computed in Query Builders at the SQL level (for correct sorting) and during row mapping. A shared utility function strips file extensions. The <code>title</code> field itself returns the computed value (no separate <code>displayTitle</code> field). Returns <code>null</code> only when all fallback options are exhausted.</p> <p>Tech Stack: TypeScript, SQLite (via Prisma raw queries), existing Query Builder pattern</p>"},{"location":"plans/2026-01-09-server-side-title-fallback/#summary-of-changes","title":"Summary of Changes","text":"Entity Current State Target State Scenes No fallback; client uses <code>getSceneTitle()</code> Fallback to <code>filePath</code> basename (ext stripped) Galleries Has fallback but no ext stripping; sort ignores fallback Add ext stripping; fix sort to use fallback Images Only COALESCE for sorting; client uses <code>getImageTitle()</code> Fallback to <code>filePath</code> basename (ext stripped)"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-1-create-shared-title-utility","title":"Task 1: Create shared title utility","text":"<p>Files: - Create: <code>server/utils/titleUtils.ts</code></p> <p>Step 1: Create the utility file</p> <pre><code>/**\n * Utilities for computing display titles with fallback logic.\n */\n\n/**\n * Strip file extension from a filename.\n * @param filename - The filename (with or without extension)\n * @returns The filename without extension\n */\nexport function stripExtension(filename: string): string {\n  return filename.replace(/\\.[^/.]+$/, \"\");\n}\n\n/**\n * Extract basename from a file path (handles both / and \\ separators).\n * @param filePath - The full file path\n * @returns The basename (filename only)\n */\nexport function extractBasename(filePath: string): string {\n  return filePath.split(/[\\\\/]/).pop() || filePath;\n}\n\n/**\n * Get fallback title for a scene when no explicit title is set.\n * Uses file path basename with extension stripped.\n *\n * @param filePath - The scene's primary file path\n * @returns The fallback title or null if no path available\n */\nexport function getSceneFallbackTitle(filePath: string | null): string | null {\n  if (!filePath) {\n    return null;\n  }\n  const basename = extractBasename(filePath);\n  return stripExtension(basename);\n}\n\n/**\n * Get fallback title for a gallery when no explicit title is set.\n * Uses file basename (for zip galleries) or folder path basename (for folder-based galleries).\n * Extensions are stripped from the result.\n *\n * @param folderPath - The gallery's folder path\n * @param fileBasename - The gallery's file basename (for zip galleries)\n * @returns The fallback title or null if neither is available\n */\nexport function getGalleryFallbackTitle(\n  folderPath: string | null,\n  fileBasename: string | null\n): string | null {\n  // Try file basename first (for zip galleries)\n  if (fileBasename) {\n    return stripExtension(fileBasename);\n  }\n  // Try folder path basename (for folder-based galleries)\n  if (folderPath) {\n    const basename = extractBasename(folderPath);\n    return basename; // Folder names don't have extensions to strip\n  }\n  return null;\n}\n\n/**\n * Get fallback title for an image when no explicit title is set.\n * Uses file path basename with extension stripped.\n *\n * @param filePath - The image's file path\n * @returns The fallback title or null if no path available\n */\nexport function getImageFallbackTitle(filePath: string | null): string | null {\n  if (!filePath) {\n    return null;\n  }\n  const basename = extractBasename(filePath);\n  return stripExtension(basename);\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/utils/titleUtils.ts\ngit commit -m \"feat: add shared title utility functions with extension stripping\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-2-update-galleryquerybuilder-to-use-new-utility-and-fix-sorting","title":"Task 2: Update GalleryQueryBuilder to use new utility and fix sorting","text":"<p>Files: - Modify: <code>server/services/GalleryQueryBuilder.ts</code> - Delete: <code>server/utils/galleryUtils.ts</code> (after migration)</p> <p>Step 1: Update import in GalleryQueryBuilder</p> <p>Change line 11 from: <pre><code>import { getGalleryFallbackTitle } from \"../utils/galleryUtils.js\";\n</code></pre> to: <pre><code>import { getGalleryFallbackTitle } from \"../utils/titleUtils.js\";\n</code></pre></p> <p>Step 2: Fix sort clause to use fallback</p> <p>In <code>buildSortClause</code> method (around line 446-448), change: <pre><code>const sortMap: Record&lt;string, string&gt; = {\n  // Gallery metadata - use COLLATE NOCASE for case-insensitive sorting\n  title: `g.title COLLATE NOCASE ${dir}`,\n</code></pre> to: <pre><code>const sortMap: Record&lt;string, string&gt; = {\n  // Gallery metadata - use COALESCE for fallback title, COLLATE NOCASE for case-insensitive sorting\n  title: `COALESCE(g.title, g.fileBasename, SUBSTR(g.folderPath, LENGTH(g.folderPath) - LENGTH(REPLACE(g.folderPath, '/', '')) + 1)) COLLATE NOCASE ${dir}`,\n</code></pre></p> <p>Note: The SUBSTR expression extracts the last path segment. SQLite doesn't have a basename function, so we compute it by finding the position after the last separator.</p> <p>Step 3: Delete old galleryUtils.ts</p> <pre><code>rm server/utils/galleryUtils.ts\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/services/GalleryQueryBuilder.ts server/utils/titleUtils.ts\ngit rm server/utils/galleryUtils.ts\ngit commit -m \"refactor: migrate gallery fallback to titleUtils, add extension stripping, fix sort\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-3-update-scenequerybuilder-with-title-fallback","title":"Task 3: Update SceneQueryBuilder with title fallback","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Add import</p> <p>Add at the top with other imports (around line 10): <pre><code>import { getSceneFallbackTitle } from \"../utils/titleUtils.js\";\n</code></pre></p> <p>Step 2: Update transformRow to apply fallback</p> <p>In <code>transformRow</code> method (around line 1495), change: <pre><code>title: row.title || null,\n</code></pre> to: <pre><code>title: row.title || getSceneFallbackTitle(row.filePath),\n</code></pre></p> <p>Step 3: Fix sort clause to use fallback</p> <p>In <code>buildSortClause</code> method (around line 1111), change: <pre><code>title: `s.title ${dir}`,\n</code></pre> to: <pre><code>title: `COALESCE(s.title, REPLACE(REPLACE(s.filePath, RTRIM(s.filePath, REPLACE(s.filePath, '/', '')), ''), RTRIM(REPLACE(REPLACE(s.filePath, RTRIM(s.filePath, REPLACE(s.filePath, '/', '')), ''), RTRIM(REPLACE(REPLACE(s.filePath, RTRIM(s.filePath, REPLACE(s.filePath, '/', '')), ''), '.', ''), '.'), '')) ${dir}`,\n</code></pre></p> <p>Actually, the SQL for stripping extension and extracting basename is complex. Let's use a simpler approach - just COALESCE with filePath for sorting (the extension will affect sort order slightly but it's acceptable):</p> <pre><code>title: `COALESCE(s.title, s.filePath) COLLATE NOCASE ${dir}`,\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"feat: add title fallback to SceneQueryBuilder using filePath basename\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-4-update-imagequerybuilder-with-title-fallback","title":"Task 4: Update ImageQueryBuilder with title fallback","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code></p> <p>Step 1: Add import</p> <p>Add at the top with other imports (around line 8): <pre><code>import { getImageFallbackTitle } from \"../utils/titleUtils.js\";\n</code></pre></p> <p>Step 2: Update row transformation to apply fallback</p> <p>In the <code>execute</code> method, the row transformation happens around line 543. We need to add title fallback there.</p> <p>Find the <code>transformedRows</code> mapping (around line 543): <pre><code>const transformedRows = rows.map((row) =&gt; ({\n  ...row,\n  fileSize: row.fileSize != null ? Number(row.fileSize) : null,\n  pathThumbnail: this.transformUrl(row.pathThumbnail),\n  pathPreview: this.transformUrl(row.pathPreview),\n  pathImage: this.transformUrl(row.pathImage),\n}));\n</code></pre></p> <p>Change to: <pre><code>const transformedRows = rows.map((row) =&gt; ({\n  ...row,\n  title: row.title || getImageFallbackTitle(row.filePath),\n  fileSize: row.fileSize != null ? Number(row.fileSize) : null,\n  pathThumbnail: this.transformUrl(row.pathThumbnail),\n  pathPreview: this.transformUrl(row.pathPreview),\n  pathImage: this.transformUrl(row.pathImage),\n}));\n</code></pre></p> <p>Step 3: Verify sort clause already uses COALESCE (no change needed)</p> <p>The sort clause at line 347 already has: <pre><code>title: `COALESCE(i.title, i.filePath) ${dir}`,\n</code></pre></p> <p>This is already correct for sorting purposes.</p> <p>Step 4: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts\ngit commit -m \"feat: add title fallback to ImageQueryBuilder using filePath basename\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-5-update-related-query-builders-that-return-galleries","title":"Task 5: Update related query builders that return galleries","text":"<p>The gallery fallback function is also used in other query builders when they return nested galleries. Check these files:</p> <p>Files to check: - <code>server/services/GroupQueryBuilder.ts</code> (line 812) - <code>server/services/StudioQueryBuilder.ts</code> (line 647) - <code>server/services/PerformerQueryBuilder.ts</code> (line 1116) - <code>server/services/TagQueryBuilder.ts</code> (line 849)</p> <p>Step 1: Update imports in each file</p> <p>In each file that imports from <code>galleryUtils.js</code>, change: <pre><code>import { getGalleryFallbackTitle } from \"../utils/galleryUtils.js\";\n</code></pre> to: <pre><code>import { getGalleryFallbackTitle } from \"../utils/titleUtils.js\";\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add server/services/GroupQueryBuilder.ts server/services/StudioQueryBuilder.ts server/services/PerformerQueryBuilder.ts server/services/TagQueryBuilder.ts\ngit commit -m \"refactor: update gallery fallback imports to use titleUtils\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#task-6-verify-and-test","title":"Task 6: Verify and test","text":"<p>Step 1: Run TypeScript compilation</p> <pre><code>cd server &amp;&amp; npm run build\n</code></pre> <p>Expected: No type errors.</p> <p>Step 2: Run linting</p> <pre><code>cd server &amp;&amp; npm run lint\n</code></pre> <p>Expected: No lint errors.</p> <p>Step 3: Run existing integration tests</p> <pre><code>cd server &amp;&amp; npm run test:integration\n</code></pre> <p>Expected: All tests pass.</p> <p>Step 4: Manual verification</p> <p>Start the server and verify: 1. Scenes with null titles show filename (without extension) in the UI 2. Galleries with null titles show folder/zip name (without extension) in the UI 3. Images with null titles show filename (without extension) in the UI 4. Sorting by title works correctly for entities without explicit titles</p> <p>Step 5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address any issues found during verification\"\n</code></pre>"},{"location":"plans/2026-01-09-server-side-title-fallback/#notes","title":"Notes","text":"<ul> <li>The client-side fallback functions (<code>getSceneTitle</code>, <code>galleryTitle</code>, <code>getImageTitle</code>) remain as defensive fallbacks but should rarely be used now</li> <li>Extension stripping uses regex <code>/\\.[^/.]+$/</code> which handles files with multiple dots correctly (e.g., <code>video.part1.mp4</code> \u2192 <code>video.part1</code>)</li> <li>SQL sorting uses COALESCE with the raw path for simplicity; the JS-side transformation does the proper basename extraction and extension stripping</li> </ul>"},{"location":"plans/2026-01-10-debounce-hooks-design/","title":"Debounce Hooks Consolidation","text":""},{"location":"plans/2026-01-10-debounce-hooks-design/#problem","title":"Problem","text":"<p>The codebase has 5 components with manual debounce logic using <code>setTimeout</code> + <code>useRef</code> patterns. This creates: - Code duplication (~50 lines of boilerplate) - Inconsistent patterns (3 different implementations) - Risk of bugs from incorrect cleanup</p>"},{"location":"plans/2026-01-10-debounce-hooks-design/#solution","title":"Solution","text":"<p>Create two reusable hooks in <code>client/src/hooks/useDebounce.js</code>:</p>"},{"location":"plans/2026-01-10-debounce-hooks-design/#usedebouncedvalue","title":"useDebouncedValue","text":"<p>Returns a debounced version of a value. Best for reactive patterns where you watch a value and respond to changes.</p> <pre><code>const debouncedSearch = useDebouncedValue(searchTerm, 300);\nuseEffect(() =&gt; { loadOptions(debouncedSearch); }, [debouncedSearch]);\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-design/#usedebouncedcallback","title":"useDebouncedCallback","text":"<p>Returns a debounced function. Best for imperative patterns where you need to transform data in an event handler.</p> <pre><code>const debouncedSave = useDebouncedCallback((value) =&gt; saveRating(value), 300);\nconst handleChange = (e) =&gt; { setValue(e.target.value); debouncedSave(e.target.value); };\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-design/#components-to-update","title":"Components to Update","text":"Component Hook to Use Current Delay SearchableSelect.jsx useDebouncedValue 300ms SearchInput.jsx useDebouncedValue 300ms (configurable) RatingSlider.jsx useDebouncedCallback 300ms RatingSliderDialog.jsx useDebouncedCallback 300ms"},{"location":"plans/2026-01-10-debounce-hooks-design/#not-changing","title":"Not Changing","text":"<ul> <li><code>useFilterState.js</code> - 500ms debounce for URL syncing (different concern, not API calls)</li> </ul>"},{"location":"plans/2026-01-10-debounce-hooks-design/#implementation","title":"Implementation","text":"<ol> <li>Create <code>useDebounce.js</code> with both hooks</li> <li>Refactor SearchableSelect to use useDebouncedValue</li> <li>Refactor SearchInput to use useDebouncedValue</li> <li>Refactor RatingSlider to use useDebouncedCallback</li> <li>Refactor RatingSliderDialog to use useDebouncedCallback</li> <li>Run linting and manual testing</li> </ol>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/","title":"Debounce Hooks Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Create reusable <code>useDebouncedValue</code> and <code>useDebouncedCallback</code> hooks and refactor 4 components to use them, eliminating ~50 lines of duplicated debounce logic.</p> <p>Architecture: Two hooks in a single file - <code>useDebouncedValue</code> for reactive value watching, <code>useDebouncedCallback</code> for imperative event handler debouncing. Each component refactored to use the appropriate hook based on its pattern.</p> <p>Tech Stack: React hooks (useState, useEffect, useRef, useCallback)</p>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-1-create-usedebouncejs-hook-file","title":"Task 1: Create useDebounce.js Hook File","text":"<p>Files: - Create: <code>client/src/hooks/useDebounce.js</code></p> <p>Step 1: Create the hook file with both exports</p> <pre><code>import { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * Returns a debounced version of a value.\n * The returned value only updates after the specified delay\n * has passed without the input value changing.\n *\n * @param {any} value - The value to debounce\n * @param {number} delay - Debounce delay in milliseconds (default: 300)\n * @returns {any} The debounced value\n *\n * @example\n * const debouncedSearch = useDebouncedValue(searchTerm, 300);\n * useEffect(() =&gt; { loadOptions(debouncedSearch); }, [debouncedSearch]);\n */\nexport const useDebouncedValue = (value, delay = 300) =&gt; {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; setDebouncedValue(value), delay);\n    return () =&gt; clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n};\n\n/**\n * Returns a debounced version of a callback function.\n * The callback only executes after the specified delay has passed\n * without the function being called again.\n *\n * @param {Function} callback - The function to debounce\n * @param {number} delay - Debounce delay in milliseconds (default: 300)\n * @returns {Function} The debounced function\n *\n * @example\n * const debouncedSave = useDebouncedCallback((value) =&gt; saveRating(value), 300);\n * const handleChange = (e) =&gt; { setValue(e.target.value); debouncedSave(e.target.value); };\n */\nexport const useDebouncedCallback = (callback, delay = 300) =&gt; {\n  const timeoutRef = useRef(null);\n  const callbackRef = useRef(callback);\n\n  // Keep callback ref fresh to avoid stale closures\n  useEffect(() =&gt; {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  // Cleanup on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return useCallback(\n    (...args) =&gt; {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() =&gt; callbackRef.current(...args), delay);\n    },\n    [delay]\n  );\n};\n</code></pre> <p>Step 2: Verify file was created correctly</p> <p>Run: <code>head -20 client/src/hooks/useDebounce.js</code></p> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/useDebounce.js\ngit commit -m \"feat: add useDebouncedValue and useDebouncedCallback hooks\"\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-2-refactor-searchableselectjsx","title":"Task 2: Refactor SearchableSelect.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx</code></p> <p>Step 1: Update imports</p> <p>Change line 1 from: <pre><code>import { useCallback, useEffect, useRef, useState } from \"react\";\n</code></pre></p> <p>To: <pre><code>import { useCallback, useEffect, useState } from \"react\";\n</code></pre></p> <p>Add after line 4: <pre><code>import { useDebouncedValue } from \"../../hooks/useDebounce.js\";\n</code></pre></p> <p>Step 2: Remove debounceTimerRef declaration</p> <p>Delete line 44: <pre><code>const debounceTimerRef = useRef(null);\n</code></pre></p> <p>Step 3: Add debouncedSearchTerm hook</p> <p>After <code>const searchInputRef = useRef(null);</code> (around line 43), add: <pre><code>const debouncedSearchTerm = useDebouncedValue(searchTerm, 300);\n</code></pre></p> <p>Step 4: Replace the debounced search useEffect</p> <p>Replace lines 221-239 (the debounce useEffect): <pre><code>  // Debounced search\n  useEffect(() =&gt; {\n    // Clear existing timer\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n\n    // Set new timer\n    debounceTimerRef.current = setTimeout(() =&gt; {\n      loadOptions(searchTerm);\n    }, 300);\n\n    // Cleanup\n    return () =&gt; {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, [searchTerm, loadOptions]);\n</code></pre></p> <p>With: <pre><code>  // Debounced search - triggers loadOptions after 300ms of no typing\n  useEffect(() =&gt; {\n    loadOptions(debouncedSearchTerm);\n  }, [debouncedSearchTerm, loadOptions]);\n</code></pre></p> <p>Step 5: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --no-warn 2&gt;&amp;1 | grep -E \"(error|SearchableSelect)\"</code> Expected: No errors for SearchableSelect.jsx</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx\ngit commit -m \"refactor: use useDebouncedValue in SearchableSelect\"\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-3-refactor-searchinputjsx","title":"Task 3: Refactor SearchInput.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchInput.jsx</code></p> <p>Step 1: Update imports</p> <p>Change lines 1-5 from: <pre><code>/**\n * Reusable search input component with debouncing\n */\nimport { useEffect, useState } from \"react\";\nimport Button from \"./Button.jsx\";\n</code></pre></p> <p>To: <pre><code>/**\n * Reusable search input component with debouncing\n */\nimport { useEffect, useState } from \"react\";\nimport { useDebouncedValue } from \"../../hooks/useDebounce.js\";\nimport Button from \"./Button.jsx\";\n</code></pre></p> <p>Step 2: Add debouncedQuery hook</p> <p>After line 16 (<code>const [query, setQuery] = useState(value || \"\");</code>), add: <pre><code>const debouncedQuery = useDebouncedValue(query, debounceMs);\n</code></pre></p> <p>Step 3: Replace the debounce useEffect</p> <p>Replace lines 26-40: <pre><code>  useEffect(() =&gt; {\n    if (!query.trim()) {\n      onSearch?.(\"\");\n      return;\n    }\n\n    const timeoutId = setTimeout(() =&gt; {\n      onSearch?.(query);\n      if (clearOnSearch) {\n        setQuery(\"\");\n      }\n    }, debounceMs);\n\n    return () =&gt; clearTimeout(timeoutId);\n  }, [query, onSearch, debounceMs, clearOnSearch]);\n</code></pre></p> <p>With: <pre><code>  useEffect(() =&gt; {\n    onSearch?.(debouncedQuery);\n    if (clearOnSearch &amp;&amp; debouncedQuery) {\n      setQuery(\"\");\n    }\n  }, [debouncedQuery, onSearch, clearOnSearch]);\n</code></pre></p> <p>Step 4: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --no-warn 2&gt;&amp;1 | grep -E \"(error|SearchInput)\"</code> Expected: No errors for SearchInput.jsx</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/SearchInput.jsx\ngit commit -m \"refactor: use useDebouncedValue in SearchInput\"\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-4-refactor-ratingsliderjsx","title":"Task 4: Refactor RatingSlider.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/RatingSlider.jsx</code></p> <p>Step 1: Update imports</p> <p>Change line 1 from: <pre><code>import { useEffect, useRef, useState } from \"react\";\n</code></pre></p> <p>To: <pre><code>import { useEffect, useState } from \"react\";\nimport { useDebouncedCallback } from \"../../hooks/useDebounce.js\";\n</code></pre></p> <p>Step 2: Remove debounceTimerRef and cleanup effect</p> <p>Delete line 18: <pre><code>const debounceTimerRef = useRef(null);\n</code></pre></p> <p>Delete lines 24-31 (the cleanup useEffect): <pre><code>  // Clean up timer on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, []);\n</code></pre></p> <p>Step 3: Add debouncedOnChange hook</p> <p>After the <code>useEffect</code> that syncs <code>value</code> from <code>rating</code> prop (around line 20-22), add: <pre><code>  const debouncedOnChange = useDebouncedCallback((newValue) =&gt; {\n    const ratingValue = Math.round(newValue * 10);\n    onChange(ratingValue === 0 ? null : ratingValue);\n  }, 300);\n</code></pre></p> <p>Step 4: Simplify handleChange</p> <p>Replace the handleChange function (lines 48-62): <pre><code>  const handleChange = (e) =&gt; {\n    const newValue = parseFloat(e.target.value);\n    setValue(newValue);\n\n    // Clear existing timer\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n\n    // Set new timer to call onChange after 300ms of no changes\n    debounceTimerRef.current = setTimeout(() =&gt; {\n      const ratingValue = Math.round(newValue * 10); // Convert back to 0-100\n      // If user drags to 0, treat as clearing the rating\n      onChange(ratingValue === 0 ? null : ratingValue);\n    }, 300);\n  };\n</code></pre></p> <p>With: <pre><code>  const handleChange = (e) =&gt; {\n    const newValue = parseFloat(e.target.value);\n    setValue(newValue);\n    debouncedOnChange(newValue);\n  };\n</code></pre></p> <p>Step 5: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --no-warn 2&gt;&amp;1 | grep -E \"(error|RatingSlider)\"</code> Expected: No errors for RatingSlider.jsx</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/RatingSlider.jsx\ngit commit -m \"refactor: use useDebouncedCallback in RatingSlider\"\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-5-refactor-ratingsliderdialogjsx","title":"Task 5: Refactor RatingSliderDialog.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/RatingSliderDialog.jsx</code></p> <p>Step 1: Update imports</p> <p>Change line 1 from: <pre><code>import { useEffect, useRef, useState } from \"react\";\n</code></pre></p> <p>To: <pre><code>import { useEffect, useRef, useState } from \"react\";\nimport { useDebouncedCallback } from \"../../hooks/useDebounce.js\";\n</code></pre></p> <p>Note: We keep <code>useRef</code> because this component uses <code>popoverRef</code> for click-outside detection.</p> <p>Step 2: Remove debounceTimerRef declaration</p> <p>Delete line 31: <pre><code>const debounceTimerRef = useRef(null);\n</code></pre></p> <p>Step 3: Remove cleanup effect</p> <p>Delete lines 117-124: <pre><code>  // Cleanup debounce timer\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, []);\n</code></pre></p> <p>Step 4: Add debouncedOnSave hook</p> <p>After the position calculation useEffect (around line 83), add: <pre><code>  const debouncedOnSave = useDebouncedCallback((newValue) =&gt; {\n    const ratingValue = Math.round(newValue * 10);\n    onSave(ratingValue === 0 ? null : ratingValue);\n  }, 300);\n</code></pre></p> <p>Step 5: Simplify handleChange</p> <p>Replace the handleChange function (lines 143-157): <pre><code>  const handleChange = (e) =&gt; {\n    const newValue = parseFloat(e.target.value);\n    setValue(newValue);\n\n    // Debounced auto-save\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n    }\n\n    debounceTimerRef.current = setTimeout(() =&gt; {\n      const ratingValue = Math.round(newValue * 10); // Convert back to 0-100\n      // If user drags to 0, treat as clearing the rating\n      onSave(ratingValue === 0 ? null : ratingValue);\n    }, 300);\n  };\n</code></pre></p> <p>With: <pre><code>  const handleChange = (e) =&gt; {\n    const newValue = parseFloat(e.target.value);\n    setValue(newValue);\n    debouncedOnSave(newValue);\n  };\n</code></pre></p> <p>Step 6: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --no-warn 2&gt;&amp;1 | grep -E \"(error|RatingSliderDialog)\"</code> Expected: No errors for RatingSliderDialog.jsx</p> <p>Step 7: Commit</p> <pre><code>git add client/src/components/ui/RatingSliderDialog.jsx\ngit commit -m \"refactor: use useDebouncedCallback in RatingSliderDialog\"\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#task-6-final-verification","title":"Task 6: Final Verification","text":"<p>Step 1: Run full linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: Only pre-existing warnings (6 warnings about missing deps in unrelated files)</p> <p>Step 2: Verify no regressions in debounce patterns</p> <p>Run: <code>grep -r \"debounceTimerRef\" client/src/components/ui/</code> Expected: No matches (all manual debounce refs removed from refactored files)</p> <p>Step 3: Verify hook is used in all refactored files</p> <p>Run: <code>grep -l \"useDebounce\" client/src/components/ui/*.jsx</code> Expected output: <pre><code>client/src/components/ui/RatingSlider.jsx\nclient/src/components/ui/RatingSliderDialog.jsx\nclient/src/components/ui/SearchableSelect.jsx\nclient/src/components/ui/SearchInput.jsx\n</code></pre></p> <p>Step 4: Final commit (if any uncommitted changes)</p> <pre><code>git status\n# If clean, proceed. If not, commit remaining changes.\n</code></pre>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#testing-checklist-manual","title":"Testing Checklist (Manual)","text":"<p>After implementation, manually verify:</p> <ol> <li>SearchableSelect: Type in a performer/tag/studio search - results should appear after ~300ms pause, not on every keystroke</li> <li>SearchInput: Same behavior for the general search input</li> <li>RatingSlider: Drag the slider on a detail page - rating should save after ~300ms pause</li> <li>RatingSliderDialog: Same behavior when rating from a card popup</li> </ol>"},{"location":"plans/2026-01-10-debounce-hooks-implementation/#summary","title":"Summary","text":"Task Component Hook Used Lines Removed Lines Added 1 useDebounce.js - 0 58 2 SearchableSelect useDebouncedValue 19 4 3 SearchInput useDebouncedValue 14 5 4 RatingSlider useDebouncedCallback 20 6 5 RatingSliderDialog useDebouncedCallback 17 6 <p>Net change: +58 (new hook) - 70 (removed boilerplate) + 21 (new usage) = +9 lines with significantly improved maintainability</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/","title":"Remove stashapp-api Dependency","text":""},{"location":"plans/2026-01-10-remove-stashapp-api-design/#overview","title":"Overview","text":"<p>Eliminate the external <code>stashapp-api</code> npm package dependency and bring GraphQL queries internal to peek-stash-browser. This improves maintainability by removing an intermediate package and enables fetching only the fields we actually need.</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#current-state","title":"Current State","text":"<p>peek-stash-browser depends on <code>stashapp-api@^0.4.0</code>, a package we authored that: - Connects to Stash GraphQL via a <code>StashApp</code> singleton class - Provides typed query methods (<code>findScenes</code>, <code>findPerformers</code>, etc.) - Generates types via GraphQL introspection + codegen</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#current-usage-11-files","title":"Current Usage (11 files)","text":"<p>Core usage: - <code>StashInstanceManager.ts</code> - creates <code>StashApp.init()</code> instances - <code>setup.ts</code> - tests connections during setup wizard - <code>StashSyncService.ts</code> - all sync queries</p> <p>Type imports: - Entity types: <code>Scene</code>, <code>Performer</code>, <code>Studio</code>, <code>Tag</code>, <code>Gallery</code>, <code>Group</code>, <code>Image</code> - Filter types: <code>SceneFilterType</code>, <code>PerformerFilterType</code>, etc. - Enums: <code>CriterionModifier</code>, <code>GenderEnum</code></p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#problems","title":"Problems","text":"<ol> <li>Over-fetching: stashapp-api queries return 50+ fields per entity; sync only needs ~15-20</li> <li>Extra maintenance: separate package to version and publish</li> <li>Type coupling: Peek's <code>NormalizedXxx</code> types extend Stash types, creating unwanted coupling</li> <li>Inflexibility: can't customize queries per use case</li> </ol>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#target-state","title":"Target State","text":"<ul> <li>GraphQL queries defined inline in peek-stash-browser</li> <li>Types generated via codegen from Stash schema (introspection)</li> <li>Lean queries fetching only needed fields</li> <li>No external package dependency</li> </ul>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2026-01-10-remove-stashapp-api-design/#phase-1-bring-graphql-internal-this-branch","title":"Phase 1: Bring GraphQL Internal (This Branch)","text":""},{"location":"plans/2026-01-10-remove-stashapp-api-design/#11-set-up-codegen-infrastructure","title":"1.1 Set Up Codegen Infrastructure","text":"<p>Add to <code>server/</code>: <pre><code>server/\n\u251c\u2500\u2500 codegen.yml           # graphql-codegen config\n\u251c\u2500\u2500 schema.json           # introspected Stash schema (gitignored)\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 graphql/\n    \u2502   \u251c\u2500\u2500 operations/   # .graphql query files\n    \u2502   \u2514\u2500\u2500 generated/    # codegen output\n</code></pre></p> <p>Dependencies to add: <pre><code>{\n  \"devDependencies\": {\n    \"@graphql-codegen/cli\": \"^5.0.0\",\n    \"@graphql-codegen/typescript\": \"^4.0.0\",\n    \"@graphql-codegen/typescript-operations\": \"^4.0.0\",\n    \"@graphql-codegen/typescript-graphql-request\": \"^6.0.0\",\n    \"graphql\": \"^16.8.0\",\n    \"graphql-request\": \"^6.1.0\"\n  }\n}\n</code></pre></p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#12-write-lean-graphql-queries","title":"1.2 Write Lean GraphQL Queries","text":"<p>Create minimal queries that fetch only what sync needs. Example for scenes:</p> <pre><code># server/src/graphql/operations/findScenes.graphql\nquery FindScenesForSync(\n  $filter: FindFilterType\n  $scene_filter: SceneFilterType\n) {\n  findScenes(filter: $filter, scene_filter: $scene_filter) {\n    count\n    scenes {\n      id\n      title\n      code\n      date\n      details\n      director\n      rating100\n      organized\n      o_counter\n      play_count\n      play_duration\n      created_at\n      updated_at\n      studio { id }\n      performers { id }\n      tags { id }\n      groups {\n        scene_index\n        group { id }\n      }\n      galleries { id }\n      files {\n        path\n        size\n        duration\n        bit_rate\n        frame_rate\n        width\n        height\n        video_codec\n        audio_codec\n      }\n      paths {\n        screenshot\n        preview\n        sprite\n        vtt\n        chapters_vtt\n        stream\n        caption\n      }\n      sceneStreams {\n        url\n        mime_type\n        label\n      }\n    }\n  }\n}\n</code></pre> <p>Similar lean queries for: performers, studios, tags, groups, galleries, images.</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#13-create-stashclient-class","title":"1.3 Create StashClient Class","text":"<p>Replace <code>StashApp</code> with a simple internal client:</p> <pre><code>// server/src/graphql/StashClient.ts\nimport { GraphQLClient } from 'graphql-request';\nimport { getSdk } from './generated/graphql';\n\nexport interface StashClientConfig {\n  url: string;\n  apiKey?: string;\n}\n\nexport class StashClient {\n  private sdk: ReturnType&lt;typeof getSdk&gt;;\n\n  constructor(config: StashClientConfig) {\n    const client = new GraphQLClient(config.url, {\n      headers: config.apiKey ? { ApiKey: config.apiKey } : {},\n    });\n    this.sdk = getSdk(client);\n  }\n\n  // Expose SDK methods directly\n  findScenes = this.sdk.FindScenesForSync;\n  findPerformers = this.sdk.FindPerformersForSync;\n  // ... etc\n}\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#14-update-stashinstancemanager","title":"1.4 Update StashInstanceManager","text":"<pre><code>// Before\nimport { StashApp } from \"stashapp-api\";\nprivate instances = new Map&lt;string, StashApp&gt;();\n\n// After\nimport { StashClient } from \"../graphql/StashClient\";\nprivate instances = new Map&lt;string, StashClient&gt;();\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#15-update-stashsyncservice","title":"1.5 Update StashSyncService","text":"<p>Minimal changes - the SDK method signatures will be similar:</p> <pre><code>// Before\nconst result = await stash.findScenes({ ids: [entityId] });\n\n// After (same pattern, just different import)\nconst result = await stash.findScenes({ ids: [entityId] });\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#16-update-type-imports","title":"1.6 Update Type Imports","text":"<p>Replace stashapp-api type imports with generated types:</p> <pre><code>// Before\nimport type { Scene, Performer } from \"stashapp-api\";\n\n// After\nimport type {\n  FindScenesForSyncQuery,\n  FindPerformersForSyncQuery\n} from \"../graphql/generated/graphql\";\n\n// Extract entity types from query results\ntype SyncScene = FindScenesForSyncQuery['findScenes']['scenes'][0];\ntype SyncPerformer = FindPerformersForSyncQuery['findPerformers']['performers'][0];\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#17-remove-stashapp-api-dependency","title":"1.7 Remove stashapp-api Dependency","text":"<pre><code>cd server\nnpm uninstall stashapp-api\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#18-add-npm-scripts","title":"1.8 Add npm Scripts","text":"<pre><code>{\n  \"scripts\": {\n    \"stash:update-schema\": \"graphql-codegen --config codegen.yml --introspect\",\n    \"stash:codegen\": \"graphql-codegen --config codegen.yml\",\n    \"stash:refresh\": \"npm run stash:update-schema &amp;&amp; npm run stash:codegen\"\n  }\n}\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#phase-2-zod-api-schemas-future-branch","title":"Phase 2: Zod API Schemas (Future Branch)","text":"<p>See: 2026-01-10-zod-api-schemas-design.md</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#files-to-modify","title":"Files to Modify","text":"File Change <code>server/package.json</code> Remove stashapp-api, add codegen deps <code>server/codegen.yml</code> New - codegen config <code>server/src/graphql/operations/*.graphql</code> New - lean query definitions <code>server/src/graphql/StashClient.ts</code> New - replaces StashApp <code>server/services/StashInstanceManager.ts</code> Use StashClient <code>server/services/StashSyncService.ts</code> Update type imports <code>server/controllers/setup.ts</code> Use StashClient <code>server/types/entities.ts</code> Remove stashapp-api imports <code>server/types/filters.ts</code> Inline filter types or import from generated <code>server/utils/stashUrlProxy.ts</code> Update type imports <code>server/types/api/playlist.ts</code> Update type imports"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>Run existing integration tests against real Stash instance</li> <li>Verify sync produces identical database state</li> <li>Test setup wizard connection testing</li> <li>Verify API responses unchanged</li> </ol>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#rollback-plan","title":"Rollback Plan","text":"<p>Keep stashapp-api in devDependencies temporarily. If issues arise, revert imports.</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-design/#success-criteria","title":"Success Criteria","text":"<ul> <li> No runtime dependency on stashapp-api</li> <li> All existing tests pass</li> <li> Sync produces identical results</li> <li> GraphQL queries fetch only needed fields (verify with network inspection)</li> <li> Types remain strict (no <code>any</code> escape hatches)</li> </ul>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/","title":"Remove stashapp-api Dependency - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the external stashapp-api npm package with internal GraphQL queries and codegen, eliminating the dependency while preserving all functionality.</p> <p>Architecture: Copy the codegen pattern from stashapp-api into peek-stash-browser/server. Write lean .graphql operation files, generate TypeScript SDK, create StashClient class that wraps the SDK. Update all imports.</p> <p>Tech Stack: graphql-request, @graphql-codegen/cli, @graphql-codegen/typescript, @graphql-codegen/typescript-operations, @graphql-codegen/typescript-graphql-request</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-1-install-dependencies","title":"Task 1: Install Dependencies","text":"<p>Files: - Modify: <code>server/package.json</code></p> <p>Step 1: Add graphql-request as runtime dependency</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nnpm install graphql-request@^6.1.0 graphql@^16.8.0\n</code></pre> <p>Step 2: Add codegen as dev dependencies</p> <pre><code>npm install -D @graphql-codegen/cli@^5.0.0 @graphql-codegen/typescript@^4.0.0 @graphql-codegen/typescript-operations@^4.0.0 @graphql-codegen/typescript-graphql-request@^6.0.0\n</code></pre> <p>Step 3: Verify installation</p> <p>Run: <code>npm ls graphql-request @graphql-codegen/cli</code> Expected: Both packages listed with versions</p> <p>Step 4: Commit</p> <pre><code>git add package.json package-lock.json\ngit commit -m \"chore: add graphql codegen dependencies\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-2-create-codegen-configuration","title":"Task 2: Create Codegen Configuration","text":"<p>Files: - Create: <code>server/codegen.yml</code> - Modify: <code>server/.gitignore</code></p> <p>Step 1: Create codegen.yml</p> <p>Create file <code>server/codegen.yml</code>:</p> <pre><code>schema: ./schema.json\ndocuments: graphql/operations/**/*.graphql\ngenerates:\n  ./graphql/generated/graphql.ts:\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-graphql-request\n    config:\n      # Use string for ID scalars (Stash uses string IDs)\n      scalars:\n        ID: string\n        Time: string\n        Timestamp: string\n        Int64: number\n        Any: any\n        Map: Record&lt;string, any&gt;\n        BoolMap: Record&lt;string, boolean&gt;\n        PluginConfigMap: Record&lt;string, any&gt;\n        Upload: File\n      # Generate lean types\n      skipTypename: true\n      # Use type imports\n      useTypeImports: true\n</code></pre> <p>Step 2: Add schema.json to .gitignore</p> <p>Append to <code>server/.gitignore</code>:</p> <pre><code># Generated Stash schema (fetched via introspection)\nschema.json\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add codegen.yml .gitignore\ngit commit -m \"chore: add graphql codegen configuration\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-3-create-graphql-operations-directory-structure","title":"Task 3: Create GraphQL Operations Directory Structure","text":"<p>Files: - Create: <code>server/graphql/operations/</code> (directory) - Create: <code>server/graphql/generated/.gitkeep</code></p> <p>Step 1: Create directory structure</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nmkdir -p graphql/operations graphql/generated\ntouch graphql/generated/.gitkeep\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add graphql/\ngit commit -m \"chore: create graphql directory structure\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-4-copy-graphql-operations-from-stashapp-api","title":"Task 4: Copy GraphQL Operations from stashapp-api","text":"<p>Files: - Create: <code>server/graphql/operations/*.graphql</code> (38 files)</p> <p>Step 1: Copy all .graphql files</p> <p>Copy all files from <code>c:\\Users\\carrotwaxr\\code\\stashapp-api\\src\\operations\\</code> to <code>c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\\graphql\\operations\\</code></p> <p>Files to copy: - configuration.graphql - findGalleries.graphql - findGallery.graphql - findGalleryIDs.graphql - findGroup.graphql - findGroupIDs.graphql - findGroups.graphql - findImageIDs.graphql - findImages.graphql - findPerformerIDs.graphql - findPerformers.graphql - findSceneIDs.graphql - findScenes.graphql - findScenesCompact.graphql - findStudioIDs.graphql - findStudios.graphql - findTagIDs.graphql - findTags.graphql - galleryUpdate.graphql - groupUpdate.graphql - imageUpdate.graphql - metadataScan.graphql - performerDestroy.graphql - performersDestroy.graphql - performerUpdate.graphql - sceneAddPlay.graphql - sceneDecrementO.graphql - sceneDestroy.graphql - sceneIncrementO.graphql - sceneSaveActivity.graphql - scenesUpdate.graphql - sceneUpdate.graphql - studioDestroy.graphql - studiosDestroy.graphql - studioUpdate.graphql - tagCreate.graphql - tagDestroy.graphql - tagsDestroy.graphql - tagUpdate.graphql</p> <p>Step 2: Commit</p> <pre><code>git add graphql/operations/\ngit commit -m \"feat: add graphql operations (copied from stashapp-api)\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-5-copy-stash-schema-and-run-codegen","title":"Task 5: Copy Stash Schema and Run Codegen","text":"<p>Files: - Create: <code>server/schema.json</code> (copied, gitignored) - Create: <code>server/graphql/generated/graphql.ts</code> (generated)</p> <p>Step 1: Copy schema.json from stashapp-api</p> <pre><code>cp c:\\Users\\carrotwaxr\\code\\stashapp-api\\schema.json c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\\schema.json\n</code></pre> <p>Step 2: Run codegen</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nnpx graphql-codegen --config codegen.yml\n</code></pre> <p>Expected: File created at <code>graphql/generated/graphql.ts</code></p> <p>Step 3: Verify generated file exists and has content</p> <pre><code>head -50 graphql/generated/graphql.ts\n</code></pre> <p>Expected: TypeScript code with type definitions and getSdk function</p> <p>Step 4: Commit generated file</p> <pre><code>git add graphql/generated/graphql.ts\ngit commit -m \"feat: generate typescript types from stash schema\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-6-add-npm-scripts-for-codegen","title":"Task 6: Add npm Scripts for Codegen","text":"<p>Files: - Modify: <code>server/package.json</code></p> <p>Step 1: Add scripts</p> <p>Add these scripts to <code>server/package.json</code>:</p> <pre><code>{\n  \"scripts\": {\n    \"stash:codegen\": \"graphql-codegen --config codegen.yml\",\n    \"stash:refresh\": \"echo 'Copy schema.json from stashapp-api or run introspection, then run npm run stash:codegen'\"\n  }\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add package.json\ngit commit -m \"chore: add stash codegen npm scripts\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-7-create-stashclient-class","title":"Task 7: Create StashClient Class","text":"<p>Files: - Create: <code>server/graphql/StashClient.ts</code></p> <p>Step 1: Create StashClient.ts</p> <p>Create file <code>server/graphql/StashClient.ts</code>:</p> <pre><code>/**\n * StashClient - Internal GraphQL client for Stash API\n *\n * Replaces the external stashapp-api package with an internal implementation.\n * Uses graphql-request and generated SDK from codegen.\n */\nimport { GraphQLClient } from \"graphql-request\";\nimport { getSdk } from \"./generated/graphql.js\";\n\nexport interface StashClientConfig {\n  url: string;\n  apiKey: string;\n}\n\n/**\n * Client for interacting with the Stash GraphQL API.\n * Each instance maintains its own connection configuration.\n */\nexport class StashClient {\n  private client: GraphQLClient;\n  private sdk: ReturnType&lt;typeof getSdk&gt;;\n\n  constructor(config: StashClientConfig) {\n    this.client = new GraphQLClient(config.url, {\n      headers: { ApiKey: config.apiKey },\n    });\n    this.sdk = getSdk(this.client);\n  }\n\n  // Find operations\n  findPerformers = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindPerformers\"]&gt;) =&gt;\n    this.sdk.FindPerformers(...args);\n  findStudios = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindStudios\"]&gt;) =&gt;\n    this.sdk.FindStudios(...args);\n  findScenes = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindScenes\"]&gt;) =&gt;\n    this.sdk.FindScenes(...args);\n  findScenesCompact = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindScenesCompact\"]&gt;) =&gt;\n    this.sdk.FindScenesCompact(...args);\n  findTags = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindTags\"]&gt;) =&gt;\n    this.sdk.FindTags(...args);\n  findGroups = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGroups\"]&gt;) =&gt;\n    this.sdk.FindGroups(...args);\n  findGroup = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGroup\"]&gt;) =&gt;\n    this.sdk.FindGroup(...args);\n  findGalleries = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGalleries\"]&gt;) =&gt;\n    this.sdk.FindGalleries(...args);\n  findGallery = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGallery\"]&gt;) =&gt;\n    this.sdk.FindGallery(...args);\n  findImages = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindImages\"]&gt;) =&gt;\n    this.sdk.FindImages(...args);\n\n  // ID-only find operations (for cleanup/deletion detection)\n  findSceneIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindSceneIDs\"]&gt;) =&gt;\n    this.sdk.FindSceneIDs(...args);\n  findPerformerIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindPerformerIDs\"]&gt;) =&gt;\n    this.sdk.FindPerformerIDs(...args);\n  findStudioIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindStudioIDs\"]&gt;) =&gt;\n    this.sdk.FindStudioIDs(...args);\n  findTagIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindTagIDs\"]&gt;) =&gt;\n    this.sdk.FindTagIDs(...args);\n  findGroupIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGroupIDs\"]&gt;) =&gt;\n    this.sdk.FindGroupIDs(...args);\n  findGalleryIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindGalleryIDs\"]&gt;) =&gt;\n    this.sdk.FindGalleryIDs(...args);\n  findImageIDs = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"FindImageIDs\"]&gt;) =&gt;\n    this.sdk.FindImageIDs(...args);\n\n  // Update operations\n  sceneUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"sceneUpdate\"]&gt;) =&gt;\n    this.sdk.sceneUpdate(...args);\n  scenesUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"scenesUpdate\"]&gt;) =&gt;\n    this.sdk.scenesUpdate(...args);\n  performerUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"performerUpdate\"]&gt;) =&gt;\n    this.sdk.performerUpdate(...args);\n  studioUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"studioUpdate\"]&gt;) =&gt;\n    this.sdk.studioUpdate(...args);\n  galleryUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"galleryUpdate\"]&gt;) =&gt;\n    this.sdk.galleryUpdate(...args);\n  groupUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"groupUpdate\"]&gt;) =&gt;\n    this.sdk.groupUpdate(...args);\n  imageUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"imageUpdate\"]&gt;) =&gt;\n    this.sdk.imageUpdate(...args);\n  tagCreate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"tagCreate\"]&gt;) =&gt;\n    this.sdk.tagCreate(...args);\n  tagUpdate = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"tagUpdate\"]&gt;) =&gt;\n    this.sdk.tagUpdate(...args);\n\n  // Destroy operations\n  performerDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"performerDestroy\"]&gt;) =&gt;\n    this.sdk.performerDestroy(...args);\n  performersDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"performersDestroy\"]&gt;) =&gt;\n    this.sdk.performersDestroy(...args);\n  tagDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"tagDestroy\"]&gt;) =&gt;\n    this.sdk.tagDestroy(...args);\n  tagsDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"tagsDestroy\"]&gt;) =&gt;\n    this.sdk.tagsDestroy(...args);\n  studioDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"studioDestroy\"]&gt;) =&gt;\n    this.sdk.studioDestroy(...args);\n  studiosDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"studiosDestroy\"]&gt;) =&gt;\n    this.sdk.studiosDestroy(...args);\n  sceneDestroy = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"sceneDestroy\"]&gt;) =&gt;\n    this.sdk.sceneDestroy(...args);\n\n  // Activity operations\n  sceneIncrementO = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"sceneIncrementO\"]&gt;) =&gt;\n    this.sdk.sceneIncrementO(...args);\n  sceneDecrementO = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"SceneDecrementO\"]&gt;) =&gt;\n    this.sdk.SceneDecrementO(...args);\n  sceneSaveActivity = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"SceneSaveActivity\"]&gt;) =&gt;\n    this.sdk.SceneSaveActivity(...args);\n  sceneAddPlay = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"SceneAddPlay\"]&gt;) =&gt;\n    this.sdk.SceneAddPlay(...args);\n\n  // Configuration\n  configuration = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"Configuration\"]&gt;) =&gt;\n    this.sdk.Configuration(...args);\n\n  // Metadata operations\n  metadataScan = (...args: Parameters&lt;ReturnType&lt;typeof getSdk&gt;[\"metadataScan\"]&gt;) =&gt;\n    this.sdk.metadataScan(...args);\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add graphql/StashClient.ts\ngit commit -m \"feat: create StashClient class wrapping generated SDK\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-8-create-type-re-exports","title":"Task 8: Create Type Re-exports","text":"<p>Files: - Create: <code>server/graphql/types.ts</code></p> <p>Step 1: Create types.ts for re-exporting commonly used types</p> <p>Create file <code>server/graphql/types.ts</code>:</p> <pre><code>/**\n * Re-export commonly used types from generated GraphQL types.\n *\n * These replace the type imports that previously came from stashapp-api.\n */\n\n// Entity types\nexport type {\n  Performer,\n  Scene,\n  Tag,\n  Studio,\n  Gallery,\n  Group,\n  Image,\n} from \"./generated/graphql.js\";\n\n// Filter types\nexport type {\n  PerformerFilterType,\n  SceneFilterType,\n  TagFilterType,\n  StudioFilterType,\n  GalleryFilterType,\n  ImageFilterType,\n  GroupFilterType,\n  FindFilterType,\n} from \"./generated/graphql.js\";\n\n// Input types\nexport type {\n  ScanMetadataInput,\n  PerformerDestroyInput,\n  TagDestroyInput,\n  StudioDestroyInput,\n  SceneDestroyInput,\n  TagCreateInput,\n  TagUpdateInput,\n  SceneUpdateInput,\n  PerformerUpdateInput,\n  StudioUpdateInput,\n  GalleryUpdateInput,\n  GroupUpdateInput,\n  ImageUpdateInput,\n} from \"./generated/graphql.js\";\n\n// Enums - re-export as values (not just types)\nexport {\n  CriterionModifier,\n  GenderEnum,\n} from \"./generated/graphql.js\";\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add graphql/types.ts\ngit commit -m \"feat: add type re-exports for generated graphql types\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-9-update-stashinstancemanager","title":"Task 9: Update StashInstanceManager","text":"<p>Files: - Modify: <code>server/services/StashInstanceManager.ts</code></p> <p>Step 1: Update imports and type references</p> <p>Replace: <pre><code>import { StashApp } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import { StashClient } from \"../graphql/StashClient.js\";\n</code></pre></p> <p>Step 2: Update Map type</p> <p>Replace: <pre><code>private instances = new Map&lt;string, StashApp&gt;();\n</code></pre></p> <p>With: <pre><code>private instances = new Map&lt;string, StashClient&gt;();\n</code></pre></p> <p>Step 3: Update initialization</p> <p>Replace: <pre><code>const stash = StashApp.init({\n  url: config.url,\n  apiKey: config.apiKey,\n});\n</code></pre></p> <p>With: <pre><code>const stash = new StashClient({\n  url: config.url,\n  apiKey: config.apiKey,\n});\n</code></pre></p> <p>Step 4: Update getDefault return type</p> <p>Replace: <pre><code>getDefault(): StashApp {\n</code></pre></p> <p>With: <pre><code>getDefault(): StashClient {\n</code></pre></p> <p>Step 5: Update get return type</p> <p>Replace: <pre><code>get(instanceId: string): StashApp | undefined {\n</code></pre></p> <p>With: <pre><code>get(instanceId: string): StashClient | undefined {\n</code></pre></p> <p>Step 6: Build to verify</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nnpm run build\n</code></pre> <p>Expected: No TypeScript errors related to StashInstanceManager</p> <p>Step 7: Commit</p> <pre><code>git add services/StashInstanceManager.ts\ngit commit -m \"refactor: use StashClient instead of StashApp in StashInstanceManager\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-10-update-setupts-controller","title":"Task 10: Update setup.ts Controller","text":"<p>Files: - Modify: <code>server/controllers/setup.ts</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { StashApp } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import { StashClient } from \"../graphql/StashClient.js\";\n</code></pre></p> <p>Step 2: Update testStashConnection function</p> <p>Replace: <pre><code>const testStash = StashApp.init({ url, apiKey });\n</code></pre></p> <p>With: <pre><code>const testStash = new StashClient({ url, apiKey });\n</code></pre></p> <p>Step 3: Update createFirstStashInstance function</p> <p>Replace: <pre><code>const testStash = StashApp.init({ url, apiKey });\n</code></pre></p> <p>With: <pre><code>const testStash = new StashClient({ url, apiKey });\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add controllers/setup.ts\ngit commit -m \"refactor: use StashClient instead of StashApp in setup controller\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-11-update-typesentitiests","title":"Task 11: Update types/entities.ts","text":"<p>Files: - Modify: <code>server/types/entities.ts</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import type {\n  Gallery,\n  Group,\n  Image,\n  Performer,\n  Scene,\n  Studio,\n  Tag,\n} from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import type {\n  Gallery,\n  Group,\n  Image,\n  Performer,\n  Scene,\n  Studio,\n  Tag,\n} from \"../graphql/types.js\";\n</code></pre></p> <p>Step 2: Build to verify</p> <pre><code>npm run build\n</code></pre> <p>Expected: No errors - types should be compatible</p> <p>Step 3: Commit</p> <pre><code>git add types/entities.ts\ngit commit -m \"refactor: import entity types from internal graphql module\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-12-update-typesfiltersts","title":"Task 12: Update types/filters.ts","text":"<p>Files: - Modify: <code>server/types/filters.ts</code></p> <p>Step 1: Update type re-exports</p> <p>Replace: <pre><code>export type {\n  PerformerFilterType,\n  SceneFilterType,\n  TagFilterType,\n  StudioFilterType,\n  GalleryFilterType,\n  ImageFilterType,\n  GroupFilterType,\n} from \"stashapp-api\";\n\nexport { CriterionModifier, GenderEnum } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>export type {\n  PerformerFilterType,\n  SceneFilterType,\n  TagFilterType,\n  StudioFilterType,\n  GalleryFilterType,\n  ImageFilterType,\n  GroupFilterType,\n} from \"../graphql/types.js\";\n\nexport { CriterionModifier, GenderEnum } from \"../graphql/types.js\";\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add types/filters.ts\ngit commit -m \"refactor: import filter types from internal graphql module\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-13-update-utilsstashurlproxyts","title":"Task 13: Update utils/stashUrlProxy.ts","text":"<p>Files: - Modify: <code>server/utils/stashUrlProxy.ts</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import type {\n  Gallery,\n  Group,\n  Performer,\n  Scene,\n  Studio,\n  Tag,\n} from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import type {\n  Gallery,\n  Group,\n  Performer,\n  Scene,\n  Studio,\n  Tag,\n} from \"../graphql/types.js\";\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add utils/stashUrlProxy.ts\ngit commit -m \"refactor: import types from internal graphql module in stashUrlProxy\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-14-update-typesapiplaylistts","title":"Task 14: Update types/api/playlist.ts","text":"<p>Files: - Modify: <code>server/types/api/playlist.ts</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import type { Scene } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import type { Scene } from \"../../graphql/types.js\";\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add types/api/playlist.ts\ngit commit -m \"refactor: import Scene type from internal graphql module in playlist types\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-15-update-stashsyncservicets-imports","title":"Task 15: Update StashSyncService.ts Imports","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Update type imports</p> <p>Replace: <pre><code>import type { Gallery, Group, Performer, Scene, Studio, Tag } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import type { Gallery, Group, Performer, Scene, Studio, Tag } from \"../graphql/types.js\";\n</code></pre></p> <p>Step 2: Build to verify</p> <pre><code>npm run build\n</code></pre> <p>Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add services/StashSyncService.ts\ngit commit -m \"refactor: import types from internal graphql module in StashSyncService\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-16-update-integration-test-file","title":"Task 16: Update Integration Test File","text":"<p>Files: - Modify: <code>server/tests/services/StashSyncService.stash.test.ts</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { StashApp } from \"stashapp-api\";\n</code></pre></p> <p>With: <pre><code>import { StashClient } from \"../../graphql/StashClient.js\";\n</code></pre></p> <p>Step 2: Update StashApp.init to new StashClient</p> <p>Replace: <pre><code>stash = StashApp.init({\n  url: process.env.STASH_URL!,\n  apiKey: process.env.STASH_API_KEY!,\n});\n</code></pre></p> <p>With: <pre><code>stash = new StashClient({\n  url: process.env.STASH_URL!,\n  apiKey: process.env.STASH_API_KEY!,\n});\n</code></pre></p> <p>Step 3: Update variable type declaration</p> <p>Replace: <pre><code>let stash: StashApp;\n</code></pre></p> <p>With: <pre><code>let stash: StashClient;\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add tests/services/StashSyncService.stash.test.ts\ngit commit -m \"refactor: use StashClient in integration tests\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-17-remove-stashapp-api-dependency","title":"Task 17: Remove stashapp-api Dependency","text":"<p>Files: - Modify: <code>server/package.json</code></p> <p>Step 1: Uninstall stashapp-api</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nnpm uninstall stashapp-api\n</code></pre> <p>Step 2: Verify removal</p> <pre><code>grep -r \"stashapp-api\" . --include=\"*.ts\" --include=\"*.json\" | grep -v node_modules | grep -v \".git\"\n</code></pre> <p>Expected: No matches (package.json should no longer have it)</p> <p>Step 3: Commit</p> <pre><code>git add package.json package-lock.json\ngit commit -m \"chore: remove stashapp-api dependency\"\n</code></pre>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-18-full-build-verification","title":"Task 18: Full Build Verification","text":"<p>Files: None (verification only)</p> <p>Step 1: Clean build</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nrm -rf dist\nnpm run build\n</code></pre> <p>Expected: Build succeeds with no errors</p> <p>Step 2: Run lint</p> <pre><code>npm run lint\n</code></pre> <p>Expected: No new lint errors</p> <p>Step 3: Run unit tests</p> <pre><code>npm run test:run\n</code></pre> <p>Expected: All tests pass</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-19-integration-test-optional-requires-stash-server","title":"Task 19: Integration Test (Optional - Requires Stash Server)","text":"<p>Files: None (verification only)</p> <p>Step 1: Run integration tests if Stash server available</p> <pre><code>cd c:\\Users\\carrotwaxr\\code\\peek-stash-browser\\server\nnpm run test:integration\n</code></pre> <p>Expected: All integration tests pass</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#task-20-final-commit-and-summary","title":"Task 20: Final Commit and Summary","text":"<p>Step 1: Create summary commit if any uncommitted changes</p> <pre><code>git status\n</code></pre> <p>If clean, skip. Otherwise:</p> <pre><code>git add -A\ngit commit -m \"chore: cleanup after stashapp-api removal\"\n</code></pre> <p>Step 2: View commit history for this branch</p> <pre><code>git log --oneline main..HEAD\n</code></pre> <p>Expected: Series of commits showing the migration</p>"},{"location":"plans/2026-01-10-remove-stashapp-api-implementation/#verification-checklist","title":"Verification Checklist","text":"<p>After completing all tasks, verify:</p> <ul> <li> <code>npm run build</code> succeeds</li> <li> <code>npm run lint</code> passes</li> <li> <code>npm run test:run</code> passes</li> <li> No imports from \"stashapp-api\" remain</li> <li> <code>server/graphql/</code> directory contains:</li> <li><code>operations/*.graphql</code> (38 files)</li> <li><code>generated/graphql.ts</code></li> <li><code>StashClient.ts</code></li> <li><code>types.ts</code></li> <li> <code>server/package.json</code> does not list stashapp-api</li> </ul>"},{"location":"plans/2026-01-10-zod-api-schemas-design/","title":"Zod API Schemas for Peek","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#overview","title":"Overview","text":"<p>Introduce Zod schemas as the source of truth for Peek's API responses. This creates predictable, composable type fragments derived from what we actually expose to clients, rather than inheriting bloated types from Stash.</p>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#goals","title":"Goals","text":"<ol> <li>Predictable API responses: Define exactly what shape leaves the server</li> <li>Composable fragments: Build complex types from reusable pieces</li> <li>Decouple from Stash types: API types derived from our needs, not Stash's schema</li> <li>Runtime validation: Catch transformation bugs before clients see malformed data</li> <li>Single source of truth: Zod schemas define both runtime validation and TypeScript types</li> </ol>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#prerequisites","title":"Prerequisites","text":"<p>Complete Phase 1 first: 2026-01-10-remove-stashapp-api-design.md</p> <p>After Phase 1: - Stash types are only used at sync boundary - Prisma types are used for internal DB operations - API response types are currently <code>NormalizedXxx</code> (extending old Stash types)</p>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Peek Server                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                   \u2502\n\u2502  Stash GraphQL \u2500\u2500\u25ba Sync Types \u2500\u2500\u25ba Prisma/SQLite                  \u2502\n\u2502  (generated)       (internal)      (storage)                     \u2502\n\u2502                                                                   \u2502\n\u2502                                        \u2502                          \u2502\n\u2502                                        \u25bc                          \u2502\n\u2502                                   Zod Schemas \u25c4\u2500\u2500 Source of Truth \u2502\n\u2502                                        \u2502                          \u2502\n\u2502                                        \u25bc                          \u2502\n\u2502                                   API Responses                   \u2502\n\u2502                                   (validated)                     \u2502\n\u2502                                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#design-principles","title":"Design Principles","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#1-schemas-are-composable","title":"1. Schemas Are Composable","text":"<p>Build from small, reusable fragments:</p> <pre><code>// Base reference types (id + display name)\nconst EntityRefSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nconst PerformerRefSchema = EntityRefSchema.extend({\n  imagePath: z.string().nullable(),\n  gender: z.string().nullable(),\n});\n\nconst StudioRefSchema = EntityRefSchema.extend({\n  imagePath: z.string().nullable(),\n});\n\nconst TagRefSchema = EntityRefSchema;\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#2-response-types-compose-fragments","title":"2. Response Types Compose Fragments","text":"<pre><code>// Card view - minimal data for grid/list display\nconst SceneCardSchema = z.object({\n  id: z.string(),\n  title: z.string().nullable(),\n  date: z.string().nullable(),\n  duration: z.number().nullable(),\n  rating100: z.number().nullable(),\n  pathScreenshot: z.string().nullable(),\n  studio: StudioRefSchema.nullable(),\n  performers: z.array(PerformerRefSchema),\n});\n\n// Detail view - extends card with additional fields\nconst SceneDetailSchema = SceneCardSchema.extend({\n  details: z.string().nullable(),\n  director: z.string().nullable(),\n  code: z.string().nullable(),\n  tags: z.array(TagRefSchema),\n  files: z.array(FileInfoSchema),\n  paths: ScenePathsSchema,\n  // User-specific data\n  userRating: z.number().nullable(),\n  playCount: z.number(),\n  isFavorite: z.boolean(),\n});\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#3-derive-typescript-types-from-schemas","title":"3. Derive TypeScript Types from Schemas","text":"<pre><code>// Types are inferred, never manually defined\nexport type SceneCard = z.infer&lt;typeof SceneCardSchema&gt;;\nexport type SceneDetail = z.infer&lt;typeof SceneDetailSchema&gt;;\nexport type PerformerRef = z.infer&lt;typeof PerformerRefSchema&gt;;\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#4-validate-at-api-boundary","title":"4. Validate at API Boundary","text":"<pre><code>// In controller/route handler\nexport async function getScene(req: Request, res: Response) {\n  const scene = await sceneService.getById(req.params.id);\n\n  // Validate before sending - catches bugs in our code\n  const validated = SceneDetailSchema.parse(scene);\n\n  res.json(validated);\n}\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#5-use-strip-for-safety","title":"5. Use <code>.strip()</code> for Safety","text":"<p>Zod's <code>.strip()</code> removes extra fields, ensuring we never accidentally leak internal data:</p> <pre><code>const SafeSceneSchema = SceneDetailSchema.strip();\n\n// Even if scene object has extra fields, they won't be in response\nconst validated = SafeSceneSchema.parse(scene);\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#schema-organization","title":"Schema Organization","text":"<pre><code>server/src/schemas/\n\u251c\u2500\u2500 index.ts              # Re-exports all schemas\n\u251c\u2500\u2500 base.ts               # Primitive/shared schemas\n\u251c\u2500\u2500 refs.ts               # EntityRef schemas (id + name patterns)\n\u251c\u2500\u2500 scene.ts              # Scene-related schemas\n\u251c\u2500\u2500 performer.ts          # Performer-related schemas\n\u251c\u2500\u2500 studio.ts             # Studio-related schemas\n\u251c\u2500\u2500 tag.ts                # Tag-related schemas\n\u251c\u2500\u2500 gallery.ts            # Gallery-related schemas\n\u251c\u2500\u2500 group.ts              # Group-related schemas\n\u251c\u2500\u2500 image.ts              # Image-related schemas\n\u251c\u2500\u2500 user.ts               # User preference/data schemas\n\u2514\u2500\u2500 api/                  # Request/response schemas per endpoint\n    \u251c\u2500\u2500 scenes.ts\n    \u251c\u2500\u2500 performers.ts\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#proposed-schemas","title":"Proposed Schemas","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#base-schemas","title":"Base Schemas","text":"<pre><code>// server/src/schemas/base.ts\nimport { z } from 'zod';\n\nexport const PaginationSchema = z.object({\n  page: z.number().int().positive(),\n  perPage: z.number().int().positive().max(100),\n  total: z.number().int().nonnegative(),\n  totalPages: z.number().int().nonnegative(),\n});\n\nexport const DateStringSchema = z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/);\n\nexport const TimestampSchema = z.string().datetime();\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#reference-schemas","title":"Reference Schemas","text":"<pre><code>// server/src/schemas/refs.ts\nimport { z } from 'zod';\n\n// Minimal reference - just enough to link/display\nexport const EntityRefSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nexport const PerformerRefSchema = EntityRefSchema.extend({\n  imagePath: z.string().nullable(),\n  gender: z.enum(['MALE', 'FEMALE', 'TRANSGENDER_MALE', 'TRANSGENDER_FEMALE',\n                  'INTERSEX', 'NON_BINARY', 'OTHER']).nullable(),\n});\n\nexport const StudioRefSchema = EntityRefSchema.extend({\n  imagePath: z.string().nullable(),\n});\n\nexport const TagRefSchema = EntityRefSchema.extend({\n  imagePath: z.string().nullable(),\n});\n\nexport const GroupRefSchema = EntityRefSchema.extend({\n  frontImagePath: z.string().nullable(),\n});\n\nexport const GalleryRefSchema = EntityRefSchema.extend({\n  coverPath: z.string().nullable(),\n  imageCount: z.number(),\n});\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#scene-schemas","title":"Scene Schemas","text":"<pre><code>// server/src/schemas/scene.ts\nimport { z } from 'zod';\nimport { PerformerRefSchema, StudioRefSchema, TagRefSchema,\n         GroupRefSchema, GalleryRefSchema } from './refs';\n\nexport const SceneFileSchema = z.object({\n  path: z.string(),\n  size: z.number(),\n  duration: z.number().nullable(),\n  width: z.number().nullable(),\n  height: z.number().nullable(),\n  bitRate: z.number().nullable(),\n  frameRate: z.number().nullable(),\n  videoCodec: z.string().nullable(),\n  audioCodec: z.string().nullable(),\n});\n\nexport const ScenePathsSchema = z.object({\n  screenshot: z.string().nullable(),\n  preview: z.string().nullable(),\n  sprite: z.string().nullable(),\n  vtt: z.string().nullable(),\n  stream: z.string().nullable(),\n});\n\nexport const SceneStreamsSchema = z.array(z.object({\n  url: z.string(),\n  mimeType: z.string().nullable(),\n  label: z.string().nullable(),\n}));\n\n// Card view - for grids and lists\nexport const SceneCardSchema = z.object({\n  id: z.string(),\n  title: z.string().nullable(),\n  date: z.string().nullable(),\n  duration: z.number().nullable(),\n  rating100: z.number().nullable(),\n  organized: z.boolean(),\n  pathScreenshot: z.string().nullable(),\n  pathPreview: z.string().nullable(),\n  studio: StudioRefSchema.nullable(),\n  performers: z.array(PerformerRefSchema),\n  tags: z.array(TagRefSchema),\n  // User data\n  userRating: z.number().nullable(),\n  playCount: z.number(),\n  isFavorite: z.boolean(),\n  lastPlayedAt: z.string().nullable(),\n});\n\n// Detail view - full scene data\nexport const SceneDetailSchema = SceneCardSchema.extend({\n  code: z.string().nullable(),\n  details: z.string().nullable(),\n  director: z.string().nullable(),\n  oCounter: z.number(),\n  playDuration: z.number(),\n  groups: z.array(GroupRefSchema.extend({ sceneIndex: z.number().nullable() })),\n  galleries: z.array(GalleryRefSchema),\n  files: z.array(SceneFileSchema),\n  paths: ScenePathsSchema,\n  streams: SceneStreamsSchema,\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\n// Infer types\nexport type SceneCard = z.infer&lt;typeof SceneCardSchema&gt;;\nexport type SceneDetail = z.infer&lt;typeof SceneDetailSchema&gt;;\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#performer-schemas","title":"Performer Schemas","text":"<pre><code>// server/src/schemas/performer.ts\nimport { z } from 'zod';\nimport { StudioRefSchema, TagRefSchema } from './refs';\n\nexport const PerformerCardSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  disambiguation: z.string().nullable(),\n  gender: z.string().nullable(),\n  imagePath: z.string().nullable(),\n  favorite: z.boolean(),\n  rating100: z.number().nullable(),\n  sceneCount: z.number(),\n  imageCount: z.number(),\n  galleryCount: z.number(),\n  // User data\n  userRating: z.number().nullable(),\n  isFavorite: z.boolean(),\n});\n\nexport const PerformerDetailSchema = PerformerCardSchema.extend({\n  birthdate: z.string().nullable(),\n  deathDate: z.string().nullable(),\n  country: z.string().nullable(),\n  ethnicity: z.string().nullable(),\n  eyeColor: z.string().nullable(),\n  hairColor: z.string().nullable(),\n  heightCm: z.number().nullable(),\n  measurements: z.string().nullable(),\n  details: z.string().nullable(),\n  tattoos: z.string().nullable(),\n  piercings: z.string().nullable(),\n  aliases: z.array(z.string()),\n  tags: z.array(TagRefSchema),\n  // Aggregated stats\n  studios: z.array(StudioRefSchema.extend({ sceneCount: z.number() })),\n  totalPlayTime: z.number(),\n  averageRating: z.number().nullable(),\n});\n\nexport type PerformerCard = z.infer&lt;typeof PerformerCardSchema&gt;;\nexport type PerformerDetail = z.infer&lt;typeof PerformerDetailSchema&gt;;\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#migration-strategy","title":"Migration Strategy","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#approach-incremental-endpoint-by-endpoint","title":"Approach: Incremental, Endpoint by Endpoint","text":"<p>Don't rewrite everything at once. Migrate one endpoint at a time:</p> <ol> <li>Start with a simple endpoint (e.g., <code>GET /api/tags</code>)</li> <li>Define the schema for that endpoint's response</li> <li>Add validation in the controller</li> <li>Update client types if using shared types</li> <li>Repeat for next endpoint</li> </ol>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#example-migration","title":"Example Migration","text":"<p>Before: <pre><code>// controller\nexport async function getScene(req, res) {\n  const scene = await sceneService.getById(req.params.id);\n  res.json(scene); // Returns NormalizedScene with 50+ fields\n}\n</code></pre></p> <p>After: <pre><code>// controller\nimport { SceneDetailSchema } from '../schemas/scene';\n\nexport async function getScene(req, res) {\n  const scene = await sceneService.getById(req.params.id);\n\n  // Transform to API shape and validate\n  const response = SceneDetailSchema.strip().parse({\n    id: scene.id,\n    title: scene.title,\n    // ... explicit mapping\n    userRating: scene.userRating,\n    isFavorite: scene.isFavorite,\n  });\n\n  res.json(response);\n}\n</code></pre></p>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#helper-transform-functions","title":"Helper: Transform Functions","text":"<p>Create transform functions to map DB entities to API shapes:</p> <pre><code>// server/src/transforms/scene.ts\nimport { SceneCard, SceneCardSchema } from '../schemas/scene';\nimport { PrismaScene } from '../prisma/types';\n\nexport function toSceneCard(scene: PrismaSceneWithRelations): SceneCard {\n  return SceneCardSchema.parse({\n    id: scene.id,\n    title: scene.title,\n    date: scene.date,\n    duration: scene.duration,\n    rating100: scene.rating100,\n    organized: scene.organized,\n    pathScreenshot: scene.pathScreenshot,\n    studio: scene.studio ? {\n      id: scene.studio.id,\n      name: scene.studio.name,\n      imagePath: scene.studio.imagePath,\n    } : null,\n    performers: scene.performers.map(p =&gt; ({\n      id: p.id,\n      name: p.name,\n      imagePath: p.imagePath,\n      gender: p.gender,\n    })),\n    tags: scene.tags.map(t =&gt; ({\n      id: t.id,\n      name: t.name,\n    })),\n    userRating: scene.userRating?.rating ?? null,\n    playCount: scene.playHistory?.length ?? 0,\n    isFavorite: scene.favorite?.isFavorite ?? false,\n    lastPlayedAt: scene.playHistory?.[0]?.playedAt ?? null,\n  });\n}\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#endpoint-priority","title":"Endpoint Priority","text":"<p>Suggested order for migration (high-traffic/high-value first):</p> <ol> <li><code>GET /api/scenes</code> and <code>GET /api/scenes/:id</code></li> <li><code>GET /api/performers</code> and <code>GET /api/performers/:id</code></li> <li><code>GET /api/tags</code> and <code>GET /api/studios</code></li> <li><code>GET /api/galleries</code> and <code>GET /api/images</code></li> <li><code>GET /api/groups</code></li> <li>Playlist endpoints</li> <li>User preference endpoints</li> <li>Stats/dashboard endpoints</li> </ol>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#testing","title":"Testing","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#unit-tests-for-schemas","title":"Unit Tests for Schemas","text":"<pre><code>import { SceneCardSchema } from '../schemas/scene';\n\ndescribe('SceneCardSchema', () =&gt; {\n  it('validates a correct scene card', () =&gt; {\n    const valid = {\n      id: '123',\n      title: 'Test Scene',\n      // ... all required fields\n    };\n    expect(() =&gt; SceneCardSchema.parse(valid)).not.toThrow();\n  });\n\n  it('strips extra fields', () =&gt; {\n    const withExtra = {\n      id: '123',\n      title: 'Test',\n      // ... required fields\n      internalField: 'should be removed',\n    };\n    const result = SceneCardSchema.strip().parse(withExtra);\n    expect(result).not.toHaveProperty('internalField');\n  });\n\n  it('rejects invalid data', () =&gt; {\n    const invalid = { id: 123 }; // id should be string\n    expect(() =&gt; SceneCardSchema.parse(invalid)).toThrow();\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#integration-tests","title":"Integration Tests","text":"<p>Verify endpoints return valid shapes:</p> <pre><code>describe('GET /api/scenes/:id', () =&gt; {\n  it('returns valid SceneDetail shape', async () =&gt; {\n    const res = await request(app).get('/api/scenes/123');\n    expect(() =&gt; SceneDetailSchema.parse(res.body)).not.toThrow();\n  });\n});\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#dependencies","title":"Dependencies","text":"<pre><code>{\n  \"dependencies\": {\n    \"zod\": \"^3.22.0\"\n  }\n}\n</code></pre> <p>Zod has no runtime dependencies and is ~50KB minified.</p>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#success-criteria","title":"Success Criteria","text":"<ul> <li> All API endpoints validated with Zod schemas</li> <li> No <code>NormalizedXxx</code> types extending Stash types</li> <li> TypeScript types derived from Zod schemas (<code>z.infer</code>)</li> <li> Transform functions for DB \u2192 API shape</li> <li> Extra fields stripped (no data leakage)</li> <li> Existing client functionality unchanged</li> <li> Test coverage for all schemas</li> </ul>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#future-considerations","title":"Future Considerations","text":""},{"location":"plans/2026-01-10-zod-api-schemas-design/#client-side-validation","title":"Client-Side Validation","text":"<p>Same schemas could be shared with client for request validation:</p> <pre><code>// shared/schemas/api.ts - if using monorepo\nexport { SceneCardSchema, SceneDetailSchema } from './scene';\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#openapi-generation","title":"OpenAPI Generation","text":"<p>Zod schemas can generate OpenAPI specs via <code>zod-to-openapi</code>:</p> <pre><code>import { generateOpenAPI } from 'zod-to-openapi';\n// Auto-generate API documentation from schemas\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-design/#error-messages","title":"Error Messages","text":"<p>Zod provides detailed error messages for debugging:</p> <pre><code>try {\n  SceneDetailSchema.parse(data);\n} catch (e) {\n  if (e instanceof z.ZodError) {\n    console.error(e.issues); // Detailed path + message for each error\n  }\n}\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/","title":"Zod API Schemas Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Introduce Zod schemas as source of truth for Peek's API responses, decoupling from Stash types.</p> <p>Architecture: Create composable Zod schemas in <code>server/schemas/</code>, transform DB entities to validated API shapes, migrate endpoints incrementally.</p> <p>Tech Stack: Zod ^3.22, TypeScript, Express</p>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-1-install-zod-dependency","title":"Task 1: Install Zod Dependency","text":"<p>Files: - Modify: <code>server/package.json</code></p> <p>Step 1: Install zod</p> <pre><code>cd server &amp;&amp; npm install zod\n</code></pre> <p>Step 2: Verify installation</p> <p>Run: <code>npm list zod</code> Expected: <code>zod@3.x.x</code></p> <p>Step 3: Commit</p> <pre><code>git add package.json package-lock.json\ngit commit -m \"chore: add zod dependency\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-2-create-schema-directory-structure","title":"Task 2: Create Schema Directory Structure","text":"<p>Files: - Create: <code>server/schemas/index.ts</code> - Create: <code>server/schemas/base.ts</code> - Create: <code>server/schemas/refs.ts</code></p> <p>Step 1: Create schemas directory and base schemas</p> <p>Create <code>server/schemas/base.ts</code>: <pre><code>/**\n * Base Schemas\n *\n * Primitive and shared schemas used across all entity types.\n */\nimport { z } from \"zod\";\n\n/**\n * Pagination response metadata\n */\nexport const PaginationSchema = z.object({\n  page: z.number().int().positive(),\n  perPage: z.number().int().positive().max(100),\n  total: z.number().int().nonnegative(),\n  totalPages: z.number().int().nonnegative(),\n});\n\n/**\n * Date string in YYYY-MM-DD format\n */\nexport const DateStringSchema = z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/).nullable();\n\n/**\n * ISO timestamp string\n */\nexport const TimestampSchema = z.string().datetime().nullable();\n\n/**\n * Proxy URL path (starts with /api/proxy or is null)\n */\nexport const ProxyUrlSchema = z.string().nullable();\n\n// Type exports\nexport type Pagination = z.infer&lt;typeof PaginationSchema&gt;;\n</code></pre></p> <p>Step 2: Create reference schemas</p> <p>Create <code>server/schemas/refs.ts</code>: <pre><code>/**\n * Entity Reference Schemas\n *\n * Minimal reference types for embedding in other entities.\n * These represent \"just enough\" data to display and link.\n */\nimport { z } from \"zod\";\n\n/**\n * Base entity reference - id + name\n */\nexport const EntityRefSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n/**\n * Performer reference for embedding in scenes/galleries\n */\nexport const PerformerRefSchema = EntityRefSchema.extend({\n  image_path: z.string().nullable(),\n  gender: z.string().nullable(),\n  disambiguation: z.string().nullable(),\n});\n\n/**\n * Studio reference for embedding\n */\nexport const StudioRefSchema = EntityRefSchema.extend({\n  image_path: z.string().nullable(),\n});\n\n/**\n * Tag reference for embedding\n */\nexport const TagRefSchema = EntityRefSchema.extend({\n  image_path: z.string().nullable(),\n});\n\n/**\n * Group reference for embedding in scenes\n */\nexport const GroupRefSchema = EntityRefSchema.extend({\n  front_image_path: z.string().nullable(),\n});\n\n/**\n * Gallery reference for embedding\n */\nexport const GalleryRefSchema = z.object({\n  id: z.string(),\n  title: z.string().nullable(),\n  cover: z.string().nullable(),\n  image_count: z.number().nullable(),\n});\n\n// Type exports\nexport type EntityRef = z.infer&lt;typeof EntityRefSchema&gt;;\nexport type PerformerRef = z.infer&lt;typeof PerformerRefSchema&gt;;\nexport type StudioRef = z.infer&lt;typeof StudioRefSchema&gt;;\nexport type TagRef = z.infer&lt;typeof TagRefSchema&gt;;\nexport type GroupRef = z.infer&lt;typeof GroupRefSchema&gt;;\nexport type GalleryRef = z.infer&lt;typeof GalleryRefSchema&gt;;\n</code></pre></p> <p>Step 3: Create index re-export</p> <p>Create <code>server/schemas/index.ts</code>: <pre><code>/**\n * Schema Index\n *\n * Re-exports all Zod schemas for API validation.\n */\n\n// Base schemas\nexport * from \"./base.js\";\n\n// Reference schemas\nexport * from \"./refs.js\";\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add base and reference Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-3-create-scene-schemas","title":"Task 3: Create Scene Schemas","text":"<p>Files: - Create: <code>server/schemas/scene.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create scene schemas</p> <p>Create <code>server/schemas/scene.ts</code>: <pre><code>/**\n * Scene Schemas\n *\n * Zod schemas for scene API responses.\n */\nimport { z } from \"zod\";\nimport { PerformerRefSchema, StudioRefSchema, TagRefSchema, GroupRefSchema, GalleryRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Scene file information\n */\nexport const SceneFileSchema = z.object({\n  id: z.string(),\n  path: z.string(),\n  size: z.number(),\n  duration: z.number().nullable(),\n  width: z.number().nullable(),\n  height: z.number().nullable(),\n  bit_rate: z.number().nullable(),\n  frame_rate: z.number().nullable(),\n  video_codec: z.string().nullable(),\n  audio_codec: z.string().nullable(),\n});\n\n/**\n * Scene paths for media access\n */\nexport const ScenePathsSchema = z.object({\n  screenshot: ProxyUrlSchema,\n  preview: ProxyUrlSchema,\n  sprite: ProxyUrlSchema,\n  vtt: ProxyUrlSchema,\n  stream: ProxyUrlSchema,\n  webp: ProxyUrlSchema,\n  funscript: ProxyUrlSchema,\n  caption: ProxyUrlSchema,\n  interactive_heatmap: ProxyUrlSchema,\n});\n\n/**\n * Scene stream option\n */\nexport const SceneStreamSchema = z.object({\n  url: z.string(),\n  mime_type: z.string().nullable(),\n  label: z.string().nullable(),\n});\n\n/**\n * Group with scene index (for scene's groups array)\n */\nexport const SceneGroupSchema = GroupRefSchema.extend({\n  scene_index: z.number().nullable(),\n});\n\n/**\n * Full scene response - used for browse and detail\n */\nexport const SceneSchema = z.object({\n  // Core fields\n  id: z.string(),\n  title: z.string().nullable(),\n  code: z.string().nullable(),\n  details: z.string().nullable(),\n  director: z.string().nullable(),\n  date: z.string().nullable(),\n\n  // Technical fields\n  duration: z.number().nullable(),\n  organized: z.boolean(),\n\n  // Stash ratings (from server)\n  rating100: z.number().nullable(),\n\n  // Media paths\n  paths: ScenePathsSchema.nullable(),\n\n  // Streams\n  sceneStreams: z.array(SceneStreamSchema),\n\n  // Relationships\n  studio: StudioRefSchema.nullable(),\n  performers: z.array(PerformerRefSchema),\n  tags: z.array(TagRefSchema),\n  groups: z.array(SceneGroupSchema),\n  galleries: z.array(GalleryRefSchema),\n\n  // Files\n  files: z.array(SceneFileSchema),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n  o_counter: z.number(),\n  play_count: z.number(),\n  play_duration: z.number(),\n  resume_time: z.number(),\n  play_history: z.array(z.string()),\n  o_history: z.array(z.coerce.date()),\n  last_played_at: TimestampSchema,\n  last_o_at: TimestampSchema,\n\n  // Inherited tags\n  inheritedTagIds: z.array(z.string()).optional(),\n  inheritedTags: z.array(z.object({ id: z.string(), name: z.string() })).optional(),\n});\n\n/**\n * Scene list response\n */\nexport const FindScenesResponseSchema = z.object({\n  findScenes: z.object({\n    count: z.number(),\n    scenes: z.array(SceneSchema),\n  }),\n});\n\n// Type exports\nexport type SceneFile = z.infer&lt;typeof SceneFileSchema&gt;;\nexport type ScenePaths = z.infer&lt;typeof ScenePathsSchema&gt;;\nexport type SceneStream = z.infer&lt;typeof SceneStreamSchema&gt;;\nexport type Scene = z.infer&lt;typeof SceneSchema&gt;;\nexport type FindScenesResponse = z.infer&lt;typeof FindScenesResponseSchema&gt;;\n</code></pre></p> <p>Step 2: Update index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// Scene schemas\nexport * from \"./scene.js\";\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add scene Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-4-create-performer-schemas","title":"Task 4: Create Performer Schemas","text":"<p>Files: - Create: <code>server/schemas/performer.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create performer schemas</p> <p>Create <code>server/schemas/performer.ts</code>: <pre><code>/**\n * Performer Schemas\n *\n * Zod schemas for performer API responses.\n */\nimport { z } from \"zod\";\nimport { StudioRefSchema, TagRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Full performer response\n */\nexport const PerformerSchema = z.object({\n  // Core fields\n  id: z.string(),\n  name: z.string(),\n  disambiguation: z.string().nullable(),\n  gender: z.string().nullable(),\n\n  // Profile\n  birthdate: z.string().nullable(),\n  death_date: z.string().nullable(),\n  country: z.string().nullable(),\n  ethnicity: z.string().nullable(),\n  eye_color: z.string().nullable(),\n  hair_color: z.string().nullable(),\n  height_cm: z.number().nullable(),\n  weight: z.number().nullable(),\n  measurements: z.string().nullable(),\n  fake_tits: z.string().nullable(),\n  penis_length: z.number().nullable(),\n  circumcised: z.string().nullable(),\n  tattoos: z.string().nullable(),\n  piercings: z.string().nullable(),\n  career_length: z.string().nullable(),\n  details: z.string().nullable(),\n\n  // Media\n  image_path: ProxyUrlSchema,\n\n  // Lists\n  aliases: z.array(z.string()).nullable(),\n  urls: z.array(z.string()).nullable(),\n\n  // Relationships\n  tags: z.array(TagRefSchema),\n\n  // Counts from Stash\n  scene_count: z.number().nullable(),\n  image_count: z.number().nullable(),\n  gallery_count: z.number().nullable(),\n  group_count: z.number().nullable(),\n  performer_count: z.number().nullable(),\n  o_counter: z.number().nullable(),\n\n  // Stash ratings\n  rating100: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n  play_count: z.number(),\n  last_played_at: TimestampSchema,\n  last_o_at: TimestampSchema,\n});\n\n/**\n * Performer list response\n */\nexport const FindPerformersResponseSchema = z.object({\n  findPerformers: z.object({\n    count: z.number(),\n    performers: z.array(PerformerSchema),\n  }),\n});\n\n/**\n * Minimal performer (for dropdowns)\n */\nexport const PerformerMinimalSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n// Type exports\nexport type Performer = z.infer&lt;typeof PerformerSchema&gt;;\nexport type FindPerformersResponse = z.infer&lt;typeof FindPerformersResponseSchema&gt;;\nexport type PerformerMinimal = z.infer&lt;typeof PerformerMinimalSchema&gt;;\n</code></pre></p> <p>Step 2: Update index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// Performer schemas\nexport * from \"./performer.js\";\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add performer Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-5-create-tag-and-studio-schemas","title":"Task 5: Create Tag and Studio Schemas","text":"<p>Files: - Create: <code>server/schemas/tag.ts</code> - Create: <code>server/schemas/studio.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create tag schemas</p> <p>Create <code>server/schemas/tag.ts</code>: <pre><code>/**\n * Tag Schemas\n *\n * Zod schemas for tag API responses.\n */\nimport { z } from \"zod\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Tag parent reference (minimal)\n */\nexport const TagParentRefSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n/**\n * Full tag response\n */\nexport const TagSchema = z.object({\n  // Core fields\n  id: z.string(),\n  name: z.string(),\n  description: z.string().nullable(),\n  ignore_auto_tag: z.boolean(),\n\n  // Media\n  image_path: ProxyUrlSchema,\n\n  // Hierarchy\n  parents: z.array(TagParentRefSchema),\n  children: z.array(TagParentRefSchema),\n\n  // Counts from Stash\n  scene_count: z.number().nullable(),\n  image_count: z.number().nullable(),\n  gallery_count: z.number().nullable(),\n  performer_count: z.number().nullable(),\n  studio_count: z.number().nullable(),\n  group_count: z.number().nullable(),\n\n  // Peek computed counts\n  scene_count_via_performers: z.number(),\n\n  // Stash ratings\n  rating100: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n  o_counter: z.number(),\n  play_count: z.number(),\n});\n\n/**\n * Tag list response\n */\nexport const FindTagsResponseSchema = z.object({\n  findTags: z.object({\n    count: z.number(),\n    tags: z.array(TagSchema),\n  }),\n});\n\n/**\n * Minimal tag (for dropdowns)\n */\nexport const TagMinimalSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n// Type exports\nexport type Tag = z.infer&lt;typeof TagSchema&gt;;\nexport type FindTagsResponse = z.infer&lt;typeof FindTagsResponseSchema&gt;;\nexport type TagMinimal = z.infer&lt;typeof TagMinimalSchema&gt;;\n</code></pre></p> <p>Step 2: Create studio schemas</p> <p>Create <code>server/schemas/studio.ts</code>: <pre><code>/**\n * Studio Schemas\n *\n * Zod schemas for studio API responses.\n */\nimport { z } from \"zod\";\nimport { TagRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Studio parent reference (minimal)\n */\nexport const StudioParentRefSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  image_path: z.string().nullable(),\n});\n\n/**\n * Full studio response\n */\nexport const StudioSchema = z.object({\n  // Core fields\n  id: z.string(),\n  name: z.string(),\n  details: z.string().nullable(),\n  url: z.string().nullable(),\n  ignore_auto_tag: z.boolean(),\n\n  // Media\n  image_path: ProxyUrlSchema,\n\n  // Hierarchy\n  parent_studio: StudioParentRefSchema.nullable(),\n  child_studios: z.array(StudioParentRefSchema),\n\n  // Relationships\n  tags: z.array(TagRefSchema),\n\n  // Counts from Stash\n  scene_count: z.number().nullable(),\n  image_count: z.number().nullable(),\n  gallery_count: z.number().nullable(),\n  performer_count: z.number().nullable(),\n  group_count: z.number().nullable(),\n\n  // Stash ratings\n  rating100: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n  o_counter: z.number(),\n  play_count: z.number(),\n});\n\n/**\n * Studio list response\n */\nexport const FindStudiosResponseSchema = z.object({\n  findStudios: z.object({\n    count: z.number(),\n    studios: z.array(StudioSchema),\n  }),\n});\n\n/**\n * Minimal studio (for dropdowns)\n */\nexport const StudioMinimalSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n// Type exports\nexport type Studio = z.infer&lt;typeof StudioSchema&gt;;\nexport type FindStudiosResponse = z.infer&lt;typeof FindStudiosResponseSchema&gt;;\nexport type StudioMinimal = z.infer&lt;typeof StudioMinimalSchema&gt;;\n</code></pre></p> <p>Step 3: Update index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// Tag schemas\nexport * from \"./tag.js\";\n\n// Studio schemas\nexport * from \"./studio.js\";\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add tag and studio Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-6-create-gallery-and-image-schemas","title":"Task 6: Create Gallery and Image Schemas","text":"<p>Files: - Create: <code>server/schemas/gallery.ts</code> - Create: <code>server/schemas/image.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create gallery schemas</p> <p>Create <code>server/schemas/gallery.ts</code>: <pre><code>/**\n * Gallery Schemas\n *\n * Zod schemas for gallery API responses.\n */\nimport { z } from \"zod\";\nimport { PerformerRefSchema, StudioRefSchema, TagRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Full gallery response\n */\nexport const GallerySchema = z.object({\n  // Core fields\n  id: z.string(),\n  title: z.string().nullable(),\n  code: z.string().nullable(),\n  details: z.string().nullable(),\n  photographer: z.string().nullable(),\n  date: z.string().nullable(),\n  organized: z.boolean(),\n\n  // Media\n  cover: ProxyUrlSchema,\n  paths: z.object({\n    cover: ProxyUrlSchema,\n  }).nullable(),\n\n  // File info\n  folder: z.object({\n    path: z.string(),\n  }).nullable(),\n  files: z.array(z.object({\n    path: z.string(),\n  })),\n\n  // Relationships\n  studio: StudioRefSchema.nullable(),\n  performers: z.array(PerformerRefSchema),\n  tags: z.array(TagRefSchema),\n  scenes: z.array(z.object({ id: z.string(), title: z.string().nullable() })),\n\n  // Counts\n  image_count: z.number().nullable(),\n\n  // Stash ratings\n  rating100: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n});\n\n/**\n * Gallery list response\n */\nexport const FindGalleriesResponseSchema = z.object({\n  findGalleries: z.object({\n    count: z.number(),\n    galleries: z.array(GallerySchema),\n  }),\n});\n\n// Type exports\nexport type Gallery = z.infer&lt;typeof GallerySchema&gt;;\nexport type FindGalleriesResponse = z.infer&lt;typeof FindGalleriesResponseSchema&gt;;\n</code></pre></p> <p>Step 2: Create image schemas</p> <p>Create <code>server/schemas/image.ts</code>: <pre><code>/**\n * Image Schemas\n *\n * Zod schemas for image API responses.\n */\nimport { z } from \"zod\";\nimport { PerformerRefSchema, StudioRefSchema, TagRefSchema, GalleryRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Image file info\n */\nexport const ImageFileSchema = z.object({\n  path: z.string(),\n  size: z.number().nullable(),\n  width: z.number().nullable(),\n  height: z.number().nullable(),\n});\n\n/**\n * Image paths for media access\n */\nexport const ImagePathsSchema = z.object({\n  thumbnail: ProxyUrlSchema,\n  preview: ProxyUrlSchema,\n  image: ProxyUrlSchema,\n});\n\n/**\n * Full image response\n */\nexport const ImageSchema = z.object({\n  // Core fields\n  id: z.string(),\n  title: z.string().nullable(),\n  code: z.string().nullable(),\n  details: z.string().nullable(),\n  photographer: z.string().nullable(),\n  date: z.string().nullable(),\n  organized: z.boolean(),\n\n  // Media paths\n  paths: ImagePathsSchema.nullable(),\n\n  // File info\n  files: z.array(ImageFileSchema),\n\n  // Visual\n  visual_files: z.array(z.object({\n    width: z.number().nullable(),\n    height: z.number().nullable(),\n  })),\n\n  // Relationships\n  studio: StudioRefSchema.nullable(),\n  performers: z.array(PerformerRefSchema),\n  tags: z.array(TagRefSchema),\n  galleries: z.array(GalleryRefSchema),\n\n  // Stash ratings &amp; counters\n  rating100: z.number().nullable(),\n  o_counter: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  rating100: z.number().nullable(),\n  favorite: z.boolean(),\n  oCounter: z.number(),\n  viewCount: z.number(),\n  lastViewedAt: TimestampSchema,\n});\n\n/**\n * Image list response\n */\nexport const FindImagesResponseSchema = z.object({\n  findImages: z.object({\n    count: z.number(),\n    images: z.array(ImageSchema),\n  }),\n});\n\n// Type exports\nexport type ImageFile = z.infer&lt;typeof ImageFileSchema&gt;;\nexport type ImagePaths = z.infer&lt;typeof ImagePathsSchema&gt;;\nexport type Image = z.infer&lt;typeof ImageSchema&gt;;\nexport type FindImagesResponse = z.infer&lt;typeof FindImagesResponseSchema&gt;;\n</code></pre></p> <p>Step 3: Update index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// Gallery schemas\nexport * from \"./gallery.js\";\n\n// Image schemas\nexport * from \"./image.js\";\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add gallery and image Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-7-create-group-schemas","title":"Task 7: Create Group Schemas","text":"<p>Files: - Create: <code>server/schemas/group.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create group schemas</p> <p>Create <code>server/schemas/group.ts</code>: <pre><code>/**\n * Group Schemas\n *\n * Zod schemas for group API responses.\n */\nimport { z } from \"zod\";\nimport { StudioRefSchema, TagRefSchema } from \"./refs.js\";\nimport { ProxyUrlSchema, TimestampSchema } from \"./base.js\";\n\n/**\n * Full group response\n */\nexport const GroupSchema = z.object({\n  // Core fields\n  id: z.string(),\n  name: z.string(),\n  aliases: z.string().nullable(),\n  director: z.string().nullable(),\n  description: z.string().nullable(),\n  date: z.string().nullable(),\n  duration: z.number().nullable(),\n\n  // Media\n  front_image_path: ProxyUrlSchema,\n  back_image_path: ProxyUrlSchema,\n\n  // Relationships\n  studio: StudioRefSchema.nullable(),\n  tags: z.array(TagRefSchema),\n\n  // Containing group (if sub-group)\n  containing_groups: z.array(z.object({\n    group: z.object({\n      id: z.string(),\n      name: z.string(),\n    }),\n  })),\n  sub_groups: z.array(z.object({\n    group: z.object({\n      id: z.string(),\n      name: z.string(),\n    }),\n  })),\n\n  // Counts\n  scene_count: z.number().nullable(),\n\n  // Stash ratings\n  rating100: z.number().nullable(),\n\n  // Timestamps\n  created_at: TimestampSchema,\n  updated_at: TimestampSchema,\n\n  // User data (Peek-specific)\n  rating: z.number().nullable(),\n  favorite: z.boolean(),\n});\n\n/**\n * Group list response\n */\nexport const FindGroupsResponseSchema = z.object({\n  findGroups: z.object({\n    count: z.number(),\n    groups: z.array(GroupSchema),\n  }),\n});\n\n/**\n * Minimal group (for dropdowns)\n */\nexport const GroupMinimalSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\n// Type exports\nexport type Group = z.infer&lt;typeof GroupSchema&gt;;\nexport type FindGroupsResponse = z.infer&lt;typeof FindGroupsResponseSchema&gt;;\nexport type GroupMinimal = z.infer&lt;typeof GroupMinimalSchema&gt;;\n</code></pre></p> <p>Step 2: Update index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// Group schemas\nexport * from \"./group.js\";\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add group Zod schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-8-create-api-response-schemas","title":"Task 8: Create API Response Schemas","text":"<p>Files: - Create: <code>server/schemas/api/common.ts</code> - Create: <code>server/schemas/api/index.ts</code> - Modify: <code>server/schemas/index.ts</code></p> <p>Step 1: Create common API response schemas</p> <p>Create <code>server/schemas/api/common.ts</code>: <pre><code>/**\n * Common API Response Schemas\n *\n * Shared response patterns for API endpoints.\n */\nimport { z } from \"zod\";\n\n/**\n * Standard error response\n */\nexport const ApiErrorResponseSchema = z.object({\n  error: z.string(),\n  message: z.string().optional(),\n  details: z.string().optional(),\n  errorType: z.string().optional(),\n});\n\n/**\n * Standard success response\n */\nexport const ApiSuccessResponseSchema = z.object({\n  success: z.literal(true),\n  message: z.string().optional(),\n});\n\n/**\n * Cache not ready response (503)\n */\nexport const CacheNotReadyResponseSchema = z.object({\n  error: z.string(),\n  message: z.string(),\n  ready: z.literal(false),\n});\n\n/**\n * Pagination metadata in responses\n */\nexport const PaginationMetaSchema = z.object({\n  page: z.number(),\n  per_page: z.number(),\n  total: z.number(),\n  total_pages: z.number(),\n});\n\n// Type exports\nexport type ApiErrorResponse = z.infer&lt;typeof ApiErrorResponseSchema&gt;;\nexport type ApiSuccessResponse = z.infer&lt;typeof ApiSuccessResponseSchema&gt;;\nexport type CacheNotReadyResponse = z.infer&lt;typeof CacheNotReadyResponseSchema&gt;;\nexport type PaginationMeta = z.infer&lt;typeof PaginationMetaSchema&gt;;\n</code></pre></p> <p>Step 2: Create API index</p> <p>Create <code>server/schemas/api/index.ts</code>: <pre><code>/**\n * API Schema Index\n *\n * Re-exports all API-specific schemas.\n */\nexport * from \"./common.js\";\n</code></pre></p> <p>Step 3: Update main index</p> <p>Add to <code>server/schemas/index.ts</code>: <pre><code>// API response schemas\nexport * from \"./api/index.js\";\n</code></pre></p> <p>Step 4: Commit</p> <pre><code>git add server/schemas/\ngit commit -m \"feat: add common API response schemas\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-9-create-schema-test-file","title":"Task 9: Create Schema Test File","text":"<p>Files: - Create: <code>server/tests/schemas/schemas.test.ts</code></p> <p>Step 1: Create comprehensive schema tests</p> <p>Create <code>server/tests/schemas/schemas.test.ts</code>: <pre><code>/**\n * Schema Tests\n *\n * Verify Zod schemas accept valid data and reject invalid data.\n */\nimport { describe, it, expect } from \"vitest\";\nimport {\n  SceneSchema,\n  PerformerSchema,\n  TagSchema,\n  StudioSchema,\n  GallerySchema,\n  ImageSchema,\n  GroupSchema,\n  PerformerRefSchema,\n  StudioRefSchema,\n  TagRefSchema,\n} from \"../../schemas/index.js\";\n\ndescribe(\"Reference Schemas\", () =&gt; {\n  describe(\"PerformerRefSchema\", () =&gt; {\n    it(\"validates correct performer ref\", () =&gt; {\n      const valid = {\n        id: \"123\",\n        name: \"Test Performer\",\n        image_path: \"/api/proxy/stash?path=/performer/123\",\n        gender: \"FEMALE\",\n        disambiguation: null,\n      };\n      expect(() =&gt; PerformerRefSchema.parse(valid)).not.toThrow();\n    });\n\n    it(\"rejects missing required fields\", () =&gt; {\n      const invalid = { id: \"123\" };\n      expect(() =&gt; PerformerRefSchema.parse(invalid)).toThrow();\n    });\n  });\n\n  describe(\"StudioRefSchema\", () =&gt; {\n    it(\"validates correct studio ref\", () =&gt; {\n      const valid = {\n        id: \"456\",\n        name: \"Test Studio\",\n        image_path: null,\n      };\n      expect(() =&gt; StudioRefSchema.parse(valid)).not.toThrow();\n    });\n  });\n\n  describe(\"TagRefSchema\", () =&gt; {\n    it(\"validates correct tag ref\", () =&gt; {\n      const valid = {\n        id: \"789\",\n        name: \"Test Tag\",\n        image_path: \"/api/proxy/stash?path=/tag/789\",\n      };\n      expect(() =&gt; TagRefSchema.parse(valid)).not.toThrow();\n    });\n  });\n});\n\ndescribe(\"Entity Schemas\", () =&gt; {\n  describe(\"SceneSchema\", () =&gt; {\n    const validScene = {\n      id: \"1\",\n      title: \"Test Scene\",\n      code: \"TEST001\",\n      details: \"Description\",\n      director: \"Director\",\n      date: \"2024-01-15\",\n      duration: 1800,\n      organized: true,\n      rating100: 80,\n      paths: {\n        screenshot: \"/api/proxy/stash?path=/screenshot/1\",\n        preview: null,\n        sprite: null,\n        vtt: null,\n        stream: null,\n        webp: null,\n        funscript: null,\n        caption: null,\n        interactive_heatmap: null,\n      },\n      sceneStreams: [],\n      studio: { id: \"1\", name: \"Studio\", image_path: null },\n      performers: [],\n      tags: [],\n      groups: [],\n      galleries: [],\n      files: [],\n      created_at: \"2024-01-15T10:00:00Z\",\n      updated_at: \"2024-01-15T10:00:00Z\",\n      rating: 4,\n      favorite: true,\n      o_counter: 5,\n      play_count: 10,\n      play_duration: 3600,\n      resume_time: 500,\n      play_history: [],\n      o_history: [],\n      last_played_at: \"2024-01-15T10:00:00Z\",\n      last_o_at: null,\n    };\n\n    it(\"validates complete scene\", () =&gt; {\n      expect(() =&gt; SceneSchema.parse(validScene)).not.toThrow();\n    });\n\n    it(\"validates scene with null optional fields\", () =&gt; {\n      const sceneWithNulls = {\n        ...validScene,\n        title: null,\n        code: null,\n        studio: null,\n        paths: null,\n      };\n      expect(() =&gt; SceneSchema.parse(sceneWithNulls)).not.toThrow();\n    });\n\n    it(\"rejects scene with wrong type\", () =&gt; {\n      const invalid = { ...validScene, id: 123 };\n      expect(() =&gt; SceneSchema.parse(invalid)).toThrow();\n    });\n  });\n\n  describe(\"PerformerSchema\", () =&gt; {\n    const validPerformer = {\n      id: \"1\",\n      name: \"Test Performer\",\n      disambiguation: null,\n      gender: \"FEMALE\",\n      birthdate: \"1990-01-01\",\n      death_date: null,\n      country: \"US\",\n      ethnicity: null,\n      eye_color: \"Brown\",\n      hair_color: \"Black\",\n      height_cm: 165,\n      weight: null,\n      measurements: \"34-24-36\",\n      fake_tits: null,\n      penis_length: null,\n      circumcised: null,\n      tattoos: \"Left arm\",\n      piercings: null,\n      career_length: \"2010-\",\n      details: \"Bio here\",\n      image_path: \"/api/proxy/stash?path=/performer/1\",\n      aliases: [\"Alias 1\"],\n      urls: [\"https://example.com\"],\n      tags: [],\n      scene_count: 50,\n      image_count: 100,\n      gallery_count: 10,\n      group_count: 5,\n      performer_count: null,\n      o_counter: 25,\n      rating100: 90,\n      created_at: \"2024-01-01T00:00:00Z\",\n      updated_at: \"2024-01-15T00:00:00Z\",\n      rating: 5,\n      favorite: true,\n      play_count: 100,\n      last_played_at: \"2024-01-15T00:00:00Z\",\n      last_o_at: null,\n    };\n\n    it(\"validates complete performer\", () =&gt; {\n      expect(() =&gt; PerformerSchema.parse(validPerformer)).not.toThrow();\n    });\n  });\n\n  describe(\"TagSchema\", () =&gt; {\n    const validTag = {\n      id: \"1\",\n      name: \"Test Tag\",\n      description: \"Tag description\",\n      ignore_auto_tag: false,\n      image_path: null,\n      parents: [],\n      children: [{ id: \"2\", name: \"Child Tag\" }],\n      scene_count: 100,\n      image_count: 50,\n      gallery_count: 10,\n      performer_count: 5,\n      studio_count: 2,\n      group_count: 1,\n      scene_count_via_performers: 150,\n      rating100: null,\n      created_at: \"2024-01-01T00:00:00Z\",\n      updated_at: \"2024-01-15T00:00:00Z\",\n      rating: null,\n      favorite: false,\n      o_counter: 0,\n      play_count: 0,\n    };\n\n    it(\"validates complete tag\", () =&gt; {\n      expect(() =&gt; TagSchema.parse(validTag)).not.toThrow();\n    });\n  });\n});\n\ndescribe(\"Schema stripping\", () =&gt; {\n  it(\"SceneSchema.strip() removes extra fields\", () =&gt; {\n    const sceneWithExtra = {\n      id: \"1\",\n      title: \"Test\",\n      code: null,\n      details: null,\n      director: null,\n      date: null,\n      duration: null,\n      organized: false,\n      rating100: null,\n      paths: null,\n      sceneStreams: [],\n      studio: null,\n      performers: [],\n      tags: [],\n      groups: [],\n      galleries: [],\n      files: [],\n      created_at: null,\n      updated_at: null,\n      rating: null,\n      favorite: false,\n      o_counter: 0,\n      play_count: 0,\n      play_duration: 0,\n      resume_time: 0,\n      play_history: [],\n      o_history: [],\n      last_played_at: null,\n      last_o_at: null,\n      // Extra field that should be stripped\n      internalSecret: \"should-not-appear\",\n    };\n\n    const result = SceneSchema.strip().parse(sceneWithExtra);\n    expect(result).not.toHaveProperty(\"internalSecret\");\n    expect(result.id).toBe(\"1\");\n  });\n});\n</code></pre></p> <p>Step 2: Run tests</p> <p>Run: <code>npm run test:run -- tests/schemas/schemas.test.ts</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/schemas/\ngit commit -m \"test: add schema validation tests\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-10-build-and-test","title":"Task 10: Build and Test","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run TypeScript build</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds with no errors</p> <p>Step 2: Run linter</p> <p>Run: <code>npm run lint</code> Expected: No new errors (pre-existing warnings OK)</p> <p>Step 3: Run all tests</p> <p>Run: <code>npm run test:run</code> Expected: All tests pass including new schema tests</p> <p>Step 4: Commit any fixes if needed</p>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-11-create-schema-validation-utility","title":"Task 11: Create Schema Validation Utility","text":"<p>Files: - Create: <code>server/utils/schemaValidation.ts</code></p> <p>Step 1: Create validation utility</p> <p>Create <code>server/utils/schemaValidation.ts</code>: <pre><code>/**\n * Schema Validation Utilities\n *\n * Helpers for validating API responses with Zod schemas.\n */\nimport { z, ZodSchema, ZodError } from \"zod\";\nimport { logger } from \"./logger.js\";\n\n/**\n * Validate and strip extra fields from data\n *\n * @param schema - Zod schema to validate against\n * @param data - Data to validate\n * @param context - Context for error logging (e.g., \"scene response\")\n * @returns Validated and stripped data\n * @throws ZodError if validation fails\n */\nexport function validateResponse&lt;T extends ZodSchema&gt;(\n  schema: T,\n  data: unknown,\n  context: string\n): z.infer&lt;T&gt; {\n  try {\n    return schema.strip().parse(data);\n  } catch (error) {\n    if (error instanceof ZodError) {\n      logger.error(`Schema validation failed for ${context}`, {\n        issues: error.issues.map(i =&gt; ({\n          path: i.path.join(\".\"),\n          message: i.message,\n          code: i.code,\n        })),\n      });\n    }\n    throw error;\n  }\n}\n\n/**\n * Safely validate data, returning null on failure instead of throwing\n *\n * @param schema - Zod schema to validate against\n * @param data - Data to validate\n * @param context - Context for error logging\n * @returns Validated data or null if validation fails\n */\nexport function safeValidateResponse&lt;T extends ZodSchema&gt;(\n  schema: T,\n  data: unknown,\n  context: string\n): z.infer&lt;T&gt; | null {\n  try {\n    return validateResponse(schema, data, context);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Validate an array of items, filtering out invalid ones\n *\n * @param schema - Zod schema for individual items\n * @param items - Array of items to validate\n * @param context - Context for error logging\n * @returns Array of valid items (invalid items logged and filtered)\n */\nexport function validateArrayResponse&lt;T extends ZodSchema&gt;(\n  schema: T,\n  items: unknown[],\n  context: string\n): z.infer&lt;T&gt;[] {\n  const validItems: z.infer&lt;T&gt;[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    try {\n      validItems.push(schema.strip().parse(items[i]));\n    } catch (error) {\n      if (error instanceof ZodError) {\n        logger.warn(`Invalid item at index ${i} in ${context}`, {\n          issues: error.issues.map(i =&gt; ({\n            path: i.path.join(\".\"),\n            message: i.message,\n          })),\n        });\n      }\n    }\n  }\n\n  return validItems;\n}\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add server/utils/schemaValidation.ts\ngit commit -m \"feat: add schema validation utility functions\"\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-12-add-schema-documentation","title":"Task 12: Add Schema Documentation","text":"<p>Files: - Create: <code>server/schemas/README.md</code></p> <p>Step 1: Create documentation</p> <p>Create <code>server/schemas/README.md</code>: <pre><code># Zod Schemas\n\nThis directory contains Zod schemas that define the shape of Peek's API responses.\n\n## Philosophy\n\n1. **Schemas are the source of truth** - TypeScript types are derived from schemas using `z.infer&lt;T&gt;`\n2. **Composable fragments** - Build complex types from reusable pieces (refs \u2192 entities \u2192 responses)\n3. **Runtime validation** - Catch transformation bugs before clients see malformed data\n4. **Extra field stripping** - Use `.strip()` to ensure we never leak internal data\n\n## Directory Structure\n</code></pre> schemas/ \u251c\u2500\u2500 index.ts          # Main re-export barrel \u251c\u2500\u2500 base.ts           # Primitives (dates, timestamps, pagination) \u251c\u2500\u2500 refs.ts           # EntityRef schemas (id + name + minimal fields) \u251c\u2500\u2500 scene.ts          # Scene entity schemas \u251c\u2500\u2500 performer.ts      # Performer entity schemas \u251c\u2500\u2500 tag.ts            # Tag entity schemas \u251c\u2500\u2500 studio.ts         # Studio entity schemas \u251c\u2500\u2500 gallery.ts        # Gallery entity schemas \u251c\u2500\u2500 image.ts          # Image entity schemas \u251c\u2500\u2500 group.ts          # Group entity schemas \u2514\u2500\u2500 api/              # API response wrappers     \u251c\u2500\u2500 index.ts     \u2514\u2500\u2500 common.ts     # Error/success responses <pre><code>## Usage\n\n### Basic Validation\n\n```typescript\nimport { SceneSchema } from \"../schemas/index.js\";\nimport { validateResponse } from \"../utils/schemaValidation.js\";\n\n// In controller\nconst validatedScene = validateResponse(SceneSchema, scene, \"scene response\");\nres.json(validatedScene);\n</code></pre></p>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#type-inference","title":"Type Inference","text":"<pre><code>import { SceneSchema } from \"../schemas/index.js\";\nimport type { Scene } from \"../schemas/index.js\";\n\n// Type is inferred from schema\nconst scene: Scene = SceneSchema.parse(data);\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#stripping-extra-fields","title":"Stripping Extra Fields","text":"<pre><code>// Ensure no internal fields leak to client\nconst safeScene = SceneSchema.strip().parse(scene);\n</code></pre>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#migration-strategy","title":"Migration Strategy","text":"<p>Schemas are being adopted incrementally. Current status: - [ ] <code>/api/library/scenes</code> - Schema defined, not yet validated at runtime - [ ] <code>/api/library/performers</code> - Schema defined, not yet validated at runtime - [ ] Other endpoints - Pending</p> <p>To enable validation for an endpoint: 1. Import the appropriate schema 2. Use <code>validateResponse()</code> before <code>res.json()</code> 3. Test with invalid data to ensure errors are logged</p>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#adding-new-schemas","title":"Adding New Schemas","text":"<ol> <li>Create schema file in <code>schemas/</code> directory</li> <li>Export from <code>schemas/index.ts</code></li> <li>Add tests in <code>tests/schemas/schemas.test.ts</code></li> <li>Document any non-obvious field meanings <pre><code>**Step 2: Commit**\n\n```bash\ngit add server/schemas/README.md\ngit commit -m \"docs: add schema documentation\"\n</code></pre></li> </ol>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#task-13-final-build-and-test","title":"Task 13: Final Build and Test","text":"<p>Files: - None (verification only)</p> <p>Step 1: Clean build</p> <pre><code>cd server\nrm -rf dist\nnpm run build\n</code></pre> <p>Expected: Build succeeds</p> <p>Step 2: Run all unit tests</p> <p>Run: <code>npm run test:run</code> Expected: All tests pass</p> <p>Step 3: Run lint</p> <p>Run: <code>npm run lint</code> Expected: No errors</p> <p>Step 4: Create final summary commit if any cleanup needed</p>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#verification-checklist","title":"Verification Checklist","text":"<p>After completing all tasks:</p> <ul> <li> <code>npm run build</code> passes</li> <li> <code>npm run lint</code> passes</li> <li> <code>npm run test:run</code> passes</li> <li> <code>server/schemas/</code> directory contains:</li> <li><code>index.ts</code> (barrel export)</li> <li><code>base.ts</code> (primitives)</li> <li><code>refs.ts</code> (reference schemas)</li> <li><code>scene.ts</code>, <code>performer.ts</code>, <code>tag.ts</code>, <code>studio.ts</code>, <code>gallery.ts</code>, <code>image.ts</code>, <code>group.ts</code></li> <li><code>api/common.ts</code>, <code>api/index.ts</code></li> <li><code>README.md</code></li> <li> <code>server/utils/schemaValidation.ts</code> exists</li> <li> <code>server/tests/schemas/schemas.test.ts</code> exists and passes</li> <li> Zod is in <code>package.json</code> dependencies</li> </ul>"},{"location":"plans/2026-01-10-zod-api-schemas-implementation/#future-work","title":"Future Work","text":"<p>This implementation creates the schema infrastructure. Future tasks: 1. Enable runtime validation in controllers (endpoint by endpoint) 2. Create transform functions (<code>toSceneCard()</code>, <code>toPerformerDetail()</code>, etc.) 3. Migrate types/api/*.ts to use Zod-inferred types 4. Consider client-side schema sharing (monorepo) 5. Consider OpenAPI generation from schemas</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/","title":"Table/List View Improvements Design","text":""},{"location":"plans/2026-01-14-table-view-improvements-design/#overview","title":"Overview","text":"<p>This document covers improvements to the Table/List view feature to ensure: 1. Correct default columns per entity type 2. Proper image aspect ratios in table cells 3. All sortable/displayable columns are available 4. Visual distinction between sorted column headers and title/name links</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#1-default-columns-per-entity-type","title":"1. Default Columns Per Entity Type","text":""},{"location":"plans/2026-01-14-table-view-improvements-design/#performers","title":"Performers","text":"<p>Default visible (in order): Image, Name, Gender, Age, Country, Ethnicity, Scenes</p> <p>Current <code>PERFORMER_COLUMNS</code> issues: - Rating and Favorite are visible by default but shouldn't be - Gender, Age, Country, Ethnicity are hidden by default but should be visible - Scenes (scenes_count) is hidden by default but should be visible</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#studios","title":"Studios","text":"<p>Default visible (in order): Image, Name, Parent Studio, Scenes</p> <p>Current <code>STUDIO_COLUMNS</code> issues: - Rating is visible by default but shouldn't be - Parent Studio is hidden by default but should be visible</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#tags","title":"Tags","text":"<p>Default visible (in order): Image, Name, Scenes, Performers, Studios, Images</p> <p>Current <code>TAG_COLUMNS</code> issues: - Missing columns: Studios count, Images count - performer_count is hidden but should be visible</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#groups","title":"Groups","text":"<p>Default visible (in order): Image, Name, Date, Scenes, Performers, Tags</p> <p>Current <code>GROUP_COLUMNS</code> issues: - Rating is visible by default but shouldn't be - Missing columns: Performers, Tags - scene_count exists but needs to be visible</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#galleries","title":"Galleries","text":"<p>Default visible (in order): Cover (rename from Thumbnail), Title, Date, Studio, Images</p> <p>Current <code>GALLERY_COLUMNS</code> issues: - Thumbnail should be renamed to \"Cover\" - Rating is visible by default but shouldn't be - Studio is hidden but should be visible - Cover image not displaying (renderer issue)</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#images","title":"Images","text":"<p>Default visible (in order): Image (rename from Thumbnail), Title, Studio, Performers, Tags, Resolution</p> <p>Current <code>IMAGE_COLUMNS</code> issues: - Thumbnail should be renamed to \"Image\" - Rating is visible by default but shouldn't be - Studio, Performers, Tags are hidden but should be visible - Resolution is hidden but should be visible</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#2-image-aspect-ratios-in-table-cells","title":"2. Image Aspect Ratios in Table Cells","text":"<p>The <code>ThumbnailCell</code> component currently uses fixed dimensions (<code>w-16 h-10</code>). This needs to be entity-aware to match aspect ratios used elsewhere:</p> Entity Type Card Aspect Ratio Table Cell Dimensions Performer \u2154 (portrait) w-10 h-14 (portrait) Gallery \u2154 (portrait) w-10 h-14 (portrait) Group \u2154 (portrait) w-10 h-14 (portrait) Scene 16/9 (landscape) w-16 h-10 (landscape) - current Studio 16/9 (landscape) w-16 h-10 (landscape) - current Tag 16/9 (landscape) w-16 h-10 (landscape) - current Image variable w-10 h-10 (square) <p>Implementation: Create an entity-aware thumbnail component or pass entity type to <code>ThumbnailCell</code>.</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#3-missing-columns-sort-fields","title":"3. Missing Columns &amp; Sort Fields","text":""},{"location":"plans/2026-01-14-table-view-improvements-design/#columns-to-add","title":"Columns to Add","text":"<p>Scenes: - <code>created_at</code> - sortable, matches existing sort option</p> <p>Studios: - <code>gallery_count</code> - Galleries count (if sortable via API) - <code>image_count</code> - Images count - <code>performer_count</code> - Performers count - <code>group_count</code> - Groups/Collections count</p> <p>Tags: - <code>studio_count</code> - Studios count (need to verify API support) - <code>image_count</code> - Images count (need to verify API support)</p> <p>Groups: - <code>performers</code> - Multi-value cell showing performers in group - <code>tags</code> - Multi-value cell showing tags</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#sort-field-mapping","title":"Sort Field Mapping","text":"<p>Some columns need mapping to their sort field equivalents. The <code>COLUMN_SORT_FIELD_OVERRIDES</code> map handles this:</p> <pre><code>const COLUMN_SORT_FIELD_OVERRIDES = {\n  \"performer:age\": \"birthdate\",\n  \"performers:age\": \"birthdate\",\n  // Add any new mappings here\n};\n</code></pre>"},{"location":"plans/2026-01-14-table-view-improvements-design/#columns-that-should-be-sortable-currently-not","title":"Columns That Should Be Sortable (Currently Not)","text":"<p>Review each entity's sort options (<code>filterConfig.js</code>) and ensure corresponding columns exist:</p> <p>Scenes - all sort options have columns except: - <code>created_at</code> (missing column) - <code>bitrate</code>, <code>framerate</code>, <code>last_o_at</code>, <code>last_played_at</code>, <code>performer_count</code>, <code>play_duration</code>, <code>tag_count</code>, <code>updated_at</code> (consider adding)</p> <p>Performers - sort options vs columns: - <code>career_length</code>, <code>height</code>, <code>measurements</code>, <code>penis_length</code>, <code>weight</code> (no columns) - <code>created_at</code>, <code>updated_at</code>, <code>last_o_at</code>, <code>last_played_at</code>, <code>play_count</code> (no columns)</p> <p>Studios - sort options vs columns: - <code>created_at</code>, <code>updated_at</code>, <code>o_counter</code>, <code>play_count</code> (no columns)</p> <p>Tags - sort options vs columns: - <code>created_at</code>, <code>updated_at</code>, <code>o_counter</code>, <code>play_count</code> (no columns)</p> <p>Groups - sort options vs columns: - <code>created_at</code>, <code>updated_at</code> (no columns)</p> <p>Galleries - sort options vs columns: - <code>created_at</code>, <code>updated_at</code> (no columns)</p> <p>Images - sort options vs columns: - <code>created_at</code>, <code>updated_at</code>, <code>date</code> (no columns for created_at, updated_at)</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#4-visual-distinction-sorted-column-headers-vs-title-links","title":"4. Visual Distinction: Sorted Column Headers vs Title Links","text":""},{"location":"plans/2026-01-14-table-view-improvements-design/#current-state","title":"Current State","text":"<p>Both use <code>--accent-primary</code> (purple), making them visually indistinct.</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#solution-use-accent-secondary-for-sorted-column-headers","title":"Solution: Use <code>--accent-secondary</code> for Sorted Column Headers","text":"<p>TableHeader.jsx change: <pre><code>style={{\n  color: isSorted\n    ? \"var(--accent-secondary)\"  // Changed from accent-primary\n    : \"var(--text-primary)\",\n  opacity: isSortable ? 1 : 0.7,\n}}\n</code></pre></p> <p>This keeps Name/Title links as <code>--accent-primary</code> (the standard link color) while sorted column headers use <code>--accent-secondary</code> (pink in default theme), providing clear visual distinction.</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#5-gallery-cover-image-not-displaying","title":"5. Gallery Cover Image Not Displaying","text":"<p>The gallery thumbnail renderer references <code>gallery.cover?.paths?.thumbnail</code> but may not be receiving the cover data. Need to verify: 1. The GraphQL query includes cover image fields 2. The data path is correct</p>"},{"location":"plans/2026-01-14-table-view-improvements-design/#implementation-checklist","title":"Implementation Checklist","text":""},{"location":"plans/2026-01-14-table-view-improvements-design/#phase-1-column-configuration-updates","title":"Phase 1: Column Configuration Updates","text":"<ul> <li> Update <code>PERFORMER_COLUMNS</code> order and defaults</li> <li> Update <code>STUDIO_COLUMNS</code> order and defaults</li> <li> Update <code>TAG_COLUMNS</code> order, defaults, and add missing columns</li> <li> Update <code>GROUP_COLUMNS</code> order, defaults, and add missing columns</li> <li> Update <code>GALLERY_COLUMNS</code> - rename Thumbnail to Cover, fix defaults</li> <li> Update <code>IMAGE_COLUMNS</code> - rename Thumbnail to Image, fix defaults</li> <li> Add <code>SCENE_COLUMNS</code> created_at column</li> </ul>"},{"location":"plans/2026-01-14-table-view-improvements-design/#phase-2-cell-renderers","title":"Phase 2: Cell Renderers","text":"<ul> <li> Update <code>ThumbnailCell</code> to accept entity type and adjust aspect ratio</li> <li> Add renderers for new columns (studio_count, image_count, etc.)</li> <li> Fix gallery cover image renderer if needed</li> <li> Add group performers and tags renderers</li> </ul>"},{"location":"plans/2026-01-14-table-view-improvements-design/#phase-3-visual-distinction","title":"Phase 3: Visual Distinction","text":"<ul> <li> Update <code>TableHeader.jsx</code> to use <code>--accent-secondary</code> for sorted columns</li> </ul>"},{"location":"plans/2026-01-14-table-view-improvements-design/#phase-4-verify-api-support","title":"Phase 4: Verify API Support","text":"<ul> <li> Check if tag studio_count and image_count are available from API</li> <li> Check if additional sort fields need columns</li> <li> Verify gallery cover image data is being fetched</li> </ul>"},{"location":"plans/2026-01-14-table-view-improvements-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>client/src/config/tableColumns.js</code> - Column definitions</li> <li><code>client/src/components/table/cellRenderers.jsx</code> - Cell rendering</li> <li><code>client/src/components/table/TableHeader.jsx</code> - Sorted column styling</li> <li>Potentially GraphQL queries if data is missing</li> </ol>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/","title":"v3.2.0 Beta Feedback Design","text":"<p>Design spec for addressing user feedback from 3.2.0-beta.1 testing.</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#1-wall-view-restoration-bug-fix","title":"1. Wall View Restoration (Bug Fix)","text":"<p>Problem: When table view was added, the <code>VIEW_MODES</code> arrays were updated to only include <code>grid</code> and <code>table</code>, removing <code>wall</code>. The wall rendering logic still exists but users can't select it.</p> <p>Fix: Add <code>wall</code> back to VIEW_MODES in pages that previously supported it: - <code>SceneSearch.jsx</code>: <code>[grid, wall, table]</code> - <code>Galleries.jsx</code>: <code>[grid, wall, table]</code> - <code>Images.jsx</code>: <code>[grid, wall, table]</code></p> <p>Pages without wall support (Performers, Studios, Groups, Tags) remain unchanged.</p> <p>Files: - <code>client/src/components/scene-search/SceneSearch.jsx</code> - <code>client/src/components/pages/Galleries.jsx</code> - <code>client/src/components/pages/Images.jsx</code></p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#2-columns-button-icon-only-in-table-copy","title":"2. Columns Button: Icon-Only + In-Table Copy","text":"<p>Current: \"Columns\" button displays icon + text, only in toolbar above table.</p> <p>Changes: 1. Make toolbar button icon-only (just <code>LucideColumns3</code>, remove \"Columns\" text) 2. Add a columns button in the table header row - first cell, always visible regardless of column config 3. Both buttons open the same <code>ColumnConfigPopover</code></p> <p>Files: - <code>client/src/components/table/ColumnConfigPopover.jsx</code> - Remove text from button - <code>client/src/components/table/TableView.jsx</code> - Add columns button in header row</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#3-tag-hierarchy-view-expandcollapse-all","title":"3. Tag Hierarchy View: Expand/Collapse All","text":"<p>Current: Users must click individual chevrons to expand/collapse each node.</p> <p>Changes: Add two quick action buttons above the hierarchy tree: - Expand All - Expands every node in the tree - Collapse All - Collapses everything to root-level tags only</p> <p>Implementation: - Add <code>expandAll()</code> - collect all tag IDs with children, set all as expanded - Add <code>collapseAll()</code> - clear the expanded set - Buttons in header area with icons (<code>LucideChevronsUpDown</code>, <code>LucideChevronsDownUp</code>)</p> <p>Files: - <code>client/src/components/tags/TagHierarchyView.jsx</code></p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#4-table-headers-increased-padding","title":"4. Table Headers: Increased Padding","text":"<p>Current: Column headings use <code>px-3 py-2</code> padding. Sort icons cause overlap with adjacent column text.</p> <p>Changes: - Increase horizontal padding (calculate based on sort icon width + buffer) - Ensure sort icons have adequate spacing from label text - All column headings remain clearly legible with spacing</p> <p>Files: - <code>client/src/components/table/TableHeader.jsx</code></p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#5-tags-table-name-column-width","title":"5. Tags Table: Name Column Width","text":"<p>Status: Deferred - reassess after header padding fix (#4) is implemented. The Name column currently grows to fill available space; padding changes may naturally address this.</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#6-studios-table-image-display","title":"6. Studios Table: Image Display","text":"<p>Current: Studio images use <code>w-16 h-10</code> (64x40px) with <code>object-cover</code> (crops to fit).</p> <p>Problem: Studio images are logos with various aspect ratios (usually wide/landscape). Cropping cuts off important parts.</p> <p>Changes (matching StudioDetail approach): - Use <code>object-contain</code> instead of <code>object-cover</code> (no cropping) - Increase container size (e.g., <code>w-24 h-12</code> or <code>w-32 h-16</code>) - Add subtle background color for logos with transparency - Container allows flexible aspect ratio</p> <p>Files: - <code>client/src/components/table/cellRenderers.jsx</code> - Studio image renderer - <code>client/src/config/tableColumns.js</code> - STUDIO_COLUMNS image width</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#7-playlist-reordering-replace-drag-drop","title":"7. Playlist Reordering: Replace Drag &amp; Drop","text":"<p>Current: HTML5 drag-and-drop with touch support. Feedback: unusable.</p> <p>Changes: Replace with explicit position controls (like ColumnConfigPopover):</p> <p>Per-item controls: - Position input - Number field showing current position (1-indexed) - Arrow buttons - Up, Down, Top, Bottom</p> <p>Position input behavior: - Enter number \u2192 item moves to that position, others shift - Number &gt; max \u2192 moves to last position - Number \u2264 0 \u2192 moves to first position</p> <p>Button behavior: - Top: Move to position 1 - Up: Swap with item above - Down: Swap with item below - Bottom: Move to last position</p> <p>Remove: Drag handles, drag-and-drop handlers, touch handlers</p> <p>Keep: Reorder mode toggle, Save/Cancel workflow</p> <p>Files: - <code>client/src/components/pages/PlaylistDetail.jsx</code></p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#8-playlistdetail-performer-image-style","title":"8. PlaylistDetail: Performer Image Style","text":"<p>Current: Performer images use circular/rounded-full styling.</p> <p>Changes: Use portrait-style performer images consistent with: - Card indicator tooltips - Scene cards - Performer cards</p> <p>Rectangular portrait orientation with standard corner rounding (<code>rounded-md</code> or <code>rounded-lg</code>).</p> <p>Files: - <code>client/src/components/pages/PlaylistDetail.jsx</code> - Possibly <code>client/src/components/ui/SceneListItem.jsx</code> if performer display is there</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#9-playlistdetail-item-context-menu","title":"9. PlaylistDetail: Item Context Menu","text":"<p>Current: Playlist items only have a \"Remove\" button.</p> <p>Changes: Add ellipsis menu (vertical dots) in bottom-right of each playlist item.</p> <p>Initial menu contents: - \"Add to Other Playlist\" - Opens playlist selection (reuse <code>AddToPlaylistButton</code> logic)</p> <p>Implementation: - Exclude current playlist from selection list - Position: Bottom-right of item card - Style: Consistent with other context menus</p> <p>Future expansion: Menu can hold additional actions later.</p> <p>Files: - <code>client/src/components/pages/PlaylistDetail.jsx</code> - May create new component for the menu</p>"},{"location":"plans/2026-01-14-v3.2.0-feedback-design/#implementation-order","title":"Implementation Order","text":"<p>Recommended sequence: 1. Wall View fix (quick fix) 2. Table header padding (foundational, affects all tables) 3. Columns button changes 4. Studios table image display 5. Tags hierarchy expand/collapse 6. Playlist reordering overhaul 7. Playlist performer images 8. Playlist context menu 9. Reassess Tags name column width</p>"},{"location":"plans/2026-01-15-card-display-customization-design/","title":"Card Display Customization Design","text":"<p>Date: 2026-01-15 Version: 3.2.0 Status: Approved</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#overview","title":"Overview","text":"<p>This feature introduces card display customization for Peek 3.2.0, allowing users to control what information appears on entity cards and detail pages. Cards are the primary way users view content in Peek, so rather than introducing opinionated views, we give users granular control over card anatomy.</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#scope","title":"Scope","text":"<p>Three main customization areas:</p> <ol> <li>Scene Code - Toggle visibility of studio code (e.g., JAV codes) on Scene cards</li> <li>Description/Details - Toggle visibility per entity type, with separate settings for cards vs detail pages</li> <li>Rating/Favorite/O Counter - Toggle each control individually, per entity type, affecting both cards and detail pages</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#entity-types-covered","title":"Entity Types Covered","text":"<ul> <li>Scene</li> <li>Performer</li> <li>Studio</li> <li>Gallery</li> <li>Group</li> <li>Tag</li> <li>Image</li> </ul>"},{"location":"plans/2026-01-15-card-display-customization-design/#whats-not-customizable","title":"What's NOT Customizable","text":"<ul> <li>EntityMenu (3-dot menu) - Always visible for hide/action functionality</li> <li>Card indicators section - Out of scope for this phase</li> <li>Title/subtitle configuration - Out of scope for this phase</li> </ul>"},{"location":"plans/2026-01-15-card-display-customization-design/#prerequisites","title":"Prerequisites","text":"<p>Before implementing the customization layer:</p> <ol> <li>Add description display to PerformerCard and ImageCard - These currently hide descriptions; we need a uniform baseline</li> <li>Align skeleton loading heights - Skeletons must match actual card anatomy for seamless loading transitions</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#data-model","title":"Data Model","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#database-schema","title":"Database Schema","text":"<p>New field on User model in <code>schema.prisma</code>:</p> <pre><code>cardDisplaySettings Json? // Stored as JSON object\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  scene: {\n    showCodeOnCard: true,         // Scene-specific: studio code in subtitle\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  performer: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  studio: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  gallery: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  group: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  tag: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  },\n  image: {\n    showDescriptionOnCard: true,\n    showDescriptionOnDetail: true,\n    showRating: true,\n    showFavorite: true,\n    showOCounter: true\n  }\n}\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#defaults","title":"Defaults","text":"<ul> <li>All toggles default to <code>true</code> when not present (preserves current behavior)</li> <li><code>showCodeOnCard</code> only exists for <code>scene</code> entity type</li> </ul>"},{"location":"plans/2026-01-15-card-display-customization-design/#settings-ui","title":"Settings UI","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#settings-page-customization-section","title":"Settings Page (Customization Section)","text":"<p>Add a \"Card Display\" subsection under Customization with accordion/tabs per entity type:</p> <pre><code>Card Display\n\u251c\u2500\u2500 Scene\n\u2502   \u251c\u2500\u2500 [toggle] Show studio code on cards\n\u2502   \u251c\u2500\u2500 [toggle] Show description on cards\n\u2502   \u251c\u2500\u2500 [toggle] Show description on detail page\n\u2502   \u251c\u2500\u2500 [toggle] Show rating\n\u2502   \u251c\u2500\u2500 [toggle] Show favorite\n\u2502   \u2514\u2500\u2500 [toggle] Show O counter\n\u251c\u2500\u2500 Performer\n\u2502   \u251c\u2500\u2500 [toggle] Show description on cards\n\u2502   \u251c\u2500\u2500 [toggle] Show description on detail page\n\u2502   \u251c\u2500\u2500 [toggle] Show rating\n\u2502   \u251c\u2500\u2500 [toggle] Show favorite\n\u2502   \u2514\u2500\u2500 [toggle] Show O counter\n\u251c\u2500\u2500 Studio / Gallery / Group / Tag / Image\n\u2502   \u2514\u2500\u2500 ... (same pattern as Performer)\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#quick-access-contextsettings-settings-cog","title":"Quick Access (ContextSettings / Settings Cog)","text":"<p>Available on card grids and entity search pages. Shows only card-relevant toggles for the current entity type:</p> <pre><code>Card Display\n\u251c\u2500\u2500 [toggle] Show studio code (Scene only)\n\u251c\u2500\u2500 [toggle] Show description\n\u251c\u2500\u2500 [toggle] Show rating\n\u251c\u2500\u2500 [toggle] Show favorite\n\u2514\u2500\u2500 [toggle] Show O counter\n</code></pre> <p>Detail page toggles are only accessible via the main Settings page.</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#component-architecture","title":"Component Architecture","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#usecarddisplaysettings-hook","title":"useCardDisplaySettings Hook","text":"<pre><code>const { getSettings, updateSettings, isLoading } = useCardDisplaySettings();\n\n// Get settings for an entity type (returns defaults if not set)\nconst sceneSettings = getSettings('scene');\n// { showCodeOnCard: true, showDescriptionOnCard: true, ... }\n\n// Update a specific setting\nupdateSettings('scene', 'showCodeOnCard', false);\n</code></pre> <p>Features: - Fetches <code>cardDisplaySettings</code> from user API - Caches in React context to avoid prop drilling - Returns <code>true</code> defaults for missing settings - Debounced persistence to API</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#card-component-integration","title":"Card Component Integration","text":"<p>Each card reads from the hook and configures BaseCard:</p> <pre><code>// In SceneCard.jsx\nconst { getSettings } = useCardDisplaySettings();\nconst settings = getSettings('scene');\n\n// Build subtitle without code if disabled\nconst subtitle = buildSceneSubtitle(scene, { includeCode: settings.showCodeOnCard });\n\n&lt;BaseCard\n  displayPreferences={{\n    showDescription: settings.showDescriptionOnCard,\n  }}\n  ratingControlsProps={{\n    ...existingProps,\n    showRating: settings.showRating,\n    showFavorite: settings.showFavorite,\n    showOCounter: settings.showOCounter,\n  }}\n/&gt;\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#cardratingrow-changes","title":"CardRatingRow Changes","text":"<p>Accept visibility props for individual controls:</p> <pre><code>export const CardRatingRow = ({\n  showRating = true,\n  showFavorite = true,\n  showOCounter = true,\n  // ... existing props\n}) =&gt; {\n  return (\n    &lt;div className=\"flex justify-between items-center w-full my-1\" style={{ height: \"2rem\" }}&gt;\n      {/* Left side: Rating badge */}\n      {showRating &amp;&amp; (\n        &lt;RatingBadge ... /&gt;\n      )}\n\n      {/* Right side: Controls + EntityMenu */}\n      &lt;div className=\"flex items-center gap-2\"&gt;\n        {showOCounter &amp;&amp; &lt;OCounterButton ... /&gt;}\n        {showFavorite &amp;&amp; &lt;FavoriteButton ... /&gt;}\n        &lt;EntityMenu ... /&gt; {/* Always visible */}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#detail-page-integration","title":"Detail Page Integration","text":"<p>Detail pages read from the same hook:</p> <pre><code>const { getSettings } = useCardDisplaySettings();\nconst settings = getSettings('scene');\n\n{settings.showDescriptionOnDetail &amp;&amp; &lt;DescriptionSection ... /&gt;}\n{settings.showRating &amp;&amp; &lt;RatingControl ... /&gt;}\n{settings.showFavorite &amp;&amp; &lt;FavoriteButton ... /&gt;}\n{settings.showOCounter &amp;&amp; &lt;OCounterButton ... /&gt;}\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-design/#skeleton-loading","title":"Skeleton Loading","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#height-alignment","title":"Height Alignment","text":"<p>Skeletons must match actual card heights. Key fixed heights: - Image: aspect ratio (16/9 or \u2154 depending on entity) - Title: line height \u00d7 max lines - Description: line height \u00d7 max lines (when shown) - Indicators: 3.5rem - Rating row: 2rem</p> <p>Width is implicit from grid layout.</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#settings-aware-skeletons","title":"Settings-Aware Skeletons","text":"<p>Skeletons respect user settings to prevent jarring transitions:</p> <pre><code>const { getSettings } = useCardDisplaySettings();\nconst settings = getSettings('scene');\n\n&lt;SkeletonCard\n  entityType=\"scene\"\n  showDescription={settings.showDescriptionOnCard}\n  showRatingRow={settings.showRating || settings.showFavorite || settings.showOCounter}\n/&gt;\n</code></pre> <p>Since EntityMenu always shows, the rating row always renders - but skeleton contents adapt based on which controls are enabled.</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#behavior-notes","title":"Behavior Notes","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#grid-alignment","title":"Grid Alignment","text":"<p>Cards in a grid must have aligned anatomy (image edges, titles, descriptions align horizontally). When a section is toggled OFF: - Space collapses entirely (cards become shorter) - All cards of that entity type remain aligned with each other - Grids are single-entity-type, so cross-entity alignment is not a concern</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#playlistdetail-items","title":"PlaylistDetail Items","text":"<p>PlaylistDetail scene items follow the same settings as regular Scene cards.</p>"},{"location":"plans/2026-01-15-card-display-customization-design/#scene-code-toggle","title":"Scene Code Toggle","text":"<ul> <li>Only affects the card subtitle (removes code from \"CODE \u2022 2024-01-15 \u2022 Studio Name\")</li> <li>Scene detail page always shows the code in its dedicated location</li> </ul>"},{"location":"plans/2026-01-15-card-display-customization-design/#implementation-order","title":"Implementation Order","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#phase-1-foundation-prerequisites","title":"Phase 1: Foundation (Prerequisites)","text":"<ol> <li>Add description to PerformerCard and ImageCard</li> <li>Audit and fix skeleton heights to match actual card anatomy</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#phase-2-core-infrastructure","title":"Phase 2: Core Infrastructure","text":"<ol> <li>Database migration - Add <code>cardDisplaySettings</code> JSON field to User model</li> <li>API endpoint - Extend user settings endpoints to handle <code>cardDisplaySettings</code></li> <li>Create <code>useCardDisplaySettings</code> hook with React context</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#phase-3-card-customization","title":"Phase 3: Card Customization","text":"<ol> <li>Scene code toggle - Implement <code>showCodeOnCard</code> for Scene cards</li> <li>Description toggle (cards) - Implement <code>showDescriptionOnCard</code> for all entity types</li> <li>Rating controls toggles - Implement <code>showRating</code>, <code>showFavorite</code>, <code>showOCounter</code> for all entity types</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#phase-4-detail-page-integration","title":"Phase 4: Detail Page Integration","text":"<ol> <li>Description toggle (detail pages) - Implement <code>showDescriptionOnDetail</code></li> <li>Rating controls on detail pages - Hide controls based on same settings</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#phase-5-settings-ui","title":"Phase 5: Settings UI","text":"<ol> <li>Settings page UI - Add Card Display subsection to Customization</li> <li>ContextSettings integration - Add quick access to card grids</li> <li>Search page settings cog - Add quick access to entity search pages</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#phase-6-skeleton-adaptation","title":"Phase 6: Skeleton Adaptation","text":"<ol> <li>Update skeleton components to adapt to user's display settings</li> </ol>"},{"location":"plans/2026-01-15-card-display-customization-design/#file-changes","title":"File Changes","text":""},{"location":"plans/2026-01-15-card-display-customization-design/#new-files","title":"New Files","text":"<ul> <li><code>client/src/hooks/useCardDisplaySettings.js</code> - Settings hook/context</li> <li><code>server/prisma/migrations/XXXX_add_card_display_settings.sql</code> - Migration</li> </ul>"},{"location":"plans/2026-01-15-card-display-customization-design/#modified-files","title":"Modified Files","text":"<p>Database/API: - <code>server/prisma/schema.prisma</code> - Add <code>cardDisplaySettings</code> field - <code>server/src/routes/user.js</code> (or similar) - Handle new settings field</p> <p>Cards: - <code>client/src/components/ui/SceneCard.jsx</code> - Scene code toggle, pass display preferences - <code>client/src/components/ui/BaseCard.jsx</code> - May need minor adjustments for control visibility - <code>client/src/components/ui/CardComponents.jsx</code> - CardRatingRow visibility props - <code>client/src/components/cards/PerformerCard.jsx</code> - Add description, integrate settings - <code>client/src/components/cards/ImageCard.jsx</code> - Add description, integrate settings - <code>client/src/components/cards/StudioCard.jsx</code> - Integrate settings - <code>client/src/components/cards/GalleryCard.jsx</code> - Integrate settings - <code>client/src/components/cards/GroupCard.jsx</code> - Integrate settings - <code>client/src/components/cards/TagCard.jsx</code> - Integrate settings</p> <p>Detail Pages: - <code>client/src/components/pages/SceneDetails.jsx</code> - Respect settings - <code>client/src/components/pages/PerformerDetails.jsx</code> - Respect settings - <code>client/src/components/pages/StudioDetails.jsx</code> - Respect settings - <code>client/src/components/pages/GalleryDetails.jsx</code> - Respect settings - <code>client/src/components/pages/GroupDetails.jsx</code> - Respect settings - <code>client/src/components/pages/TagDetails.jsx</code> - Respect settings - <code>client/src/components/pages/ImageDetails.jsx</code> - Respect settings</p> <p>Skeletons: - <code>client/src/components/ui/SkeletonSceneCard.jsx</code> - Fix heights, respect settings - (may need entity-specific skeletons or a configurable component)</p> <p>Settings UI: - <code>client/src/components/pages/Settings.jsx</code> (or Customization section) - Card Display UI - <code>client/src/components/ui/ContextSettings.jsx</code> - Add card display options</p>"},{"location":"plans/2026-01-15-card-display-customization-implementation/","title":"Card Display Customization Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Allow users to customize what information appears on entity cards (scene code, descriptions, rating/favorite/O counter controls) with settings accessible from the Settings page and in-context via card grids.</p> <p>Architecture: Add a <code>cardDisplaySettings</code> JSON field to the User model storing per-entity-type visibility toggles. Create a React context/hook (<code>useCardDisplaySettings</code>) to provide settings throughout the app. Modify cards and detail pages to respect these settings.</p> <p>Tech Stack: Prisma (SQLite), Express API, React (Context API), existing UI patterns from CustomizationTab.</p>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-1-foundation","title":"Phase 1: Foundation","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-1-add-description-to-performercard","title":"Task 1: Add description to PerformerCard","text":"<p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Step 1: Add description prop to BaseCard</p> <p>In <code>PerformerCard.jsx</code>, remove <code>hideDescription</code> and add <code>description</code> prop:</p> <pre><code>// Line 86: Change from:\nhideDescription\n// To:\ndescription={performer.details}\n</code></pre> <p>Step 2: Verify visually</p> <p>Run: <code>npm run dev</code> (client) Navigate to Performers grid, verify performers with details now show descriptions.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/cards/PerformerCard.jsx\ngit commit -m \"feat(cards): show description on PerformerCard\n\nPerformers with details now display them on cards, matching other entity types.\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-2-add-description-to-imagecard","title":"Task 2: Add description to ImageCard","text":"<p>Files: - Modify: <code>client/src/components/cards/ImageCard.jsx</code></p> <p>Step 1: Add description prop to BaseCard</p> <p>Images don't have a direct description field, but they can inherit from galleries. Check if there's a description or title we can use. Looking at the code, images have a <code>title</code> field but no description. For consistency, we'll pass the image title as description if it exists and is different from what's shown as the card title.</p> <p>Actually, looking at the data model, images don't have a <code>description</code> field. The title is already shown. Skip this task - ImageCard doesn't need a description since images don't have one.</p> <p>Step 1: Verify ImageCard data model</p> <p>Images in the schema don't have a description field. The <code>title</code> is already displayed. No change needed for ImageCard description.</p> <p>Step 2: Commit (skip if no changes)</p> <p>No changes needed - ImageCard already doesn't show description because images don't have one.</p>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-3-audit-skeleton-vs-actual-card-heights","title":"Task 3: Audit skeleton vs actual card heights","text":"<p>Files: - Read: <code>client/src/components/ui/SkeletonSceneCard.jsx</code> - Read: <code>client/src/components/ui/BaseCard.jsx</code> - Read: <code>client/src/components/ui/CardComponents.jsx</code></p> <p>Step 1: Document current skeleton structure</p> <p>Current SkeletonSceneCard has: - Thumbnail: <code>aspect-video</code> (16:9) - Title: <code>h-5</code> (1.25rem) - Stats row: 3 items with <code>h-4</code> each - Metadata rows: performers, studio, tags with <code>h-3</code> each - Quality badges: <code>h-5</code> (1.25rem) - Rating row: <code>height: 2rem</code></p> <p>Step 2: Document actual card structure</p> <p>Actual cards have: - Image: aspect ratio via <code>useEntityImageAspectRatio</code> - Title: via <code>CardTitle</code> component - Description: via <code>CardDescription</code> (optional) - Indicators: via <code>CardIndicators</code> with fixed <code>height: 3.5rem</code> - Rating row: via <code>CardRatingRow</code> with fixed <code>height: 2rem</code></p> <p>Step 3: Identify mismatches</p> <p>The skeleton shows metadata rows (performers, studio, tags) which don't exist in the actual card structure. The actual card has: - Title (with optional subtitle) - Description (expandable) - Indicators (count badges) - Rating row</p> <p>The skeleton is outdated and doesn't match current card anatomy.</p>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-4-fix-skeletonscenecard-to-match-actual-card-anatomy","title":"Task 4: Fix SkeletonSceneCard to match actual card anatomy","text":"<p>Files: - Modify: <code>client/src/components/ui/SkeletonSceneCard.jsx</code></p> <p>Step 1: Rewrite skeleton to match BaseCard structure</p> <p>Replace the entire component with one that matches actual card anatomy:</p> <pre><code>/**\n * Skeleton loading card that matches BaseCard structure\n * Used in carousels and grids while data is loading\n */\nconst SkeletonSceneCard = ({ entityType = \"scene\" }) =&gt; {\n  // Match aspect ratio logic from useEntityImageAspectRatio\n  const aspectRatio = [\"performer\", \"gallery\", \"group\"].includes(entityType)\n    ? \"2/3\"\n    : \"16/9\";\n\n  return (\n    &lt;div\n      className=\"relative rounded-lg border overflow-hidden\"\n      style={{\n        backgroundColor: \"var(--bg-card)\",\n        borderColor: \"var(--border-color)\",\n        borderWidth: \"1px\",\n      }}\n    &gt;\n      {/* Image skeleton */}\n      &lt;div\n        className=\"relative animate-pulse\"\n        style={{\n          aspectRatio,\n          backgroundColor: \"var(--bg-tertiary)\",\n        }}\n      /&gt;\n\n      {/* Card content */}\n      &lt;div className=\"p-3 space-y-2\"&gt;\n        {/* Title skeleton */}\n        &lt;div\n          className=\"h-5 rounded animate-pulse\"\n          style={{\n            backgroundColor: \"var(--bg-tertiary)\",\n            width: \"85%\",\n          }}\n        /&gt;\n\n        {/* Subtitle skeleton */}\n        &lt;div\n          className=\"h-4 rounded animate-pulse\"\n          style={{\n            backgroundColor: \"var(--bg-tertiary)\",\n            width: \"60%\",\n          }}\n        /&gt;\n\n        {/* Description skeleton (2 lines) */}\n        &lt;div className=\"space-y-1\"&gt;\n          &lt;div\n            className=\"h-3 rounded animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"100%\",\n            }}\n          /&gt;\n          &lt;div\n            className=\"h-3 rounded animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"75%\",\n            }}\n          /&gt;\n        &lt;/div&gt;\n\n        {/* Indicators skeleton - matches CardIndicators height */}\n        &lt;div\n          className=\"flex items-center gap-2\"\n          style={{ height: \"3.5rem\" }}\n        &gt;\n          &lt;div\n            className=\"h-6 rounded-full animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"3rem\",\n            }}\n          /&gt;\n          &lt;div\n            className=\"h-6 rounded-full animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"3rem\",\n            }}\n          /&gt;\n          &lt;div\n            className=\"h-6 rounded-full animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"3rem\",\n            }}\n          /&gt;\n        &lt;/div&gt;\n\n        {/* Rating controls row skeleton - matches CardRatingRow height */}\n        &lt;div\n          className=\"flex justify-between items-center w-full\"\n          style={{ height: \"2rem\" }}\n        &gt;\n          {/* Rating badge placeholder */}\n          &lt;div\n            className=\"h-6 rounded-full animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              width: \"3.5rem\",\n            }}\n          /&gt;\n\n          {/* Right side: O Counter + Favorite + Menu */}\n          &lt;div className=\"flex items-center gap-2\"&gt;\n            &lt;div\n              className=\"h-6 w-6 rounded-full animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n            &lt;div\n              className=\"h-6 w-6 rounded-full animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n            &lt;div\n              className=\"h-6 w-6 rounded-full animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default SkeletonSceneCard;\n</code></pre> <p>Step 2: Verify skeleton matches loaded card</p> <p>Run: <code>npm run dev</code> Navigate to Scenes grid, observe skeleton during loading matches the loaded card structure.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/SkeletonSceneCard.jsx\ngit commit -m \"fix(skeleton): align SkeletonSceneCard with actual card anatomy\n\n- Match image aspect ratio\n- Add title and subtitle placeholders\n- Add description placeholder\n- Match indicators section height (3.5rem)\n- Match rating row height (2rem)\n- Remove outdated metadata rows\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-2-core-infrastructure","title":"Phase 2: Core Infrastructure","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-5-add-carddisplaysettings-to-database-schema","title":"Task 5: Add cardDisplaySettings to database schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add field to User model</p> <p>After line 30 (after <code>tableColumnDefaults</code>), add:</p> <pre><code>  cardDisplaySettings     Json? // Object with per-entity-type card display toggles: {scene: {showCodeOnCard, showDescriptionOnCard, ...}, performer: {...}, ...}\n</code></pre> <p>Step 2: Generate migration</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma migrate dev --name add_card_display_settings\n</code></pre></p> <p>Expected: Migration created successfully.</p> <p>Step 3: Commit</p> <pre><code>git add server/prisma/schema.prisma server/prisma/migrations/\ngit commit -m \"feat(db): add cardDisplaySettings field to User model\n\nJSON field for per-entity-type card display preferences:\n- showCodeOnCard (scene only)\n- showDescriptionOnCard\n- showDescriptionOnDetail\n- showRating\n- showFavorite\n- showOCounter\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-6-add-carddisplaysettings-to-user-settings-api","title":"Task 6: Add cardDisplaySettings to user settings API","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code></p> <p>Step 1: Add to GET /settings select</p> <p>Find the <code>select</code> object in the settings GET handler and add <code>cardDisplaySettings: true</code>.</p> <p>Step 2: Add to PUT /settings validation and update</p> <p>Add validation for <code>cardDisplaySettings</code> similar to <code>tableColumnDefaults</code>:</p> <pre><code>// In validation section\nif (cardDisplaySettings !== undefined) {\n  if (cardDisplaySettings !== null &amp;&amp; typeof cardDisplaySettings !== \"object\") {\n    return res.status(400).json({ error: \"Card display settings must be an object or null\" });\n  }\n}\n\n// In update data object\n...(cardDisplaySettings !== undefined &amp;&amp; { cardDisplaySettings }),\n</code></pre> <p>Step 3: Verify API works</p> <p>Run: <code>curl -X PUT http://localhost:3001/api/user/settings -H \"Content-Type: application/json\" -d '{\"cardDisplaySettings\": {\"scene\": {\"showCodeOnCard\": false}}}'</code></p> <p>Expected: 200 OK with updated settings.</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/user.ts\ngit commit -m \"feat(api): add cardDisplaySettings to user settings endpoints\n\n- Include in GET /user/settings response\n- Accept in PUT /user/settings with validation\n- Follows existing pattern for JSON settings fields\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-7-create-usecarddisplaysettings-hook","title":"Task 7: Create useCardDisplaySettings hook","text":"<p>Files: - Create: <code>client/src/hooks/useCardDisplaySettings.js</code> - Create: <code>client/src/contexts/CardDisplaySettingsContext.jsx</code></p> <p>Step 1: Create the context</p> <pre><code>// client/src/contexts/CardDisplaySettingsContext.jsx\nimport { createContext, useContext, useState, useEffect, useCallback } from \"react\";\nimport axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\n// Default settings - all features ON\nconst DEFAULT_ENTITY_SETTINGS = {\n  showDescriptionOnCard: true,\n  showDescriptionOnDetail: true,\n  showRating: true,\n  showFavorite: true,\n  showOCounter: true,\n};\n\nconst DEFAULT_SCENE_SETTINGS = {\n  ...DEFAULT_ENTITY_SETTINGS,\n  showCodeOnCard: true,\n};\n\nconst getDefaultSettings = (entityType) =&gt; {\n  if (entityType === \"scene\") {\n    return DEFAULT_SCENE_SETTINGS;\n  }\n  return DEFAULT_ENTITY_SETTINGS;\n};\n\nconst CardDisplaySettingsContext = createContext(null);\n\nexport const CardDisplaySettingsProvider = ({ children }) =&gt; {\n  const [settings, setSettings] = useState({});\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load settings on mount\n  useEffect(() =&gt; {\n    const loadSettings = async () =&gt; {\n      try {\n        const response = await api.get(\"/user/settings\");\n        setSettings(response.data.settings.cardDisplaySettings || {});\n      } catch (error) {\n        console.error(\"Failed to load card display settings:\", error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    loadSettings();\n  }, []);\n\n  // Get settings for a specific entity type (with defaults)\n  const getSettings = useCallback((entityType) =&gt; {\n    const defaults = getDefaultSettings(entityType);\n    const entitySettings = settings[entityType] || {};\n    return { ...defaults, ...entitySettings };\n  }, [settings]);\n\n  // Update a specific setting\n  const updateSettings = useCallback(async (entityType, key, value) =&gt; {\n    const newEntitySettings = {\n      ...(settings[entityType] || {}),\n      [key]: value,\n    };\n    const newSettings = {\n      ...settings,\n      [entityType]: newEntitySettings,\n    };\n\n    // Optimistic update\n    setSettings(newSettings);\n\n    try {\n      await api.put(\"/user/settings\", {\n        cardDisplaySettings: newSettings,\n      });\n    } catch (error) {\n      console.error(\"Failed to save card display settings:\", error);\n      // Revert on error\n      setSettings(settings);\n      throw error;\n    }\n  }, [settings]);\n\n  return (\n    &lt;CardDisplaySettingsContext.Provider value={{ getSettings, updateSettings, isLoading }}&gt;\n      {children}\n    &lt;/CardDisplaySettingsContext.Provider&gt;\n  );\n};\n\nexport const useCardDisplaySettings = () =&gt; {\n  const context = useContext(CardDisplaySettingsContext);\n  if (!context) {\n    throw new Error(\"useCardDisplaySettings must be used within CardDisplaySettingsProvider\");\n  }\n  return context;\n};\n</code></pre> <p>Step 2: Add provider to app</p> <p>Find the main App component and wrap with <code>CardDisplaySettingsProvider</code>. This is likely in <code>client/src/App.jsx</code> or similar.</p> <p>Step 3: Verify hook works</p> <p>Add a console.log in a card component to verify settings are accessible.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/contexts/CardDisplaySettingsContext.jsx\ngit commit -m \"feat(client): add CardDisplaySettingsContext and useCardDisplaySettings hook\n\n- Provides card display settings throughout the app\n- getSettings(entityType) returns settings with defaults\n- updateSettings(entityType, key, value) persists changes\n- Optimistic updates with error rollback\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-8-wire-up-carddisplaysettingsprovider-in-app","title":"Task 8: Wire up CardDisplaySettingsProvider in App","text":"<p>Files: - Modify: <code>client/src/App.jsx</code> (or wherever providers are configured)</p> <p>Step 1: Import and add provider</p> <pre><code>import { CardDisplaySettingsProvider } from \"./contexts/CardDisplaySettingsContext.jsx\";\n\n// Wrap existing content with provider (inside other providers)\n&lt;CardDisplaySettingsProvider&gt;\n  {/* existing app content */}\n&lt;/CardDisplaySettingsProvider&gt;\n</code></pre> <p>Step 2: Verify no errors</p> <p>Run: <code>npm run dev</code> Expected: App loads without errors.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/App.jsx\ngit commit -m \"feat(client): wire up CardDisplaySettingsProvider in App\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-3-card-customization","title":"Phase 3: Card Customization","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-9-implement-scene-code-toggle-on-scenecard","title":"Task 9: Implement scene code toggle on SceneCard","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code></p> <p>Step 1: Import useCardDisplaySettings</p> <pre><code>import { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\n</code></pre> <p>Step 2: Use settings to control code in subtitle</p> <p>Find where the subtitle is built (likely around line 25-30 where <code>scene.code</code> is used). Modify to check settings:</p> <pre><code>const { getSettings } = useCardDisplaySettings();\nconst sceneSettings = getSettings(\"scene\");\n\n// In subtitle building logic:\nif (sceneSettings.showCodeOnCard &amp;&amp; scene.code) {\n  parts.push(scene.code);\n}\n</code></pre> <p>Step 3: Verify toggle works</p> <p>Manually set <code>showCodeOnCard: false</code> in database, verify code disappears from scene cards.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/SceneCard.jsx\ngit commit -m \"feat(cards): implement scene code toggle on SceneCard\n\nScene code (e.g., JAV codes) in subtitle now respects showCodeOnCard setting.\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-10-implement-description-toggle-on-cards","title":"Task 10: Implement description toggle on cards","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code> - Modify: <code>client/src/components/cards/PerformerCard.jsx</code> - Modify: <code>client/src/components/cards/StudioCard.jsx</code> - Modify: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/GroupCard.jsx</code> - Modify: <code>client/src/components/cards/TagCard.jsx</code></p> <p>Step 1: Update each card to use settings</p> <p>For each card component:</p> <ol> <li>Import <code>useCardDisplaySettings</code></li> <li>Get settings for entity type</li> <li>Pass <code>displayPreferences={{ showDescription: settings.showDescriptionOnCard }}</code> to BaseCard</li> </ol> <p>Example for StudioCard:</p> <pre><code>import { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\n\n// Inside component:\nconst { getSettings } = useCardDisplaySettings();\nconst studioSettings = getSettings(\"studio\");\n\n// In BaseCard props:\ndisplayPreferences={{ showDescription: studioSettings.showDescriptionOnCard }}\n</code></pre> <p>Step 2: Verify each card respects setting</p> <p>Test by setting <code>showDescriptionOnCard: false</code> for each entity type.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/SceneCard.jsx client/src/components/cards/*.jsx\ngit commit -m \"feat(cards): implement description toggle for all card types\n\nAll entity cards now respect showDescriptionOnCard setting from user preferences.\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-11-implement-rating-controls-toggles","title":"Task 11: Implement rating controls toggles","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code> (CardRatingRow) - Modify: All card components to pass visibility props</p> <p>Step 1: Add visibility props to CardRatingRow</p> <p>Modify <code>CardRatingRow</code> to accept and respect visibility props:</p> <pre><code>export const CardRatingRow = ({\n  entityType,\n  entityId,\n  initialRating,\n  initialFavorite,\n  initialOCounter,\n  entityTitle,\n  onHideSuccess,\n  onOCounterChange,\n  onRatingChange,\n  onFavoriteChange,\n  // NEW: visibility controls\n  showRating = true,\n  showFavorite = true,\n  showOCounter = true,\n}) =&gt; {\n  // ... existing state and handlers ...\n\n  return (\n    &lt;&gt;\n      &lt;div\n        className=\"flex justify-between items-center w-full my-1\"\n        style={{ height: \"2rem\" }}\n      &gt;\n        {/* Left side: Rating badge (conditional) */}\n        &lt;div ref={badgeRef}&gt;\n          {showRating ? (\n            &lt;RatingBadge\n              rating={rating}\n              onClick={() =&gt; setDialogOpen(true)}\n              size=\"small\"\n            /&gt;\n          ) : (\n            &lt;div /&gt; {/* Empty placeholder to maintain layout */}\n          )}\n        &lt;/div&gt;\n\n        {/* Right side: O Counter + Favorite + EntityMenu */}\n        &lt;div className=\"flex items-center gap-2\"&gt;\n          {showOCounter &amp;&amp; (\n            &lt;OCounterButton\n              sceneId={entityType === \"scene\" ? entityId : null}\n              imageId={entityType === \"image\" ? entityId : null}\n              initialCount={oCounter ?? 0}\n              onChange={handleOCounterChange}\n              size=\"small\"\n              variant=\"card\"\n              interactive={isSceneOrImage}\n            /&gt;\n          )}\n          {showFavorite &amp;&amp; (\n            &lt;FavoriteButton\n              isFavorite={isFavorite}\n              onChange={handleFavoriteChange}\n              size=\"small\"\n              variant=\"card\"\n            /&gt;\n          )}\n          &lt;EntityMenu\n            entityType={entityType}\n            entityId={entityId}\n            entityName={entityTitle}\n            onHide={handleHideClick}\n          /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Dialogs only needed if controls are shown */}\n      {showRating &amp;&amp; (\n        &lt;RatingSliderDialog\n          isOpen={dialogOpen}\n          onClose={() =&gt; setDialogOpen(false)}\n          initialRating={rating}\n          onSave={handleRatingSave}\n          entityType={entityType}\n          entityTitle={entityTitle}\n          anchorEl={badgeRef.current}\n        /&gt;\n      )}\n\n      &lt;HideConfirmationDialog\n        isOpen={hideDialogOpen}\n        onClose={handleHideCancel}\n        onConfirm={handleHideConfirm}\n        entityType={pendingHide?.entityType}\n        entityName={pendingHide?.entityName}\n      /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre> <p>Step 2: Update all cards to pass visibility props</p> <p>Each card needs to get settings and pass to ratingControlsProps:</p> <pre><code>const { getSettings } = useCardDisplaySettings();\nconst settings = getSettings(\"scene\"); // or appropriate entity type\n\n// In ratingControlsProps:\nratingControlsProps={{\n  ...existingProps,\n  showRating: settings.showRating,\n  showFavorite: settings.showFavorite,\n  showOCounter: settings.showOCounter,\n}}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/SceneCard.jsx client/src/components/cards/*.jsx\ngit commit -m \"feat(cards): implement rating/favorite/O counter visibility toggles\n\n- CardRatingRow accepts showRating, showFavorite, showOCounter props\n- All card components pass settings to control visibility\n- EntityMenu always visible for hide functionality\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-4-detail-page-integration","title":"Phase 4: Detail Page Integration","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-12-implement-settings-on-scenedetails","title":"Task 12: Implement settings on SceneDetails","text":"<p>Files: - Modify: <code>client/src/components/pages/SceneDetails.jsx</code></p> <p>Step 1: Import and use settings</p> <pre><code>import { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\n\n// Inside component:\nconst { getSettings } = useCardDisplaySettings();\nconst sceneSettings = getSettings(\"scene\");\n</code></pre> <p>Step 2: Conditionally render description</p> <p>Wrap description section:</p> <pre><code>{sceneSettings.showDescriptionOnDetail &amp;&amp; scene.details &amp;&amp; (\n  &lt;DescriptionSection details={scene.details} /&gt;\n)}\n</code></pre> <p>Step 3: Conditionally render rating controls</p> <p>Find where RatingSlider, FavoriteButton, OCounterButton are rendered and wrap:</p> <pre><code>{sceneSettings.showRating &amp;&amp; &lt;RatingSlider ... /&gt;}\n{sceneSettings.showFavorite &amp;&amp; &lt;FavoriteButton ... /&gt;}\n{sceneSettings.showOCounter &amp;&amp; &lt;OCounterButton ... /&gt;}\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add client/src/components/pages/SceneDetails.jsx\ngit commit -m \"feat(detail): implement display settings on SceneDetails page\n\n- Description respects showDescriptionOnDetail\n- Rating/Favorite/O Counter respect visibility settings\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-13-implement-settings-on-other-detail-pages","title":"Task 13: Implement settings on other detail pages","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetails.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetails.jsx</code> - Modify: <code>client/src/components/pages/GroupDetails.jsx</code> - Modify: <code>client/src/components/pages/TagDetails.jsx</code> - Modify: <code>client/src/components/pages/ImageDetails.jsx</code> (if exists)</p> <p>Step 1: Apply same pattern to each detail page</p> <p>For each: 1. Import <code>useCardDisplaySettings</code> 2. Get settings for entity type 3. Conditionally render description based on <code>showDescriptionOnDetail</code> 4. Conditionally render rating controls based on <code>showRating</code>, <code>showFavorite</code>, <code>showOCounter</code></p> <p>Step 2: Commit</p> <pre><code>git add client/src/components/pages/*Detail*.jsx\ngit commit -m \"feat(detail): implement display settings on all detail pages\n\nAll entity detail pages now respect card display settings for:\n- Description visibility\n- Rating/Favorite/O Counter visibility\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-5-settings-ui","title":"Phase 5: Settings UI","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-14-create-carddisplaysettings-component","title":"Task 14: Create CardDisplaySettings component","text":"<p>Files: - Create: <code>client/src/components/settings/CardDisplaySettings.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\nimport { showSuccess, showError } from \"../../utils/toast.jsx\";\n\nconst ENTITY_TYPES = [\n  { id: \"scene\", label: \"Scene\", hasCode: true },\n  { id: \"performer\", label: \"Performer\", hasCode: false },\n  { id: \"studio\", label: \"Studio\", hasCode: false },\n  { id: \"gallery\", label: \"Gallery\", hasCode: false },\n  { id: \"group\", label: \"Group\", hasCode: false },\n  { id: \"tag\", label: \"Tag\", hasCode: false },\n  { id: \"image\", label: \"Image\", hasCode: false },\n];\n\nconst Toggle = ({ label, checked, onChange, description }) =&gt; (\n  &lt;label className=\"flex items-start gap-3 cursor-pointer\"&gt;\n    &lt;input\n      type=\"checkbox\"\n      checked={checked}\n      onChange={(e) =&gt; onChange(e.target.checked)}\n      className=\"mt-1 w-4 h-4 rounded\"\n      style={{\n        accentColor: \"var(--accent-primary)\",\n      }}\n    /&gt;\n    &lt;div&gt;\n      &lt;span style={{ color: \"var(--text-primary)\" }}&gt;{label}&lt;/span&gt;\n      {description &amp;&amp; (\n        &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n          {description}\n        &lt;/p&gt;\n      )}\n    &lt;/div&gt;\n  &lt;/label&gt;\n);\n\nconst EntitySettingsSection = ({ entityType, label, hasCode }) =&gt; {\n  const { getSettings, updateSettings } = useCardDisplaySettings();\n  const settings = getSettings(entityType);\n\n  const handleChange = async (key, value) =&gt; {\n    try {\n      await updateSettings(entityType, key, value);\n      showSuccess(\"Setting saved\");\n    } catch {\n      showError(\"Failed to save setting\");\n    }\n  };\n\n  return (\n    &lt;div className=\"space-y-3\"&gt;\n      &lt;h4\n        className=\"font-medium\"\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        {label}\n      &lt;/h4&gt;\n      &lt;div className=\"space-y-2 pl-2\"&gt;\n        {hasCode &amp;&amp; (\n          &lt;Toggle\n            label=\"Show studio code on cards\"\n            checked={settings.showCodeOnCard}\n            onChange={(v) =&gt; handleChange(\"showCodeOnCard\", v)}\n            description=\"Display scene codes (e.g., JAV codes) in card subtitles\"\n          /&gt;\n        )}\n        &lt;Toggle\n          label=\"Show description on cards\"\n          checked={settings.showDescriptionOnCard}\n          onChange={(v) =&gt; handleChange(\"showDescriptionOnCard\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show description on detail page\"\n          checked={settings.showDescriptionOnDetail}\n          onChange={(v) =&gt; handleChange(\"showDescriptionOnDetail\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show rating\"\n          checked={settings.showRating}\n          onChange={(v) =&gt; handleChange(\"showRating\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show favorite\"\n          checked={settings.showFavorite}\n          onChange={(v) =&gt; handleChange(\"showFavorite\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show O counter\"\n          checked={settings.showOCounter}\n          onChange={(v) =&gt; handleChange(\"showOCounter\", v)}\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst CardDisplaySettings = () =&gt; {\n  const [expandedEntity, setExpandedEntity] = useState(\"scene\");\n\n  return (\n    &lt;div&gt;\n      &lt;h3\n        className=\"text-lg font-semibold mb-4\"\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        Card Display\n      &lt;/h3&gt;\n      &lt;p className=\"text-sm mb-4\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Control what information appears on entity cards and detail pages.\n      &lt;/p&gt;\n\n      {/* Accordion-style entity sections */}\n      &lt;div className=\"space-y-2\"&gt;\n        {ENTITY_TYPES.map(({ id, label, hasCode }) =&gt; (\n          &lt;div\n            key={id}\n            className=\"rounded-lg border\"\n            style={{\n              backgroundColor: \"var(--bg-secondary)\",\n              borderColor: \"var(--border-color)\",\n            }}\n          &gt;\n            &lt;button\n              onClick={() =&gt; setExpandedEntity(expandedEntity === id ? null : id)}\n              className=\"w-full px-4 py-3 flex justify-between items-center\"\n              style={{ color: \"var(--text-primary)\" }}\n            &gt;\n              &lt;span className=\"font-medium\"&gt;{label}&lt;/span&gt;\n              &lt;span&gt;{expandedEntity === id ? \"\u2212\" : \"+\"}&lt;/span&gt;\n            &lt;/button&gt;\n            {expandedEntity === id &amp;&amp; (\n              &lt;div className=\"px-4 pb-4\"&gt;\n                &lt;EntitySettingsSection\n                  entityType={id}\n                  label={label}\n                  hasCode={hasCode}\n                /&gt;\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CardDisplaySettings;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/CardDisplaySettings.jsx\ngit commit -m \"feat(settings): create CardDisplaySettings component\n\nAccordion-style UI for configuring card display per entity type:\n- Scene code toggle (scene only)\n- Description toggles (cards and detail pages)\n- Rating/Favorite/O Counter toggles\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-15-add-carddisplaysettings-to-customizationtab","title":"Task 15: Add CardDisplaySettings to CustomizationTab","text":"<p>Files: - Modify: <code>client/src/components/settings/tabs/CustomizationTab.jsx</code></p> <p>Step 1: Import and add component</p> <pre><code>import CardDisplaySettings from \"../CardDisplaySettings.jsx\";\n\n// In the return, add after View Preferences section (around line 203):\n{/* Card Display Settings */}\n&lt;div\n  className=\"p-6 rounded-lg border\"\n  style={{\n    backgroundColor: \"var(--bg-card)\",\n    borderColor: \"var(--border-color)\",\n  }}\n&gt;\n  &lt;CardDisplaySettings /&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 2: Verify in UI</p> <p>Run: <code>npm run dev</code> Navigate to Settings &gt; Customization, verify Card Display section appears.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/tabs/CustomizationTab.jsx\ngit commit -m \"feat(settings): add CardDisplaySettings to Customization tab\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-16-add-card-display-to-contextsettings","title":"Task 16: Add card display to ContextSettings","text":"<p>Files: - Modify: <code>client/src/components/ui/ContextSettings.jsx</code></p> <p>Step 1: Extend ContextSettings to support card display settings</p> <p>Add a new section for card display when entity type is provided:</p> <pre><code>// Add prop for entityType\nconst ContextSettings = ({ settings, onSettingChange, entityType }) =&gt; {\n  const { getSettings, updateSettings } = useCardDisplaySettings();\n  const cardSettings = entityType ? getSettings(entityType) : null;\n\n  // ... existing code ...\n\n  // Add card display section when entityType is provided\n  {entityType &amp;&amp; cardSettings &amp;&amp; (\n    &lt;div className=\"border-t pt-3 mt-3\" style={{ borderColor: \"var(--border-color)\" }}&gt;\n      &lt;h4 className=\"text-sm font-medium mb-2\" style={{ color: \"var(--text-secondary)\" }}&gt;\n        Card Display\n      &lt;/h4&gt;\n      &lt;div className=\"space-y-2\"&gt;\n        {entityType === \"scene\" &amp;&amp; (\n          &lt;Toggle\n            label=\"Show code\"\n            checked={cardSettings.showCodeOnCard}\n            onChange={(v) =&gt; updateSettings(entityType, \"showCodeOnCard\", v)}\n          /&gt;\n        )}\n        &lt;Toggle\n          label=\"Show description\"\n          checked={cardSettings.showDescriptionOnCard}\n          onChange={(v) =&gt; updateSettings(entityType, \"showDescriptionOnCard\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show rating\"\n          checked={cardSettings.showRating}\n          onChange={(v) =&gt; updateSettings(entityType, \"showRating\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show favorite\"\n          checked={cardSettings.showFavorite}\n          onChange={(v) =&gt; updateSettings(entityType, \"showFavorite\", v)}\n        /&gt;\n        &lt;Toggle\n          label=\"Show O counter\"\n          checked={cardSettings.showOCounter}\n          onChange={(v) =&gt; updateSettings(entityType, \"showOCounter\", v)}\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )}\n};\n</code></pre> <p>Step 2: Update grid components to pass entityType to ContextSettings</p> <p>Find where ContextSettings is used in grids and pass the entityType prop.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/ContextSettings.jsx\ngit commit -m \"feat(ui): add card display toggles to ContextSettings popover\n\nQuick access to card display settings from grid context menus.\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-17-add-settings-cog-to-entity-search-pages","title":"Task 17: Add settings cog to entity search pages","text":"<p>Files: - Modify entity search/list pages to include ContextSettings with entityType</p> <p>This task depends on the specific structure of search pages. Find where the settings cog is rendered and ensure entityType is passed to ContextSettings.</p> <p>Step 1: Identify search page components</p> <p>Look for files like <code>SceneSearch.jsx</code>, <code>PerformerSearch.jsx</code>, etc. or grid wrapper components.</p> <p>Step 2: Add/update ContextSettings usage</p> <p>Ensure each search page passes entityType to ContextSettings.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/*.jsx\ngit commit -m \"feat(search): add card display settings to entity search pages\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#phase-6-skeleton-adaptation","title":"Phase 6: Skeleton Adaptation","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-18-make-skeleton-respect-display-settings","title":"Task 18: Make skeleton respect display settings","text":"<p>Files: - Modify: <code>client/src/components/ui/SkeletonSceneCard.jsx</code></p> <p>Step 1: Accept and use display settings</p> <pre><code>import { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\n\nconst SkeletonSceneCard = ({ entityType = \"scene\" }) =&gt; {\n  const { getSettings } = useCardDisplaySettings();\n  const settings = getSettings(entityType);\n\n  const showDescription = settings.showDescriptionOnCard;\n  const showRatingRow = settings.showRating || settings.showFavorite || settings.showOCounter;\n\n  // ... aspect ratio logic ...\n\n  return (\n    &lt;div ...&gt;\n      {/* Image skeleton */}\n      ...\n\n      &lt;div className=\"p-3 space-y-2\"&gt;\n        {/* Title skeleton */}\n        ...\n\n        {/* Subtitle skeleton */}\n        ...\n\n        {/* Description skeleton (conditional) */}\n        {showDescription &amp;&amp; (\n          &lt;div className=\"space-y-1\"&gt;\n            &lt;div className=\"h-3 rounded animate-pulse\" style={{...}} /&gt;\n            &lt;div className=\"h-3 rounded animate-pulse\" style={{...}} /&gt;\n          &lt;/div&gt;\n        )}\n\n        {/* Indicators skeleton */}\n        ...\n\n        {/* Rating controls row skeleton (conditional based on any control being visible) */}\n        {showRatingRow &amp;&amp; (\n          &lt;div className=\"flex justify-between items-center w-full\" style={{ height: \"2rem\" }}&gt;\n            {settings.showRating &amp;&amp; &lt;div ... /&gt;}\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              {settings.showOCounter &amp;&amp; &lt;div ... /&gt;}\n              {settings.showFavorite &amp;&amp; &lt;div ... /&gt;}\n              {/* EntityMenu placeholder always shown */}\n              &lt;div className=\"h-6 w-6 rounded-full animate-pulse\" style={{...}} /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 2: Verify skeleton matches customized card</p> <p>Toggle settings and verify skeleton adapts accordingly.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/SkeletonSceneCard.jsx\ngit commit -m \"feat(skeleton): adapt skeleton to respect card display settings\n\nSkeleton now shows/hides sections based on user's card display preferences,\nensuring seamless loading transitions.\"\n</code></pre>"},{"location":"plans/2026-01-15-card-display-customization-implementation/#final-verification","title":"Final Verification","text":""},{"location":"plans/2026-01-15-card-display-customization-implementation/#task-19-end-to-end-testing","title":"Task 19: End-to-end testing","text":"<p>Step 1: Test all entity types</p> <p>For each entity type (scene, performer, studio, gallery, group, tag, image): 1. Toggle each setting in Settings &gt; Customization 2. Verify cards update accordingly 3. Verify detail pages update accordingly 4. Verify skeleton matches loaded state</p> <p>Step 2: Test quick access</p> <ol> <li>Open a grid (e.g., Scenes)</li> <li>Open ContextSettings</li> <li>Toggle card display settings</li> <li>Verify immediate effect</li> </ol> <p>Step 3: Test persistence</p> <ol> <li>Change settings</li> <li>Refresh page</li> <li>Verify settings persist</li> </ol> <p>Step 4: Final commit</p> <pre><code>git add -A\ngit commit -m \"feat: complete card display customization feature\n\nAllows users to customize card display per entity type:\n- Scene code visibility (scene only)\n- Description visibility (cards and detail pages separately)\n- Rating/Favorite/O Counter visibility\n\nSettings accessible from:\n- Settings &gt; Customization &gt; Card Display\n- ContextSettings popover on grids\n- Settings cog on search pages\"\n</code></pre>"},{"location":"plans/2026-01-16-settings-reorganization-design/","title":"Settings Page Reorganization Design","text":""},{"location":"plans/2026-01-16-settings-reorganization-design/#summary","title":"Summary","text":"<p>Reorganize the Settings page to improve logical grouping of options and rename \"User Settings\" to \"User Preferences\".</p>"},{"location":"plans/2026-01-16-settings-reorganization-design/#changes","title":"Changes","text":""},{"location":"plans/2026-01-16-settings-reorganization-design/#1-rename-user-settings-to-user-preferences","title":"1. Rename User Settings to User Preferences","text":"<p>Update the section selector button and any references from \"User Settings\" to \"User Preferences\".</p>"},{"location":"plans/2026-01-16-settings-reorganization-design/#2-new-navigation-tab","title":"2. New Navigation Tab","text":"<p>Create a new top-level tab called \"Navigation\" containing:</p> <ul> <li>Navigation Menu section - nav item reordering and visibility toggles</li> <li>Homepage Carousels section - carousel reordering, visibility, and custom carousel management</li> </ul> <p>These sections move from the Customization tab.</p>"},{"location":"plans/2026-01-16-settings-reorganization-design/#3-consolidate-view-preferences","title":"3. Consolidate View Preferences","text":"<p>Move Measurement Units into the View Preferences section within Customization. The View Preferences card will contain:</p> <ul> <li>Scene Card Preview Quality</li> <li>Wall View Preview Behavior</li> <li>Measurement Units</li> </ul>"},{"location":"plans/2026-01-16-settings-reorganization-design/#4-reorder-server-settings-tabs","title":"4. Reorder Server Settings Tabs","text":"<p>Change tab order from User Management \u2192 Server Configuration to Server Configuration \u2192 User Management.</p>"},{"location":"plans/2026-01-16-settings-reorganization-design/#final-structure","title":"Final Structure","text":""},{"location":"plans/2026-01-16-settings-reorganization-design/#user-preferences-tabs","title":"User Preferences Tabs","text":"Tab Sections Theme Built-in themes, Custom themes, UI Examples Playback Quality, mode, Chromecast, min play percent Customization View Preferences (incl. Measurement Units), Card Display Settings, Table Column Defaults Content Hidden items, hide confirmation Account Change password Navigation Navigation Menu, Homepage Carousels"},{"location":"plans/2026-01-16-settings-reorganization-design/#server-settings-tabs","title":"Server Settings Tabs","text":"<ol> <li>Server Configuration</li> <li>User Management</li> </ol>"},{"location":"plans/2026-01-16-settings-reorganization-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>client/src/components/pages/SettingsPage.jsx</code> - Update USER_TABS, SERVER_TABS arrays</li> <li><code>client/src/components/settings/SectionSelector.jsx</code> - Update button label</li> <li><code>client/src/components/settings/tabs/CustomizationTab.jsx</code> - Remove Navigation and Carousel sections, merge Measurement Units into View Preferences</li> <li><code>client/src/components/settings/tabs/NavigationTab.jsx</code> - New file</li> </ol>"},{"location":"plans/2026-01-16-settings-reorganization-design/#url-routes","title":"URL Routes","text":"<p>New route: <code>/settings?section=user&amp;tab=navigation</code></p> <p>All existing routes unchanged.</p>"},{"location":"plans/2026-01-16-settings-reorganization-design/#no-api-changes","title":"No API Changes","text":"<p>All existing settings endpoints remain the same. This is a UI-only reorganization.</p>"},{"location":"plans/2026-01-16-user-stats-implementation/","title":"User Stats Page Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Create a <code>/user-stats</code> page showing personalized engagement statistics (library counts, watch time, top performers/studios/tags, highlights) for the logged-in user.</p> <p>Architecture: Backend aggregation service computes exclusion-aware stats via Prisma queries, exposed through a single REST endpoint. React frontend fetches and displays in a card-based layout with loading/empty states.</p> <p>Tech Stack: Express/TypeScript backend, Prisma ORM, React frontend, Tailwind CSS, existing Paper/Button components.</p>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-1-create-api-types","title":"Task 1: Create API Types","text":"<p>Files: - Create: <code>server/types/api/userStats.ts</code> - Modify: <code>server/types/api/index.ts</code></p> <p>Step 1: Create the types file</p> <pre><code>// server/types/api/userStats.ts\n\nexport interface LibraryStats {\n  sceneCount: number;\n  performerCount: number;\n  studioCount: number;\n  tagCount: number;\n  galleryCount: number;\n  imageCount: number;\n}\n\nexport interface EngagementStats {\n  totalWatchTime: number; // seconds\n  totalPlayCount: number;\n  totalOCount: number; // scenes + images\n  totalImagesViewed: number;\n  uniqueScenesWatched: number;\n}\n\nexport interface TopPerformer {\n  id: string;\n  name: string;\n  imageUrl: string | null;\n  playCount: number;\n  oCount: number;\n}\n\nexport interface TopStudio {\n  id: string;\n  name: string;\n  imageUrl: string | null;\n  playCount: number;\n  oCount: number;\n}\n\nexport interface TopTag {\n  id: string;\n  name: string;\n  playCount: number;\n  oCount: number;\n}\n\nexport interface HighlightScene {\n  id: string;\n  title: string;\n  imageUrl: string | null;\n  playCount?: number;\n  oCount?: number;\n}\n\nexport interface HighlightImage {\n  id: string;\n  title: string | null;\n  imageUrl: string | null;\n  viewCount: number;\n}\n\nexport interface HighlightPerformer {\n  id: string;\n  name: string;\n  imageUrl: string | null;\n  oCount: number;\n}\n\nexport interface UserStatsResponse {\n  library: LibraryStats;\n  engagement: EngagementStats;\n  topPerformers: TopPerformer[];\n  topStudios: TopStudio[];\n  topTags: TopTag[];\n  mostWatchedScene: HighlightScene | null;\n  mostViewedImage: HighlightImage | null;\n  mostOdScene: HighlightScene | null;\n  mostOdPerformer: HighlightPerformer | null;\n}\n</code></pre> <p>Step 2: Export from index</p> <p>Add to <code>server/types/api/index.ts</code>:</p> <pre><code>export * from \"./userStats.js\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/types/api/userStats.ts server/types/api/index.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(api): add user stats API types\n\nDefine TypeScript interfaces for the user stats endpoint response\nincluding library counts, engagement totals, top lists, and highlights.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-2-create-userstatsaggregationservice","title":"Task 2: Create UserStatsAggregationService","text":"<p>Files: - Create: <code>server/services/UserStatsAggregationService.ts</code></p> <p>Step 1: Create the service</p> <pre><code>// server/services/UserStatsAggregationService.ts\n\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\nimport type {\n  UserStatsResponse,\n  LibraryStats,\n  EngagementStats,\n  TopPerformer,\n  TopStudio,\n  TopTag,\n  HighlightScene,\n  HighlightImage,\n  HighlightPerformer,\n} from \"../types/api/index.js\";\n\nclass UserStatsAggregationService {\n  /**\n   * Get all user stats in a single call\n   * All queries respect content exclusions via UserExcludedEntity\n   */\n  async getUserStats(userId: number): Promise&lt;UserStatsResponse&gt; {\n    const [\n      library,\n      engagement,\n      topPerformers,\n      topStudios,\n      topTags,\n      mostWatchedScene,\n      mostViewedImage,\n      mostOdScene,\n      mostOdPerformer,\n    ] = await Promise.all([\n      this.getLibraryStats(userId),\n      this.getEngagementStats(userId),\n      this.getTopPerformers(userId, 5),\n      this.getTopStudios(userId, 5),\n      this.getTopTags(userId, 5),\n      this.getMostWatchedScene(userId),\n      this.getMostViewedImage(userId),\n      this.getMostOdScene(userId),\n      this.getMostOdPerformer(userId),\n    ]);\n\n    return {\n      library,\n      engagement,\n      topPerformers,\n      topStudios,\n      topTags,\n      mostWatchedScene,\n      mostViewedImage,\n      mostOdScene,\n      mostOdPerformer,\n    };\n  }\n\n  /**\n   * Get library counts from pre-computed UserEntityStats\n   */\n  private async getLibraryStats(userId: number): Promise&lt;LibraryStats&gt; {\n    const stats = await prisma.userEntityStats.findMany({\n      where: { userId },\n      select: { entityType: true, visibleCount: true },\n    });\n\n    const statsMap = new Map(stats.map((s) =&gt; [s.entityType, s.visibleCount]));\n\n    return {\n      sceneCount: statsMap.get(\"scene\") ?? 0,\n      performerCount: statsMap.get(\"performer\") ?? 0,\n      studioCount: statsMap.get(\"studio\") ?? 0,\n      tagCount: statsMap.get(\"tag\") ?? 0,\n      galleryCount: statsMap.get(\"gallery\") ?? 0,\n      imageCount: statsMap.get(\"image\") ?? 0,\n    };\n  }\n\n  /**\n   * Get engagement totals with exclusion filtering\n   */\n  private async getEngagementStats(userId: number): Promise&lt;EngagementStats&gt; {\n    // Scene engagement (filtered by exclusions)\n    const sceneStats = await prisma.$queryRaw&lt;\n      Array&lt;{\n        totalWatchTime: number | null;\n        totalPlayCount: number | null;\n        totalOCount: number | null;\n        uniqueScenesWatched: number | null;\n      }&gt;\n    &gt;`\n      SELECT\n        COALESCE(SUM(w.playDuration), 0) as totalWatchTime,\n        COALESCE(SUM(w.playCount), 0) as totalPlayCount,\n        COALESCE(SUM(w.oCount), 0) as totalOCount,\n        COUNT(DISTINCT w.sceneId) as uniqueScenesWatched\n      FROM WatchHistory w\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'scene'\n        AND e.entityId = w.sceneId\n      WHERE w.userId = ${userId}\n        AND e.id IS NULL\n    `;\n\n    // Image engagement (filtered by exclusions)\n    const imageStats = await prisma.$queryRaw&lt;\n      Array&lt;{\n        totalImagesViewed: number | null;\n        imageOCount: number | null;\n      }&gt;\n    &gt;`\n      SELECT\n        COUNT(DISTINCT iv.imageId) as totalImagesViewed,\n        COALESCE(SUM(iv.oCount), 0) as imageOCount\n      FROM ImageViewHistory iv\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'image'\n        AND e.entityId = iv.imageId\n      WHERE iv.userId = ${userId}\n        AND e.id IS NULL\n    `;\n\n    const scene = sceneStats[0] || {};\n    const image = imageStats[0] || {};\n\n    return {\n      totalWatchTime: Number(scene.totalWatchTime) || 0,\n      totalPlayCount: Number(scene.totalPlayCount) || 0,\n      totalOCount:\n        (Number(scene.totalOCount) || 0) + (Number(image.imageOCount) || 0),\n      totalImagesViewed: Number(image.totalImagesViewed) || 0,\n      uniqueScenesWatched: Number(scene.uniqueScenesWatched) || 0,\n    };\n  }\n\n  /**\n   * Get top performers by play count (exclusion-aware)\n   */\n  private async getTopPerformers(\n    userId: number,\n    limit: number\n  ): Promise&lt;TopPerformer[]&gt; {\n    const stats = await prisma.$queryRaw&lt;\n      Array&lt;{\n        performerId: string;\n        playCount: number;\n        oCounter: number;\n      }&gt;\n    &gt;`\n      SELECT\n        ups.performerId,\n        ups.playCount,\n        ups.oCounter\n      FROM UserPerformerStats ups\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'performer'\n        AND e.entityId = ups.performerId\n      WHERE ups.userId = ${userId}\n        AND e.id IS NULL\n        AND ups.playCount &gt; 0\n      ORDER BY ups.playCount DESC\n      LIMIT ${limit}\n    `;\n\n    if (stats.length === 0) return [];\n\n    // Fetch performer details\n    const performers = await prisma.stashPerformer.findMany({\n      where: { id: { in: stats.map((s) =&gt; s.performerId) } },\n      select: { id: true, name: true, imagePath: true },\n    });\n\n    const performerMap = new Map(performers.map((p) =&gt; [p.id, p]));\n\n    return stats.map((s) =&gt; {\n      const performer = performerMap.get(s.performerId);\n      return {\n        id: s.performerId,\n        name: performer?.name ?? \"Unknown\",\n        imageUrl: performer?.imagePath ?? null,\n        playCount: s.playCount,\n        oCount: s.oCounter,\n      };\n    });\n  }\n\n  /**\n   * Get top studios by play count (exclusion-aware)\n   */\n  private async getTopStudios(\n    userId: number,\n    limit: number\n  ): Promise&lt;TopStudio[]&gt; {\n    const stats = await prisma.$queryRaw&lt;\n      Array&lt;{\n        studioId: string;\n        playCount: number;\n        oCounter: number;\n      }&gt;\n    &gt;`\n      SELECT\n        uss.studioId,\n        uss.playCount,\n        uss.oCounter\n      FROM UserStudioStats uss\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'studio'\n        AND e.entityId = uss.studioId\n      WHERE uss.userId = ${userId}\n        AND e.id IS NULL\n        AND uss.playCount &gt; 0\n      ORDER BY uss.playCount DESC\n      LIMIT ${limit}\n    `;\n\n    if (stats.length === 0) return [];\n\n    // Fetch studio details\n    const studios = await prisma.stashStudio.findMany({\n      where: { id: { in: stats.map((s) =&gt; s.studioId) } },\n      select: { id: true, name: true, imagePath: true },\n    });\n\n    const studioMap = new Map(studios.map((s) =&gt; [s.id, s]));\n\n    return stats.map((s) =&gt; {\n      const studio = studioMap.get(s.studioId);\n      return {\n        id: s.studioId,\n        name: studio?.name ?? \"Unknown\",\n        imageUrl: studio?.imagePath ?? null,\n        playCount: s.playCount,\n        oCount: s.oCounter,\n      };\n    });\n  }\n\n  /**\n   * Get top tags by play count (exclusion-aware)\n   */\n  private async getTopTags(userId: number, limit: number): Promise&lt;TopTag[]&gt; {\n    const stats = await prisma.$queryRaw&lt;\n      Array&lt;{\n        tagId: string;\n        playCount: number;\n        oCounter: number;\n      }&gt;\n    &gt;`\n      SELECT\n        uts.tagId,\n        uts.playCount,\n        uts.oCounter\n      FROM UserTagStats uts\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'tag'\n        AND e.entityId = uts.tagId\n      WHERE uts.userId = ${userId}\n        AND e.id IS NULL\n        AND uts.playCount &gt; 0\n      ORDER BY uts.playCount DESC\n      LIMIT ${limit}\n    `;\n\n    if (stats.length === 0) return [];\n\n    // Fetch tag details\n    const tags = await prisma.stashTag.findMany({\n      where: { id: { in: stats.map((s) =&gt; s.tagId) } },\n      select: { id: true, name: true },\n    });\n\n    const tagMap = new Map(tags.map((t) =&gt; [t.id, t]));\n\n    return stats.map((s) =&gt; {\n      const tag = tagMap.get(s.tagId);\n      return {\n        id: s.tagId,\n        name: tag?.name ?? \"Unknown\",\n        playCount: s.playCount,\n        oCount: s.oCounter,\n      };\n    });\n  }\n\n  /**\n   * Get most watched scene (by play count, exclusion-aware)\n   */\n  private async getMostWatchedScene(\n    userId: number\n  ): Promise&lt;HighlightScene | null&gt; {\n    const result = await prisma.$queryRaw&lt;\n      Array&lt;{\n        sceneId: string;\n        playCount: number;\n      }&gt;\n    &gt;`\n      SELECT\n        w.sceneId,\n        w.playCount\n      FROM WatchHistory w\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'scene'\n        AND e.entityId = w.sceneId\n      WHERE w.userId = ${userId}\n        AND e.id IS NULL\n        AND w.playCount &gt; 0\n      ORDER BY w.playCount DESC\n      LIMIT 1\n    `;\n\n    if (result.length === 0) return null;\n\n    const scene = await prisma.stashScene.findUnique({\n      where: { id: result[0].sceneId },\n      select: { id: true, title: true, screenshotPath: true },\n    });\n\n    if (!scene) return null;\n\n    return {\n      id: scene.id,\n      title: scene.title ?? \"Untitled\",\n      imageUrl: scene.screenshotPath ?? null,\n      playCount: result[0].playCount,\n    };\n  }\n\n  /**\n   * Get most viewed image (by view count, exclusion-aware)\n   */\n  private async getMostViewedImage(\n    userId: number\n  ): Promise&lt;HighlightImage | null&gt; {\n    const result = await prisma.$queryRaw&lt;\n      Array&lt;{\n        imageId: string;\n        viewCount: number;\n      }&gt;\n    &gt;`\n      SELECT\n        iv.imageId,\n        iv.viewCount\n      FROM ImageViewHistory iv\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'image'\n        AND e.entityId = iv.imageId\n      WHERE iv.userId = ${userId}\n        AND e.id IS NULL\n        AND iv.viewCount &gt; 0\n      ORDER BY iv.viewCount DESC\n      LIMIT 1\n    `;\n\n    if (result.length === 0) return null;\n\n    const image = await prisma.stashImage.findUnique({\n      where: { id: result[0].imageId },\n      select: { id: true, title: true, thumbnailPath: true },\n    });\n\n    if (!image) return null;\n\n    return {\n      id: image.id,\n      title: image.title ?? null,\n      imageUrl: image.thumbnailPath ?? null,\n      viewCount: result[0].viewCount,\n    };\n  }\n\n  /**\n   * Get scene with most Os (exclusion-aware)\n   */\n  private async getMostOdScene(userId: number): Promise&lt;HighlightScene | null&gt; {\n    const result = await prisma.$queryRaw&lt;\n      Array&lt;{\n        sceneId: string;\n        oCount: number;\n      }&gt;\n    &gt;`\n      SELECT\n        w.sceneId,\n        w.oCount\n      FROM WatchHistory w\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'scene'\n        AND e.entityId = w.sceneId\n      WHERE w.userId = ${userId}\n        AND e.id IS NULL\n        AND w.oCount &gt; 0\n      ORDER BY w.oCount DESC\n      LIMIT 1\n    `;\n\n    if (result.length === 0) return null;\n\n    const scene = await prisma.stashScene.findUnique({\n      where: { id: result[0].sceneId },\n      select: { id: true, title: true, screenshotPath: true },\n    });\n\n    if (!scene) return null;\n\n    return {\n      id: scene.id,\n      title: scene.title ?? \"Untitled\",\n      imageUrl: scene.screenshotPath ?? null,\n      oCount: result[0].oCount,\n    };\n  }\n\n  /**\n   * Get performer with most Os (exclusion-aware)\n   */\n  private async getMostOdPerformer(\n    userId: number\n  ): Promise&lt;HighlightPerformer | null&gt; {\n    const result = await prisma.$queryRaw&lt;\n      Array&lt;{\n        performerId: string;\n        oCounter: number;\n      }&gt;\n    &gt;`\n      SELECT\n        ups.performerId,\n        ups.oCounter\n      FROM UserPerformerStats ups\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ${userId}\n        AND e.entityType = 'performer'\n        AND e.entityId = ups.performerId\n      WHERE ups.userId = ${userId}\n        AND e.id IS NULL\n        AND ups.oCounter &gt; 0\n      ORDER BY ups.oCounter DESC\n      LIMIT 1\n    `;\n\n    if (result.length === 0) return null;\n\n    const performer = await prisma.stashPerformer.findUnique({\n      where: { id: result[0].performerId },\n      select: { id: true, name: true, imagePath: true },\n    });\n\n    if (!performer) return null;\n\n    return {\n      id: performer.id,\n      name: performer.name ?? \"Unknown\",\n      imageUrl: performer.imagePath ?? null,\n      oCount: result[0].oCounter,\n    };\n  }\n}\n\nexport const userStatsAggregationService = new UserStatsAggregationService();\nexport default userStatsAggregationService;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/services/UserStatsAggregationService.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(service): add UserStatsAggregationService\n\nImplements exclusion-aware stats aggregation:\n- Library counts from UserEntityStats\n- Engagement totals from WatchHistory/ImageViewHistory\n- Top performers/studios/tags from pre-computed stats\n- Highlight cards for most watched/viewed/O'd content\n\nAll queries filter out excluded content via UserExcludedEntity JOIN.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-3-create-controller-and-route","title":"Task 3: Create Controller and Route","text":"<p>Files: - Create: <code>server/controllers/userStats.ts</code> - Create: <code>server/routes/userStats.ts</code> - Modify: <code>server/initializers/api.ts</code></p> <p>Step 1: Create the controller</p> <pre><code>// server/controllers/userStats.ts\n\nimport type {\n  TypedAuthRequest,\n  TypedResponse,\n  ApiErrorResponse,\n  UserStatsResponse,\n} from \"../types/api/index.js\";\nimport { userStatsAggregationService } from \"../services/UserStatsAggregationService.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * Get aggregated user stats\n */\nexport async function getUserStats(\n  req: TypedAuthRequest,\n  res: TypedResponse&lt;UserStatsResponse | ApiErrorResponse&gt;\n) {\n  try {\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    const stats = await userStatsAggregationService.getUserStats(userId);\n\n    res.json(stats);\n  } catch (error) {\n    logger.error(\"Error fetching user stats\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n    res.status(500).json({ error: \"Failed to fetch user stats\" });\n  }\n}\n</code></pre> <p>Step 2: Create the route</p> <pre><code>// server/routes/userStats.ts\n\nimport express from \"express\";\nimport { getUserStats } from \"../controllers/userStats.js\";\nimport { authenticate } from \"../middleware/auth.js\";\nimport { authenticated } from \"../utils/routeHelpers.js\";\n\nconst router = express.Router();\n\n// All user stats routes require authentication\nrouter.use(authenticate);\n\n// Get user stats\nrouter.get(\"/\", authenticated(getUserStats));\n\nexport default router;\n</code></pre> <p>Step 3: Register route in api.ts</p> <p>Add import at top of <code>server/initializers/api.ts</code> (around line 33):</p> <pre><code>import userStatsRoutes from \"../routes/userStats.js\";\n</code></pre> <p>Add route registration after watch history routes (around line 128):</p> <pre><code>  // User stats routes (protected)\n  app.use(\"/api/user-stats\", userStatsRoutes);\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/controllers/userStats.ts server/routes/userStats.ts server/initializers/api.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(api): add GET /api/user-stats endpoint\n\nExposes user stats aggregation through authenticated REST endpoint.\nReturns library counts, engagement totals, top lists, and highlights.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-4-create-frontend-hook","title":"Task 4: Create Frontend Hook","text":"<p>Files: - Create: <code>client/src/hooks/useUserStats.js</code></p> <p>Step 1: Create the hook</p> <pre><code>// client/src/hooks/useUserStats.js\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useAuth } from \"./useAuth.js\";\nimport { apiGet } from \"../services/api.js\";\n\n/**\n * Hook for fetching user stats\n * @returns {Object} { data, loading, error, refresh }\n */\nexport function useUserStats() {\n  const { isAuthenticated } = useAuth();\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const fetchStats = useCallback(async () =&gt; {\n    if (!isAuthenticated) {\n      setLoading(false);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await apiGet(\"/user-stats\");\n      setData(response);\n    } catch (err) {\n      console.error(\"Error fetching user stats:\", err);\n      setError(err.message || \"Failed to fetch stats\");\n    } finally {\n      setLoading(false);\n    }\n  }, [isAuthenticated]);\n\n  useEffect(() =&gt; {\n    fetchStats();\n  }, [fetchStats]);\n\n  return { data, loading, error, refresh: fetchStats };\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/hooks/useUserStats.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(client): add useUserStats hook\n\nFetches user stats from /api/user-stats with loading/error states.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-5-create-ui-components","title":"Task 5: Create UI Components","text":"<p>Files: - Create: <code>client/src/components/pages/UserStats/components/StatCard.jsx</code> - Create: <code>client/src/components/pages/UserStats/components/LibraryOverview.jsx</code> - Create: <code>client/src/components/pages/UserStats/components/EngagementTotals.jsx</code> - Create: <code>client/src/components/pages/UserStats/components/TopList.jsx</code> - Create: <code>client/src/components/pages/UserStats/components/HighlightCard.jsx</code> - Create: <code>client/src/components/pages/UserStats/components/index.js</code></p> <p>Step 1: Create StatCard component</p> <pre><code>// client/src/components/pages/UserStats/components/StatCard.jsx\n\nimport { Paper } from \"../../../ui/index.js\";\n\n/**\n * Simple stat display card\n */\nconst StatCard = ({ label, value, subtitle, icon }) =&gt; (\n  &lt;Paper padding=\"md\" className=\"text-center flex flex-col items-center gap-1\"&gt;\n    {icon &amp;&amp; (\n      &lt;div style={{ color: \"var(--text-muted)\" }} className=\"mb-1\"&gt;\n        {icon}\n      &lt;/div&gt;\n    )}\n    &lt;div\n      style={{ color: \"var(--text-primary)\" }}\n      className=\"text-2xl font-bold\"\n    &gt;\n      {value}\n    &lt;/div&gt;\n    &lt;div style={{ color: \"var(--text-secondary)\" }} className=\"text-sm\"&gt;\n      {label}\n    &lt;/div&gt;\n    {subtitle &amp;&amp; (\n      &lt;div style={{ color: \"var(--text-muted)\" }} className=\"text-xs\"&gt;\n        {subtitle}\n      &lt;/div&gt;\n    )}\n  &lt;/Paper&gt;\n);\n\nexport default StatCard;\n</code></pre> <p>Step 2: Create LibraryOverview component</p> <pre><code>// client/src/components/pages/UserStats/components/LibraryOverview.jsx\n\nimport { Film, Users, Building2, Tag, Images, Image } from \"lucide-react\";\nimport StatCard from \"./StatCard.jsx\";\n\n/**\n * Compact row of library count stats\n */\nconst LibraryOverview = ({ library }) =&gt; {\n  const stats = [\n    { label: \"Scenes\", value: library.sceneCount, icon: &lt;Film size={20} /&gt; },\n    { label: \"Performers\", value: library.performerCount, icon: &lt;Users size={20} /&gt; },\n    { label: \"Studios\", value: library.studioCount, icon: &lt;Building2 size={20} /&gt; },\n    { label: \"Tags\", value: library.tagCount, icon: &lt;Tag size={20} /&gt; },\n    { label: \"Galleries\", value: library.galleryCount, icon: &lt;Images size={20} /&gt; },\n    { label: \"Images\", value: library.imageCount, icon: &lt;Image size={20} /&gt; },\n  ];\n\n  return (\n    &lt;div className=\"grid grid-cols-3 md:grid-cols-6 gap-3\"&gt;\n      {stats.map((stat) =&gt; (\n        &lt;StatCard\n          key={stat.label}\n          label={stat.label}\n          value={stat.value.toLocaleString()}\n          icon={stat.icon}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default LibraryOverview;\n</code></pre> <p>Step 3: Create EngagementTotals component</p> <pre><code>// client/src/components/pages/UserStats/components/EngagementTotals.jsx\n\nimport { Clock, Play, Heart, Image, Film } from \"lucide-react\";\nimport StatCard from \"./StatCard.jsx\";\n\n/**\n * Format seconds as human-readable duration\n */\nfunction formatDuration(seconds) {\n  if (!seconds || seconds === 0) return \"0m\";\n\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n\n  const parts = [];\n  if (days &gt; 0) parts.push(`${days}d`);\n  if (hours &gt; 0) parts.push(`${hours}h`);\n  if (minutes &gt; 0 || parts.length === 0) parts.push(`${minutes}m`);\n\n  return parts.join(\" \");\n}\n\n/**\n * Hero section with engagement totals\n */\nconst EngagementTotals = ({ engagement, librarySceneCount }) =&gt; {\n  const coveragePercent =\n    librarySceneCount &gt; 0\n      ? Math.round((engagement.uniqueScenesWatched / librarySceneCount) * 100)\n      : 0;\n\n  const stats = [\n    {\n      label: \"Watch Time\",\n      value: formatDuration(engagement.totalWatchTime),\n      icon: &lt;Clock size={24} /&gt;,\n    },\n    {\n      label: \"Play Count\",\n      value: engagement.totalPlayCount.toLocaleString(),\n      icon: &lt;Play size={24} /&gt;,\n    },\n    {\n      label: \"O Count\",\n      value: engagement.totalOCount.toLocaleString(),\n      icon: &lt;Heart size={24} /&gt;,\n    },\n    {\n      label: \"Scenes Watched\",\n      value: engagement.uniqueScenesWatched.toLocaleString(),\n      subtitle: `${coveragePercent}% of library`,\n      icon: &lt;Film size={24} /&gt;,\n    },\n    {\n      label: \"Images Viewed\",\n      value: engagement.totalImagesViewed.toLocaleString(),\n      icon: &lt;Image size={24} /&gt;,\n    },\n  ];\n\n  return (\n    &lt;div className=\"grid grid-cols-2 md:grid-cols-5 gap-4\"&gt;\n      {stats.map((stat) =&gt; (\n        &lt;StatCard\n          key={stat.label}\n          label={stat.label}\n          value={stat.value}\n          subtitle={stat.subtitle}\n          icon={stat.icon}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default EngagementTotals;\n</code></pre> <p>Step 4: Create TopList component</p> <pre><code>// client/src/components/pages/UserStats/components/TopList.jsx\n\nimport { Link } from \"react-router-dom\";\nimport { Paper } from \"../../../ui/index.js\";\n\n/**\n * Ranked list of top items\n */\nconst TopList = ({ title, items, linkPrefix, showImage = true }) =&gt; {\n  if (!items || items.length === 0) {\n    return null;\n  }\n\n  return (\n    &lt;Paper padding=\"none\"&gt;\n      &lt;div\n        className=\"px-4 py-3 border-b\"\n        style={{ borderColor: \"var(--border-color)\" }}\n      &gt;\n        &lt;h3\n          className=\"font-semibold\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          {title}\n        &lt;/h3&gt;\n      &lt;/div&gt;\n      &lt;div className=\"divide-y\" style={{ borderColor: \"var(--border-color)\" }}&gt;\n        {items.map((item, index) =&gt; (\n          &lt;Link\n            key={item.id}\n            to={`${linkPrefix}/${item.id}`}\n            className=\"flex items-center gap-3 px-4 py-3 transition-colors hover:bg-[var(--bg-secondary)]\"\n          &gt;\n            &lt;span\n              className=\"w-6 text-center font-bold\"\n              style={{ color: \"var(--text-muted)\" }}\n            &gt;\n              {index + 1}\n            &lt;/span&gt;\n            {showImage &amp;&amp; (\n              &lt;div\n                className=\"w-10 h-10 rounded overflow-hidden flex-shrink-0\"\n                style={{ backgroundColor: \"var(--bg-secondary)\" }}\n              &gt;\n                {item.imageUrl ? (\n                  &lt;img\n                    src={`/api/proxy/stash?url=${encodeURIComponent(item.imageUrl)}`}\n                    alt={item.name}\n                    className=\"w-full h-full object-cover\"\n                  /&gt;\n                ) : (\n                  &lt;div className=\"w-full h-full flex items-center justify-center text-xs\"&gt;\n                    ?\n                  &lt;/div&gt;\n                )}\n              &lt;/div&gt;\n            )}\n            &lt;div className=\"flex-1 min-w-0\"&gt;\n              &lt;div\n                className=\"font-medium truncate\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                {item.name}\n              &lt;/div&gt;\n              &lt;div className=\"text-xs\" style={{ color: \"var(--text-muted)\" }}&gt;\n                {item.playCount} plays \u2022 {item.oCount} Os\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/Link&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/Paper&gt;\n  );\n};\n\nexport default TopList;\n</code></pre> <p>Step 5: Create HighlightCard component</p> <pre><code>// client/src/components/pages/UserStats/components/HighlightCard.jsx\n\nimport { Link } from \"react-router-dom\";\nimport { Paper } from \"../../../ui/index.js\";\n\n/**\n * Feature card for highlight stats (most watched, etc.)\n */\nconst HighlightCard = ({ title, item, linkPrefix, statLabel, statValue }) =&gt; {\n  if (!item) {\n    return null;\n  }\n\n  const displayName = item.name || item.title || \"Unknown\";\n\n  return (\n    &lt;Paper padding=\"none\" className=\"overflow-hidden\"&gt;\n      &lt;div\n        className=\"px-4 py-2 border-b\"\n        style={{ borderColor: \"var(--border-color)\" }}\n      &gt;\n        &lt;h3\n          className=\"text-sm font-medium\"\n          style={{ color: \"var(--text-secondary)\" }}\n        &gt;\n          {title}\n        &lt;/h3&gt;\n      &lt;/div&gt;\n      &lt;Link\n        to={`${linkPrefix}/${item.id}`}\n        className=\"block hover:bg-[var(--bg-secondary)] transition-colors\"\n      &gt;\n        &lt;div className=\"aspect-video relative overflow-hidden\"&gt;\n          {item.imageUrl ? (\n            &lt;img\n              src={`/api/proxy/stash?url=${encodeURIComponent(item.imageUrl)}`}\n              alt={displayName}\n              className=\"w-full h-full object-cover\"\n            /&gt;\n          ) : (\n            &lt;div\n              className=\"w-full h-full flex items-center justify-center\"\n              style={{ backgroundColor: \"var(--bg-secondary)\" }}\n            &gt;\n              &lt;span style={{ color: \"var(--text-muted)\" }}&gt;No image&lt;/span&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n        &lt;div className=\"p-3\"&gt;\n          &lt;div\n            className=\"font-medium truncate\"\n            style={{ color: \"var(--text-primary)\" }}\n          &gt;\n            {displayName}\n          &lt;/div&gt;\n          &lt;div className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n            {statValue.toLocaleString()} {statLabel}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/Link&gt;\n    &lt;/Paper&gt;\n  );\n};\n\nexport default HighlightCard;\n</code></pre> <p>Step 6: Create index export</p> <pre><code>// client/src/components/pages/UserStats/components/index.js\n\nexport { default as StatCard } from \"./StatCard.jsx\";\nexport { default as LibraryOverview } from \"./LibraryOverview.jsx\";\nexport { default as EngagementTotals } from \"./EngagementTotals.jsx\";\nexport { default as TopList } from \"./TopList.jsx\";\nexport { default as HighlightCard } from \"./HighlightCard.jsx\";\n</code></pre> <p>Step 7: Commit</p> <pre><code>git add client/src/components/pages/UserStats/components/\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(client): add user stats UI components\n\n- StatCard: Simple stat display with icon/value/label\n- LibraryOverview: Grid of library counts\n- EngagementTotals: Hero section with watch time, plays, Os\n- TopList: Ranked list for performers/studios/tags\n- HighlightCard: Feature card for most watched/viewed\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-6-create-userstats-page","title":"Task 6: Create UserStats Page","text":"<p>Files: - Create: <code>client/src/components/pages/UserStats/UserStats.jsx</code> - Create: <code>client/src/components/pages/UserStats/index.js</code></p> <p>Step 1: Create the page component</p> <pre><code>// client/src/components/pages/UserStats/UserStats.jsx\n\nimport { BarChart3 } from \"lucide-react\";\nimport { usePageTitle } from \"../../../hooks/usePageTitle.js\";\nimport { useUserStats } from \"../../../hooks/useUserStats.js\";\nimport { PageHeader, PageLayout, LoadingSpinner } from \"../../ui/index.js\";\nimport {\n  LibraryOverview,\n  EngagementTotals,\n  TopList,\n  HighlightCard,\n} from \"./components/index.js\";\n\nconst UserStats = () =&gt; {\n  usePageTitle(\"My Stats\");\n\n  const { data, loading, error } = useUserStats();\n\n  if (loading) {\n    return (\n      &lt;PageLayout fullHeight style={{ backgroundColor: \"var(--bg-primary)\" }}&gt;\n        &lt;div className=\"flex items-center justify-center h-64\"&gt;\n          &lt;LoadingSpinner /&gt;\n        &lt;/div&gt;\n      &lt;/PageLayout&gt;\n    );\n  }\n\n  if (error) {\n    return (\n      &lt;PageLayout fullHeight style={{ backgroundColor: \"var(--bg-primary)\" }}&gt;\n        &lt;PageHeader\n          title=\"My Stats\"\n          icon={&lt;BarChart3 className=\"w-8 h-8\" /&gt;}\n        /&gt;\n        &lt;div\n          className=\"text-center py-12\"\n          style={{ color: \"var(--status-error)\" }}\n        &gt;\n          Failed to load stats: {error}\n        &lt;/div&gt;\n      &lt;/PageLayout&gt;\n    );\n  }\n\n  // Check if user has any engagement data\n  const hasEngagement =\n    data?.engagement?.totalPlayCount &gt; 0 ||\n    data?.engagement?.totalImagesViewed &gt; 0;\n\n  return (\n    &lt;PageLayout fullHeight style={{ backgroundColor: \"var(--bg-primary)\" }}&gt;\n      &lt;PageHeader\n        title=\"My Stats\"\n        subtitle=\"Your viewing statistics\"\n        icon={&lt;BarChart3 className=\"w-8 h-8\" /&gt;}\n      /&gt;\n\n      &lt;div className=\"space-y-8 pb-8\"&gt;\n        {/* Library Overview */}\n        &lt;section&gt;\n          &lt;h2\n            className=\"text-lg font-semibold mb-4\"\n            style={{ color: \"var(--text-primary)\" }}\n          &gt;\n            Library\n          &lt;/h2&gt;\n          &lt;LibraryOverview library={data.library} /&gt;\n        &lt;/section&gt;\n\n        {/* Engagement Stats */}\n        {hasEngagement ? (\n          &lt;&gt;\n            &lt;section&gt;\n              &lt;h2\n                className=\"text-lg font-semibold mb-4\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Engagement\n              &lt;/h2&gt;\n              &lt;EngagementTotals\n                engagement={data.engagement}\n                librarySceneCount={data.library.sceneCount}\n              /&gt;\n            &lt;/section&gt;\n\n            {/* Top Lists */}\n            &lt;section&gt;\n              &lt;h2\n                className=\"text-lg font-semibold mb-4\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Top Content\n              &lt;/h2&gt;\n              &lt;div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\"&gt;\n                &lt;TopList\n                  title=\"Top Performers\"\n                  items={data.topPerformers}\n                  linkPrefix=\"/performer\"\n                /&gt;\n                &lt;TopList\n                  title=\"Top Studios\"\n                  items={data.topStudios}\n                  linkPrefix=\"/studio\"\n                /&gt;\n                &lt;TopList\n                  title=\"Top Tags\"\n                  items={data.topTags}\n                  linkPrefix=\"/tag\"\n                  showImage={false}\n                /&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n\n            {/* Highlights */}\n            &lt;section&gt;\n              &lt;h2\n                className=\"text-lg font-semibold mb-4\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Highlights\n              &lt;/h2&gt;\n              &lt;div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\"&gt;\n                &lt;HighlightCard\n                  title=\"Most Watched Scene\"\n                  item={data.mostWatchedScene}\n                  linkPrefix=\"/scene\"\n                  statLabel=\"plays\"\n                  statValue={data.mostWatchedScene?.playCount || 0}\n                /&gt;\n                &lt;HighlightCard\n                  title=\"Most Viewed Image\"\n                  item={data.mostViewedImage}\n                  linkPrefix=\"/image\"\n                  statLabel=\"views\"\n                  statValue={data.mostViewedImage?.viewCount || 0}\n                /&gt;\n                &lt;HighlightCard\n                  title=\"Most O'd Scene\"\n                  item={data.mostOdScene}\n                  linkPrefix=\"/scene\"\n                  statLabel=\"Os\"\n                  statValue={data.mostOdScene?.oCount || 0}\n                /&gt;\n                &lt;HighlightCard\n                  title=\"Most O'd Performer\"\n                  item={data.mostOdPerformer}\n                  linkPrefix=\"/performer\"\n                  statLabel=\"Os\"\n                  statValue={data.mostOdPerformer?.oCount || 0}\n                /&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n          &lt;/&gt;\n        ) : (\n          &lt;div\n            className=\"text-center py-12\"\n            style={{ color: \"var(--text-muted)\" }}\n          &gt;\n            &lt;BarChart3\n              size={48}\n              className=\"mx-auto mb-4\"\n              style={{ color: \"var(--text-muted)\" }}\n            /&gt;\n            &lt;p className=\"text-lg mb-2\"&gt;No engagement data yet&lt;/p&gt;\n            &lt;p&gt;Start watching content to see your stats!&lt;/p&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/PageLayout&gt;\n  );\n};\n\nexport default UserStats;\n</code></pre> <p>Step 2: Create index export</p> <pre><code>// client/src/components/pages/UserStats/index.js\n\nexport { default } from \"./UserStats.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/UserStats/\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(client): add UserStats page component\n\nMain page displaying library overview, engagement totals,\ntop performers/studios/tags, and highlight cards.\nIncludes loading and empty states.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-7-add-route-and-navigation","title":"Task 7: Add Route and Navigation","text":"<p>Files: - Modify: <code>client/src/App.jsx</code> - Modify: <code>client/src/components/ui/UserMenu.jsx</code></p> <p>Step 1: Add lazy import in App.jsx</p> <p>Add after WatchHistory import (around line 41):</p> <pre><code>const UserStats = lazy(() =&gt; import(\"./components/pages/UserStats/index.js\"));\n</code></pre> <p>Step 2: Add route in App.jsx</p> <p>Add after <code>/watch-history</code> route (around line 270):</p> <pre><code>          &lt;Route\n            path=\"/user-stats\"\n            element={\n              &lt;ProtectedRoute setupStatus={safeSetupStatus} checkingSetup={checkingSetup}&gt;\n                &lt;GlobalLayout&gt;\n                  &lt;UserStats /&gt;\n                &lt;/GlobalLayout&gt;\n              &lt;/ProtectedRoute&gt;\n            }\n          /&gt;\n</code></pre> <p>Step 3: Add menu item in UserMenu.jsx</p> <p>Add after Watch History link (after line 121):</p> <pre><code>            &lt;Link\n              to=\"/user-stats\"\n              onClick={() =&gt; setIsOpen(false)}\n              className=\"w-full flex items-center gap-3 px-3 py-2 text-sm rounded transition-colors duration-200\"\n              style={{\n                color: \"var(--text-primary)\",\n              }}\n              onMouseEnter={(e) =&gt; {\n                e.currentTarget.style.backgroundColor = \"var(--bg-secondary)\";\n              }}\n              onMouseLeave={(e) =&gt; {\n                e.currentTarget.style.backgroundColor = \"transparent\";\n              }}\n            &gt;\n              &lt;ThemedIcon name=\"bar-chart-3\" size={16} /&gt;\n              &lt;span&gt;My Stats&lt;/span&gt;\n            &lt;/Link&gt;\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add client/src/App.jsx client/src/components/ui/UserMenu.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(client): add user stats route and navigation\n\n- Add /user-stats route with ProtectedRoute wrapper\n- Add \"My Stats\" link to user context menu\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-8-manual-testing","title":"Task 8: Manual Testing","text":"<p>Step 1: Start development servers</p> <pre><code># Terminal 1 - Server\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run dev\n\n# Terminal 2 - Client\ncd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Test the feature</p> <ol> <li>Open browser to <code>http://localhost:5173</code></li> <li>Log in with test user</li> <li>Click user icon in nav \u2192 verify \"My Stats\" appears in menu</li> <li>Click \"My Stats\" \u2192 verify page loads</li> <li>Verify library counts display correctly</li> <li>If you have watch history, verify engagement stats display</li> <li>If you have watch history, verify top lists show correct data</li> <li>Test clicking on items to verify navigation works</li> <li>Test with a user that has no watch history \u2192 verify empty state</li> </ol> <p>Step 3: Test exclusions</p> <ol> <li>Hide a performer via Hidden Items page</li> <li>Refresh user stats page</li> <li>Verify hidden performer doesn't appear in top lists</li> <li>Verify engagement totals don't include hidden content</li> </ol>"},{"location":"plans/2026-01-16-user-stats-implementation/#task-9-final-commit","title":"Task 9: Final Commit","text":"<p>Step 1: Verify all changes</p> <pre><code>git status\ngit log --oneline -10\n</code></pre> <p>Step 2: Create summary commit if needed</p> <p>If there are any uncommitted fixes from testing:</p> <pre><code>git add -A\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfix: address issues found during manual testing\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-implementation/#summary","title":"Summary","text":"<p>This plan creates:</p> <ol> <li>Backend:</li> <li><code>server/types/api/userStats.ts</code> - TypeScript interfaces</li> <li><code>server/services/UserStatsAggregationService.ts</code> - Exclusion-aware stats queries</li> <li><code>server/controllers/userStats.ts</code> - Controller function</li> <li><code>server/routes/userStats.ts</code> - Express route</li> <li> <p>Modified <code>server/initializers/api.ts</code> - Route registration</p> </li> <li> <p>Frontend:</p> </li> <li><code>client/src/hooks/useUserStats.js</code> - Data fetching hook</li> <li><code>client/src/components/pages/UserStats/</code> - Page and components</li> <li>Modified <code>client/src/App.jsx</code> - Route</li> <li>Modified <code>client/src/components/ui/UserMenu.jsx</code> - Navigation link</li> </ol> <p>All stats respect content exclusions via <code>UserExcludedEntity</code> JOIN pattern.</p>"},{"location":"plans/2026-01-16-user-stats-page-design/","title":"User Stats Page Design","text":"<p>Issue: #194 Date: 2026-01-16 Status: Draft</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#overview","title":"Overview","text":"<p>A dedicated page showing personalized engagement statistics for the logged-in user, accessed via the user context menu in the navigation (alongside Watch History).</p> <p>Route: <code>/user-stats</code></p>"},{"location":"plans/2026-01-16-user-stats-page-design/#goals","title":"Goals","text":"<ul> <li>Surface library composition at a glance (counts)</li> <li>Highlight personal engagement metrics (watch time, play counts, O counts)</li> <li>Show \"top\" lists for performers, studios, tags, scenes, images</li> <li>Track streaks and personal records (future)</li> <li>Provide time-based insights (future)</li> <li>Include fun/novelty stats that make the data feel personal (future)</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#context","title":"Context","text":"<p>This feature prepares for Issue #290 (homepage options) by creating a stats page that could become one of several homepage landing options. Inspired by Stash's stats page but focused on per-user engagement rather than just library counts.</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#mvp-scope","title":"MVP Scope","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#features-included","title":"Features Included","text":"<ol> <li>Library Overview - Counts of visible entities (scenes, performers, studios, tags, galleries, images)</li> <li>Engagement Totals - Total watch time, play count, O count, images viewed, unique scenes watched</li> <li>Top 5 Lists - Top performers, studios, and tags by play count</li> <li>Highlights - Most watched scene, most viewed image, most O'd scene, most O'd performer</li> </ol>"},{"location":"plans/2026-01-16-user-stats-page-design/#features-excluded-from-mvp","title":"Features Excluded from MVP","text":"<ul> <li>Streaks (activity, O count)</li> <li>Personal records</li> <li>Time-based patterns (day of week, time of day)</li> <li>Calendar heatmap</li> <li>Time period filtering</li> <li>Personality types</li> <li>Shareable cards</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#data-architecture","title":"Data Architecture","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#exclusion-handling","title":"Exclusion Handling","text":"<p>All stats must respect content restrictions and hidden items using the established pattern:</p> <pre><code>-- Filter excluded content via LEFT JOIN\nLEFT JOIN UserExcludedEntity e\n  ON e.userId = ?\n  AND e.entityType = 'scene'\n  AND e.entityId = w.sceneId\nWHERE e.id IS NULL  -- Only include non-excluded\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-page-design/#data-sources","title":"Data Sources","text":"Stat Source Exclusion Handling Library counts <code>UserEntityStats.visibleCount</code> Already exclusion-aware Watch time <code>WatchHistory.playDuration</code> JOIN with scene exclusions Play count <code>WatchHistory.playCount</code> JOIN with scene exclusions Scene O count <code>WatchHistory.oCount</code> JOIN with scene exclusions Image O count <code>ImageViewHistory.oCount</code> JOIN with image exclusions Image views <code>ImageViewHistory.viewCount</code> JOIN with image exclusions Top performers <code>UserPerformerStats</code> JOIN with performer exclusions Top studios <code>UserStudioStats</code> JOIN with studio exclusions Top tags <code>UserTagStats</code> JOIN with tag exclusions Most watched scene <code>WatchHistory</code> JOIN with scene exclusions Most viewed image <code>ImageViewHistory</code> JOIN with image exclusions"},{"location":"plans/2026-01-16-user-stats-page-design/#new-api-endpoint","title":"New API Endpoint","text":"<pre><code>GET /api/user-stats\n</code></pre> <p>Single endpoint returning all aggregated stats for the authenticated user.</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#response-schema","title":"Response Schema","text":"<pre><code>interface UserStatsResponse {\n  library: {\n    sceneCount: number\n    performerCount: number\n    studioCount: number\n    tagCount: number\n    galleryCount: number\n    imageCount: number\n  }\n  engagement: {\n    totalWatchTime: number        // seconds\n    totalPlayCount: number\n    totalOCount: number           // scenes + images combined\n    totalImagesViewed: number\n    uniqueScenesWatched: number\n  }\n  topPerformers: Array&lt;{\n    id: string\n    name: string\n    imageUrl: string | null\n    playCount: number\n    oCount: number\n  }&gt;  // top 5\n  topStudios: Array&lt;{\n    id: string\n    name: string\n    imageUrl: string | null\n    playCount: number\n    oCount: number\n  }&gt;  // top 5\n  topTags: Array&lt;{\n    id: string\n    name: string\n    playCount: number\n    oCount: number\n  }&gt;  // top 5\n  mostWatchedScene: {\n    id: string\n    title: string\n    imageUrl: string | null\n    playCount: number\n  } | null\n  mostViewedImage: {\n    id: string\n    title: string | null\n    imageUrl: string | null\n    viewCount: number\n  } | null\n  mostOdScene: {\n    id: string\n    title: string\n    imageUrl: string | null\n    oCount: number\n  } | null\n  mostOdPerformer: {\n    id: string\n    name: string\n    imageUrl: string | null\n    oCount: number\n  } | null\n}\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-page-design/#new-service","title":"New Service","text":"<p><code>UserStatsAggregationService</code> - Dedicated service for computing aggregated stats with proper exclusion handling. Uses raw SQL queries (like QueryBuilders) for performance.</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#ui-design","title":"UI Design","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#page-structure","title":"Page Structure","text":"<pre><code>UserStatsPage\n\u251c\u2500\u2500 PageLayout\n\u2502   \u251c\u2500\u2500 Header: \"My Stats\"\n\u2502   \u2514\u2500\u2500 Content\n\u2502       \u251c\u2500\u2500 LibraryOverview (compact row of counts)\n\u2502       \u251c\u2500\u2500 EngagementTotals (prominent metrics)\n\u2502       \u251c\u2500\u2500 TopLists (grid of top 5 lists)\n\u2502       \u2502   \u251c\u2500\u2500 TopPerformers\n\u2502       \u2502   \u251c\u2500\u2500 TopStudios\n\u2502       \u2502   \u2514\u2500\u2500 TopTags\n\u2502       \u2514\u2500\u2500 Highlights (most watched/viewed/O'd)\n\u2502           \u251c\u2500\u2500 MostWatchedScene\n\u2502           \u251c\u2500\u2500 MostViewedImage\n\u2502           \u251c\u2500\u2500 MostOdScene\n\u2502           \u2514\u2500\u2500 MostOdPerformer\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-page-design/#component-descriptions","title":"Component Descriptions","text":"<p>LibraryOverview - Compact horizontal row of 6 stat boxes - Shows: Scenes, Performers, Studios, Tags, Galleries, Images - Count + label per box - Uses existing <code>Paper</code> component styling</p> <p>EngagementTotals - Hero section with larger numbers - Total Watch Time (formatted: \"2d 14h 32m\" or \"47h 12m\") - Total Play Count - Total O Count - Unique Scenes Watched (with % of library) - Images Viewed</p> <p>TopLists - Grid of 3 ranked lists (performers, studios, tags) - Each shows rank 1-5 with:   - Small thumbnail   - Name (clickable link to entity page)   - Play count and O count as secondary info - Responsive: 3 columns desktop, stacks mobile</p> <p>Highlights - 2x2 grid of feature cards - Each card shows:   - Larger thumbnail   - Title/name   - The highlighted stat - Clickable to navigate to entity</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#states","title":"States","text":"<p>Loading: Skeleton loaders matching layout structure</p> <p>Empty: Friendly message if no watch history (\"Start watching to see your stats!\")</p> <p>Partial: Individual sections hide if no data (e.g., no images viewed = hide image-related stats)</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#file-structure","title":"File Structure","text":"<pre><code>client/src/pages/\n  UserStats/\n    UserStats.jsx\n    components/\n      LibraryOverview.jsx\n      EngagementTotals.jsx\n      TopList.jsx\n      HighlightCard.jsx\n    hooks/\n      useUserStats.js\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-page-design/#navigation-integration","title":"Navigation Integration","text":"<p>Add \"My Stats\" to the user context menu in the navigation, positioned after \"Watch History\":</p> <pre><code>User Menu\n\u251c\u2500\u2500 Watch History\n\u251c\u2500\u2500 My Stats        \u2190 new\n\u251c\u2500\u2500 Hidden Items\n\u251c\u2500\u2500 Settings\n\u2514\u2500\u2500 Logout\n</code></pre>"},{"location":"plans/2026-01-16-user-stats-page-design/#future-enhancements","title":"Future Enhancements","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#streaks-records","title":"Streaks &amp; Records","text":"Stat Description Data Source Current activity streak Consecutive days with play activity <code>playHistory</code> timestamps Longest activity streak All-time record <code>playHistory</code> timestamps Current O streak Consecutive days with O activity <code>oHistory</code> timestamps Longest O streak All-time record <code>oHistory</code> timestamps Day with most Os Single day highest O count Aggregate by date Day with most watch time Single day highest duration Aggregate by date Longest single session Longest continuous viewing Session detection Most scenes in one day Single day record Count by date <p>Notes: - Streak calculation requires iterating sorted timestamps - Consider pre-computing and caching streaks - Session detection: gap &gt; 2 minutes = new session</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#time-based-insights","title":"Time-Based Insights","text":"Stat Visualization Day of week patterns Bar chart (Mon-Sun) Time of day patterns Pie/bar chart (Morning/Afternoon/Evening/Night) Monthly trends Line or bar chart Busiest week Text callout First watched this year Feature card Calendar heatmap GitHub-style activity grid <p>Notes: - Parse timestamps from <code>playHistory</code> and <code>oHistory</code> - Calendar heatmap: 52\u00d77 grid, color intensity by activity</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#advanced-top-lists","title":"Advanced Top Lists","text":"Stat Description Top by watch time Ranked by total seconds Top by O count Ranked by total Os Most loyal performer Most consistent returns over time Recent discoveries First watched in last 30 days Rising favorites Increasing activity trend"},{"location":"plans/2026-01-16-user-stats-page-design/#comparative-stats","title":"Comparative Stats","text":"Stat Description Library coverage % of scenes watched Performer coverage % of performers with watched scenes Average rating given Mean of all ratings Rating distribution Histogram (0-100) Favorites count Total favorites by type"},{"location":"plans/2026-01-16-user-stats-page-design/#funnovelty-stats","title":"Fun/Novelty Stats","text":"Stat Description Viewer personality type Behavior-based type assignment Surprising insights Unexpected correlations Rarest tag watched Least common tag in watched content Average scene length preference Short vs long preference Completion rate % of scenes watched to completion <p>Personality Types: - \"Night Owl\" - mostly late night activity - \"Weekend Warrior\" - weekend activity spikes - \"Completionist\" - high completion rate - \"Explorer\" - many different performers/tags - \"Loyalist\" - returns to same favorites - \"Binger\" - long sessions, many scenes per day</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#time-period-filtering","title":"Time Period Filtering","text":"<p>Dropdown options: - All time (default) - This year - This month - Last 30 days - Last 7 days - Custom date range</p> <p>Notes: - Filter timestamps in history arrays - Consider caching common periods</p>"},{"location":"plans/2026-01-16-user-stats-page-design/#shareable-cards","title":"Shareable Cards","text":"<ul> <li>Generate image cards summarizing stats</li> <li>\"Wrapped\" style year-end presentation</li> <li>Download as image for sharing</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#ui-enhancements","title":"UI Enhancements","text":"Enhancement Description Animated counters Numbers count up on load Charts library recharts or similar Theme-aware charts Match dark/light theme Print/export PDF or image export Comparison mode Compare two time periods"},{"location":"plans/2026-01-16-user-stats-page-design/#technical-considerations","title":"Technical Considerations","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#performance","title":"Performance","text":"<ul> <li>Single API call for all stats (reduce round trips)</li> <li>Use <code>UserEntityStats</code> for pre-computed library counts</li> <li>Use <code>UserPerformerStats</code>, <code>UserStudioStats</code>, <code>UserTagStats</code> for top lists</li> <li>Raw SQL with proper indexes for aggregations</li> <li>Consider caching response (invalidate on activity)</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#database-indexes","title":"Database Indexes","text":"<p>Existing indexes should be sufficient: - <code>WatchHistory</code>: <code>userId</code>, <code>sceneId</code>, <code>lastPlayedAt</code> - <code>ImageViewHistory</code>: <code>userId</code>, <code>imageId</code>, <code>lastViewedAt</code> - <code>UserExcludedEntity</code>: <code>[userId, entityType]</code> - <code>User*Stats</code>: <code>userId</code></p>"},{"location":"plans/2026-01-16-user-stats-page-design/#security","title":"Security","text":"<ul> <li>Endpoint requires authentication</li> <li>Stats only returned for requesting user</li> <li>No cross-user data exposure</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#implementation-checklist","title":"Implementation Checklist","text":""},{"location":"plans/2026-01-16-user-stats-page-design/#backend","title":"Backend","text":"<ul> <li> Create <code>UserStatsAggregationService</code></li> <li> Implement exclusion-aware aggregation queries</li> <li> Add <code>GET /api/user-stats</code> endpoint</li> <li> Add route to Express router</li> <li> Write integration tests</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#frontend","title":"Frontend","text":"<ul> <li> Create <code>UserStats</code> page component</li> <li> Create <code>LibraryOverview</code> component</li> <li> Create <code>EngagementTotals</code> component</li> <li> Create <code>TopList</code> component</li> <li> Create <code>HighlightCard</code> component</li> <li> Create <code>useUserStats</code> hook</li> <li> Add route to React Router</li> <li> Add \"My Stats\" to user context menu</li> <li> Implement loading skeletons</li> <li> Implement empty state</li> <li> Write component tests</li> </ul>"},{"location":"plans/2026-01-16-user-stats-page-design/#polish","title":"Polish","text":"<ul> <li> Responsive layout testing</li> <li> TV mode navigation support</li> <li> Time formatting utilities (duration display)</li> <li> Link all clickable entities to their pages</li> </ul>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/","title":"Issue #221: Density and Styling Fixes Design","text":"<p>Date: 2026-01-17 Branch: <code>fix/221-density-and-styling-bugs</code> GitHub Issue: https://github.com/carrotwaxr/peek-stash-browser/issues/221</p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#overview","title":"Overview","text":"<p>This design addresses feedback from user @honeypotfields in issue #221 regarding card density, styling bugs, and new customization settings.</p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#scope","title":"Scope","text":"# Issue Type Priority 1 View Toggle Active Styling Bug Bug High 2 Table View Gallery Images Not Showing Bug High 3 Card Density - Fixed Heights Bug Bug High 4 New Setting: Hide Relationship Indicators Feature Medium 5 New Setting: Hide Date Feature Medium 6 New Setting: Hide Studio Name Feature Medium 7 Default View Mode (per-entity) Feature Medium 8 Fullscreen Exit Behavior Bug Medium <p>Deferred: - Table View mobile column overlay (separate issue - responsive table design)</p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issue-1-view-toggle-active-styling-bug","title":"Issue 1: View Toggle Active Styling Bug","text":"<p>Problem: Rapidly tapping Grid/Wall/Hierarchy/Table buttons can cause multiple buttons to appear highlighted, or none at all.</p> <p>Root Cause: <code>ViewModeToggle</code> component uses inline styles with <code>value === mode.id</code> comparison. React state updates asynchronously, causing race conditions when users click rapidly.</p> <p>Solution: Add local optimistic state to provide immediate visual feedback:</p> <pre><code>// ViewModeToggle.jsx\nconst [localValue, setLocalValue] = useState(value);\n\nuseEffect(() =&gt; {\n  setLocalValue(value); // sync when parent state settles\n}, [value]);\n\nconst handleClick = (modeId) =&gt; {\n  setLocalValue(modeId);  // immediate visual feedback\n  onChange(modeId);        // trigger parent update\n};\n\n// Use localValue for styling comparison\nbackgroundColor: localValue === mode.id ? \"var(--accent-primary)\" : \"transparent\"\n</code></pre> <p>Files: <code>client/src/components/ui/ViewModeToggle.jsx</code></p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issue-2-table-view-gallery-images-not-showing","title":"Issue 2: Table View Gallery Images Not Showing","text":"<p>Problem: Gallery cover images don't appear in Table View at all.</p> <p>Root Cause: In <code>cellRenderers.jsx</code>, the gallery cover renderer expects: <pre><code>src={gallery.cover?.paths?.thumbnail || gallery.image_path}\n</code></pre></p> <p>But the backend sends <code>gallery.cover</code> as a direct string URL, not an object with nested <code>paths.thumbnail</code>.</p> <p>Solution: Change the gallery cover cell renderer:</p> <pre><code>cover: (gallery) =&gt; (\n  &lt;ThumbnailCell\n    src={gallery.cover}\n    alt={gallery.title}\n    linkTo={`/gallery/${gallery.id}`}\n    entityType=\"gallery\"\n  /&gt;\n),\n</code></pre> <p>Files: <code>client/src/components/table/cellRenderers.jsx</code></p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issue-3-card-density-fixed-heights-bug","title":"Issue 3: Card Density - Fixed Heights Bug","text":"<p>Problem: Hiding card elements (ratings, favorites, etc.) doesn't reduce card size because components use fixed heights.</p> <p>Root Causes: 1. <code>CardContainer</code>: <code>minHeight: \"20rem\"</code> (320px) prevents shrinking 2. <code>CardTitle</code> subtitle: <code>height: \"1.25rem\"</code> always reserves space even when hidden 3. <code>CardIndicators</code>: Fixed <code>height: \"3.5rem\"</code> even when empty 4. <code>CardRatingRow</code>: Fixed <code>height: \"2rem\"</code> even when all buttons hidden</p> <p>Solution:</p> <ol> <li> <p>CardContainer: Remove <code>minHeight</code>. Grid container with <code>align-items: stretch</code> will ensure cards in same row have equal height (tallest card sets row height).</p> </li> <li> <p>CardTitle: Only reserve subtitle height when subtitle is actually rendered.</p> </li> <li> <p>CardIndicators: Don't render the wrapper div at all when <code>indicators</code> array is empty (currently in BaseCard: <code>{indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators ... /&gt;}</code> - but CardIndicators itself adds fixed height div).</p> </li> <li> <p>CardRatingRow: When only EntityMenu remains (all buttons hidden), reduce height from <code>2rem</code> to <code>auto</code> or smaller value (~1.5rem).</p> </li> </ol> <p>Files: - <code>client/src/components/ui/CardComponents.jsx</code> - <code>client/src/components/ui/BaseCard.jsx</code></p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issues-4-6-new-per-entity-settings","title":"Issues 4-6: New Per-Entity Settings","text":"<p>New settings to add:</p> Setting Applicable Entities Description <code>showRelationshipIndicators</code> All Toggle count indicators (performers, tags, scenes, etc.) <code>showDate</code> scene, gallery, image Toggle date in subtitle <code>showStudio</code> scene, gallery, image Toggle studio name in subtitle <p>Implementation:</p> <ol> <li>CardDisplaySettingsContext.jsx - Add new default settings per entity type</li> <li>CardDisplaySettings.jsx - Add toggle UI for new settings</li> <li>Card components - Pass settings to subtitle builders and BaseCard</li> <li>Subtitle builder functions - Conditionally include studio/date</li> </ol> <p>Settings UI example (Scenes): <pre><code>Scene Cards\n\u251c\u2500\u2500 Default View Mode: [Grid \u25bc]\n\u251c\u2500\u2500 Show Description on Card\n\u251c\u2500\u2500 Show Description on Detail\n\u251c\u2500\u2500 Show Code on Card\n\u251c\u2500\u2500 Show Studio \u2190 NEW\n\u251c\u2500\u2500 Show Date \u2190 NEW\n\u251c\u2500\u2500 Show Relationship Indicators \u2190 NEW\n\u251c\u2500\u2500 Show Rating\n\u251c\u2500\u2500 Show Favorite\n\u2514\u2500\u2500 Show O-Counter\n</code></pre></p> <p>Files: - <code>client/src/contexts/CardDisplaySettingsContext.jsx</code> - <code>client/src/components/settings/CardDisplaySettings.jsx</code> - <code>client/src/components/cards/SceneCard.jsx</code> (and other card components) - Subtitle builder utilities</p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issue-7-default-view-mode-per-entity","title":"Issue 7: Default View Mode (Per-Entity)","text":"<p>Problem: Users must manually select preferred view mode each page visit.</p> <p>Solution: Add <code>defaultViewMode</code> setting per entity type.</p> <p>Shared Config Structure:</p> <p>Create a DRY config that defines per-entity: - Available view modes - Default view mode - Which settings apply to that entity</p> <pre><code>// client/src/config/entityDisplayConfig.js\nexport const ENTITY_DISPLAY_CONFIG = {\n  scene: {\n    viewModes: [\"grid\", \"wall\", \"table\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showCodeOnCard: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n  gallery: {\n    viewModes: [\"grid\", \"wall\", \"table\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n  image: {\n    viewModes: [\"grid\", \"wall\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n  performer: {\n    viewModes: [\"grid\", \"wall\", \"table\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n  studio: {\n    viewModes: [\"grid\", \"wall\", \"table\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n  tag: {\n    viewModes: [\"grid\", \"table\", \"hierarchy\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n    }\n  },\n  group: {\n    viewModes: [\"grid\", \"wall\", \"table\"],\n    defaultViewMode: \"grid\",\n    settings: {\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    }\n  },\n};\n</code></pre> <p>Integration: - <code>CardDisplaySettingsContext.jsx</code> uses config for defaults - <code>CardDisplaySettings.jsx</code> uses config to render appropriate toggles per entity - Page components use config to determine available view modes and load default</p> <p>Files: - <code>client/src/config/entityDisplayConfig.js</code> (NEW) - <code>client/src/contexts/CardDisplaySettingsContext.jsx</code> - <code>client/src/components/settings/CardDisplaySettings.jsx</code> - Page components (Scenes.jsx, Galleries.jsx, etc.) - <code>client/src/hooks/useFilterState.js</code></p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#issue-8-fullscreen-exit-behavior","title":"Issue 8: Fullscreen Exit Behavior","text":"<p>Problem: Closing lightbox (X button, swipe down) doesn't exit browser fullscreen mode.</p> <p>Solution: When handling close actions, exit fullscreen first:</p> <pre><code>const handleClose = () =&gt; {\n  // Exit browser fullscreen if active\n  if (document.fullscreenElement) {\n    document.exitFullscreen();\n  }\n  // Then close lightbox\n  onClose();\n};\n</code></pre> <p>Apply to all close triggers: - X button click - Swipe down gesture - Escape key press</p> <p>Files: Lightbox component (location TBD during implementation)</p>"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#file-impact-summary","title":"File Impact Summary","text":"File Changes <code>client/src/components/ui/ViewModeToggle.jsx</code> Add local optimistic state <code>client/src/components/table/cellRenderers.jsx</code> Fix gallery cover renderer <code>client/src/components/ui/CardComponents.jsx</code> Remove fixed heights, conditional rendering <code>client/src/components/ui/BaseCard.jsx</code> Pass through new settings <code>client/src/config/entityDisplayConfig.js</code> NEW - shared entity config <code>client/src/contexts/CardDisplaySettingsContext.jsx</code> Add new settings, use shared config <code>client/src/components/settings/CardDisplaySettings.jsx</code> Add new toggles, use shared config <code>client/src/components/cards/*.jsx</code> Pass new settings to subtitle builders <code>client/src/components/pages/*.jsx</code> Load default view mode from settings <code>client/src/hooks/useFilterState.js</code> Accept default view mode parameter Lightbox component Exit fullscreen on close"},{"location":"plans/2026-01-17-issue-221-density-and-styling-fixes-design/#implementation-order","title":"Implementation Order","text":"<ol> <li>Bug fixes first:</li> <li>View Toggle styling (isolated, quick fix)</li> <li>Table View gallery images (one-line fix)</li> <li> <p>Fullscreen exit behavior (isolated fix)</p> </li> <li> <p>Card density fix:</p> </li> <li> <p>Requires testing to ensure grid layout still works properly</p> </li> <li> <p>New shared config:</p> </li> <li>Create <code>entityDisplayConfig.js</code></li> <li> <p>Foundation for features below</p> </li> <li> <p>New settings (can be done together):</p> </li> <li>Add to context and settings UI</li> <li> <p>Wire up to card components</p> </li> <li> <p>Default view mode:</p> </li> <li>Add to settings UI</li> <li>Integrate with page components and useFilterState</li> </ol>"},{"location":"plans/2026-01-17-issue-221-implementation/","title":"Issue #221 Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix card density bugs, view toggle styling, table view gallery images, fullscreen exit, and add new card display settings (hide indicators/date/studio, default view mode per entity).</p> <p>Architecture: Extend existing CardDisplaySettingsContext with new per-entity settings. Create shared entityDisplayConfig.js for DRY configuration of available view modes and settings per entity type. Fix component bugs in ViewModeToggle, cellRenderers, CardComponents, and Lightbox.</p> <p>Tech Stack: React, Vitest, React Testing Library</p>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-1-fix-view-toggle-active-styling-bug","title":"Task 1: Fix View Toggle Active Styling Bug","text":"<p>Files: - Modify: <code>client/src/components/ui/ViewModeToggle.jsx</code> - Modify: <code>client/tests/components/ui/ViewModeToggle.test.jsx</code></p> <p>Step 1: Add test for rapid click stability</p> <p>Add to existing test file:</p> <pre><code>// In client/tests/components/ui/ViewModeToggle.test.jsx\n\ndescribe(\"rapid click stability\", () =&gt; {\n  it(\"shows exactly one active button after rapid clicks\", async () =&gt; {\n    const onChange = vi.fn();\n    const { rerender } = render(\n      &lt;ViewModeToggle\n        modes={[\n          { id: \"grid\", label: \"Grid view\" },\n          { id: \"wall\", label: \"Wall view\" },\n          { id: \"table\", label: \"Table view\" },\n        ]}\n        value=\"grid\"\n        onChange={onChange}\n      /&gt;\n    );\n\n    const wallBtn = screen.getByLabelText(\"Wall view\");\n    const tableBtn = screen.getByLabelText(\"Table view\");\n    const gridBtn = screen.getByLabelText(\"Grid view\");\n\n    // Rapid clicks\n    fireEvent.click(wallBtn);\n    fireEvent.click(tableBtn);\n    fireEvent.click(gridBtn);\n    fireEvent.click(wallBtn);\n\n    // Simulate parent updating value to last clicked\n    rerender(\n      &lt;ViewModeToggle\n        modes={[\n          { id: \"grid\", label: \"Grid view\" },\n          { id: \"wall\", label: \"Wall view\" },\n          { id: \"table\", label: \"Table view\" },\n        ]}\n        value=\"wall\"\n        onChange={onChange}\n      /&gt;\n    );\n\n    // Verify exactly one button is active\n    const buttons = screen.getAllByRole(\"button\");\n    const activeButtons = buttons.filter(\n      (btn) =&gt; btn.getAttribute(\"aria-pressed\") === \"true\"\n    );\n    expect(activeButtons).toHaveLength(1);\n    expect(activeButtons[0]).toBe(screen.getByLabelText(\"Wall view\"));\n  });\n\n  it(\"immediately shows clicked button as active (optimistic)\", () =&gt; {\n    const onChange = vi.fn();\n    render(\n      &lt;ViewModeToggle\n        modes={[\n          { id: \"grid\", label: \"Grid view\" },\n          { id: \"wall\", label: \"Wall view\" },\n        ]}\n        value=\"grid\"\n        onChange={onChange}\n      /&gt;\n    );\n\n    const wallBtn = screen.getByLabelText(\"Wall view\");\n    fireEvent.click(wallBtn);\n\n    // Should immediately show as active (optimistic update)\n    expect(wallBtn.getAttribute(\"aria-pressed\")).toBe(\"true\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run ViewModeToggle</code> Expected: FAIL - optimistic test fails because current implementation doesn't have local state</p> <p>Step 3: Implement local optimistic state</p> <pre><code>// client/src/components/ui/ViewModeToggle.jsx\nimport { useState, useEffect } from \"react\";\nimport { LucideGrid2X2, LucideSquare, LucideNetwork, LucideList } from \"lucide-react\";\n\n// Default modes for backward compatibility\nconst DEFAULT_MODES = [\n  { id: \"grid\", icon: LucideGrid2X2, label: \"Grid view\" },\n  { id: \"wall\", icon: LucideSquare, label: \"Wall view\" },\n];\n\n// Icon mapping for custom mode definitions\nconst MODE_ICONS = {\n  grid: LucideGrid2X2,\n  wall: LucideSquare,\n  hierarchy: LucideNetwork,\n  table: LucideList,\n};\n\n/**\n * Toggle between view modes.\n *\n * @param {Array} modes - Optional custom modes array [{id, label, icon?}]\n *                        If not provided, defaults to grid/wall\n * @param {string} value - Currently selected mode id\n * @param {function} onChange - Called with mode id when selection changes\n */\nconst ViewModeToggle = ({ modes, value = \"grid\", onChange, className = \"\" }) =&gt; {\n  // Local state for immediate visual feedback (optimistic update)\n  const [localValue, setLocalValue] = useState(value);\n\n  // Sync local state when parent value changes (authoritative)\n  useEffect(() =&gt; {\n    setLocalValue(value);\n  }, [value]);\n\n  const handleClick = (modeId) =&gt; {\n    setLocalValue(modeId); // Immediate visual feedback\n    onChange(modeId);       // Trigger parent update\n  };\n\n  // Use custom modes or fall back to defaults\n  const effectiveModes = modes\n    ? modes.map((mode) =&gt; ({\n        ...mode,\n        icon: mode.icon || MODE_ICONS[mode.id] || LucideGrid2X2,\n      }))\n    : DEFAULT_MODES;\n\n  return (\n    &lt;div\n      className={`inline-flex items-center rounded-lg overflow-hidden h-[34px] ${className}`}\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {effectiveModes.map((mode) =&gt; (\n        &lt;button\n          key={mode.id}\n          type=\"button\"\n          onClick={() =&gt; handleClick(mode.id)}\n          className=\"px-2.5 h-full transition-colors flex items-center justify-center\"\n          style={{\n            backgroundColor: localValue === mode.id ? \"var(--accent-primary)\" : \"transparent\",\n            color: localValue === mode.id ? \"white\" : \"var(--text-secondary)\",\n          }}\n          title={mode.label}\n          aria-label={mode.label}\n          aria-pressed={localValue === mode.id}\n        &gt;\n          &lt;mode.icon size={18} /&gt;\n        &lt;/button&gt;\n      ))}\n    &lt;/div&gt;\n  );\n};\n\nexport default ViewModeToggle;\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run ViewModeToggle</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/ViewModeToggle.jsx client/tests/components/ui/ViewModeToggle.test.jsx &amp;&amp; git commit -m \"fix: View toggle uses local state for immediate visual feedback\n\nPrevents visual glitches when rapidly clicking view mode buttons.\nLocal state provides optimistic update while parent state settles.\n\nFixes #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-2-fix-table-view-gallery-images","title":"Task 2: Fix Table View Gallery Images","text":"<p>Files: - Modify: <code>client/src/components/table/cellRenderers.jsx:394-401</code></p> <p>Step 1: Write test for gallery cover renderer</p> <p>Create new test file:</p> <pre><code>// client/tests/components/table/cellRenderers.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { MemoryRouter } from \"react-router-dom\";\nimport { describe, it, expect } from \"vitest\";\nimport { getCellRenderer } from \"../../../src/components/table/cellRenderers.jsx\";\n\ndescribe(\"cellRenderers\", () =&gt; {\n  describe(\"gallery cover renderer\", () =&gt; {\n    it(\"renders thumbnail from gallery.cover string URL\", () =&gt; {\n      const gallery = {\n        id: \"123\",\n        title: \"Test Gallery\",\n        cover: \"/api/proxy/stash?path=/galleries/cover.jpg\",\n      };\n\n      const CoverRenderer = getCellRenderer(\"cover\", \"gallery\");\n      render(\n        &lt;MemoryRouter&gt;\n          &lt;CoverRenderer {...gallery} /&gt;\n        &lt;/MemoryRouter&gt;\n      );\n\n      const img = screen.getByRole(\"img\");\n      expect(img).toHaveAttribute(\"src\", \"/api/proxy/stash?path=/galleries/cover.jpg\");\n    });\n\n    it(\"renders placeholder when gallery has no cover\", () =&gt; {\n      const gallery = {\n        id: \"123\",\n        title: \"Test Gallery\",\n        cover: null,\n      };\n\n      const CoverRenderer = getCellRenderer(\"cover\", \"gallery\");\n      render(\n        &lt;MemoryRouter&gt;\n          &lt;CoverRenderer {...gallery} /&gt;\n        &lt;/MemoryRouter&gt;\n      );\n\n      // Should render ThumbnailCell with no src (shows placeholder)\n      const link = screen.getByRole(\"link\");\n      expect(link).toHaveAttribute(\"href\", \"/gallery/123\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run cellRenderers</code> Expected: FAIL - image src will be undefined because current code tries <code>gallery.cover?.paths?.thumbnail</code></p> <p>Step 3: Fix gallery cover renderer</p> <p>In <code>client/src/components/table/cellRenderers.jsx</code>, change lines 394-401:</p> <pre><code>// FROM:\ncover: (gallery) =&gt; (\n  &lt;ThumbnailCell\n    src={gallery.cover?.paths?.thumbnail || gallery.image_path}\n    alt={gallery.title}\n    linkTo={`/gallery/${gallery.id}`}\n    entityType=\"gallery\"\n  /&gt;\n),\n\n// TO:\ncover: (gallery) =&gt; (\n  &lt;ThumbnailCell\n    src={gallery.cover}\n    alt={gallery.title}\n    linkTo={`/gallery/${gallery.id}`}\n    entityType=\"gallery\"\n  /&gt;\n),\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run cellRenderers</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/table/cellRenderers.jsx client/tests/components/table/cellRenderers.test.jsx &amp;&amp; git commit -m \"fix: Gallery cover images now display in Table View\n\nBackend sends gallery.cover as string URL, not object with paths.thumbnail.\nUpdated renderer to use the direct string value.\n\nFixes #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-3-fix-card-density-remove-fixed-heights","title":"Task 3: Fix Card Density - Remove Fixed Heights","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx</code></p> <p>Step 1: Write tests for dynamic height behavior</p> <pre><code>// client/tests/components/ui/CardComponents.density.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { MemoryRouter } from \"react-router-dom\";\nimport { describe, it, expect, vi } from \"vitest\";\nimport { CardContainer, CardTitle, CardIndicators, CardRatingRow } from \"../../../src/components/ui/CardComponents.jsx\";\n\n// Mock hooks used by CardRatingRow\nvi.mock(\"../../../src/hooks/useHiddenEntities.js\", () =&gt; ({\n  useHiddenEntities: () =&gt; ({\n    hideEntity: vi.fn(),\n    hideConfirmationDisabled: false,\n  }),\n}));\n\ndescribe(\"CardComponents density\", () =&gt; {\n  describe(\"CardContainer\", () =&gt; {\n    it(\"does not have fixed minHeight\", () =&gt; {\n      render(&lt;CardContainer&gt;Content&lt;/CardContainer&gt;);\n      const container = screen.getByLabelText(\"Card\");\n      expect(container.style.minHeight).toBe(\"\");\n    });\n  });\n\n  describe(\"CardTitle\", () =&gt; {\n    it(\"does not reserve height when subtitle is null\", () =&gt; {\n      const { container } = render(\n        &lt;MemoryRouter&gt;\n          &lt;CardTitle title=\"Test\" subtitle={null} /&gt;\n        &lt;/MemoryRouter&gt;\n      );\n      // Should not render subtitle element at all\n      const subtitles = container.querySelectorAll(\"h4\");\n      expect(subtitles).toHaveLength(0);\n    });\n\n    it(\"renders subtitle when provided\", () =&gt; {\n      render(\n        &lt;MemoryRouter&gt;\n          &lt;CardTitle title=\"Test\" subtitle=\"Studio Name\" /&gt;\n        &lt;/MemoryRouter&gt;\n      );\n      expect(screen.getByText(\"Studio Name\")).toBeInTheDocument();\n    });\n  });\n\n  describe(\"CardIndicators\", () =&gt; {\n    it(\"does not render wrapper when indicators is empty\", () =&gt; {\n      const { container } = render(&lt;CardIndicators indicators={[]} /&gt;);\n      expect(container.firstChild).toBeNull();\n    });\n\n    it(\"does not render wrapper when indicators is null\", () =&gt; {\n      const { container } = render(&lt;CardIndicators indicators={null} /&gt;);\n      expect(container.firstChild).toBeNull();\n    });\n  });\n\n  describe(\"CardRatingRow\", () =&gt; {\n    it(\"uses compact height when only menu is visible\", () =&gt; {\n      render(\n        &lt;CardRatingRow\n          entityType=\"scene\"\n          entityId=\"123\"\n          showRating={false}\n          showFavorite={false}\n          showOCounter={false}\n        /&gt;\n      );\n      const row = screen.getByRole(\"button\", { name: /menu/i }).closest(\"div\");\n      // Row should exist but be more compact\n      expect(row).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run CardComponents.density</code> Expected: FAIL - CardContainer has minHeight, CardTitle always renders subtitle space, etc.</p> <p>Step 3: Update CardContainer - remove minHeight</p> <p>In <code>client/src/components/ui/CardComponents.jsx</code>, modify <code>CardContainer</code> (around line 38-56):</p> <pre><code>export const CardContainer = forwardRef(\n  (\n    {\n      children,\n      className = \"\",\n      entityType = \"card\",\n      onClick,\n      style = {},\n      ...others\n    },\n    ref\n  ) =&gt; {\n    const entityDisplayType =\n      entityType.charAt(0).toUpperCase() + entityType.slice(1);\n\n    return (\n      &lt;div\n        aria-label={`${entityDisplayType}`}\n        className={`flex flex-col items-center justify-between rounded-lg border p-2 hover:shadow-lg hover:scale-[1.02] transition-all focus:outline-none ${className}`}\n        ref={ref}\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n          // Removed: minHeight: \"20rem\"\n          // Removed: maxHeight: \"36rem\"\n          ...style,\n        }}\n        onClick={onClick}\n        {...others}\n      &gt;\n        {children}\n      &lt;/div&gt;\n    );\n  }\n);\n</code></pre> <p>Step 4: Update CardTitle - only render subtitle when present</p> <p>In <code>client/src/components/ui/CardComponents.jsx</code>, modify <code>CardTitle</code> (around line 317-410):</p> <pre><code>export const CardTitle = ({\n  title,\n  subtitle,\n  hideSubtitle = false,\n  maxTitleLines = 1,\n  linkTo,\n  fromPageTitle,\n  onClickOverride,\n}) =&gt; {\n  // Calculate fixed height based on line count\n  const titleHeight = useMemo(() =&gt; {\n    return `${maxTitleLines * 1.25}rem`;\n  }, [maxTitleLines]);\n\n  const titleIsString = typeof title === \"string\";\n  const shouldShowSubtitle = !hideSubtitle &amp;&amp; subtitle;\n\n  const titleElement = (\n    &lt;h3\n      className=\"font-semibold leading-tight text-center\"\n      style={{\n        color: \"var(--text-primary)\",\n        height: titleHeight,\n        display: \"-webkit-box\",\n        WebkitLineClamp: maxTitleLines,\n        WebkitBoxOrient: \"vertical\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        overflowWrap: \"break-word\",\n      }}\n    &gt;\n      {title}\n    &lt;/h3&gt;\n  );\n\n  // Wrap in Link if linkTo provided\n  const titleContent = linkTo ? (\n    &lt;Link\n      to={linkTo}\n      state={{ fromPageTitle }}\n      className=\"block hover:underline cursor-pointer\"\n      onClick={onClickOverride}\n    &gt;\n      {titleElement}\n    &lt;/Link&gt;\n  ) : (\n    titleElement\n  );\n\n  // Only render subtitle element if we have content\n  const subtitleElement = shouldShowSubtitle &amp;&amp; (\n    &lt;h4\n      className=\"text-sm leading-tight text-center\"\n      style={{\n        color: \"var(--text-muted)\",\n        display: \"-webkit-box\",\n        WebkitLineClamp: 1,\n        WebkitBoxOrient: \"vertical\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n      }}\n      title={subtitle}\n    &gt;\n      {subtitle}\n    &lt;/h4&gt;\n  );\n\n  const subtitleContent = linkTo &amp;&amp; subtitleElement ? (\n    &lt;Link\n      to={linkTo}\n      state={{ fromPageTitle }}\n      className=\"block cursor-pointer\"\n      onClick={onClickOverride}\n    &gt;\n      {subtitleElement}\n    &lt;/Link&gt;\n  ) : (\n    subtitleElement\n  );\n\n  return (\n    &lt;div className=\"w-full text-center mb-2\"&gt;\n      {titleIsString ? (\n        &lt;Tooltip content={title} disabled={!title || title.length &lt; 30}&gt;\n          {titleContent}\n        &lt;/Tooltip&gt;\n      ) : (\n        titleContent\n      )}\n      {subtitleContent}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 5: Update CardIndicators - don't render when empty</p> <p>In <code>client/src/components/ui/CardComponents.jsx</code>, modify <code>CardIndicators</code> (around line 426-431):</p> <pre><code>/**\n * Card indicators section - only renders when indicators exist\n */\nexport const CardIndicators = ({ indicators }) =&gt; {\n  // Don't render anything if no indicators\n  if (!indicators || indicators.length === 0) {\n    return null;\n  }\n\n  return (\n    &lt;div className=\"my-2 w-full\"&gt;\n      &lt;CardCountIndicators indicators={indicators} /&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 6: Update CardRatingRow - compact when only menu visible</p> <p>In <code>client/src/components/ui/CardComponents.jsx</code>, modify <code>CardRatingRow</code> (around line 557-602):</p> <pre><code>// Inside CardRatingRow, update the return statement:\n\n// Check if any controls are visible (besides the always-present menu)\nconst hasVisibleControls = showRating || showFavorite || showOCounter;\n\nreturn (\n  &lt;&gt;\n    &lt;div\n      className=\"flex justify-between items-center w-full my-1\"\n      style={{ height: hasVisibleControls ? \"2rem\" : \"1.5rem\" }}\n    &gt;\n      {/* Left side: Rating badge */}\n      &lt;div ref={badgeRef}&gt;\n        {showRating &amp;&amp; (\n          &lt;RatingBadge\n            rating={rating}\n            onClick={() =&gt; setDialogOpen(true)}\n            size=\"small\"\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      {/* Right side: O Counter + Favorite + EntityMenu */}\n      &lt;div className=\"flex items-center gap-2\"&gt;\n        {showOCounter &amp;&amp; (\n          &lt;OCounterButton\n            sceneId={entityType === \"scene\" ? entityId : null}\n            imageId={entityType === \"image\" ? entityId : null}\n            initialCount={oCounter ?? 0}\n            onChange={handleOCounterChange}\n            size=\"small\"\n            variant=\"card\"\n            interactive={isSceneOrImage}\n          /&gt;\n        )}\n        {showFavorite &amp;&amp; (\n          &lt;FavoriteButton\n            isFavorite={isFavorite}\n            onChange={handleFavoriteChange}\n            size=\"small\"\n            variant=\"card\"\n          /&gt;\n        )}\n        &lt;EntityMenu\n          entityType={entityType}\n          entityId={entityId}\n          entityName={entityTitle}\n          onHide={handleHideClick}\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    {/* ... dialogs remain unchanged ... */}\n  &lt;/&gt;\n);\n</code></pre> <p>Step 7: Run tests to verify they pass</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run CardComponents</code> Expected: PASS</p> <p>Step 8: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/CardComponents.jsx client/tests/components/ui/CardComponents.density.test.jsx &amp;&amp; git commit -m \"fix: Cards now shrink when elements are hidden\n\n- Remove fixed minHeight from CardContainer (grid handles row alignment)\n- CardTitle only reserves subtitle space when subtitle exists\n- CardIndicators returns null when empty (no fixed height wrapper)\n- CardRatingRow uses compact height when only menu visible\n\nFixes #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-4-create-shared-entity-display-config","title":"Task 4: Create Shared Entity Display Config","text":"<p>Files: - Create: <code>client/src/config/entityDisplayConfig.js</code></p> <p>Step 1: Create the shared configuration file</p> <pre><code>// client/src/config/entityDisplayConfig.js\n\n/**\n * Shared configuration for entity display settings.\n * Used by CardDisplaySettingsContext, CardDisplaySettings UI, and page components.\n * Single source of truth for available view modes and settings per entity type.\n */\n\nexport const ENTITY_DISPLAY_CONFIG = {\n  scene: {\n    label: \"Scene\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showCodeOnCard: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    // Which settings to show in UI for this entity\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showCodeOnCard\",\n      \"showStudio\",\n      \"showDate\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n  gallery: {\n    label: \"Gallery\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showStudio\",\n      \"showDate\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n  image: {\n    label: \"Image\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showStudio: true,\n      showDate: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showStudio\",\n      \"showDate\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n  performer: {\n    label: \"Performer\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n  studio: {\n    label: \"Studio\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n  tag: {\n    label: \"Tag\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"table\", label: \"Table\" },\n      { id: \"hierarchy\", label: \"Hierarchy\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n    ],\n  },\n  group: {\n    label: \"Group\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n    ],\n    defaultSettings: {\n      defaultViewMode: \"grid\",\n      showDescriptionOnCard: true,\n      showDescriptionOnDetail: true,\n      showRelationshipIndicators: true,\n      showRating: true,\n      showFavorite: true,\n      showOCounter: true,\n    },\n    availableSettings: [\n      \"defaultViewMode\",\n      \"showDescriptionOnCard\",\n      \"showDescriptionOnDetail\",\n      \"showRelationshipIndicators\",\n      \"showRating\",\n      \"showFavorite\",\n      \"showOCounter\",\n    ],\n  },\n};\n\n/**\n * Get list of entity types in display order\n */\nexport const getEntityTypes = () =&gt; Object.keys(ENTITY_DISPLAY_CONFIG);\n\n/**\n * Get default settings for an entity type\n */\nexport const getDefaultSettings = (entityType) =&gt; {\n  return ENTITY_DISPLAY_CONFIG[entityType]?.defaultSettings || {};\n};\n\n/**\n * Get available view modes for an entity type\n */\nexport const getViewModes = (entityType) =&gt; {\n  return ENTITY_DISPLAY_CONFIG[entityType]?.viewModes || [{ id: \"grid\", label: \"Grid\" }];\n};\n\n/**\n * Get available settings for an entity type (for UI rendering)\n */\nexport const getAvailableSettings = (entityType) =&gt; {\n  return ENTITY_DISPLAY_CONFIG[entityType]?.availableSettings || [];\n};\n\n/**\n * Setting labels for UI display\n */\nexport const SETTING_LABELS = {\n  defaultViewMode: \"Default view mode\",\n  showCodeOnCard: \"Show studio code on cards\",\n  showStudio: \"Show studio name\",\n  showDate: \"Show date\",\n  showDescriptionOnCard: \"Show description on cards\",\n  showDescriptionOnDetail: \"Show description on detail page\",\n  showRelationshipIndicators: \"Show relationship indicators\",\n  showRating: \"Show rating\",\n  showFavorite: \"Show favorite\",\n  showOCounter: \"Show O counter\",\n};\n\n/**\n * Setting descriptions for UI display\n */\nexport const SETTING_DESCRIPTIONS = {\n  showCodeOnCard: \"Display scene codes (e.g., JAV codes) in card subtitles\",\n  showStudio: \"Display studio name in card subtitles\",\n  showDate: \"Display date in card subtitles\",\n  showRelationshipIndicators: \"Display count badges for performers, tags, etc.\",\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/config/entityDisplayConfig.js &amp;&amp; git commit -m \"feat: Add shared entity display configuration\n\nSingle source of truth for view modes and settings per entity type.\nUsed by CardDisplaySettingsContext and CardDisplaySettings UI.\n\nPart of #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-5-update-carddisplaysettingscontext-to-use-shared-config","title":"Task 5: Update CardDisplaySettingsContext to Use Shared Config","text":"<p>Files: - Modify: <code>client/src/contexts/CardDisplaySettingsContext.jsx</code></p> <p>Step 1: Update context to use shared config</p> <pre><code>// client/src/contexts/CardDisplaySettingsContext.jsx\n/* eslint-disable react-refresh/only-export-components */\nimport { createContext, useContext, useState, useEffect, useCallback } from \"react\";\nimport axios from \"axios\";\nimport { getDefaultSettings } from \"../config/entityDisplayConfig.js\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst CardDisplaySettingsContext = createContext(null);\n\nexport const CardDisplaySettingsProvider = ({ children }) =&gt; {\n  const [settings, setSettings] = useState({});\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load settings on mount\n  useEffect(() =&gt; {\n    const loadSettings = async () =&gt; {\n      try {\n        const response = await api.get(\"/user/settings\");\n        setSettings(response.data.settings.cardDisplaySettings || {});\n      } catch (error) {\n        console.error(\"Failed to load card display settings:\", error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    loadSettings();\n  }, []);\n\n  // Get settings for a specific entity type (with defaults from shared config)\n  const getSettings = useCallback((entityType) =&gt; {\n    const defaults = getDefaultSettings(entityType);\n    const entitySettings = settings[entityType] || {};\n    return { ...defaults, ...entitySettings };\n  }, [settings]);\n\n  // Update a specific setting\n  const updateSettings = useCallback(async (entityType, key, value) =&gt; {\n    const newEntitySettings = {\n      ...(settings[entityType] || {}),\n      [key]: value,\n    };\n    const newSettings = {\n      ...settings,\n      [entityType]: newEntitySettings,\n    };\n\n    // Optimistic update\n    setSettings(newSettings);\n\n    try {\n      await api.put(\"/user/settings\", {\n        cardDisplaySettings: newSettings,\n      });\n    } catch (error) {\n      console.error(\"Failed to save card display settings:\", error);\n      // Revert on error\n      setSettings(settings);\n      throw error;\n    }\n  }, [settings]);\n\n  return (\n    &lt;CardDisplaySettingsContext.Provider value={{ getSettings, updateSettings, isLoading }}&gt;\n      {children}\n    &lt;/CardDisplaySettingsContext.Provider&gt;\n  );\n};\n\nexport const useCardDisplaySettings = () =&gt; {\n  const context = useContext(CardDisplaySettingsContext);\n  if (!context) {\n    throw new Error(\"useCardDisplaySettings must be used within CardDisplaySettingsProvider\");\n  }\n  return context;\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/contexts/CardDisplaySettingsContext.jsx &amp;&amp; git commit -m \"refactor: CardDisplaySettingsContext uses shared config for defaults\n\nPart of #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-6-update-carddisplaysettings-ui-to-use-shared-config","title":"Task 6: Update CardDisplaySettings UI to Use Shared Config","text":"<p>Files: - Modify: <code>client/src/components/settings/CardDisplaySettings.jsx</code></p> <p>Step 1: Rewrite settings UI to use shared config</p> <pre><code>// client/src/components/settings/CardDisplaySettings.jsx\nimport { useState } from \"react\";\nimport { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\nimport {\n  ENTITY_DISPLAY_CONFIG,\n  getEntityTypes,\n  getAvailableSettings,\n  getViewModes,\n  SETTING_LABELS,\n  SETTING_DESCRIPTIONS,\n} from \"../../config/entityDisplayConfig.js\";\nimport { showSuccess, showError } from \"../../utils/toast.jsx\";\n\nconst Toggle = ({ label, checked, onChange, description }) =&gt; (\n  &lt;label className=\"flex items-start gap-3 cursor-pointer\"&gt;\n    &lt;input\n      type=\"checkbox\"\n      checked={checked}\n      onChange={(e) =&gt; onChange(e.target.checked)}\n      className=\"mt-1 w-4 h-4 rounded\"\n      style={{\n        accentColor: \"var(--accent-primary)\",\n      }}\n    /&gt;\n    &lt;div&gt;\n      &lt;span style={{ color: \"var(--text-primary)\" }}&gt;{label}&lt;/span&gt;\n      {description &amp;&amp; (\n        &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n          {description}\n        &lt;/p&gt;\n      )}\n    &lt;/div&gt;\n  &lt;/label&gt;\n);\n\nconst Dropdown = ({ label, value, options, onChange, description }) =&gt; (\n  &lt;div className=\"flex flex-col gap-1\"&gt;\n    &lt;label className=\"flex items-center justify-between gap-3\"&gt;\n      &lt;div&gt;\n        &lt;span style={{ color: \"var(--text-primary)\" }}&gt;{label}&lt;/span&gt;\n        {description &amp;&amp; (\n          &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n            {description}\n          &lt;/p&gt;\n        )}\n      &lt;/div&gt;\n      &lt;select\n        value={value}\n        onChange={(e) =&gt; onChange(e.target.value)}\n        className=\"px-3 py-1.5 rounded border\"\n        style={{\n          backgroundColor: \"var(--bg-primary)\",\n          borderColor: \"var(--border-color)\",\n          color: \"var(--text-primary)\",\n        }}\n      &gt;\n        {options.map((opt) =&gt; (\n          &lt;option key={opt.id} value={opt.id}&gt;\n            {opt.label}\n          &lt;/option&gt;\n        ))}\n      &lt;/select&gt;\n    &lt;/label&gt;\n  &lt;/div&gt;\n);\n\nconst EntitySettingsSection = ({ entityType }) =&gt; {\n  const { getSettings, updateSettings } = useCardDisplaySettings();\n  const settings = getSettings(entityType);\n  const availableSettings = getAvailableSettings(entityType);\n  const viewModes = getViewModes(entityType);\n\n  const handleChange = async (key, value) =&gt; {\n    try {\n      await updateSettings(entityType, key, value);\n      showSuccess(\"Setting saved\");\n    } catch {\n      showError(\"Failed to save setting\");\n    }\n  };\n\n  return (\n    &lt;div className=\"space-y-3\"&gt;\n      &lt;div className=\"space-y-2\"&gt;\n        {/* Default View Mode - always first if available */}\n        {availableSettings.includes(\"defaultViewMode\") &amp;&amp; (\n          &lt;Dropdown\n            label={SETTING_LABELS.defaultViewMode}\n            value={settings.defaultViewMode}\n            options={viewModes}\n            onChange={(v) =&gt; handleChange(\"defaultViewMode\", v)}\n          /&gt;\n        )}\n\n        {/* Toggle settings */}\n        {availableSettings\n          .filter((key) =&gt; key !== \"defaultViewMode\")\n          .map((settingKey) =&gt; (\n            &lt;Toggle\n              key={settingKey}\n              label={SETTING_LABELS[settingKey]}\n              checked={settings[settingKey]}\n              onChange={(v) =&gt; handleChange(settingKey, v)}\n              description={SETTING_DESCRIPTIONS[settingKey]}\n            /&gt;\n          ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst CardDisplaySettings = () =&gt; {\n  const [expandedEntity, setExpandedEntity] = useState(\"scene\");\n  const entityTypes = getEntityTypes();\n\n  return (\n    &lt;div&gt;\n      &lt;h3\n        className=\"text-lg font-semibold mb-4\"\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        Card Display\n      &lt;/h3&gt;\n      &lt;p className=\"text-sm mb-4\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Control what information appears on entity cards and detail pages.\n      &lt;/p&gt;\n\n      {/* Accordion-style entity sections */}\n      &lt;div className=\"space-y-2\"&gt;\n        {entityTypes.map((entityType) =&gt; {\n          const config = ENTITY_DISPLAY_CONFIG[entityType];\n          return (\n            &lt;div\n              key={entityType}\n              className=\"rounded-lg border\"\n              style={{\n                backgroundColor: \"var(--bg-secondary)\",\n                borderColor: \"var(--border-color)\",\n              }}\n            &gt;\n              &lt;button\n                onClick={() =&gt;\n                  setExpandedEntity(expandedEntity === entityType ? null : entityType)\n                }\n                className=\"w-full px-4 py-3 flex justify-between items-center\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                &lt;span className=\"font-medium\"&gt;{config.label}&lt;/span&gt;\n                &lt;span&gt;{expandedEntity === entityType ? \"\u2212\" : \"+\"}&lt;/span&gt;\n              &lt;/button&gt;\n              {expandedEntity === entityType &amp;&amp; (\n                &lt;div className=\"px-4 pb-4\"&gt;\n                  &lt;EntitySettingsSection entityType={entityType} /&gt;\n                &lt;/div&gt;\n              )}\n            &lt;/div&gt;\n          );\n        })}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CardDisplaySettings;\n</code></pre> <p>Step 2: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/settings/CardDisplaySettings.jsx &amp;&amp; git commit -m \"feat: CardDisplaySettings UI uses shared config\n\nNow dynamically renders settings based on entityDisplayConfig.\nIncludes new settings: defaultViewMode, showStudio, showDate, showRelationshipIndicators.\n\nPart of #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-7-wire-new-settings-to-card-components","title":"Task 7: Wire New Settings to Card Components","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code> - Modify: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/ImageCard.jsx</code></p> <p>Step 1: Update SceneCard to respect new settings</p> <p>In <code>client/src/components/ui/SceneCard.jsx</code>, update <code>buildSceneSubtitle</code> and the component:</p> <pre><code>/**\n * Build scene subtitle with studio, code, and date\n * @param {Object} scene - The scene object\n * @param {Object} options - Display options\n */\nconst buildSceneSubtitle = (scene, { showCodeOnCard = true, showStudio = true, showDate = true } = {}) =&gt; {\n  const parts = [];\n\n  if (showStudio &amp;&amp; scene.studio) {\n    parts.push(scene.studio.name);\n  }\n\n  if (showCodeOnCard &amp;&amp; scene.code) {\n    parts.push(scene.code);\n  }\n\n  if (showDate) {\n    const date = scene.date ? formatRelativeTime(scene.date) : null;\n    if (date) {\n      parts.push(date);\n    }\n  }\n\n  return parts.length &gt; 0 ? parts.join(' \u2022 ') : null;\n};\n\n// Inside SceneCard component, update subtitle and indicators usage:\nconst subtitle = buildSceneSubtitle(scene, {\n  showCodeOnCard: sceneSettings.showCodeOnCard,\n  showStudio: sceneSettings.showStudio,\n  showDate: sceneSettings.showDate,\n});\n\n// Update indicators prop - only pass if setting enabled\nconst indicatorsToShow = sceneSettings.showRelationshipIndicators ? indicators : [];\n\n// In BaseCard JSX:\n&lt;BaseCard\n  // ... other props\n  indicators={indicatorsToShow}\n  // ...\n/&gt;\n</code></pre> <p>Step 2: Update GalleryCard to respect new settings</p> <p>In <code>client/src/components/cards/GalleryCard.jsx</code>:</p> <pre><code>// Update subtitle building (around line 18-31):\nconst subtitle = (() =&gt; {\n  const parts = [];\n\n  if (gallerySettings.showStudio &amp;&amp; gallery.studio) {\n    parts.push(gallery.studio.name);\n  }\n\n  if (gallerySettings.showDate &amp;&amp; gallery.date) {\n    parts.push(new Date(gallery.date).toLocaleDateString());\n  }\n\n  return parts.length &gt; 0 ? parts.join(' \u2022 ') : null;\n})();\n\n// Update indicators (before BaseCard):\nconst indicatorsToShow = gallerySettings.showRelationshipIndicators ? indicators : [];\n\n// In BaseCard JSX:\n&lt;BaseCard\n  // ... other props\n  indicators={indicatorsToShow}\n  // ...\n/&gt;\n</code></pre> <p>Step 3: Update ImageCard similarly</p> <p>Find ImageCard.jsx and apply same pattern for subtitle and indicators.</p> <p>Step 4: Run tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/SceneCard.jsx client/src/components/cards/GalleryCard.jsx client/src/components/cards/ImageCard.jsx &amp;&amp; git commit -m \"feat: Card components respect new display settings\n\n- showStudio: controls studio name in subtitle\n- showDate: controls date in subtitle\n- showRelationshipIndicators: controls indicator badges\n\nPart of #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-8-wire-default-view-mode-to-page-components","title":"Task 8: Wire Default View Mode to Page Components","text":"<p>Files: - Modify: <code>client/src/components/pages/Scenes.jsx</code> - Modify: <code>client/src/components/pages/Galleries.jsx</code> - Modify: <code>client/src/components/pages/Images.jsx</code> - Modify: <code>client/src/components/pages/Performers.jsx</code> - Modify: <code>client/src/components/pages/Studios.jsx</code> - Modify: <code>client/src/components/pages/Tags.jsx</code> - Modify: <code>client/src/components/pages/Groups.jsx</code></p> <p>Step 1: Update Galleries.jsx as example pattern</p> <pre><code>// At top of file, add import:\nimport { useCardDisplaySettings } from \"../../contexts/CardDisplaySettingsContext.jsx\";\n\n// Inside component, before useFilterState or similar:\nconst { getSettings } = useCardDisplaySettings();\nconst gallerySettings = getSettings(\"gallery\");\n\n// When initializing view mode state or passing to SearchControls:\n// The defaultViewMode should be used as initial value\n// This depends on how useFilterState handles initialization\n\n// If useFilterState accepts a defaultViewMode option:\nconst filterState = useFilterState({\n  artifactType: \"gallery\",\n  defaultViewMode: gallerySettings.defaultViewMode,\n  // ... other options\n});\n\n// OR if viewMode is managed separately, initialize with setting:\nconst [viewMode, setViewMode] = useState(gallerySettings.defaultViewMode || \"grid\");\n</code></pre> <p>Note: The exact implementation depends on how each page currently manages viewMode. Some use <code>useFilterState</code>, others may manage it directly. Follow the existing pattern in each file.</p> <p>Step 2: Apply same pattern to all other page components</p> <p>Each page should: 1. Import <code>useCardDisplaySettings</code> 2. Get settings for its entity type 3. Use <code>settings.defaultViewMode</code> as the initial view mode</p> <p>Step 3: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/pages/*.jsx &amp;&amp; git commit -m \"feat: Pages use per-entity default view mode setting\n\nEach page loads defaultViewMode from card display settings.\n\nCompletes #221 default view mode feature\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-9-fix-fullscreen-exit-on-lightbox-close","title":"Task 9: Fix Fullscreen Exit on Lightbox Close","text":"<p>Files: - Modify: <code>client/src/components/ui/Lightbox.jsx</code></p> <p>Step 1: Write test for fullscreen exit on close</p> <pre><code>// Add to client/tests/components/ui/Lightbox.test.jsx\n\ndescribe(\"fullscreen exit behavior\", () =&gt; {\n  it(\"exits fullscreen when close button is clicked\", async () =&gt; {\n    const exitFullscreen = vi.fn();\n    Object.defineProperty(document, \"fullscreenElement\", {\n      value: document.body,\n      writable: true,\n    });\n    document.exitFullscreen = exitFullscreen;\n\n    const onClose = vi.fn();\n    render(\n      &lt;Lightbox\n        images={[{ id: \"1\", paths: { image: \"/test.jpg\" } }]}\n        isOpen={true}\n        onClose={onClose}\n        supportsFullscreen={true}\n      /&gt;\n    );\n\n    const closeButton = screen.getByLabelText(\"Close lightbox\");\n    fireEvent.click(closeButton);\n\n    expect(exitFullscreen).toHaveBeenCalled();\n    expect(onClose).toHaveBeenCalled();\n  });\n\n  it(\"exits fullscreen on Escape key when not in drawer\", async () =&gt; {\n    const exitFullscreen = vi.fn();\n    Object.defineProperty(document, \"fullscreenElement\", {\n      value: document.body,\n      writable: true,\n    });\n    document.exitFullscreen = exitFullscreen;\n\n    const onClose = vi.fn();\n    render(\n      &lt;Lightbox\n        images={[{ id: \"1\", paths: { image: \"/test.jpg\" } }]}\n        isOpen={true}\n        onClose={onClose}\n      /&gt;\n    );\n\n    fireEvent.keyDown(document, { key: \"Escape\" });\n\n    expect(exitFullscreen).toHaveBeenCalled();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run Lightbox</code> Expected: FAIL - exitFullscreen not called because current code doesn't exit fullscreen on close</p> <p>Step 3: Create helper function and update close handlers</p> <p>In <code>client/src/components/ui/Lightbox.jsx</code>:</p> <pre><code>// Add helper function inside component (after hooks, before handlers):\nconst handleCloseWithFullscreenExit = useCallback(() =&gt; {\n  // Exit browser fullscreen if active\n  if (document.fullscreenElement) {\n    document.exitFullscreen().catch(() =&gt; {\n      // Ignore errors (e.g., if already exiting)\n    });\n  }\n  onClose();\n}, [onClose]);\n\n// Update swipe handler (around line 306-311):\nonSwipedDown: () =&gt; {\n  if (drawerOpen) {\n    setDrawerOpen(false);\n  } else {\n    handleCloseWithFullscreenExit();\n  }\n},\n\n// Update keyboard handler (around line 398-405):\ncase \"Escape\":\n  if (drawerOpen) {\n    setDrawerOpen(false);\n  } else if (isFullscreen) {\n    // Browser handles fullscreen exit via Escape, but we also close\n    handleCloseWithFullscreenExit();\n  } else {\n    handleCloseWithFullscreenExit();\n  }\n  break;\n\n// Update close button (around line 587-598):\n&lt;button\n  onClick={handleCloseWithFullscreenExit}\n  className=\"p-2 rounded-full transition-colors\"\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    color: \"var(--text-primary)\",\n  }}\n  aria-label=\"Close lightbox\"\n&gt;\n  &lt;X size={24} /&gt;\n&lt;/button&gt;\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run Lightbox</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add client/src/components/ui/Lightbox.jsx client/tests/components/ui/Lightbox.test.jsx &amp;&amp; git commit -m \"fix: Closing lightbox now exits browser fullscreen\n\nAll close triggers (X button, swipe down, Escape) exit fullscreen mode.\n\nFixes #221\"\n</code></pre>"},{"location":"plans/2026-01-17-issue-221-implementation/#task-10-final-integration-test-and-cleanup","title":"Task 10: Final Integration Test and Cleanup","text":"<p>Step 1: Run full test suite</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run</code> Expected: All tests PASS</p> <p>Step 2: Manual testing checklist</p> <ul> <li> View toggle: Rapid clicking shows exactly one active button</li> <li> Table view: Gallery covers display correctly</li> <li> Cards: Hiding all settings makes cards visibly smaller</li> <li> Settings: New toggles appear (showStudio, showDate, showRelationshipIndicators, defaultViewMode)</li> <li> Settings: Toggling settings affects card display</li> <li> Default view mode: Setting persists and loads on page refresh</li> <li> Lightbox: Closing via X/swipe/Escape exits fullscreen</li> </ul> <p>Step 3: Final commit with issue reference</p> <pre><code>cd /home/carrot/code/peek-stash-browser &amp;&amp; git add -A &amp;&amp; git commit -m \"chore: Final cleanup for #221\n\nAll bug fixes and features complete:\n- View toggle styling bug fixed\n- Table view gallery images fixed\n- Card density bug fixed\n- New settings: showStudio, showDate, showRelationshipIndicators\n- Default view mode per entity type\n- Fullscreen exit on lightbox close\n\nCloses #221\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/","title":"Post-Login Landing Page Preference","text":"<p>Issue: https://github.com/carrotwaxr/peek-stash-browser/issues/290 Date: 2026-01-17</p>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#summary","title":"Summary","text":"<p>Add a user preference to configure which page to land on after login. Currently, users always land on the Home page (carousels). This feature lets users choose any entity page as their landing destination, with an optional \"random\" mode to pick from multiple selections.</p>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#requirements","title":"Requirements","text":"<ul> <li>New setting under User Preferences \u2192 Navigation</li> <li>Single-select by default (pick one landing page)</li> <li>\"Random one of\" toggle enables multi-select mode</li> <li>When random mode is enabled, minimum 2 pages must be selected</li> <li>Saved redirect URLs (from route guards) take priority over the preference</li> <li>Default to Home for backwards compatibility</li> </ul>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#data-model","title":"Data Model","text":""},{"location":"plans/2026-01-17-post-login-landing-page-design/#prisma-schema-change","title":"Prisma Schema Change","text":"<p>Add to User model:</p> <pre><code>landingPagePreference  Json?  @default(\"{\\\"pages\\\":[\\\"home\\\"],\\\"randomize\\\":false}\")\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#typescript-interface","title":"TypeScript Interface","text":"<pre><code>interface LandingPagePreference {\n  pages: string[];    // Page keys, e.g., [\"home\"] or [\"scenes\", \"performers\"]\n  randomize: boolean; // false = use pages[0], true = pick random from array\n}\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#valid-page-keys","title":"Valid Page Keys","text":"Key Label Path <code>home</code> Home <code>/</code> <code>scenes</code> Scenes <code>/scenes</code> <code>performers</code> Performers <code>/performers</code> <code>studios</code> Studios <code>/studios</code> <code>tags</code> Tags <code>/tags</code> <code>collections</code> Collections <code>/collections</code> <code>galleries</code> Galleries <code>/galleries</code> <code>images</code> Images <code>/images</code> <code>playlists</code> Playlists <code>/playlists</code> <code>recommended</code> Recommended <code>/recommended</code> <code>watch-history</code> Watch History <code>/watch-history</code> <code>user-stats</code> User Stats <code>/user-stats</code>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#ui-design","title":"UI Design","text":""},{"location":"plans/2026-01-17-post-login-landing-page-design/#location","title":"Location","text":"<p>Settings \u2192 User Preferences \u2192 Navigation tab</p>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#layout","title":"Layout","text":"<pre><code>Landing Page After Login\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\u25a1 Random one of selected pages\n\n\u25cb Home\n\u25cb Scenes\n\u25cb Performers\n\u25cb Studios\n\u25cb Tags\n\u25cb Collections\n\u25cb Galleries\n\u25cb Images\n\u25cb Playlists\n\u25cb Recommended\n\u25cb Watch History\n\u25cb User Stats\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#behavior","title":"Behavior","text":"<p>When \"Random\" toggle is OFF: - Radio button selection (single choice) - One page must be selected</p> <p>When \"Random\" toggle is ON: - Checkbox selection (multi-select) - Minimum 2 pages must be selected - Validation error if fewer than 2: \"Select at least 2 pages for random mode\"</p>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#display-order","title":"Display Order","text":"<p>Fixed logical grouping (not alphabetical, not user-configurable): 1. Home 2. Scenes 3. Performers 4. Studios 5. Tags 6. Collections 7. Galleries 8. Images 9. Playlists 10. Recommended 11. Watch History 12. User Stats</p>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#post-login-navigation-flow","title":"Post-Login Navigation Flow","text":""},{"location":"plans/2026-01-17-post-login-landing-page-design/#current-flow-loginjsx","title":"Current Flow (Login.jsx)","text":"<pre><code>const savedUrl = sessionStorage.getItem(REDIRECT_STORAGE_KEY);\nif (savedUrl) {\n  sessionStorage.removeItem(REDIRECT_STORAGE_KEY);\n  navigate(savedUrl);\n} else {\n  navigate(\"/\");\n}\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#new-flow","title":"New Flow","text":"<pre><code>const savedUrl = sessionStorage.getItem(REDIRECT_STORAGE_KEY);\nif (savedUrl) {\n  sessionStorage.removeItem(REDIRECT_STORAGE_KEY);\n  navigate(savedUrl);\n} else {\n  const destination = getLandingPage(user.landingPagePreference);\n  navigate(destination);\n}\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#helper-functions","title":"Helper Functions","text":"<pre><code>const PAGE_KEY_TO_PATH = {\n  home: \"/\",\n  scenes: \"/scenes\",\n  performers: \"/performers\",\n  studios: \"/studios\",\n  tags: \"/tags\",\n  collections: \"/collections\",\n  galleries: \"/galleries\",\n  images: \"/images\",\n  playlists: \"/playlists\",\n  recommended: \"/recommended\",\n  \"watch-history\": \"/watch-history\",\n  \"user-stats\": \"/user-stats\",\n};\n\nfunction getLandingPage(preference) {\n  // Default fallback\n  if (!preference || !preference.pages?.length) {\n    return \"/\";\n  }\n\n  if (preference.randomize &amp;&amp; preference.pages.length &gt; 1) {\n    const randomIndex = Math.floor(Math.random() * preference.pages.length);\n    return PAGE_KEY_TO_PATH[preference.pages[randomIndex]] || \"/\";\n  }\n\n  return PAGE_KEY_TO_PATH[preference.pages[0]] || \"/\";\n}\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#priority-order","title":"Priority Order","text":"<ol> <li>Saved redirect URL in sessionStorage (from route guards when user was redirected to login)</li> <li>User's landing page preference</li> <li>Default to \"/\" (Home)</li> </ol>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#api-changes","title":"API Changes","text":"<p>No new endpoints required. Uses existing settings infrastructure:</p> <ul> <li><code>GET /api/user/settings</code> \u2014 returns <code>landingPagePreference</code> field</li> <li><code>PUT /api/user/settings</code> \u2014 accepts <code>landingPagePreference</code> updates</li> </ul>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2026-01-17-post-login-landing-page-design/#database","title":"Database","text":"<ul> <li><code>server/prisma/schema.prisma</code> \u2014 add <code>landingPagePreference</code> field</li> </ul>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#server","title":"Server","text":"<ul> <li><code>server/controllers/user.ts</code> \u2014 include field in settings get/put</li> </ul>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#client","title":"Client","text":"<ul> <li><code>client/src/components/pages/Login.jsx</code> \u2014 implement new navigation logic</li> <li><code>client/src/components/settings/tabs/NavigationTab.jsx</code> \u2014 add landing page UI</li> <li><code>client/src/constants/navigation.js</code> \u2014 add <code>LANDING_PAGE_OPTIONS</code> constant</li> </ul>"},{"location":"plans/2026-01-17-post-login-landing-page-design/#migration","title":"Migration","text":"<p>Existing users without the preference get the default <code>{ pages: [\"home\"], randomize: false }</code>, preserving current behavior.</p>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/","title":"Post-Login Landing Page Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a user preference to configure which page to land on after login, with optional randomization.</p> <p>Architecture: New <code>landingPagePreference</code> JSON field on User model. Login flow reads preference and navigates accordingly. Settings UI in Navigation tab allows configuration.</p> <p>Tech Stack: React, Prisma (SQLite), Express, react-router-dom</p> <p>Design Doc: 2026-01-17-post-login-landing-page-design.md</p>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-1-add-database-field","title":"Task 1: Add Database Field","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma:10-68</code> (User model)</p> <p>Step 1: Add field to User model</p> <p>In <code>server/prisma/schema.prisma</code>, add after line 31 (after <code>cardDisplaySettings</code>):</p> <pre><code>  landingPagePreference  Json?  @default(\"{\\\"pages\\\":[\\\"home\\\"],\\\"randomize\\\":false}\")\n</code></pre> <p>Step 2: Generate migration</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma migrate dev --name add_landing_page_preference\n</code></pre></p> <p>Expected: Migration creates successfully, schema.prisma updated.</p> <p>Step 3: Commit</p> <pre><code>git add server/prisma/schema.prisma server/prisma/migrations/\ngit commit -m \"feat(db): add landingPagePreference field to User model (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-2-add-landing-page-constants","title":"Task 2: Add Landing Page Constants","text":"<p>Files: - Modify: <code>client/src/constants/navigation.js</code></p> <p>Step 1: Add LANDING_PAGE_OPTIONS constant</p> <p>Add after line 69 (after <code>NAV_DEFINITIONS</code>):</p> <pre><code>/**\n * Landing page options for post-login redirect\n * Order matters - this is the display order in settings\n */\nexport const LANDING_PAGE_OPTIONS = [\n  { key: \"home\", label: \"Home\", path: \"/\" },\n  { key: \"scenes\", label: \"Scenes\", path: \"/scenes\" },\n  { key: \"performers\", label: \"Performers\", path: \"/performers\" },\n  { key: \"studios\", label: \"Studios\", path: \"/studios\" },\n  { key: \"tags\", label: \"Tags\", path: \"/tags\" },\n  { key: \"collections\", label: \"Collections\", path: \"/collections\" },\n  { key: \"galleries\", label: \"Galleries\", path: \"/galleries\" },\n  { key: \"images\", label: \"Images\", path: \"/images\" },\n  { key: \"playlists\", label: \"Playlists\", path: \"/playlists\" },\n  { key: \"recommended\", label: \"Recommended\", path: \"/recommended\" },\n  { key: \"watch-history\", label: \"Watch History\", path: \"/watch-history\" },\n  { key: \"user-stats\", label: \"User Stats\", path: \"/user-stats\" },\n];\n\n/**\n * Get the path for a landing page key\n * @param {string} key - Landing page key\n * @returns {string} Path for the landing page, defaults to \"/\"\n */\nexport const getLandingPagePath = (key) =&gt; {\n  const option = LANDING_PAGE_OPTIONS.find((opt) =&gt; opt.key === key);\n  return option?.path || \"/\";\n};\n\n/**\n * Get the landing page destination based on user preference\n * @param {Object} preference - User's landing page preference {pages: string[], randomize: boolean}\n * @returns {string} Path to navigate to\n */\nexport const getLandingPage = (preference) =&gt; {\n  // Default fallback\n  if (!preference || !preference.pages?.length) {\n    return \"/\";\n  }\n\n  if (preference.randomize &amp;&amp; preference.pages.length &gt; 1) {\n    const randomIndex = Math.floor(Math.random() * preference.pages.length);\n    return getLandingPagePath(preference.pages[randomIndex]);\n  }\n\n  return getLandingPagePath(preference.pages[0]);\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/constants/navigation.js\ngit commit -m \"feat(client): add landing page options and helper functions (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-3-update-server-settings-api","title":"Task 3: Update Server Settings API","text":"<p>Files: - Modify: <code>server/controllers/user.ts:106-168</code> (getUserSettings) - Modify: <code>server/controllers/user.ts:173-438</code> (updateUserSettings)</p> <p>Step 1: Add landingPagePreference to getUserSettings select and response</p> <p>In <code>getUserSettings</code> function, add to the <code>select</code> object (around line 137):</p> <pre><code>        landingPagePreference: true,\n</code></pre> <p>And in the response <code>settings</code> object (around line 161):</p> <pre><code>        landingPagePreference: user.landingPagePreference || { pages: [\"home\"], randomize: false },\n</code></pre> <p>Step 2: Add landingPagePreference to updateUserSettings</p> <p>In <code>updateUserSettings</code> function, add to destructuring (around line 212):</p> <pre><code>      landingPagePreference,\n</code></pre> <p>Add validation after the cardDisplaySettings validation (around line 379):</p> <pre><code>    // Validate landing page preference if provided\n    if (landingPagePreference !== undefined) {\n      if (landingPagePreference !== null &amp;&amp; typeof landingPagePreference !== \"object\") {\n        return res\n          .status(400)\n          .json({ error: \"Landing page preference must be an object or null\" });\n      }\n\n      if (landingPagePreference !== null) {\n        if (!Array.isArray(landingPagePreference.pages) || landingPagePreference.pages.length === 0) {\n          return res\n            .status(400)\n            .json({ error: \"Landing page preference must have at least one page\" });\n        }\n\n        if (typeof landingPagePreference.randomize !== \"boolean\") {\n          return res\n            .status(400)\n            .json({ error: \"Landing page preference randomize must be a boolean\" });\n        }\n\n        // Validate minimum pages for randomize mode\n        if (landingPagePreference.randomize &amp;&amp; landingPagePreference.pages.length &lt; 2) {\n          return res\n            .status(400)\n            .json({ error: \"Random mode requires at least 2 pages selected\" });\n        }\n\n        // Validate page keys\n        const validPageKeys = [\n          \"home\", \"scenes\", \"performers\", \"studios\", \"tags\", \"collections\",\n          \"galleries\", \"images\", \"playlists\", \"recommended\", \"watch-history\", \"user-stats\"\n        ];\n        for (const pageKey of landingPagePreference.pages) {\n          if (!validPageKeys.includes(pageKey)) {\n            return res\n              .status(400)\n              .json({ error: `Invalid landing page key: ${pageKey}` });\n          }\n        }\n      }\n    }\n</code></pre> <p>Add to the Prisma update data object (around line 398):</p> <pre><code>        ...(landingPagePreference !== undefined &amp;&amp; { landingPagePreference }),\n</code></pre> <p>Add to the response settings object (around line 431):</p> <pre><code>        landingPagePreference: updatedUser.landingPagePreference || { pages: [\"home\"], randomize: false },\n</code></pre> <p>Also add to the select in the update call (around line 414):</p> <pre><code>        landingPagePreference: true,\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/controllers/user.ts\ngit commit -m \"feat(server): add landingPagePreference to user settings API (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-4-update-auth-login-to-include-landing-preference","title":"Task 4: Update Auth Login to Include Landing Preference","text":"<p>Files: - Modify: <code>server/routes/auth.ts:15-59</code> (login endpoint)</p> <p>Step 1: Include landingPagePreference in login response</p> <p>Modify the login endpoint to select and return landingPagePreference. Change the select to include it (after line 25):</p> <pre><code>    const user = await prisma.user.findUnique({\n      where: { username },\n      select: {\n        id: true,\n        username: true,\n        password: true,\n        role: true,\n        landingPagePreference: true,\n      },\n    });\n</code></pre> <p>And update the response (around line 47):</p> <pre><code>    res.json({\n      success: true,\n      user: {\n        id: user.id,\n        username: user.username,\n        role: user.role,\n        landingPagePreference: user.landingPagePreference || { pages: [\"home\"], randomize: false },\n      },\n    });\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/routes/auth.ts\ngit commit -m \"feat(server): include landingPagePreference in login response (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-5-update-login-component-navigation","title":"Task 5: Update Login Component Navigation","text":"<p>Files: - Modify: <code>client/src/components/pages/Login.jsx</code></p> <p>Step 1: Import getLandingPage helper</p> <p>Add import at top of file:</p> <pre><code>import { getLandingPage } from \"../../constants/navigation.js\";\n</code></pre> <p>Step 2: Update handleSubmit to use landing page preference</p> <p>Modify the success handler (around line 25-33):</p> <pre><code>      if (result.success) {\n        // Check for saved redirect URL (takes priority over preference)\n        const redirectUrl = sessionStorage.getItem(REDIRECT_STORAGE_KEY);\n        if (redirectUrl) {\n          sessionStorage.removeItem(REDIRECT_STORAGE_KEY);\n          window.location.href = redirectUrl;\n        } else {\n          // Use landing page preference if available\n          const destination = getLandingPage(result.user?.landingPagePreference);\n          window.location.href = destination;\n        }\n      } else {\n</code></pre> <p>Step 3: Update useAuth login call to return user data</p> <p>We need to modify how Login.jsx gets the user data. The <code>login</code> function from <code>useAuth</code> returns <code>{ success: true }</code> but we need access to the user data.</p> <p>Looking at AuthContext.jsx, the login function sets <code>setUser(data.user)</code> but only returns <code>{ success: true }</code>. We need to return the user data as well.</p> <p>Modify <code>client/src/contexts/AuthContext.jsx</code> login function (around line 43-49):</p> <pre><code>    if (response.ok) {\n      setIsAuthenticated(true);\n      setUser(data.user);\n      return { success: true, user: data.user };\n    } else {\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add client/src/components/pages/Login.jsx client/src/contexts/AuthContext.jsx\ngit commit -m \"feat(client): use landing page preference for post-login navigation (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-6-create-landing-page-settings-component","title":"Task 6: Create Landing Page Settings Component","text":"<p>Files: - Create: <code>client/src/components/settings/LandingPageSettings.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>import { useState } from \"react\";\nimport { LANDING_PAGE_OPTIONS } from \"../../constants/navigation.js\";\nimport { Button, Switch } from \"../ui/index.js\";\n\n/**\n * Landing page preference settings component\n * Allows users to configure which page to land on after login\n */\nconst LandingPageSettings = ({ landingPagePreference, onSave }) =&gt; {\n  const [randomize, setRandomize] = useState(\n    landingPagePreference?.randomize || false\n  );\n  const [selectedPages, setSelectedPages] = useState(\n    landingPagePreference?.pages || [\"home\"]\n  );\n  const [hasChanges, setHasChanges] = useState(false);\n  const [validationError, setValidationError] = useState(\"\");\n\n  const handleRandomizeToggle = (checked) =&gt; {\n    setRandomize(checked);\n    setHasChanges(true);\n    setValidationError(\"\");\n\n    // If turning off randomize and multiple pages selected, keep only first\n    if (!checked &amp;&amp; selectedPages.length &gt; 1) {\n      setSelectedPages([selectedPages[0]]);\n    }\n  };\n\n  const handlePageSelect = (pageKey) =&gt; {\n    setHasChanges(true);\n    setValidationError(\"\");\n\n    if (randomize) {\n      // Multi-select mode\n      if (selectedPages.includes(pageKey)) {\n        // Don't allow deselecting if only 2 left (minimum for random)\n        if (selectedPages.length &lt;= 2) {\n          setValidationError(\"Select at least 2 pages for random mode\");\n          return;\n        }\n        setSelectedPages(selectedPages.filter((p) =&gt; p !== pageKey));\n      } else {\n        setSelectedPages([...selectedPages, pageKey]);\n      }\n    } else {\n      // Single-select mode (radio behavior)\n      setSelectedPages([pageKey]);\n    }\n  };\n\n  const handleSave = () =&gt; {\n    // Validate\n    if (randomize &amp;&amp; selectedPages.length &lt; 2) {\n      setValidationError(\"Select at least 2 pages for random mode\");\n      return;\n    }\n\n    onSave({\n      pages: selectedPages,\n      randomize,\n    });\n    setHasChanges(false);\n  };\n\n  const handleReset = () =&gt; {\n    setRandomize(landingPagePreference?.randomize || false);\n    setSelectedPages(landingPagePreference?.pages || [\"home\"]);\n    setHasChanges(false);\n    setValidationError(\"\");\n  };\n\n  return (\n    &lt;div className=\"space-y-4\"&gt;\n      &lt;div className=\"flex items-center justify-between\"&gt;\n        &lt;h3\n          className=\"text-lg font-medium\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          Landing Page After Login\n        &lt;/h3&gt;\n      &lt;/div&gt;\n\n      {/* Randomize toggle */}\n      &lt;div className=\"flex items-center gap-3\"&gt;\n        &lt;Switch\n          checked={randomize}\n          onChange={handleRandomizeToggle}\n          id=\"randomize-toggle\"\n        /&gt;\n        &lt;label\n          htmlFor=\"randomize-toggle\"\n          className=\"text-sm cursor-pointer\"\n          style={{ color: \"var(--text-secondary)\" }}\n        &gt;\n          Random one of selected pages\n        &lt;/label&gt;\n      &lt;/div&gt;\n\n      {/* Page options */}\n      &lt;div className=\"space-y-2\"&gt;\n        {LANDING_PAGE_OPTIONS.map((option) =&gt; {\n          const isSelected = selectedPages.includes(option.key);\n          return (\n            &lt;label\n              key={option.key}\n              className=\"flex items-center gap-3 p-2 rounded cursor-pointer hover:bg-opacity-50\"\n              style={{\n                backgroundColor: isSelected\n                  ? \"var(--bg-hover)\"\n                  : \"transparent\",\n              }}\n            &gt;\n              &lt;input\n                type={randomize ? \"checkbox\" : \"radio\"}\n                name=\"landing-page\"\n                checked={isSelected}\n                onChange={() =&gt; handlePageSelect(option.key)}\n                className=\"w-4 h-4\"\n                style={{ accentColor: \"var(--accent-primary)\" }}\n              /&gt;\n              &lt;span style={{ color: \"var(--text-primary)\" }}&gt;\n                {option.label}\n              &lt;/span&gt;\n            &lt;/label&gt;\n          );\n        })}\n      &lt;/div&gt;\n\n      {/* Validation error */}\n      {validationError &amp;&amp; (\n        &lt;p className=\"text-sm\" style={{ color: \"var(--status-error)\" }}&gt;\n          {validationError}\n        &lt;/p&gt;\n      )}\n\n      {/* Save/Reset buttons */}\n      {hasChanges &amp;&amp; (\n        &lt;div className=\"flex gap-2 pt-2\"&gt;\n          &lt;Button variant=\"primary\" onClick={handleSave}&gt;\n            Save\n          &lt;/Button&gt;\n          &lt;Button variant=\"secondary\" onClick={handleReset}&gt;\n            Reset\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default LandingPageSettings;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/settings/LandingPageSettings.jsx\ngit commit -m \"feat(client): add LandingPageSettings component (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-7-integrate-landing-page-settings-into-navigation-tab","title":"Task 7: Integrate Landing Page Settings into Navigation Tab","text":"<p>Files: - Modify: <code>client/src/components/settings/tabs/NavigationTab.jsx</code></p> <p>Step 1: Import LandingPageSettings</p> <p>Add import at top:</p> <pre><code>import LandingPageSettings from \"../LandingPageSettings.jsx\";\n</code></pre> <p>Step 2: Add state for landing page preference</p> <p>Add to state declarations (around line 16-17):</p> <pre><code>  const [landingPagePreference, setLandingPagePreference] = useState(null);\n</code></pre> <p>Step 3: Load landing page preference in useEffect</p> <p>In the loadSettings async function, add after navPreferences (around line 33):</p> <pre><code>        setLandingPagePreference(\n          settings.landingPagePreference || { pages: [\"home\"], randomize: false }\n        );\n</code></pre> <p>Step 4: Add save function</p> <p>Add after saveNavPreferences function (around line 71):</p> <pre><code>  const saveLandingPagePreference = async (newPreference) =&gt; {\n    try {\n      await api.put(\"/user/settings\", {\n        landingPagePreference: newPreference,\n      });\n\n      setLandingPagePreference(newPreference);\n      showSuccess(\"Landing page preference saved successfully!\");\n    } catch (err) {\n      showError(err.response?.data?.error || \"Failed to save landing page preference\");\n    }\n  };\n</code></pre> <p>Step 5: Add LandingPageSettings component to render</p> <p>Add new section before Navigation Settings (around line 86):</p> <pre><code>      {/* Landing Page Settings */}\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;LandingPageSettings\n          landingPagePreference={landingPagePreference}\n          onSave={saveLandingPagePreference}\n        /&gt;\n      &lt;/div&gt;\n</code></pre> <p>Step 6: Commit</p> <pre><code>git add client/src/components/settings/tabs/NavigationTab.jsx\ngit commit -m \"feat(client): integrate LandingPageSettings into NavigationTab (#290)\"\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-8-manual-testing","title":"Task 8: Manual Testing","text":"<p>Step 1: Start the development servers</p> <pre><code># Terminal 1 - Server\ncd server &amp;&amp; npm run dev\n\n# Terminal 2 - Client\ncd client &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Test default behavior</p> <ol> <li>Log out if logged in</li> <li>Log in</li> <li>Verify you land on Home (/)</li> </ol> <p>Step 3: Test single-select mode</p> <ol> <li>Go to Settings \u2192 User Preferences \u2192 Navigation</li> <li>Find \"Landing Page After Login\" section</li> <li>Select \"Scenes\"</li> <li>Click Save</li> <li>Log out and log in</li> <li>Verify you land on /scenes</li> </ol> <p>Step 4: Test random mode</p> <ol> <li>Go to Settings \u2192 User Preferences \u2192 Navigation</li> <li>Enable \"Random one of selected pages\"</li> <li>Select at least 2 pages (e.g., Scenes, Performers, Studios)</li> <li>Click Save</li> <li>Log out and log in multiple times</li> <li>Verify you land on different pages (statistically)</li> </ol> <p>Step 5: Test saved redirect URL priority</p> <ol> <li>While logged out, navigate to /performer/123 (or any protected route)</li> <li>Get redirected to login</li> <li>Log in</li> <li>Verify you land on /performer/123 (not your landing preference)</li> </ol> <p>Step 6: Test validation</p> <ol> <li>Enable random mode</li> <li>Try to deselect pages until only 1 is selected</li> <li>Verify error message appears: \"Select at least 2 pages for random mode\"</li> </ol>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#task-9-final-commit-and-verification","title":"Task 9: Final Commit and Verification","text":"<p>Step 1: Run linting</p> <pre><code>cd client &amp;&amp; npm run lint\ncd ../server &amp;&amp; npm run lint\n</code></pre> <p>Fix any lint errors if they appear.</p> <p>Step 2: Run tests (if any exist)</p> <pre><code>cd client &amp;&amp; npm test\ncd ../server &amp;&amp; npm test\n</code></pre> <p>Step 3: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address lint/test issues for landing page preference (#290)\"\n</code></pre> <p>Step 4: Push branch</p> <pre><code>git push -u origin 290-post-login-landing-page\n</code></pre>"},{"location":"plans/2026-01-17-post-login-landing-page-plan/#summary","title":"Summary","text":"Task Description Files Modified 1 Add database field schema.prisma 2 Add constants navigation.js 3 Update settings API user.ts 4 Update auth login auth.ts 5 Update Login component Login.jsx, AuthContext.jsx 6 Create settings component LandingPageSettings.jsx (new) 7 Integrate into NavigationTab NavigationTab.jsx 8 Manual testing - 9 Final verification -"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/","title":"Scene Merge Reconciliation Design","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#problem-statement","title":"Problem Statement","text":"<p>When scenes are merged in Stash, the source scene is completely deleted (no audit trail). Peek's sync detects this as a deletion and soft-deletes the scene, but user activity data (WatchHistory, SceneRating) becomes orphaned - it's not transferred to the surviving scene.</p> <p>Use cases: - User downloads higher resolution version of a scene they already had - User discovers duplicates after syncing to Peek - User merges alternate versions (director's cut, different endings)</p> <p>Current behavior: Orphaned user data is preserved indefinitely (no cleanup), but not reconciled with the surviving scene. Users lose their play history, ratings, O counts, and favorites when viewing the merged scene.</p>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#solution-overview","title":"Solution Overview","text":"<p>Two-pronged approach:</p> <ol> <li> <p>Sync-time merge detection (automatic): When a scene is about to be soft-deleted during sync, check if its PHASH matches another scene. If so, automatically transfer user data.</p> </li> <li> <p>Admin recovery tool (manual): A new Settings subtab where admins can view orphaned scenes with user data and manually reconcile them to surviving scenes.</p> </li> </ol>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#technical-background","title":"Technical Background","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#phash-perceptual-hash","title":"PHASH (Perceptual Hash)","text":"<p>Stash generates perceptual hashes for video files that: - Match the same video at different resolutions (720p vs 1080p) - Match across different codecs/bitrates - Match re-encoded files - Survive merges (all file fingerprints are preserved on destination scene)</p> <p>PHASH is stored per-file in Stash's <code>files_fingerprints</code> table and exposed via GraphQL.</p>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#current-peek-state","title":"Current Peek State","text":"<ul> <li>Peek does NOT currently sync or store fingerprints</li> <li>Orphaned WatchHistory and SceneRating records are preserved (no FK constraints)</li> <li>Admin infrastructure exists (<code>requireAdmin</code> middleware)</li> </ul>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#data-model-changes","title":"Data Model Changes","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#stashscene-table-additions","title":"StashScene Table Additions","text":"<pre><code>model StashScene {\n  // ... existing fields ...\n\n  phash         String?    // Primary perceptual hash (from first file)\n  phashes       Json?      // Array of all phashes if scene has multiple files: [\"hash1\", \"hash2\"]\n}\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#new-mergerecord-table","title":"New MergeRecord Table","text":"<pre><code>model MergeRecord {\n  id              String   @id @default(uuid())\n  sourceSceneId   String   // The scene that was merged away (soft-deleted)\n  targetSceneId   String   // The scene it was merged into (survivor)\n  matchedByPhash  String?  // The phash that linked them (null if manual reconciliation)\n\n  // User data that was transferred\n  userId          String\n  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // Transfer details\n  playCountTransferred    Int @default(0)\n  playDurationTransferred Float @default(0)\n  oCountTransferred       Int @default(0)\n  ratingTransferred       Int?\n  favoriteTransferred     Boolean @default(false)\n\n  // Audit\n  reconciledAt    DateTime @default(now())\n  reconciledBy    String?  // Admin user ID (null if automatic)\n  automatic       Boolean  @default(true)  // true = sync-time, false = manual\n\n  createdAt       DateTime @default(now())\n\n  @@index([sourceSceneId])\n  @@index([targetSceneId])\n  @@index([userId])\n}\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#graphql-query-update","title":"GraphQL Query Update","text":"<p>Update <code>findScenesCompact.graphql</code> to request fingerprints:</p> <pre><code>fragment SceneCompactData on Scene {\n  # ... existing fields ...\n  files {\n    # ... existing fields ...\n    fingerprints {\n      type\n      value\n    }\n  }\n}\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#sync-time-merge-detection","title":"Sync-Time Merge Detection","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#trigger-point","title":"Trigger Point","text":"<p>During <code>cleanupDeletedEntities(\"scene\")</code> in <code>StashSyncService.ts</code>, when a scene is about to be soft-deleted.</p>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#detection-flow","title":"Detection Flow","text":"<pre><code>1. Scene ID \"abc123\" is missing from Stash \u2192 about to be soft-deleted\n2. Before soft-deleting, look up the scene's phash(es) from local DB\n3. If no phash stored, skip detection (treat as normal deletion)\n4. Search for any OTHER non-deleted scene that has a matching phash\n5. If match found:\n   a. This is a merge - the matching scene is the \"survivor\"\n   b. For each user with activity on the deleted scene:\n      - Transfer user data to survivor (see transfer rules below)\n      - Create MergeRecord for audit trail\n   c. Soft-delete the source scene\n6. If no match found:\n   a. This is a true deletion, not a merge\n   b. Soft-delete as normal (user data preserved but orphaned)\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#phash-matching-logic","title":"PHASH Matching Logic","text":"<pre><code>// Exact match first (most common case for merges)\nconst exactMatch = await prisma.stashScene.findFirst({\n  where: {\n    id: { not: sourceSceneId },\n    deletedAt: null,\n    OR: [\n      { phash: sourcePhash },\n      { phashes: { contains: sourcePhash } }\n    ]\n  }\n});\n\n// If no exact match, could optionally do Hamming distance matching\n// for near-duplicates (future enhancement)\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#user-data-transfer-rules","title":"User Data Transfer Rules","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#watchhistory-fields","title":"WatchHistory Fields","text":"Field Transfer Logic <code>playCount</code> Sum both values <code>playDuration</code> Sum both values <code>oCount</code> Sum both values <code>oHistory</code> Merge JSON arrays, sort by timestamp, deduplicate <code>playHistory</code> Merge JSON arrays, sort by startTime <code>resumeTime</code> Survivor wins (keep existing) <code>lastPlayedAt</code> Keep the more recent timestamp"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#scenerating-fields","title":"SceneRating Fields","text":"Field Transfer Logic <code>rating</code> Survivor wins (keep existing if set) <code>favorite</code> OR logic (if either was favorite, result is favorite)"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#transfer-implementation","title":"Transfer Implementation","text":"<pre><code>async function transferUserData(\n  sourceSceneId: string,\n  targetSceneId: string,\n  userId: string,\n  reconciledBy?: string  // null for automatic\n): Promise&lt;MergeRecord&gt; {\n\n  const sourceHistory = await prisma.watchHistory.findUnique({\n    where: { userId_sceneId: { userId, sceneId: sourceSceneId } }\n  });\n\n  const sourceRating = await prisma.sceneRating.findUnique({\n    where: { userId_sceneId: { userId, sceneId: sourceSceneId } }\n  });\n\n  if (!sourceHistory &amp;&amp; !sourceRating) {\n    return null; // Nothing to transfer\n  }\n\n  // Upsert target WatchHistory\n  if (sourceHistory) {\n    await prisma.watchHistory.upsert({\n      where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n      create: {\n        userId,\n        sceneId: targetSceneId,\n        ...sourceHistory  // Copy all fields\n      },\n      update: {\n        playCount: { increment: sourceHistory.playCount },\n        playDuration: { increment: sourceHistory.playDuration },\n        oCount: { increment: sourceHistory.oCount },\n        oHistory: mergeJsonArrays(existing.oHistory, sourceHistory.oHistory),\n        playHistory: mergeJsonArrays(existing.playHistory, sourceHistory.playHistory),\n        lastPlayedAt: laterDate(existing.lastPlayedAt, sourceHistory.lastPlayedAt)\n        // resumeTime: keep existing (survivor wins)\n      }\n    });\n  }\n\n  // Upsert target SceneRating\n  if (sourceRating) {\n    await prisma.sceneRating.upsert({\n      where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n      create: {\n        userId,\n        sceneId: targetSceneId,\n        rating: sourceRating.rating,\n        favorite: sourceRating.favorite\n      },\n      update: {\n        // Survivor wins for rating (only update if target has no rating)\n        rating: existing.rating ?? sourceRating.rating,\n        // OR logic for favorite\n        favorite: existing.favorite || sourceRating.favorite\n      }\n    });\n  }\n\n  // Create audit record\n  return prisma.mergeRecord.create({\n    data: {\n      sourceSceneId,\n      targetSceneId,\n      matchedByPhash: phash,\n      userId,\n      playCountTransferred: sourceHistory?.playCount ?? 0,\n      playDurationTransferred: sourceHistory?.playDuration ?? 0,\n      oCountTransferred: sourceHistory?.oCount ?? 0,\n      ratingTransferred: sourceRating?.rating,\n      favoriteTransferred: sourceRating?.favorite ?? false,\n      reconciledBy,\n      automatic: !reconciledBy\n    }\n  });\n}\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#admin-recovery-tool","title":"Admin Recovery Tool","text":""},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#location","title":"Location","text":"<p>New subtab under Server Settings: \"Merge Recovery\" or \"Orphaned Scenes\"</p>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#api-endpoints","title":"API Endpoints","text":"<pre><code>GET  /api/admin/orphaned-scenes\n     Returns scenes with deletedAt set that have WatchHistory or SceneRating records\n     Response: { scenes: [...], totalCount: number }\n\nGET  /api/admin/orphaned-scenes/:id/matches\n     Returns potential phash matches for an orphaned scene\n     Response: { matches: [{ scene, similarity, recommended }] }\n\nPOST /api/admin/orphaned-scenes/:id/reconcile\n     Body: { targetSceneId: string }\n     Transfers all user data from orphan to target, creates MergeRecords\n\nPOST /api/admin/orphaned-scenes/:id/discard\n     Deletes orphaned WatchHistory and SceneRating records for the scene\n\nPOST /api/admin/reconcile-all\n     Auto-reconciles all orphans with high-confidence (exact) phash matches\n     Response: { reconciled: number, skipped: number }\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#ui-design","title":"UI Design","text":"<pre><code>Server Settings &gt; Merge Recovery\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n[Auto-Reconcile All] (processes exact phash matches only)\n\nFound 12 orphaned scenes with user activity\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \"Beach Scene 4K\" (deleted 2025-01-10)                       \u2502\n\u2502 phash: a1b2c3d4e5f6                                         \u2502\n\u2502                                                             \u2502\n\u2502 User activity across all users:                             \u2502\n\u2502   \u2022 3 users with watch history (total 12 plays)             \u2502\n\u2502   \u2022 2 users with ratings                                    \u2502\n\u2502   \u2022 1 user favorited                                        \u2502\n\u2502                                                             \u2502\n\u2502 Potential matches:                                          \u2502\n\u2502   \u25c9 \"Beach Scene 1080p\" (exact phash match) [Recommended]   \u2502\n\u2502   \u25cb \"Beach Scene Director Cut\" (similar - 4 bit distance)   \u2502\n\u2502   \u25cb Enter scene ID manually: [___________]                  \u2502\n\u2502                                                             \u2502\n\u2502 [Transfer Activity] [Discard Activity] [Skip]               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \"Old Movie Clip\" (deleted 2024-12-05)                       \u2502\n\u2502 phash: (none - fingerprinting not run)                      \u2502\n\u2502 ...                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#implementation-order","title":"Implementation Order","text":"<ol> <li>Schema + Migration</li> <li>Add <code>phash</code>, <code>phashes</code> to StashScene</li> <li>Create MergeRecord table</li> <li> <p>Run migration</p> </li> <li> <p>Sync Changes</p> </li> <li>Update <code>findScenesCompact.graphql</code> to request fingerprints</li> <li> <p>Update <code>StashSyncService.ts</code> to extract and store phashes during scene sync</p> </li> <li> <p>MergeReconciliationService (new file)</p> </li> <li><code>findOrphanedScenesWithActivity()</code> - query orphans</li> <li><code>findPhashMatches(sceneId)</code> - find potential targets</li> <li><code>transferUserData(source, target, userId)</code> - core transfer logic</li> <li><code>reconcileScene(sourceId, targetId)</code> - transfer for all users</li> <li> <p><code>discardOrphanedData(sceneId)</code> - delete orphaned records</p> </li> <li> <p>Sync-Time Detection</p> </li> <li>Modify <code>cleanupDeletedEntities</code> to call reconciliation before soft-delete</li> <li> <p>Only for scenes with phashes</p> </li> <li> <p>Admin API Routes (new file)</p> </li> <li>Wire up endpoints to MergeReconciliationService</li> <li> <p>Add <code>requireAdmin</code> middleware</p> </li> <li> <p>Admin UI</p> </li> <li>New component under Settings</li> <li>List orphans, show matches, reconcile/discard actions</li> </ol>"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#edge-cases","title":"Edge Cases","text":"Scenario Handling Scene has no phash Skip auto-detection, show in admin tool with \"no phash\" note Multiple phash matches Pick scene with most recent <code>stashUpdatedAt</code> for auto-reconcile; show all options in admin tool Phash matches deleted scene Skip (both are deleted) User data exists on both scenes Merge using rules above (sum counts, survivor wins conflicts, OR for favorite) Scene deleted before phash sync Cannot auto-match; admin tool allows manual ID entry Same scene merged multiple times Each merge creates separate MergeRecord; data accumulates on survivor"},{"location":"plans/2026-01-17-scene-merge-reconciliation-design/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Hamming distance matching: For near-duplicates that aren't exact phash matches</li> <li>Performer/Tag merge reconciliation: Similar pattern for other mergeable entities</li> <li>Undo reconciliation: Use MergeRecord to reverse a transfer if needed</li> <li>Bulk operations in admin UI: Select multiple orphans, batch reconcile/discard</li> </ul>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/","title":"Scene Merge Reconciliation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Automatically transfer user activity data (watch history, ratings, O counts) when scenes are merged in Stash, and provide an admin tool to reconcile orphaned data from past merges.</p> <p>Architecture: PHASH-based merge detection during sync cleanup, with a MergeReconciliationService handling data transfer logic. Admin UI under Server Settings for manual recovery of orphaned scenes.</p> <p>Tech Stack: Prisma (SQLite), Express routes, React (JSX), Vitest for testing</p>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-1-schema-changes-add-phash-fields-to-stashscene","title":"Task 1: Schema Changes - Add PHASH Fields to StashScene","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma:462-537</code> (StashScene model)</p> <p>Step 1: Add phash fields to StashScene model</p> <p>In <code>server/prisma/schema.prisma</code>, add these fields after line 514 (after <code>inheritedTagIds</code>):</p> <pre><code>  // === Fingerprint data (for merge detection) ===\n  phash   String? // Primary perceptual hash (from first file)\n  phashes String? // JSON array of all phashes if scene has multiple files\n</code></pre> <p>Step 2: Add index for phash lookups</p> <p>After line 535, add:</p> <pre><code>  @@index([phash])\n</code></pre> <p>Step 3: Verify schema is valid</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The schema is valid.\"</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"feat(schema): add phash fields to StashScene for merge detection\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-2-schema-changes-add-mergerecord-table","title":"Task 2: Schema Changes - Add MergeRecord Table","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code> (add new model) - Modify: <code>server/prisma/schema.prisma:10-65</code> (add relation to User model)</p> <p>Step 1: Add MergeRecord model</p> <p>At the end of <code>server/prisma/schema.prisma</code> (before the closing of the file), add:</p> <pre><code>// ============================================================================\n// Merge Reconciliation\n// ============================================================================\n\nmodel MergeRecord {\n  id              String   @id @default(uuid())\n  sourceSceneId   String // The scene that was merged away (soft-deleted)\n  targetSceneId   String // The scene it was merged into (survivor)\n  matchedByPhash  String? // The phash that linked them (null if manual)\n\n  // User data that was transferred\n  userId Int\n  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // Transfer details\n  playCountTransferred    Int     @default(0)\n  playDurationTransferred Float   @default(0)\n  oCountTransferred       Int     @default(0)\n  ratingTransferred       Int?\n  favoriteTransferred     Boolean @default(false)\n\n  // Audit\n  reconciledAt DateTime @default(now())\n  reconciledBy Int? // Admin user ID (null if automatic)\n  automatic    Boolean  @default(true) // true = sync-time, false = manual\n\n  createdAt DateTime @default(now())\n\n  @@index([sourceSceneId])\n  @@index([targetSceneId])\n  @@index([userId])\n}\n</code></pre> <p>Step 2: Add relation to User model</p> <p>In the User model (around line 50), add after <code>imageViewHistory ImageViewHistory[]</code>:</p> <pre><code>  // Merge reconciliation audit records\n  mergeRecords MergeRecord[]\n</code></pre> <p>Step 3: Verify schema is valid</p> <p>Run: <code>cd server &amp;&amp; npx prisma validate</code> Expected: \"The schema is valid.\"</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/schema.prisma\ngit commit -m \"feat(schema): add MergeRecord table for reconciliation audit\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-3-create-database-migration","title":"Task 3: Create Database Migration","text":"<p>Files: - Create: <code>server/prisma/migrations/YYYYMMDDHHMMSS_scene_merge_reconciliation/migration.sql</code> (auto-generated)</p> <p>Step 1: Generate migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name scene_merge_reconciliation</code></p> <p>Expected: Migration created successfully with: - ALTER TABLE StashScene ADD phash, phashes columns - CREATE TABLE MergeRecord - CREATE INDEX statements</p> <p>Step 2: Verify migration applied</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate status</code> Expected: All migrations applied</p> <p>Step 3: Generate Prisma client</p> <p>Run: <code>cd server &amp;&amp; npx prisma generate</code> Expected: Prisma Client generated</p> <p>Step 4: Commit migration</p> <pre><code>git add server/prisma/migrations/\ngit commit -m \"chore(db): add migration for scene merge reconciliation\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-4-update-graphql-query-to-fetch-fingerprints","title":"Task 4: Update GraphQL Query to Fetch Fingerprints","text":"<p>Files: - Modify: <code>server/graphql/operations/findScenesCompact.graphql:60-74</code></p> <p>Step 1: Add fingerprints to files fragment</p> <p>In <code>server/graphql/operations/findScenesCompact.graphql</code>, modify the <code>files</code> block (around line 60-74) to add fingerprints:</p> <pre><code>      files {\n        audio_codec\n        basename\n        bit_rate\n        created_at\n        duration\n        format\n        frame_rate\n        height\n        path\n        size\n        updated_at\n        video_codec\n        width\n        fingerprints {\n          type\n          value\n        }\n      }\n</code></pre> <p>Step 2: Regenerate GraphQL types</p> <p>Run: <code>cd server &amp;&amp; npm run stash:codegen</code> Expected: Types generated successfully</p> <p>Step 3: Verify types include fingerprints</p> <p>Run: <code>grep -n \"fingerprints\" server/graphql/generated/graphql.ts | head -5</code> Expected: Should show fingerprints in the generated types</p> <p>Step 4: Commit</p> <pre><code>git add server/graphql/operations/findScenesCompact.graphql server/graphql/generated/graphql.ts\ngit commit -m \"feat(graphql): add fingerprints to scene sync query\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-5-update-stashsyncservice-to-store-phashes","title":"Task 5: Update StashSyncService to Store PHASHes","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code> (syncScenes method)</p> <p>Step 1: Find the scene data extraction logic</p> <p>Search for where scene data is mapped to Prisma format. Look for the <code>syncScenes</code> method and find where file data is extracted.</p> <p>Run: <code>grep -n \"filePath\\|files\\?\\[0\\]\" server/services/StashSyncService.ts | head -10</code></p> <p>Step 2: Add phash extraction helper function</p> <p>Near the top of <code>StashSyncService.ts</code> (after the imports, around line 60), add:</p> <pre><code>/**\n * Extract PHASH fingerprints from scene files.\n * Returns primary phash and array of all phashes.\n */\nfunction extractPhashes(files: Array&lt;{ fingerprints?: Array&lt;{ type: string; value: string }&gt; }&gt; | undefined): {\n  phash: string | null;\n  phashes: string | null;\n} {\n  if (!files || files.length === 0) {\n    return { phash: null, phashes: null };\n  }\n\n  const allPhashes: string[] = [];\n  for (const file of files) {\n    if (file.fingerprints) {\n      for (const fp of file.fingerprints) {\n        if (fp.type === \"phash\" &amp;&amp; fp.value) {\n          allPhashes.push(fp.value);\n        }\n      }\n    }\n  }\n\n  if (allPhashes.length === 0) {\n    return { phash: null, phashes: null };\n  }\n\n  return {\n    phash: allPhashes[0],\n    phashes: allPhashes.length &gt; 1 ? JSON.stringify(allPhashes) : null,\n  };\n}\n</code></pre> <p>Step 3: Add phash fields to scene upsert data</p> <p>Find where the scene data object is built for Prisma (search for <code>filePath:</code> or the scene upsert/create call). Add the phash extraction:</p> <pre><code>// Extract phashes from files\nconst { phash, phashes } = extractPhashes(scene.files);\n\n// Add to the data object being upserted:\nphash,\nphashes,\n</code></pre> <p>Step 4: Verify build succeeds</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds without errors</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat(sync): extract and store phash fingerprints during scene sync\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-6-create-mergereconciliationservice-core-structure","title":"Task 6: Create MergeReconciliationService - Core Structure","text":"<p>Files: - Create: <code>server/services/MergeReconciliationService.ts</code></p> <p>Step 1: Create the service file with basic structure</p> <p>Create <code>server/services/MergeReconciliationService.ts</code>:</p> <pre><code>/**\n * MergeReconciliationService\n *\n * Handles detection of merged scenes and transfer of user activity data\n * from orphaned scenes to their merge targets.\n */\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\nexport interface OrphanedSceneInfo {\n  id: string;\n  title: string | null;\n  phash: string | null;\n  deletedAt: Date;\n  userActivityCount: number;\n  totalPlayCount: number;\n  hasRatings: boolean;\n  hasFavorites: boolean;\n}\n\nexport interface PhashMatch {\n  sceneId: string;\n  title: string | null;\n  similarity: \"exact\" | \"similar\";\n  recommended: boolean;\n}\n\nexport interface ReconcileResult {\n  sourceSceneId: string;\n  targetSceneId: string;\n  usersReconciled: number;\n  mergeRecordsCreated: number;\n}\n\nclass MergeReconciliationService {\n  /**\n   * Find all soft-deleted scenes that have orphaned user activity data.\n   */\n  async findOrphanedScenesWithActivity(): Promise&lt;OrphanedSceneInfo[]&gt; {\n    // Find deleted scenes that have WatchHistory or SceneRating records\n    const orphans = await prisma.$queryRaw&lt;\n      Array&lt;{\n        id: string;\n        title: string | null;\n        phash: string | null;\n        deletedAt: Date;\n        watchHistoryCount: number;\n        totalPlayCount: number;\n        ratingCount: number;\n        favoriteCount: number;\n      }&gt;\n    &gt;`\n      SELECT\n        s.id,\n        s.title,\n        s.phash,\n        s.deletedAt,\n        COALESCE(wh.watchHistoryCount, 0) as watchHistoryCount,\n        COALESCE(wh.totalPlayCount, 0) as totalPlayCount,\n        COALESCE(r.ratingCount, 0) as ratingCount,\n        COALESCE(r.favoriteCount, 0) as favoriteCount\n      FROM StashScene s\n      LEFT JOIN (\n        SELECT sceneId, COUNT(*) as watchHistoryCount, SUM(playCount) as totalPlayCount\n        FROM WatchHistory\n        GROUP BY sceneId\n      ) wh ON wh.sceneId = s.id\n      LEFT JOIN (\n        SELECT sceneId, COUNT(*) as ratingCount, SUM(CASE WHEN favorite = 1 THEN 1 ELSE 0 END) as favoriteCount\n        FROM SceneRating\n        GROUP BY sceneId\n      ) r ON r.sceneId = s.id\n      WHERE s.deletedAt IS NOT NULL\n        AND (wh.watchHistoryCount &gt; 0 OR r.ratingCount &gt; 0)\n      ORDER BY s.deletedAt DESC\n    `;\n\n    return orphans.map((o) =&gt; ({\n      id: o.id,\n      title: o.title,\n      phash: o.phash,\n      deletedAt: o.deletedAt,\n      userActivityCount: Number(o.watchHistoryCount) + Number(o.ratingCount),\n      totalPlayCount: Number(o.totalPlayCount),\n      hasRatings: Number(o.ratingCount) &gt; 0,\n      hasFavorites: Number(o.favoriteCount) &gt; 0,\n    }));\n  }\n\n  /**\n   * Find potential phash matches for an orphaned scene.\n   */\n  async findPhashMatches(sceneId: string): Promise&lt;PhashMatch[]&gt; {\n    const scene = await prisma.stashScene.findUnique({\n      where: { id: sceneId },\n      select: { phash: true, phashes: true },\n    });\n\n    if (!scene?.phash) {\n      return [];\n    }\n\n    // Get all phashes for this scene\n    const scenePhashes: string[] = [scene.phash];\n    if (scene.phashes) {\n      try {\n        const parsed = JSON.parse(scene.phashes);\n        if (Array.isArray(parsed)) {\n          scenePhashes.push(...parsed.filter((p: string) =&gt; p !== scene.phash));\n        }\n      } catch {\n        // Invalid JSON, ignore\n      }\n    }\n\n    // Find non-deleted scenes with matching phash\n    const matches = await prisma.stashScene.findMany({\n      where: {\n        id: { not: sceneId },\n        deletedAt: null,\n        OR: [\n          { phash: { in: scenePhashes } },\n          // Also check if any of our phashes appear in their phashes array\n          // This is a simple string contains check for SQLite\n          ...scenePhashes.map((ph) =&gt; ({ phashes: { contains: ph } })),\n        ],\n      },\n      select: {\n        id: true,\n        title: true,\n        phash: true,\n        stashUpdatedAt: true,\n      },\n      orderBy: { stashUpdatedAt: \"desc\" },\n    });\n\n    return matches.map((m, index) =&gt; ({\n      sceneId: m.id,\n      title: m.title,\n      similarity: \"exact\" as const,\n      recommended: index === 0, // Recommend the most recently updated\n    }));\n  }\n}\n\nexport const mergeReconciliationService = new MergeReconciliationService();\n</code></pre> <p>Step 2: Verify build succeeds</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 3: Commit</p> <pre><code>git add server/services/MergeReconciliationService.ts\ngit commit -m \"feat(service): add MergeReconciliationService with orphan detection\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-7-add-transfer-logic-to-mergereconciliationservice","title":"Task 7: Add Transfer Logic to MergeReconciliationService","text":"<p>Files: - Modify: <code>server/services/MergeReconciliationService.ts</code></p> <p>Step 1: Add helper functions for merging data</p> <p>Add these helper functions before the class definition:</p> <pre><code>/**\n * Merge two JSON arrays (for oHistory and playHistory).\n * Deduplicates by stringified value and sorts.\n */\nfunction mergeJsonArrays(arr1: unknown, arr2: unknown): string {\n  const list1 = parseJsonArray(arr1);\n  const list2 = parseJsonArray(arr2);\n  const merged = [...list1, ...list2];\n  // Deduplicate by stringified value\n  const seen = new Set&lt;string&gt;();\n  const deduped = merged.filter((item) =&gt; {\n    const key = JSON.stringify(item);\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n  // Sort by timestamp/startTime if present\n  deduped.sort((a, b) =&gt; {\n    const aTime = typeof a === \"string\" ? a : (a as Record&lt;string, unknown&gt;).startTime || (a as Record&lt;string, unknown&gt;).time || \"\";\n    const bTime = typeof b === \"string\" ? b : (b as Record&lt;string, unknown&gt;).startTime || (b as Record&lt;string, unknown&gt;).time || \"\";\n    return String(aTime).localeCompare(String(bTime));\n  });\n  return JSON.stringify(deduped);\n}\n\nfunction parseJsonArray(value: unknown): unknown[] {\n  if (!value) return [];\n  if (Array.isArray(value)) return value;\n  if (typeof value === \"string\") {\n    try {\n      const parsed = JSON.parse(value);\n      return Array.isArray(parsed) ? parsed : [];\n    } catch {\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction laterDate(d1: Date | null, d2: Date | null): Date | null {\n  if (!d1) return d2;\n  if (!d2) return d1;\n  return d1 &gt; d2 ? d1 : d2;\n}\n</code></pre> <p>Step 2: Add transferUserData method to the class</p> <p>Add this method to <code>MergeReconciliationService</code>:</p> <pre><code>  /**\n   * Transfer user activity data from source scene to target scene.\n   * Creates a MergeRecord for audit.\n   */\n  async transferUserData(\n    sourceSceneId: string,\n    targetSceneId: string,\n    userId: number,\n    matchedByPhash: string | null,\n    reconciledBy: number | null\n  ): Promise&lt;{ success: boolean; mergeRecordId?: string }&gt; {\n    const sourceHistory = await prisma.watchHistory.findUnique({\n      where: { userId_sceneId: { userId, sceneId: sourceSceneId } },\n    });\n\n    const sourceRating = await prisma.sceneRating.findUnique({\n      where: { userId_sceneId: { userId, sceneId: sourceSceneId } },\n    });\n\n    if (!sourceHistory &amp;&amp; !sourceRating) {\n      return { success: false }; // Nothing to transfer\n    }\n\n    // Transfer WatchHistory\n    if (sourceHistory) {\n      const targetHistory = await prisma.watchHistory.findUnique({\n        where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n      });\n\n      if (targetHistory) {\n        // Merge with existing\n        await prisma.watchHistory.update({\n          where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n          data: {\n            playCount: targetHistory.playCount + sourceHistory.playCount,\n            playDuration: targetHistory.playDuration + sourceHistory.playDuration,\n            oCount: targetHistory.oCount + sourceHistory.oCount,\n            oHistory: mergeJsonArrays(targetHistory.oHistory, sourceHistory.oHistory),\n            playHistory: mergeJsonArrays(targetHistory.playHistory, sourceHistory.playHistory),\n            lastPlayedAt: laterDate(targetHistory.lastPlayedAt, sourceHistory.lastPlayedAt),\n            // resumeTime: keep target's (survivor wins)\n          },\n        });\n      } else {\n        // Create new record for target\n        await prisma.watchHistory.create({\n          data: {\n            userId,\n            sceneId: targetSceneId,\n            playCount: sourceHistory.playCount,\n            playDuration: sourceHistory.playDuration,\n            resumeTime: sourceHistory.resumeTime,\n            lastPlayedAt: sourceHistory.lastPlayedAt,\n            oCount: sourceHistory.oCount,\n            oHistory: sourceHistory.oHistory,\n            playHistory: sourceHistory.playHistory,\n          },\n        });\n      }\n    }\n\n    // Transfer SceneRating\n    if (sourceRating) {\n      const targetRating = await prisma.sceneRating.findUnique({\n        where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n      });\n\n      if (targetRating) {\n        // Merge: survivor wins for rating, OR for favorite\n        await prisma.sceneRating.update({\n          where: { userId_sceneId: { userId, sceneId: targetSceneId } },\n          data: {\n            rating: targetRating.rating ?? sourceRating.rating,\n            favorite: targetRating.favorite || sourceRating.favorite,\n          },\n        });\n      } else {\n        // Create new record for target\n        await prisma.sceneRating.create({\n          data: {\n            userId,\n            sceneId: targetSceneId,\n            rating: sourceRating.rating,\n            favorite: sourceRating.favorite,\n          },\n        });\n      }\n    }\n\n    // Create audit record\n    const mergeRecord = await prisma.mergeRecord.create({\n      data: {\n        sourceSceneId,\n        targetSceneId,\n        matchedByPhash,\n        userId,\n        playCountTransferred: sourceHistory?.playCount ?? 0,\n        playDurationTransferred: sourceHistory?.playDuration ?? 0,\n        oCountTransferred: sourceHistory?.oCount ?? 0,\n        ratingTransferred: sourceRating?.rating,\n        favoriteTransferred: sourceRating?.favorite ?? false,\n        reconciledBy,\n        automatic: reconciledBy === null,\n      },\n    });\n\n    logger.info(`Transferred user data from scene ${sourceSceneId} to ${targetSceneId} for user ${userId}`);\n\n    return { success: true, mergeRecordId: mergeRecord.id };\n  }\n</code></pre> <p>Step 3: Add reconcileScene method</p> <p>Add this method to reconcile all users for a scene:</p> <pre><code>  /**\n   * Reconcile all user data for a source scene to a target scene.\n   */\n  async reconcileScene(\n    sourceSceneId: string,\n    targetSceneId: string,\n    matchedByPhash: string | null,\n    reconciledBy: number | null\n  ): Promise&lt;ReconcileResult&gt; {\n    // Find all users with activity on the source scene\n    const usersWithHistory = await prisma.watchHistory.findMany({\n      where: { sceneId: sourceSceneId },\n      select: { userId: true },\n    });\n\n    const usersWithRatings = await prisma.sceneRating.findMany({\n      where: { sceneId: sourceSceneId },\n      select: { userId: true },\n    });\n\n    // Combine and deduplicate user IDs\n    const userIds = [...new Set([\n      ...usersWithHistory.map((h) =&gt; h.userId),\n      ...usersWithRatings.map((r) =&gt; r.userId),\n    ])];\n\n    let mergeRecordsCreated = 0;\n\n    for (const userId of userIds) {\n      const result = await this.transferUserData(\n        sourceSceneId,\n        targetSceneId,\n        userId,\n        matchedByPhash,\n        reconciledBy\n      );\n      if (result.success) {\n        mergeRecordsCreated++;\n      }\n    }\n\n    logger.info(`Reconciled ${mergeRecordsCreated} users from scene ${sourceSceneId} to ${targetSceneId}`);\n\n    return {\n      sourceSceneId,\n      targetSceneId,\n      usersReconciled: userIds.length,\n      mergeRecordsCreated,\n    };\n  }\n\n  /**\n   * Discard orphaned user data for a scene (delete WatchHistory and SceneRating).\n   */\n  async discardOrphanedData(sceneId: string): Promise&lt;{ watchHistoryDeleted: number; ratingsDeleted: number }&gt; {\n    const watchHistoryResult = await prisma.watchHistory.deleteMany({\n      where: { sceneId },\n    });\n\n    const ratingsResult = await prisma.sceneRating.deleteMany({\n      where: { sceneId },\n    });\n\n    logger.info(`Discarded orphaned data for scene ${sceneId}: ${watchHistoryResult.count} watch history, ${ratingsResult.count} ratings`);\n\n    return {\n      watchHistoryDeleted: watchHistoryResult.count,\n      ratingsDeleted: ratingsResult.count,\n    };\n  }\n</code></pre> <p>Step 4: Verify build succeeds</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 5: Commit</p> <pre><code>git add server/services/MergeReconciliationService.ts\ngit commit -m \"feat(service): add transfer and reconcile logic to MergeReconciliationService\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-8-write-unit-tests-for-mergereconciliationservice","title":"Task 8: Write Unit Tests for MergeReconciliationService","text":"<p>Files: - Create: <code>server/tests/services/MergeReconciliationService.test.ts</code></p> <p>Step 1: Create test file with mocks</p> <p>Create <code>server/tests/services/MergeReconciliationService.test.ts</code>:</p> <pre><code>/**\n * Unit Tests for MergeReconciliationService\n */\nimport { describe, it, expect, beforeEach, vi } from \"vitest\";\n\n// Mock prisma\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $queryRaw: vi.fn(),\n    stashScene: {\n      findUnique: vi.fn(),\n      findMany: vi.fn(),\n    },\n    watchHistory: {\n      findUnique: vi.fn(),\n      findMany: vi.fn(),\n      create: vi.fn(),\n      update: vi.fn(),\n      deleteMany: vi.fn(),\n    },\n    sceneRating: {\n      findUnique: vi.fn(),\n      findMany: vi.fn(),\n      create: vi.fn(),\n      update: vi.fn(),\n      deleteMany: vi.fn(),\n    },\n    mergeRecord: {\n      create: vi.fn(),\n    },\n  },\n}));\n\nimport prisma from \"../../prisma/singleton.js\";\nimport { mergeReconciliationService } from \"../../services/MergeReconciliationService.js\";\n\ndescribe(\"MergeReconciliationService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"findOrphanedScenesWithActivity\", () =&gt; {\n    it(\"should return orphaned scenes with user activity\", async () =&gt; {\n      vi.mocked(prisma.$queryRaw).mockResolvedValue([\n        {\n          id: \"scene-1\",\n          title: \"Test Scene\",\n          phash: \"abc123\",\n          deletedAt: new Date(\"2025-01-10\"),\n          watchHistoryCount: 2,\n          totalPlayCount: 5,\n          ratingCount: 1,\n          favoriteCount: 1,\n        },\n      ]);\n\n      const result = await mergeReconciliationService.findOrphanedScenesWithActivity();\n\n      expect(result).toHaveLength(1);\n      expect(result[0].id).toBe(\"scene-1\");\n      expect(result[0].userActivityCount).toBe(3);\n      expect(result[0].hasRatings).toBe(true);\n      expect(result[0].hasFavorites).toBe(true);\n    });\n  });\n\n  describe(\"findPhashMatches\", () =&gt; {\n    it(\"should find scenes with matching phash\", async () =&gt; {\n      vi.mocked(prisma.stashScene.findUnique).mockResolvedValue({\n        phash: \"abc123\",\n        phashes: null,\n      } as never);\n\n      vi.mocked(prisma.stashScene.findMany).mockResolvedValue([\n        { id: \"scene-2\", title: \"Match Scene\", phash: \"abc123\", stashUpdatedAt: new Date() },\n      ] as never);\n\n      const result = await mergeReconciliationService.findPhashMatches(\"scene-1\");\n\n      expect(result).toHaveLength(1);\n      expect(result[0].sceneId).toBe(\"scene-2\");\n      expect(result[0].similarity).toBe(\"exact\");\n      expect(result[0].recommended).toBe(true);\n    });\n\n    it(\"should return empty array if scene has no phash\", async () =&gt; {\n      vi.mocked(prisma.stashScene.findUnique).mockResolvedValue({\n        phash: null,\n        phashes: null,\n      } as never);\n\n      const result = await mergeReconciliationService.findPhashMatches(\"scene-1\");\n\n      expect(result).toHaveLength(0);\n    });\n  });\n\n  describe(\"transferUserData\", () =&gt; {\n    it(\"should transfer watch history to target without existing data\", async () =&gt; {\n      vi.mocked(prisma.watchHistory.findUnique)\n        .mockResolvedValueOnce({\n          userId: 1,\n          sceneId: \"source\",\n          playCount: 5,\n          playDuration: 1000,\n          oCount: 2,\n          oHistory: \"[]\",\n          playHistory: \"[]\",\n          resumeTime: 100,\n          lastPlayedAt: new Date(),\n        } as never)\n        .mockResolvedValueOnce(null); // No target history\n\n      vi.mocked(prisma.sceneRating.findUnique).mockResolvedValue(null);\n      vi.mocked(prisma.watchHistory.create).mockResolvedValue({} as never);\n      vi.mocked(prisma.mergeRecord.create).mockResolvedValue({ id: \"mr-1\" } as never);\n\n      const result = await mergeReconciliationService.transferUserData(\n        \"source\",\n        \"target\",\n        1,\n        \"abc123\",\n        null\n      );\n\n      expect(result.success).toBe(true);\n      expect(prisma.watchHistory.create).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: expect.objectContaining({\n            sceneId: \"target\",\n            playCount: 5,\n          }),\n        })\n      );\n    });\n\n    it(\"should merge watch history with existing target data\", async () =&gt; {\n      vi.mocked(prisma.watchHistory.findUnique)\n        .mockResolvedValueOnce({\n          userId: 1,\n          sceneId: \"source\",\n          playCount: 5,\n          playDuration: 1000,\n          oCount: 2,\n          oHistory: '[\"2025-01-01\"]',\n          playHistory: \"[]\",\n          resumeTime: 100,\n          lastPlayedAt: new Date(\"2025-01-01\"),\n        } as never)\n        .mockResolvedValueOnce({\n          userId: 1,\n          sceneId: \"target\",\n          playCount: 3,\n          playDuration: 500,\n          oCount: 1,\n          oHistory: '[\"2025-01-02\"]',\n          playHistory: \"[]\",\n          resumeTime: 200,\n          lastPlayedAt: new Date(\"2025-01-02\"),\n        } as never);\n\n      vi.mocked(prisma.sceneRating.findUnique).mockResolvedValue(null);\n      vi.mocked(prisma.watchHistory.update).mockResolvedValue({} as never);\n      vi.mocked(prisma.mergeRecord.create).mockResolvedValue({ id: \"mr-1\" } as never);\n\n      const result = await mergeReconciliationService.transferUserData(\n        \"source\",\n        \"target\",\n        1,\n        \"abc123\",\n        null\n      );\n\n      expect(result.success).toBe(true);\n      expect(prisma.watchHistory.update).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: expect.objectContaining({\n            playCount: 8, // 5 + 3\n            playDuration: 1500, // 1000 + 500\n            oCount: 3, // 2 + 1\n          }),\n        })\n      );\n    });\n\n    it(\"should use OR logic for favorites\", async () =&gt; {\n      vi.mocked(prisma.watchHistory.findUnique).mockResolvedValue(null);\n      vi.mocked(prisma.sceneRating.findUnique)\n        .mockResolvedValueOnce({\n          userId: 1,\n          sceneId: \"source\",\n          rating: 80,\n          favorite: true,\n        } as never)\n        .mockResolvedValueOnce({\n          userId: 1,\n          sceneId: \"target\",\n          rating: 90,\n          favorite: false,\n        } as never);\n\n      vi.mocked(prisma.sceneRating.update).mockResolvedValue({} as never);\n      vi.mocked(prisma.mergeRecord.create).mockResolvedValue({ id: \"mr-1\" } as never);\n\n      await mergeReconciliationService.transferUserData(\"source\", \"target\", 1, null, null);\n\n      expect(prisma.sceneRating.update).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: expect.objectContaining({\n            rating: 90, // Survivor wins\n            favorite: true, // OR logic\n          }),\n        })\n      );\n    });\n  });\n\n  describe(\"discardOrphanedData\", () =&gt; {\n    it(\"should delete watch history and ratings\", async () =&gt; {\n      vi.mocked(prisma.watchHistory.deleteMany).mockResolvedValue({ count: 3 });\n      vi.mocked(prisma.sceneRating.deleteMany).mockResolvedValue({ count: 2 });\n\n      const result = await mergeReconciliationService.discardOrphanedData(\"scene-1\");\n\n      expect(result.watchHistoryDeleted).toBe(3);\n      expect(result.ratingsDeleted).toBe(2);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/MergeReconciliationService.test.ts</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/services/MergeReconciliationService.test.ts\ngit commit -m \"test: add unit tests for MergeReconciliationService\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-9-integrate-merge-detection-into-sync-cleanup","title":"Task 9: Integrate Merge Detection into Sync Cleanup","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:1070-1237</code> (cleanupDeletedEntities method)</p> <p>Step 1: Import MergeReconciliationService</p> <p>At the top of <code>StashSyncService.ts</code>, add:</p> <pre><code>import { mergeReconciliationService } from \"./MergeReconciliationService.js\";\n</code></pre> <p>Step 2: Add merge detection before soft-delete</p> <p>Modify the <code>cleanupDeletedEntities</code> method. In the scene case (around line 1175-1180), replace the simple <code>updateMany</code> with merge detection logic:</p> <pre><code>        case \"scene\": {\n          // Before soft-deleting, check for merges and reconcile user data\n          const scenesToDelete = await prisma.stashScene.findMany({\n            where: { deletedAt: null, stashInstanceId: stashInstanceId ?? null, id: { notIn: stashIds } },\n            select: { id: true, phash: true },\n          });\n\n          for (const scene of scenesToDelete) {\n            if (scene.phash) {\n              // Try to find a merge target\n              const matches = await mergeReconciliationService.findPhashMatches(scene.id);\n              if (matches.length &gt; 0) {\n                const target = matches[0]; // Use the recommended match\n                logger.info(`Detected merge: scene ${scene.id} -&gt; ${target.sceneId}`);\n                await mergeReconciliationService.reconcileScene(\n                  scene.id,\n                  target.sceneId,\n                  scene.phash,\n                  null // automatic\n                );\n              }\n            }\n          }\n\n          // Now soft-delete all the scenes\n          deletedCount = (await prisma.stashScene.updateMany({\n            where: { deletedAt: null, stashInstanceId: stashInstanceId ?? null, id: { notIn: stashIds } },\n            data: { deletedAt: now },\n          })).count;\n          break;\n        }\n</code></pre> <p>Step 3: Verify build succeeds</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat(sync): detect merges and reconcile user data during cleanup\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-10-create-admin-api-routes","title":"Task 10: Create Admin API Routes","text":"<p>Files: - Create: <code>server/routes/mergeReconciliation.ts</code> - Modify: <code>server/initializers/api.ts</code> (register routes)</p> <p>Step 1: Create the routes file</p> <p>Create <code>server/routes/mergeReconciliation.ts</code>:</p> <pre><code>/**\n * Merge Reconciliation Routes (Admin Only)\n *\n * Handles admin endpoints for managing orphaned scene data:\n * - GET /api/admin/orphaned-scenes - List orphaned scenes with user activity\n * - GET /api/admin/orphaned-scenes/:id/matches - Get phash matches for an orphan\n * - POST /api/admin/orphaned-scenes/:id/reconcile - Transfer data to target scene\n * - POST /api/admin/orphaned-scenes/:id/discard - Delete orphaned user data\n * - POST /api/admin/reconcile-all - Auto-reconcile all with exact phash matches\n */\nimport express from \"express\";\nimport { authenticate, requireAdmin } from \"../middleware/auth.js\";\nimport { mergeReconciliationService } from \"../services/MergeReconciliationService.js\";\nimport { authenticated } from \"../utils/routeHelpers.js\";\n\nconst router = express.Router();\n\n// All routes require authentication and admin role\nrouter.use(authenticate);\nrouter.use(requireAdmin);\n\n/**\n * GET /api/admin/orphaned-scenes\n * List all orphaned scenes with user activity\n */\nrouter.get(\n  \"/orphaned-scenes\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const orphans = await mergeReconciliationService.findOrphanedScenesWithActivity();\n      res.json({\n        scenes: orphans,\n        totalCount: orphans.length,\n      });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to fetch orphaned scenes\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * GET /api/admin/orphaned-scenes/:id/matches\n * Get potential phash matches for an orphaned scene\n */\nrouter.get(\n  \"/orphaned-scenes/:id/matches\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const { id } = req.params;\n      const matches = await mergeReconciliationService.findPhashMatches(id);\n      res.json({ matches });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to fetch matches\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * POST /api/admin/orphaned-scenes/:id/reconcile\n * Transfer user data from orphan to target scene\n */\nrouter.post(\n  \"/orphaned-scenes/:id/reconcile\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const { id } = req.params;\n      const { targetSceneId } = req.body;\n\n      if (!targetSceneId) {\n        return res.status(400).json({ error: \"targetSceneId is required\" });\n      }\n\n      const result = await mergeReconciliationService.reconcileScene(\n        id,\n        targetSceneId,\n        null, // Will be looked up if available\n        req.user!.id // Admin who initiated\n      );\n\n      res.json({\n        ok: true,\n        ...result,\n      });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to reconcile scene\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * POST /api/admin/orphaned-scenes/:id/discard\n * Delete orphaned user data for a scene\n */\nrouter.post(\n  \"/orphaned-scenes/:id/discard\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const { id } = req.params;\n      const result = await mergeReconciliationService.discardOrphanedData(id);\n\n      res.json({\n        ok: true,\n        ...result,\n      });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to discard orphaned data\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * POST /api/admin/reconcile-all\n * Auto-reconcile all orphans with exact phash matches\n */\nrouter.post(\n  \"/reconcile-all\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const orphans = await mergeReconciliationService.findOrphanedScenesWithActivity();\n      let reconciled = 0;\n      let skipped = 0;\n\n      for (const orphan of orphans) {\n        if (!orphan.phash) {\n          skipped++;\n          continue;\n        }\n\n        const matches = await mergeReconciliationService.findPhashMatches(orphan.id);\n        const exactMatch = matches.find((m) =&gt; m.similarity === \"exact\");\n\n        if (exactMatch) {\n          await mergeReconciliationService.reconcileScene(\n            orphan.id,\n            exactMatch.sceneId,\n            orphan.phash,\n            req.user!.id\n          );\n          reconciled++;\n        } else {\n          skipped++;\n        }\n      }\n\n      res.json({\n        ok: true,\n        reconciled,\n        skipped,\n      });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to reconcile all\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\nexport default router;\n</code></pre> <p>Step 2: Register routes in api.ts</p> <p>In <code>server/initializers/api.ts</code>, add the import (around line 30):</p> <pre><code>import mergeReconciliationRoutes from \"../routes/mergeReconciliation.js\";\n</code></pre> <p>And register the routes (around line 116, after exclusionsRoutes):</p> <pre><code>  // Merge reconciliation routes (admin only)\n  app.use(\"/api/admin\", mergeReconciliationRoutes);\n</code></pre> <p>Step 3: Verify build succeeds</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4: Commit</p> <pre><code>git add server/routes/mergeReconciliation.ts server/initializers/api.ts\ngit commit -m \"feat(api): add admin routes for merge reconciliation\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-11-create-admin-ui-component-mergerecoverytab","title":"Task 11: Create Admin UI Component - MergeRecoveryTab","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/MergeRecoveryTab.jsx</code></p> <p>Step 1: Create the component</p> <p>Create <code>client/src/components/settings/tabs/MergeRecoveryTab.jsx</code>:</p> <pre><code>import { useState, useEffect, useCallback } from \"react\";\nimport axios from \"axios\";\nimport { showError, showSuccess } from \"../../../utils/toast.jsx\";\nimport { Button } from \"../../ui/index.js\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst MergeRecoveryTab = () =&gt; {\n  const [orphans, setOrphans] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [processing, setProcessing] = useState(null);\n  const [expandedOrphan, setExpandedOrphan] = useState(null);\n  const [matches, setMatches] = useState({});\n  const [manualTargetId, setManualTargetId] = useState({});\n\n  const fetchOrphans = useCallback(async () =&gt; {\n    try {\n      setLoading(true);\n      const response = await api.get(\"/admin/orphaned-scenes\");\n      setOrphans(response.data.scenes);\n    } catch (error) {\n      showError(\"Failed to load orphaned scenes\");\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() =&gt; {\n    fetchOrphans();\n  }, [fetchOrphans]);\n\n  const fetchMatches = async (sceneId) =&gt; {\n    if (matches[sceneId]) return;\n    try {\n      const response = await api.get(`/admin/orphaned-scenes/${sceneId}/matches`);\n      setMatches((prev) =&gt; ({ ...prev, [sceneId]: response.data.matches }));\n    } catch (error) {\n      showError(\"Failed to load matches\");\n    }\n  };\n\n  const handleExpand = (sceneId) =&gt; {\n    if (expandedOrphan === sceneId) {\n      setExpandedOrphan(null);\n    } else {\n      setExpandedOrphan(sceneId);\n      fetchMatches(sceneId);\n    }\n  };\n\n  const handleReconcile = async (sourceId, targetId) =&gt; {\n    try {\n      setProcessing(sourceId);\n      await api.post(`/admin/orphaned-scenes/${sourceId}/reconcile`, { targetSceneId: targetId });\n      showSuccess(\"Activity transferred successfully\");\n      fetchOrphans();\n    } catch (error) {\n      showError(\"Failed to reconcile scene\");\n    } finally {\n      setProcessing(null);\n    }\n  };\n\n  const handleDiscard = async (sceneId) =&gt; {\n    if (!confirm(\"Are you sure you want to discard this orphaned data? This cannot be undone.\")) {\n      return;\n    }\n    try {\n      setProcessing(sceneId);\n      await api.post(`/admin/orphaned-scenes/${sceneId}/discard`);\n      showSuccess(\"Orphaned data discarded\");\n      fetchOrphans();\n    } catch (error) {\n      showError(\"Failed to discard data\");\n    } finally {\n      setProcessing(null);\n    }\n  };\n\n  const handleReconcileAll = async () =&gt; {\n    if (!confirm(\"This will auto-reconcile all orphans with exact PHASH matches. Continue?\")) {\n      return;\n    }\n    try {\n      setProcessing(\"all\");\n      const response = await api.post(\"/admin/reconcile-all\");\n      showSuccess(`Reconciled ${response.data.reconciled} scenes, skipped ${response.data.skipped}`);\n      fetchOrphans();\n    } catch (error) {\n      showError(\"Failed to reconcile all\");\n    } finally {\n      setProcessing(null);\n    }\n  };\n\n  if (loading) {\n    return &lt;div className=\"p-6\"&gt;Loading orphaned scenes...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div className=\"space-y-6\"&gt;\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--color-bg-secondary)\",\n          borderColor: \"var(--color-border)\",\n        }}\n      &gt;\n        &lt;div className=\"flex justify-between items-center mb-4\"&gt;\n          &lt;div&gt;\n            &lt;h3 className=\"text-lg font-semibold\" style={{ color: \"var(--color-text-primary)\" }}&gt;\n              Merge Recovery\n            &lt;/h3&gt;\n            &lt;p className=\"text-sm\" style={{ color: \"var(--color-text-secondary)\" }}&gt;\n              Recover user activity from scenes that were merged in Stash\n            &lt;/p&gt;\n          &lt;/div&gt;\n          &lt;Button\n            onClick={handleReconcileAll}\n            disabled={processing === \"all\" || orphans.length === 0}\n            variant=\"primary\"\n          &gt;\n            {processing === \"all\" ? \"Processing...\" : \"Auto-Reconcile All\"}\n          &lt;/Button&gt;\n        &lt;/div&gt;\n\n        {orphans.length === 0 ? (\n          &lt;p style={{ color: \"var(--color-text-secondary)\" }}&gt;No orphaned scenes with user activity found.&lt;/p&gt;\n        ) : (\n          &lt;div className=\"space-y-4\"&gt;\n            &lt;p style={{ color: \"var(--color-text-secondary)\" }}&gt;\n              Found {orphans.length} orphaned scene{orphans.length !== 1 ? \"s\" : \"\"} with user activity\n            &lt;/p&gt;\n\n            {orphans.map((orphan) =&gt; (\n              &lt;div\n                key={orphan.id}\n                className=\"p-4 rounded-lg border\"\n                style={{\n                  backgroundColor: \"var(--color-bg-tertiary)\",\n                  borderColor: \"var(--color-border)\",\n                }}\n              &gt;\n                &lt;div\n                  className=\"flex justify-between items-start cursor-pointer\"\n                  onClick={() =&gt; handleExpand(orphan.id)}\n                &gt;\n                  &lt;div&gt;\n                    &lt;h4 className=\"font-medium\" style={{ color: \"var(--color-text-primary)\" }}&gt;\n                      {orphan.title || orphan.id}\n                    &lt;/h4&gt;\n                    &lt;p className=\"text-sm\" style={{ color: \"var(--color-text-secondary)\" }}&gt;\n                      Deleted: {new Date(orphan.deletedAt).toLocaleDateString()}\n                      {orphan.phash ? ` | PHASH: ${orphan.phash.substring(0, 12)}...` : \" | No PHASH\"}\n                    &lt;/p&gt;\n                    &lt;p className=\"text-sm\" style={{ color: \"var(--color-text-secondary)\" }}&gt;\n                      Activity: {orphan.totalPlayCount} plays\n                      {orphan.hasRatings &amp;&amp; \" | Has ratings\"}\n                      {orphan.hasFavorites &amp;&amp; \" | Favorited\"}\n                    &lt;/p&gt;\n                  &lt;/div&gt;\n                  &lt;span style={{ color: \"var(--color-text-secondary)\" }}&gt;\n                    {expandedOrphan === orphan.id ? \"\u25bc\" : \"\u25b6\"}\n                  &lt;/span&gt;\n                &lt;/div&gt;\n\n                {expandedOrphan === orphan.id &amp;&amp; (\n                  &lt;div className=\"mt-4 pt-4 border-t\" style={{ borderColor: \"var(--color-border)\" }}&gt;\n                    &lt;p className=\"text-sm mb-2\" style={{ color: \"var(--color-text-primary)\" }}&gt;\n                      Potential matches:\n                    &lt;/p&gt;\n\n                    {!matches[orphan.id] ? (\n                      &lt;p className=\"text-sm\" style={{ color: \"var(--color-text-secondary)\" }}&gt;\n                        Loading matches...\n                      &lt;/p&gt;\n                    ) : matches[orphan.id].length === 0 ? (\n                      &lt;p className=\"text-sm\" style={{ color: \"var(--color-text-secondary)\" }}&gt;\n                        No PHASH matches found\n                      &lt;/p&gt;\n                    ) : (\n                      &lt;div className=\"space-y-2\"&gt;\n                        {matches[orphan.id].map((match) =&gt; (\n                          &lt;div\n                            key={match.sceneId}\n                            className=\"flex justify-between items-center p-2 rounded\"\n                            style={{ backgroundColor: \"var(--color-bg-secondary)\" }}\n                          &gt;\n                            &lt;div&gt;\n                              &lt;span style={{ color: \"var(--color-text-primary)\" }}&gt;\n                                {match.title || match.sceneId}\n                              &lt;/span&gt;\n                              &lt;span\n                                className=\"ml-2 text-sm\"\n                                style={{ color: \"var(--color-text-secondary)\" }}\n                              &gt;\n                                ({match.similarity} match)\n                                {match.recommended &amp;&amp; \" \u2605 Recommended\"}\n                              &lt;/span&gt;\n                            &lt;/div&gt;\n                            &lt;Button\n                              onClick={() =&gt; handleReconcile(orphan.id, match.sceneId)}\n                              disabled={processing === orphan.id}\n                              size=\"sm\"\n                            &gt;\n                              Transfer\n                            &lt;/Button&gt;\n                          &lt;/div&gt;\n                        ))}\n                      &lt;/div&gt;\n                    )}\n\n                    &lt;div className=\"mt-4 flex items-center gap-2\"&gt;\n                      &lt;input\n                        type=\"text\"\n                        placeholder=\"Manual scene ID\"\n                        value={manualTargetId[orphan.id] || \"\"}\n                        onChange={(e) =&gt;\n                          setManualTargetId((prev) =&gt; ({ ...prev, [orphan.id]: e.target.value }))\n                        }\n                        className=\"flex-1 p-2 rounded border\"\n                        style={{\n                          backgroundColor: \"var(--color-bg-primary)\",\n                          borderColor: \"var(--color-border)\",\n                          color: \"var(--color-text-primary)\",\n                        }}\n                      /&gt;\n                      &lt;Button\n                        onClick={() =&gt; handleReconcile(orphan.id, manualTargetId[orphan.id])}\n                        disabled={!manualTargetId[orphan.id] || processing === orphan.id}\n                        size=\"sm\"\n                      &gt;\n                        Transfer\n                      &lt;/Button&gt;\n                    &lt;/div&gt;\n\n                    &lt;div className=\"mt-4\"&gt;\n                      &lt;Button\n                        onClick={() =&gt; handleDiscard(orphan.id)}\n                        disabled={processing === orphan.id}\n                        variant=\"danger\"\n                        size=\"sm\"\n                      &gt;\n                        Discard Activity\n                      &lt;/Button&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n              &lt;/div&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default MergeRecoveryTab;\n</code></pre> <p>Step 2: Verify no syntax errors</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- src/components/settings/tabs/MergeRecoveryTab.jsx</code> Expected: No errors (or only warnings)</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/tabs/MergeRecoveryTab.jsx\ngit commit -m \"feat(ui): add MergeRecoveryTab component for admin reconciliation\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-12-register-mergerecoverytab-in-settings-page","title":"Task 12: Register MergeRecoveryTab in Settings Page","text":"<p>Files: - Modify: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Import the new tab</p> <p>At the top of <code>SettingsPage.jsx</code>, add the import (around line 15):</p> <pre><code>import MergeRecoveryTab from \"../settings/tabs/MergeRecoveryTab.jsx\";\n</code></pre> <p>Step 2: Add tab to SERVER_TABS array</p> <p>Modify the <code>SERVER_TABS</code> array (around line 27-30) to add the new tab:</p> <pre><code>const SERVER_TABS = [\n  { id: \"server-config\", label: \"Server Configuration\" },\n  { id: \"user-management\", label: \"User Management\" },\n  { id: \"merge-recovery\", label: \"Merge Recovery\" },\n];\n</code></pre> <p>Step 3: Add tab rendering</p> <p>In the server section rendering (around line 115-119), add:</p> <pre><code>          {activeSection === \"server\" &amp;&amp; (\n            &lt;&gt;\n              {activeTab === \"server-config\" &amp;&amp; &lt;ServerConfigTab /&gt;}\n              {activeTab === \"user-management\" &amp;&amp; &lt;UserManagementTab /&gt;}\n              {activeTab === \"merge-recovery\" &amp;&amp; &lt;MergeRecoveryTab /&gt;}\n            &lt;/&gt;\n          )}\n</code></pre> <p>Step 4: Verify no syntax errors</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- src/components/pages/SettingsPage.jsx</code> Expected: No errors (or only warnings)</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/SettingsPage.jsx\ngit commit -m \"feat(ui): add Merge Recovery tab to Server Settings\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-13-integration-test-full-workflow","title":"Task 13: Integration Test - Full Workflow","text":"<p>Files: - Create: <code>server/integration/api/mergeReconciliation.integration.test.ts</code></p> <p>Step 1: Create integration test</p> <p>Create <code>server/integration/api/mergeReconciliation.integration.test.ts</code>:</p> <pre><code>/**\n * Integration Tests for Merge Reconciliation API\n */\nimport { describe, it, expect, beforeAll, afterAll } from \"vitest\";\nimport request from \"supertest\";\nimport { setupAPI } from \"../../initializers/api.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nconst app = setupAPI();\n\ndescribe(\"Merge Reconciliation API\", () =&gt; {\n  let adminToken: string;\n  let testSceneId: string;\n  let targetSceneId: string;\n\n  beforeAll(async () =&gt; {\n    // Create admin user and get token\n    // (This would use your existing test setup patterns)\n  });\n\n  afterAll(async () =&gt; {\n    // Cleanup test data\n  });\n\n  describe(\"GET /api/admin/orphaned-scenes\", () =&gt; {\n    it(\"should return 401 for unauthenticated requests\", async () =&gt; {\n      const response = await request(app).get(\"/api/admin/orphaned-scenes\");\n      expect(response.status).toBe(401);\n    });\n\n    it(\"should return orphaned scenes for admin\", async () =&gt; {\n      const response = await request(app)\n        .get(\"/api/admin/orphaned-scenes\")\n        .set(\"Cookie\", `token=${adminToken}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty(\"scenes\");\n      expect(response.body).toHaveProperty(\"totalCount\");\n    });\n  });\n\n  describe(\"POST /api/admin/orphaned-scenes/:id/reconcile\", () =&gt; {\n    it(\"should require targetSceneId\", async () =&gt; {\n      const response = await request(app)\n        .post(`/api/admin/orphaned-scenes/${testSceneId}/reconcile`)\n        .set(\"Cookie\", `token=${adminToken}`)\n        .send({});\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe(\"targetSceneId is required\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run integration tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run integration/api/mergeReconciliation.integration.test.ts</code> Expected: Tests pass (or skip if test DB not configured)</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/mergeReconciliation.integration.test.ts\ngit commit -m \"test: add integration tests for merge reconciliation API\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#task-14-final-build-and-test","title":"Task 14: Final Build and Test","text":"<p>Step 1: Run full server build</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 2: Run all server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Run client build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4: Commit any remaining changes</p> <pre><code>git status\n# If any uncommitted changes:\ngit add -A\ngit commit -m \"chore: final cleanup for merge reconciliation feature\"\n</code></pre>"},{"location":"plans/2026-01-17-scene-merge-reconciliation/#summary","title":"Summary","text":"<p>This implementation plan covers:</p> <ol> <li>Tasks 1-3: Database schema changes (phash fields, MergeRecord table, migration)</li> <li>Tasks 4-5: Sync changes (GraphQL query update, phash storage during sync)</li> <li>Tasks 6-8: MergeReconciliationService (core logic with tests)</li> <li>Task 9: Sync-time detection integration</li> <li>Tasks 10-12: Admin API and UI (routes, MergeRecoveryTab component)</li> <li>Tasks 13-14: Integration tests and final verification</li> </ol> <p>Total commits: ~14 focused commits following TDD principles.</p>"},{"location":"plans/2026-01-18-database-backup-design/","title":"Database Backup Feature Design","text":""},{"location":"plans/2026-01-18-database-backup-design/#overview","title":"Overview","text":"<p>Allow admins to create, view, and delete database backups from the Settings UI.</p>"},{"location":"plans/2026-01-18-database-backup-design/#requirements","title":"Requirements","text":"<ul> <li>Create timestamped backups of the SQLite database</li> <li>View list of existing backups with size and date</li> <li>Delete individual backups</li> <li>No auto-pruning - users manage cleanup manually</li> <li>No restore functionality (manual file replacement required)</li> </ul>"},{"location":"plans/2026-01-18-database-backup-design/#api-endpoints","title":"API Endpoints","text":"<p>All endpoints require admin authentication.</p> Method Endpoint Description <code>GET</code> <code>/api/admin/database/backups</code> List all backups with metadata <code>POST</code> <code>/api/admin/database/backup</code> Create a new backup <code>DELETE</code> <code>/api/admin/database/backups/:filename</code> Delete a specific backup"},{"location":"plans/2026-01-18-database-backup-design/#response-formats","title":"Response Formats","text":"<p>GET /api/admin/database/backups <pre><code>{\n  \"backups\": [\n    {\n      \"filename\": \"peek-stash-browser.db.backup-20260118-104532\",\n      \"size\": 246747136,\n      \"createdAt\": \"2026-01-18T10:45:32.000Z\"\n    }\n  ]\n}\n</code></pre></p> <p>POST /api/admin/database/backup <pre><code>{\n  \"backup\": {\n    \"filename\": \"peek-stash-browser.db.backup-20260118-104532\",\n    \"size\": 246747136,\n    \"createdAt\": \"2026-01-18T10:45:32.000Z\"\n  }\n}\n</code></pre></p>"},{"location":"plans/2026-01-18-database-backup-design/#technical-approach","title":"Technical Approach","text":""},{"location":"plans/2026-01-18-database-backup-design/#backup-mechanism","title":"Backup Mechanism","text":"<p>Use SQLite's <code>VACUUM INTO</code> command for atomic, consistent backups:</p> <pre><code>await prisma.$executeRawUnsafe(`VACUUM INTO '${backupPath}'`);\n</code></pre> <p>This is safer than file copy because it guarantees a consistent snapshot even during active writes.</p>"},{"location":"plans/2026-01-18-database-backup-design/#backup-location","title":"Backup Location","text":"<p>Same directory as the database (<code>CONFIG_DIR</code>, typically <code>/app/data</code>). This ensures backups are included in the Docker volume mount and persist with the database.</p>"},{"location":"plans/2026-01-18-database-backup-design/#filename-pattern","title":"Filename Pattern","text":"<p><code>peek-stash-browser.db.backup-YYYYMMDD-HHmmss</code></p> <p>Example: <code>peek-stash-browser.db.backup-20260118-104532</code></p>"},{"location":"plans/2026-01-18-database-backup-design/#security","title":"Security","text":"<p>The delete endpoint validates filenames against the expected pattern to prevent path traversal:</p> <pre><code>const BACKUP_PATTERN = /^peek-stash-browser\\.db\\.backup-\\d{8}-\\d{6}$/;\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-design/#ui-design","title":"UI Design","text":"<p>New \"Backup\" tab in Server Settings section.</p>"},{"location":"plans/2026-01-18-database-backup-design/#layout","title":"Layout","text":"<ol> <li>Header - Title \"Backup\" with description</li> <li>Create Backup button - Primary action</li> <li>Backup list - Table/list of existing backups showing:</li> <li>Formatted date (e.g., \"Jan 18, 2026 at 10:45 AM\")</li> <li>File size (e.g., \"235 MB\")</li> <li>Delete button with confirmation</li> <li>Empty state when no backups exist</li> </ol>"},{"location":"plans/2026-01-18-database-backup-design/#states","title":"States","text":"<ul> <li>Loading: Show spinner while fetching list</li> <li>Creating: Button shows \"Creating backup...\" and is disabled</li> <li>Deleting: Show confirmation dialog, then processing state</li> </ul>"},{"location":"plans/2026-01-18-database-backup-design/#files-to-create","title":"Files to Create","text":"<ul> <li><code>server/services/DatabaseBackupService.ts</code></li> <li><code>server/routes/databaseBackup.ts</code></li> <li><code>server/tests/services/DatabaseBackupService.test.ts</code></li> <li><code>server/tests/routes/databaseBackup.test.ts</code></li> <li><code>client/src/components/settings/tabs/BackupTab.jsx</code></li> </ul>"},{"location":"plans/2026-01-18-database-backup-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>server/initializers/api.ts</code> - Register route</li> <li><code>client/src/components/pages/SettingsPage.jsx</code> - Add tab</li> </ul>"},{"location":"plans/2026-01-18-database-backup-design/#future-considerations-out-of-scope","title":"Future Considerations (Out of Scope)","text":"<ul> <li>Restore from backup via UI</li> <li>Auto-pruning old backups</li> <li>Scheduled automatic backups</li> <li>Download backup to browser</li> </ul>"},{"location":"plans/2026-01-18-database-backup-plan/","title":"Database Backup Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Allow admins to create, view, and delete database backups from the Settings UI.</p> <p>Architecture: A DatabaseBackupService handles file operations (list, create via VACUUM INTO, delete). Express routes expose admin-only endpoints. A React BackupTab component provides the UI in Server Settings.</p> <p>Tech Stack: Node.js fs/promises, SQLite VACUUM INTO via Prisma raw query, Express routes, React component</p>"},{"location":"plans/2026-01-18-database-backup-plan/#task-1-databasebackupservice-listbackups","title":"Task 1: DatabaseBackupService - listBackups","text":"<p>Files: - Create: <code>server/services/DatabaseBackupService.ts</code> - Create: <code>server/tests/services/DatabaseBackupService.test.ts</code></p> <p>Step 1: Write the failing test</p> <pre><code>// server/tests/services/DatabaseBackupService.test.ts\n/**\n * Unit Tests for DatabaseBackupService\n */\nimport { describe, it, expect, beforeEach, vi, afterEach } from \"vitest\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\n// Mock fs/promises\nvi.mock(\"fs/promises\");\n\n// Mock environment\nconst originalEnv = process.env;\n\ndescribe(\"DatabaseBackupService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n    process.env = { ...originalEnv, CONFIG_DIR: \"/app/data\" };\n  });\n\n  afterEach(() =&gt; {\n    process.env = originalEnv;\n    vi.resetModules();\n  });\n\n  describe(\"listBackups\", () =&gt; {\n    it(\"should return empty array when no backups exist\", async () =&gt; {\n      vi.mocked(fs.readdir).mockResolvedValue([\n        \"peek-stash-browser.db\",\n        \"other-file.txt\",\n      ] as any);\n\n      const { databaseBackupService } = await import(\n        \"../../services/DatabaseBackupService.js\"\n      );\n      const backups = await databaseBackupService.listBackups();\n\n      expect(backups).toEqual([]);\n    });\n\n    it(\"should return backup files with metadata\", async () =&gt; {\n      vi.mocked(fs.readdir).mockResolvedValue([\n        \"peek-stash-browser.db\",\n        \"peek-stash-browser.db.backup-20260118-104532\",\n        \"peek-stash-browser.db.backup-20260117-093045\",\n      ] as any);\n\n      vi.mocked(fs.stat).mockImplementation(async (filePath) =&gt; {\n        const filename = path.basename(filePath as string);\n        if (filename === \"peek-stash-browser.db.backup-20260118-104532\") {\n          return { size: 246747136, mtime: new Date(\"2026-01-18T10:45:32.000Z\") } as any;\n        }\n        return { size: 123456789, mtime: new Date(\"2026-01-17T09:30:45.000Z\") } as any;\n      });\n\n      const { databaseBackupService } = await import(\n        \"../../services/DatabaseBackupService.js\"\n      );\n      const backups = await databaseBackupService.listBackups();\n\n      expect(backups).toHaveLength(2);\n      expect(backups[0].filename).toBe(\"peek-stash-browser.db.backup-20260118-104532\");\n      expect(backups[0].size).toBe(246747136);\n      expect(backups[1].filename).toBe(\"peek-stash-browser.db.backup-20260117-093045\");\n    });\n\n    it(\"should sort backups by date descending (newest first)\", async () =&gt; {\n      vi.mocked(fs.readdir).mockResolvedValue([\n        \"peek-stash-browser.db.backup-20260117-093045\",\n        \"peek-stash-browser.db.backup-20260118-104532\",\n      ] as any);\n\n      vi.mocked(fs.stat).mockImplementation(async (filePath) =&gt; {\n        const filename = path.basename(filePath as string);\n        if (filename.includes(\"20260118\")) {\n          return { size: 100, mtime: new Date(\"2026-01-18T10:45:32.000Z\") } as any;\n        }\n        return { size: 100, mtime: new Date(\"2026-01-17T09:30:45.000Z\") } as any;\n      });\n\n      const { databaseBackupService } = await import(\n        \"../../services/DatabaseBackupService.js\"\n      );\n      const backups = await databaseBackupService.listBackups();\n\n      expect(backups[0].filename).toContain(\"20260118\");\n      expect(backups[1].filename).toContain(\"20260117\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// server/services/DatabaseBackupService.ts\n/**\n * DatabaseBackupService\n *\n * Handles database backup operations:\n * - List existing backups\n * - Create new backups using VACUUM INTO\n * - Delete backup files\n */\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nconst BACKUP_PATTERN = /^peek-stash-browser\\.db\\.backup-\\d{8}-\\d{6}$/;\n\nexport interface BackupInfo {\n  filename: string;\n  size: number;\n  createdAt: Date;\n}\n\nclass DatabaseBackupService {\n  private getDataDir(): string {\n    return process.env.CONFIG_DIR || \"/app/data\";\n  }\n\n  /**\n   * List all backup files with metadata.\n   * Returns sorted by date descending (newest first).\n   */\n  async listBackups(): Promise&lt;BackupInfo[]&gt; {\n    const dataDir = this.getDataDir();\n    const files = await fs.readdir(dataDir);\n\n    const backupFiles = files.filter((f) =&gt; BACKUP_PATTERN.test(f));\n\n    const backups: BackupInfo[] = await Promise.all(\n      backupFiles.map(async (filename) =&gt; {\n        const filePath = path.join(dataDir, filename);\n        const stat = await fs.stat(filePath);\n        return {\n          filename,\n          size: stat.size,\n          createdAt: stat.mtime,\n        };\n      })\n    );\n\n    // Sort by date descending (newest first)\n    backups.sort((a, b) =&gt; b.createdAt.getTime() - a.createdAt.getTime());\n\n    return backups;\n  }\n}\n\nexport const databaseBackupService = new DatabaseBackupService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/DatabaseBackupService.ts server/tests/services/DatabaseBackupService.test.ts\ngit commit -m \"feat(backup): add DatabaseBackupService with listBackups\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-2-databasebackupservice-createbackup","title":"Task 2: DatabaseBackupService - createBackup","text":"<p>Files: - Modify: <code>server/services/DatabaseBackupService.ts</code> - Modify: <code>server/tests/services/DatabaseBackupService.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>server/tests/services/DatabaseBackupService.test.ts</code>:</p> <pre><code>// Mock prisma - add at top with other mocks\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $executeRawUnsafe: vi.fn(),\n  },\n}));\n\nimport prisma from \"../../prisma/singleton.js\";\n\n// Add this describe block after listBackups tests:\ndescribe(\"createBackup\", () =&gt; {\n  it(\"should create a backup with timestamped filename\", async () =&gt; {\n    vi.mocked(prisma.$executeRawUnsafe).mockResolvedValue(0);\n    vi.mocked(fs.stat).mockResolvedValue({\n      size: 246747136,\n      mtime: new Date(\"2026-01-18T10:45:32.000Z\"),\n    } as any);\n\n    const { databaseBackupService } = await import(\n      \"../../services/DatabaseBackupService.js\"\n    );\n\n    // Mock Date to get predictable filename\n    const mockDate = new Date(\"2026-01-18T10:45:32.000Z\");\n    vi.setSystemTime(mockDate);\n\n    const backup = await databaseBackupService.createBackup();\n\n    expect(backup.filename).toBe(\"peek-stash-browser.db.backup-20260118-104532\");\n    expect(backup.size).toBe(246747136);\n    expect(prisma.$executeRawUnsafe).toHaveBeenCalledWith(\n      expect.stringContaining(\"VACUUM INTO\")\n    );\n\n    vi.useRealTimers();\n  });\n\n  it(\"should throw error if VACUUM INTO fails\", async () =&gt; {\n    vi.mocked(prisma.$executeRawUnsafe).mockRejectedValue(\n      new Error(\"Database locked\")\n    );\n\n    const { databaseBackupService } = await import(\n      \"../../services/DatabaseBackupService.js\"\n    );\n\n    await expect(databaseBackupService.createBackup()).rejects.toThrow(\n      \"Database locked\"\n    );\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: FAIL with \"createBackup is not a function\" or similar</p> <p>Step 3: Write minimal implementation</p> <p>Add to <code>server/services/DatabaseBackupService.ts</code>:</p> <pre><code>// Add import at top\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Add method to class:\n/**\n * Create a new backup using SQLite VACUUM INTO.\n * Returns info about the created backup.\n */\nasync createBackup(): Promise&lt;BackupInfo&gt; {\n  const dataDir = this.getDataDir();\n  const timestamp = this.formatTimestamp(new Date());\n  const filename = `peek-stash-browser.db.backup-${timestamp}`;\n  const backupPath = path.join(dataDir, filename);\n\n  logger.info(`Creating database backup: ${filename}`);\n\n  // Use VACUUM INTO for atomic, consistent backup\n  await prisma.$executeRawUnsafe(`VACUUM INTO '${backupPath}'`);\n\n  const stat = await fs.stat(backupPath);\n\n  logger.info(`Backup created successfully: ${filename} (${stat.size} bytes)`);\n\n  return {\n    filename,\n    size: stat.size,\n    createdAt: stat.mtime,\n  };\n}\n\nprivate formatTimestamp(date: Date): string {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const hours = String(date.getHours()).padStart(2, \"0\");\n  const minutes = String(date.getMinutes()).padStart(2, \"0\");\n  const seconds = String(date.getSeconds()).padStart(2, \"0\");\n  return `${year}${month}${day}-${hours}${minutes}${seconds}`;\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/DatabaseBackupService.ts server/tests/services/DatabaseBackupService.test.ts\ngit commit -m \"feat(backup): add createBackup using VACUUM INTO\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-3-databasebackupservice-deletebackup","title":"Task 3: DatabaseBackupService - deleteBackup","text":"<p>Files: - Modify: <code>server/services/DatabaseBackupService.ts</code> - Modify: <code>server/tests/services/DatabaseBackupService.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>server/tests/services/DatabaseBackupService.test.ts</code>:</p> <pre><code>describe(\"deleteBackup\", () =&gt; {\n  it(\"should delete a valid backup file\", async () =&gt; {\n    vi.mocked(fs.unlink).mockResolvedValue(undefined);\n\n    const { databaseBackupService } = await import(\n      \"../../services/DatabaseBackupService.js\"\n    );\n\n    await databaseBackupService.deleteBackup(\n      \"peek-stash-browser.db.backup-20260118-104532\"\n    );\n\n    expect(fs.unlink).toHaveBeenCalledWith(\n      \"/app/data/peek-stash-browser.db.backup-20260118-104532\"\n    );\n  });\n\n  it(\"should reject invalid filenames (path traversal prevention)\", async () =&gt; {\n    const { databaseBackupService } = await import(\n      \"../../services/DatabaseBackupService.js\"\n    );\n\n    await expect(\n      databaseBackupService.deleteBackup(\"../../../etc/passwd\")\n    ).rejects.toThrow(\"Invalid backup filename\");\n\n    await expect(\n      databaseBackupService.deleteBackup(\"peek-stash-browser.db\")\n    ).rejects.toThrow(\"Invalid backup filename\");\n\n    await expect(\n      databaseBackupService.deleteBackup(\"random-file.txt\")\n    ).rejects.toThrow(\"Invalid backup filename\");\n\n    expect(fs.unlink).not.toHaveBeenCalled();\n  });\n\n  it(\"should throw error if file does not exist\", async () =&gt; {\n    vi.mocked(fs.unlink).mockRejectedValue(\n      Object.assign(new Error(\"ENOENT\"), { code: \"ENOENT\" })\n    );\n\n    const { databaseBackupService } = await import(\n      \"../../services/DatabaseBackupService.js\"\n    );\n\n    await expect(\n      databaseBackupService.deleteBackup(\n        \"peek-stash-browser.db.backup-20260118-104532\"\n      )\n    ).rejects.toThrow();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: FAIL with \"deleteBackup is not a function\"</p> <p>Step 3: Write minimal implementation</p> <p>Add to <code>server/services/DatabaseBackupService.ts</code>:</p> <pre><code>/**\n * Delete a backup file.\n * Validates filename to prevent path traversal attacks.\n */\nasync deleteBackup(filename: string): Promise&lt;void&gt; {\n  // Security: validate filename matches expected pattern\n  if (!BACKUP_PATTERN.test(filename)) {\n    throw new Error(\"Invalid backup filename\");\n  }\n\n  const dataDir = this.getDataDir();\n  const filePath = path.join(dataDir, filename);\n\n  logger.info(`Deleting backup: ${filename}`);\n  await fs.unlink(filePath);\n  logger.info(`Backup deleted: ${filename}`);\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/DatabaseBackupService.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/DatabaseBackupService.ts server/tests/services/DatabaseBackupService.test.ts\ngit commit -m \"feat(backup): add deleteBackup with path traversal protection\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-4-database-backup-routes","title":"Task 4: Database Backup Routes","text":"<p>Files: - Create: <code>server/routes/databaseBackup.ts</code> - Create: <code>server/tests/routes/databaseBackup.test.ts</code></p> <p>Step 1: Write the failing test</p> <pre><code>// server/tests/routes/databaseBackup.test.ts\n/**\n * Unit Tests for Database Backup Routes (Admin API)\n */\nimport { describe, it, expect, beforeEach, vi, afterEach } from \"vitest\";\nimport { Request, Response, NextFunction } from \"express\";\n\n// Mock DatabaseBackupService\nvi.mock(\"../../services/DatabaseBackupService.js\", () =&gt; ({\n  databaseBackupService: {\n    listBackups: vi.fn(),\n    createBackup: vi.fn(),\n    deleteBackup: vi.fn(),\n  },\n}));\n\n// Mock auth middleware\nvi.mock(\"../../middleware/auth.js\", () =&gt; ({\n  authenticate: vi.fn((_req: Request, _res: Response, next: NextFunction) =&gt; next()),\n  requireAdmin: vi.fn((_req: Request, _res: Response, next: NextFunction) =&gt; next()),\n}));\n\n// Mock logger\nvi.mock(\"../../utils/logger.js\", () =&gt; ({\n  logger: {\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n  },\n}));\n\nimport { databaseBackupService } from \"../../services/DatabaseBackupService.js\";\n\nconst mockService = vi.mocked(databaseBackupService);\n\nfunction createMockRequest(options: {\n  params?: Record&lt;string, string&gt;;\n  body?: Record&lt;string, unknown&gt;;\n  user?: { id: number; username: string; role: string };\n} = {}): Partial&lt;Request&gt; {\n  return {\n    params: options.params || {},\n    body: options.body || {},\n    user: options.user,\n  } as Partial&lt;Request&gt;;\n}\n\nfunction createMockResponse() {\n  const responseJson = vi.fn();\n  const responseStatus = vi.fn(() =&gt; ({ json: responseJson }));\n  return {\n    json: responseJson,\n    status: responseStatus,\n    responseJson,\n    responseStatus,\n  };\n}\n\ndescribe(\"Database Backup Routes\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  afterEach(() =&gt; {\n    vi.resetAllMocks();\n  });\n\n  describe(\"GET /api/admin/database/backups\", () =&gt; {\n    it(\"should return list of backups\", async () =&gt; {\n      const mockBackups = [\n        {\n          filename: \"peek-stash-browser.db.backup-20260118-104532\",\n          size: 246747136,\n          createdAt: new Date(\"2026-01-18T10:45:32.000Z\"),\n        },\n      ];\n      mockService.listBackups.mockResolvedValue(mockBackups);\n\n      const { default: router } = await import(\"../../routes/databaseBackup.js\");\n\n      const mockReq = createMockRequest({\n        user: { id: 1, username: \"admin\", role: \"ADMIN\" },\n      });\n      const { json, status } = createMockResponse();\n      const mockRes = { json, status } as unknown as Response;\n\n      // Find and call the route handler\n      const layer = router.stack.find(\n        (l: any) =&gt; l.route?.path === \"/database/backups\" &amp;&amp; l.route?.methods?.get\n      );\n      const handler = layer?.route?.stack?.[0]?.handle;\n\n      await handler(mockReq, mockRes, () =&gt; {});\n\n      expect(mockService.listBackups).toHaveBeenCalled();\n      expect(json).toHaveBeenCalledWith({ backups: mockBackups });\n    });\n\n    it(\"should return 500 on service error\", async () =&gt; {\n      mockService.listBackups.mockRejectedValue(new Error(\"Disk error\"));\n\n      const { default: router } = await import(\"../../routes/databaseBackup.js\");\n\n      const mockReq = createMockRequest({\n        user: { id: 1, username: \"admin\", role: \"ADMIN\" },\n      });\n      const { json, status, responseJson, responseStatus } = createMockResponse();\n      const mockRes = { json, status } as unknown as Response;\n\n      const layer = router.stack.find(\n        (l: any) =&gt; l.route?.path === \"/database/backups\" &amp;&amp; l.route?.methods?.get\n      );\n      const handler = layer?.route?.stack?.[0]?.handle;\n\n      await handler(mockReq, mockRes, () =&gt; {});\n\n      expect(responseStatus).toHaveBeenCalledWith(500);\n      expect(responseJson).toHaveBeenCalledWith({\n        error: \"Failed to list backups\",\n        message: \"Disk error\",\n      });\n    });\n  });\n\n  describe(\"POST /api/admin/database/backup\", () =&gt; {\n    it(\"should create a backup and return info\", async () =&gt; {\n      const mockBackup = {\n        filename: \"peek-stash-browser.db.backup-20260118-104532\",\n        size: 246747136,\n        createdAt: new Date(\"2026-01-18T10:45:32.000Z\"),\n      };\n      mockService.createBackup.mockResolvedValue(mockBackup);\n\n      const { default: router } = await import(\"../../routes/databaseBackup.js\");\n\n      const mockReq = createMockRequest({\n        user: { id: 1, username: \"admin\", role: \"ADMIN\" },\n      });\n      const { json, status } = createMockResponse();\n      const mockRes = { json, status } as unknown as Response;\n\n      const layer = router.stack.find(\n        (l: any) =&gt; l.route?.path === \"/database/backup\" &amp;&amp; l.route?.methods?.post\n      );\n      const handler = layer?.route?.stack?.[0]?.handle;\n\n      await handler(mockReq, mockRes, () =&gt; {});\n\n      expect(mockService.createBackup).toHaveBeenCalled();\n      expect(json).toHaveBeenCalledWith({ backup: mockBackup });\n    });\n  });\n\n  describe(\"DELETE /api/admin/database/backups/:filename\", () =&gt; {\n    it(\"should delete a backup\", async () =&gt; {\n      mockService.deleteBackup.mockResolvedValue(undefined);\n\n      const { default: router } = await import(\"../../routes/databaseBackup.js\");\n\n      const mockReq = createMockRequest({\n        params: { filename: \"peek-stash-browser.db.backup-20260118-104532\" },\n        user: { id: 1, username: \"admin\", role: \"ADMIN\" },\n      });\n      const { json, status } = createMockResponse();\n      const mockRes = { json, status } as unknown as Response;\n\n      const layer = router.stack.find(\n        (l: any) =&gt;\n          l.route?.path === \"/database/backups/:filename\" &amp;&amp;\n          l.route?.methods?.delete\n      );\n      const handler = layer?.route?.stack?.[0]?.handle;\n\n      await handler(mockReq, mockRes, () =&gt; {});\n\n      expect(mockService.deleteBackup).toHaveBeenCalledWith(\n        \"peek-stash-browser.db.backup-20260118-104532\"\n      );\n      expect(json).toHaveBeenCalledWith({ ok: true });\n    });\n\n    it(\"should return 400 for invalid filename\", async () =&gt; {\n      mockService.deleteBackup.mockRejectedValue(\n        new Error(\"Invalid backup filename\")\n      );\n\n      const { default: router } = await import(\"../../routes/databaseBackup.js\");\n\n      const mockReq = createMockRequest({\n        params: { filename: \"../etc/passwd\" },\n        user: { id: 1, username: \"admin\", role: \"ADMIN\" },\n      });\n      const { json, status, responseJson, responseStatus } = createMockResponse();\n      const mockRes = { json, status } as unknown as Response;\n\n      const layer = router.stack.find(\n        (l: any) =&gt;\n          l.route?.path === \"/database/backups/:filename\" &amp;&amp;\n          l.route?.methods?.delete\n      );\n      const handler = layer?.route?.stack?.[0]?.handle;\n\n      await handler(mockReq, mockRes, () =&gt; {});\n\n      expect(responseStatus).toHaveBeenCalledWith(400);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/routes/databaseBackup.test.ts</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// server/routes/databaseBackup.ts\n/**\n * Database Backup Routes (Admin Only)\n *\n * Handles admin endpoints for database backup management:\n * - GET /api/admin/database/backups - List all backups\n * - POST /api/admin/database/backup - Create a new backup\n * - DELETE /api/admin/database/backups/:filename - Delete a backup\n */\nimport express from \"express\";\nimport { authenticate, requireAdmin } from \"../middleware/auth.js\";\nimport { databaseBackupService } from \"../services/DatabaseBackupService.js\";\nimport { authenticated } from \"../utils/routeHelpers.js\";\n\nconst router = express.Router();\n\n// All routes require authentication and admin role\nrouter.use(authenticate);\nrouter.use(requireAdmin);\n\n/**\n * GET /api/admin/database/backups\n * List all database backups\n */\nrouter.get(\n  \"/database/backups\",\n  authenticated(async (_req, res) =&gt; {\n    try {\n      const backups = await databaseBackupService.listBackups();\n      res.json({ backups });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to list backups\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * POST /api/admin/database/backup\n * Create a new database backup\n */\nrouter.post(\n  \"/database/backup\",\n  authenticated(async (_req, res) =&gt; {\n    try {\n      const backup = await databaseBackupService.createBackup();\n      res.json({ backup });\n    } catch (error) {\n      res.status(500).json({\n        error: \"Failed to create backup\",\n        message: error instanceof Error ? error.message : String(error),\n      });\n    }\n  })\n);\n\n/**\n * DELETE /api/admin/database/backups/:filename\n * Delete a specific backup\n */\nrouter.delete(\n  \"/database/backups/:filename\",\n  authenticated(async (req, res) =&gt; {\n    try {\n      const { filename } = req.params;\n      await databaseBackupService.deleteBackup(filename);\n      res.json({ ok: true });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      const status = message.includes(\"Invalid\") ? 400 : 500;\n      res.status(status).json({\n        error: \"Failed to delete backup\",\n        message,\n      });\n    }\n  })\n);\n\nexport default router;\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/routes/databaseBackup.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/routes/databaseBackup.ts server/tests/routes/databaseBackup.test.ts\ngit commit -m \"feat(api): add database backup admin routes\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-5-register-routes","title":"Task 5: Register Routes","text":"<p>Files: - Modify: <code>server/initializers/api.ts</code></p> <p>Step 1: Add import and registration</p> <p>Add after line 31 (after mergeReconciliationRoutes import):</p> <pre><code>import databaseBackupRoutes from \"../routes/databaseBackup.js\";\n</code></pre> <p>Add after line 120 (after mergeReconciliationRoutes registration):</p> <pre><code>// Database backup routes (admin only)\napp.use(\"/api/admin\", databaseBackupRoutes);\n</code></pre> <p>Step 2: Run server tests to ensure no regressions</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/initializers/api.ts\ngit commit -m \"feat(api): register database backup routes\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-6-backuptab-component","title":"Task 6: BackupTab Component","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/BackupTab.jsx</code></p> <p>Step 1: Create the component</p> <pre><code>// client/src/components/settings/tabs/BackupTab.jsx\nimport { useState, useEffect, useCallback } from \"react\";\nimport axios from \"axios\";\nimport { Trash2 } from \"lucide-react\";\nimport { showError, showSuccess } from \"../../../utils/toast.jsx\";\nimport { Button } from \"../../ui/index.js\";\n\nconst api = axios.create({\n  baseURL: \"/api\",\n  withCredentials: true,\n});\n\nconst formatBytes = (bytes) =&gt; {\n  if (bytes === 0) return \"0 B\";\n  const k = 1024;\n  const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i];\n};\n\nconst formatDate = (dateString) =&gt; {\n  const date = new Date(dateString);\n  return date.toLocaleDateString(undefined, {\n    year: \"numeric\",\n    month: \"short\",\n    day: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n  });\n};\n\nconst BackupTab = () =&gt; {\n  const [backups, setBackups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [creating, setCreating] = useState(false);\n  const [deleting, setDeleting] = useState(null);\n\n  const fetchBackups = useCallback(async () =&gt; {\n    try {\n      setLoading(true);\n      const response = await api.get(\"/admin/database/backups\");\n      setBackups(response.data.backups);\n    } catch {\n      showError(\"Failed to load backups\");\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() =&gt; {\n    fetchBackups();\n  }, [fetchBackups]);\n\n  const handleCreateBackup = async () =&gt; {\n    try {\n      setCreating(true);\n      await api.post(\"/admin/database/backup\");\n      showSuccess(\"Backup created successfully\");\n      fetchBackups();\n    } catch {\n      showError(\"Failed to create backup\");\n    } finally {\n      setCreating(false);\n    }\n  };\n\n  const handleDeleteBackup = async (filename) =&gt; {\n    if (!confirm(`Are you sure you want to delete this backup?\\n\\n${filename}\\n\\nThis cannot be undone.`)) {\n      return;\n    }\n    try {\n      setDeleting(filename);\n      await api.delete(`/admin/database/backups/${encodeURIComponent(filename)}`);\n      showSuccess(\"Backup deleted\");\n      fetchBackups();\n    } catch {\n      showError(\"Failed to delete backup\");\n    } finally {\n      setDeleting(null);\n    }\n  };\n\n  if (loading) {\n    return &lt;div className=\"p-6\"&gt;Loading backups...&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div className=\"space-y-6\"&gt;\n      &lt;div\n        className=\"p-6 rounded-lg border\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          borderColor: \"var(--border-color)\",\n        }}\n      &gt;\n        &lt;div className=\"flex justify-between items-center mb-4\"&gt;\n          &lt;div&gt;\n            &lt;h3 className=\"text-lg font-semibold\" style={{ color: \"var(--text-primary)\" }}&gt;\n              Database Backup\n            &lt;/h3&gt;\n            &lt;p className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n              Create and manage database backups\n            &lt;/p&gt;\n          &lt;/div&gt;\n          &lt;Button\n            onClick={handleCreateBackup}\n            disabled={creating}\n            variant=\"primary\"\n          &gt;\n            {creating ? \"Creating...\" : \"Create Backup\"}\n          &lt;/Button&gt;\n        &lt;/div&gt;\n\n        {backups.length === 0 ? (\n          &lt;p style={{ color: \"var(--text-secondary)\" }}&gt;\n            No backups yet. Create your first backup to protect your data.\n          &lt;/p&gt;\n        ) : (\n          &lt;div className=\"space-y-2\"&gt;\n            &lt;p className=\"text-sm mb-3\" style={{ color: \"var(--text-secondary)\" }}&gt;\n              {backups.length} backup{backups.length !== 1 ? \"s\" : \"\"} available\n            &lt;/p&gt;\n\n            {backups.map((backup) =&gt; (\n              &lt;div\n                key={backup.filename}\n                className=\"flex justify-between items-center p-3 rounded-lg border\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  borderColor: \"var(--border-color)\",\n                }}\n              &gt;\n                &lt;div&gt;\n                  &lt;p className=\"font-medium\" style={{ color: \"var(--text-primary)\" }}&gt;\n                    {formatDate(backup.createdAt)}\n                  &lt;/p&gt;\n                  &lt;p className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                    {formatBytes(backup.size)}\n                  &lt;/p&gt;\n                &lt;/div&gt;\n                &lt;Button\n                  onClick={() =&gt; handleDeleteBackup(backup.filename)}\n                  disabled={deleting === backup.filename}\n                  variant=\"danger\"\n                  size=\"sm\"\n                &gt;\n                  {deleting === backup.filename ? (\n                    \"Deleting...\"\n                  ) : (\n                    &lt;Trash2 size={16} /&gt;\n                  )}\n                &lt;/Button&gt;\n              &lt;/div&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default BackupTab;\n</code></pre> <p>Step 2: Verify component renders (manual check after integration)</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/tabs/BackupTab.jsx\ngit commit -m \"feat(ui): add BackupTab component\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-7-integrate-backuptab-into-settingspage","title":"Task 7: Integrate BackupTab into SettingsPage","text":"<p>Files: - Modify: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Add import and tab</p> <p>Add import after line 16:</p> <pre><code>import BackupTab from \"../settings/tabs/BackupTab.jsx\";\n</code></pre> <p>Modify SERVER_TABS (around line 28-32) to add the new tab:</p> <pre><code>const SERVER_TABS = [\n  { id: \"server-config\", label: \"Server Configuration\" },\n  { id: \"user-management\", label: \"User Management\" },\n  { id: \"merge-recovery\", label: \"Merge Recovery\" },\n  { id: \"backup\", label: \"Backup\" },\n];\n</code></pre> <p>Add rendering after line 121 (after MergeRecoveryTab):</p> <pre><code>{activeTab === \"backup\" &amp;&amp; &lt;BackupTab /&gt;}\n</code></pre> <p>Step 2: Run client tests to ensure no regressions</p> <p>Run: <code>cd client &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Run client build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/pages/SettingsPage.jsx\ngit commit -m \"feat(ui): add Backup tab to Server Settings\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#task-8-manual-testing-final-verification","title":"Task 8: Manual Testing &amp; Final Verification","text":"<p>Step 1: Start the application</p> <p>Run: <code>docker compose up</code></p> <p>Step 2: Test the feature</p> <ol> <li>Navigate to Settings \u2192 Server \u2192 Backup</li> <li>Click \"Create Backup\" - should show success toast and new backup in list</li> <li>Verify backup appears with correct date and size</li> <li>Click delete button - should prompt for confirmation</li> <li>Confirm delete - should remove backup from list</li> </ol> <p>Step 3: Run all tests</p> <p>Run: <code>cd server &amp;&amp; npm test &amp;&amp; npm run lint &amp;&amp; npx tsc --noEmit</code> Run: <code>cd client &amp;&amp; npm test &amp;&amp; npm run lint &amp;&amp; npm run build</code></p> <p>Expected: All checks pass</p> <p>Step 4: Final commit (if any fixes needed)</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during testing\"\n</code></pre>"},{"location":"plans/2026-01-18-database-backup-plan/#summary","title":"Summary","text":"<ol> <li>Task 1: DatabaseBackupService listBackups (tests + implementation)</li> <li>Task 2: DatabaseBackupService createBackup (tests + implementation)</li> <li>Task 3: DatabaseBackupService deleteBackup (tests + implementation)</li> <li>Task 4: Database backup routes (tests + implementation)</li> <li>Task 5: Register routes in api.ts</li> <li>Task 6: BackupTab React component</li> <li>Task 7: Integrate into SettingsPage</li> <li>Task 8: Manual testing and verification</li> </ol> <p>Total commits: ~8 focused commits following TDD principles.</p>"},{"location":"plans/2026-01-18-grid-density-controls-design/","title":"Grid Density Controls Design","text":""},{"location":"plans/2026-01-18-grid-density-controls-design/#summary","title":"Summary","text":"<p>Add density controls (S/M/L) to the card grid view, matching the existing Wall view zoom functionality. Also surface density/zoom settings in the Default View Mode settings UI so users can set their preferred defaults.</p>"},{"location":"plans/2026-01-18-grid-density-controls-design/#problem","title":"Problem","text":"<ol> <li>When setting Default View Mode to \"Wall\" in settings, users can't set their preferred zoom level (S/M/L) - it always defaults to Medium</li> <li>Grid view has no density control - users can't adjust how many cards appear per row</li> </ol>"},{"location":"plans/2026-01-18-grid-density-controls-design/#solution","title":"Solution","text":""},{"location":"plans/2026-01-18-grid-density-controls-design/#1-grid-density-control-in-search-controls","title":"1. Grid Density Control in Search Controls","text":"<p>Add an S/M/L toggle (reusing <code>ZoomSlider</code> component) that appears when Grid view is active:</p> <ul> <li>Small: More columns, smaller cards</li> <li>Medium: Current default column counts</li> <li>Large: Fewer columns, larger cards</li> </ul> <p>Column counts by density:</p> <p>Standard Grid (performers, studios, tags):</p> Breakpoint Small Medium Large &lt; 640px 2 1 1 640-1023px 3 2 2 1024-1919px 4 3 2 1920-2559px 6 5 3 2560-3839px 8 6 4 3840px+ 12 10 6 <p>Scene Grid:</p> Breakpoint Small Medium Large &lt; 768px 2 1 1 768-1279px 3 2 2 1280-1919px 4 3 2 1920-2559px 5 4 3 2560-3839px 7 5 4 3840px+ 10 8 5"},{"location":"plans/2026-01-18-grid-density-controls-design/#2-default-density-settings","title":"2. Default Density Settings","text":"<p>In both the Settings page and ContextSettings popover, when a view mode with density options (Grid or Wall) is selected:</p> <ul> <li>A secondary S/M/L control appears below the view mode dropdown</li> <li>Label: \"Default Density\"</li> <li>Sets the default density for that view mode per entity type</li> </ul>"},{"location":"plans/2026-01-18-grid-density-controls-design/#3-url-state","title":"3. URL State","text":"<p>Grid density syncs to URL as <code>grid_density=small|medium|large</code> (parallel to existing <code>zoom_level</code> for Wall).</p>"},{"location":"plans/2026-01-18-grid-density-controls-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li> <p><code>constants/grids.js</code> - Add density variants (S/M/L class strings for both grid types)</p> </li> <li> <p><code>config/entityDisplayConfig.js</code> - Add <code>defaultGridDensity</code> and <code>defaultWallZoom</code> to available settings and defaults</p> </li> <li> <p><code>components/ui/BaseGrid.jsx</code> - Accept <code>density</code> prop, select appropriate class string</p> </li> <li> <p><code>hooks/useFilterState.js</code> - Add <code>gridDensity</code> state with URL sync</p> </li> <li> <p><code>components/ui/SearchControls.jsx</code> - Render ZoomSlider when <code>viewMode === \"grid\"</code></p> </li> <li> <p><code>components/ui/ContextSettings.jsx</code> - Show density toggle below view mode dropdown when Grid or Wall selected</p> </li> <li> <p><code>components/settings/CardDisplaySettings.jsx</code> - Same density toggle below view mode dropdown</p> </li> <li> <p>Search page components - Pass <code>gridDensity</code> to their grid components</p> </li> </ol>"},{"location":"plans/2026-01-18-grid-density-controls-design/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Reuse existing <code>ZoomSlider</code> component for all density toggles</li> <li>No new components needed</li> <li>Density defaults to user's saved preference, falling back to \"medium\"</li> <li>Per-entity-type settings (scenes can have different default than performers)</li> </ul>"},{"location":"plans/2026-01-18-grid-density-controls/","title":"Grid Density Controls Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add S/M/L density controls to card grids and surface density defaults in the view mode settings.</p> <p>Architecture: Extend the existing zoom level pattern (used by Wall view) to Grid view. Add <code>gridDensity</code> state to <code>useFilterState</code>, URL params, and grid components. Add default density settings to the card display settings UI that appear below the view mode dropdown when Grid or Wall is selected.</p> <p>Tech Stack: React, Tailwind CSS responsive classes, existing ZoomSlider component.</p>"},{"location":"plans/2026-01-18-grid-density-controls/#task-1-add-grid-density-constants","title":"Task 1: Add Grid Density Constants","text":"<p>Files: - Modify: <code>client/src/constants/grids.js</code></p> <p>Step 1: Add density-aware grid class constants</p> <p>Replace the existing constants with a density-aware structure:</p> <pre><code>/** BREAKPOINTS\n  sm    (640px)\n  md    (768px)\n  lg    (1024px)\n  xl    (1280px)\n  2xl   (1536px)\n  3xl (1920px)\n  4xl (2560px)\n  5xl (3840px)\n*/\n\n/** STANDARD GRID DENSITY LEVELS\n  Density: small (more columns), medium (current), large (fewer columns)\n*/\nexport const STANDARD_GRID_DENSITIES = {\n  small: \"card-grid-responsive grid gap-4 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 3xl:grid-cols-6 4xl:grid-cols-8 5xl:grid-cols-12\",\n  medium: \"card-grid-responsive grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 3xl:grid-cols-5 4xl:grid-cols-6 5xl:grid-cols-10\",\n  large: \"card-grid-responsive grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 3xl:grid-cols-3 4xl:grid-cols-4 5xl:grid-cols-6\",\n};\n\n/** SCENE GRID DENSITY LEVELS */\nexport const SCENE_GRID_DENSITIES = {\n  small: \"card-grid-responsive grid gap-4 grid-cols-2 md:grid-cols-3 xl:grid-cols-4 3xl:grid-cols-5 4xl:grid-cols-7 5xl:grid-cols-10\",\n  medium: \"card-grid-responsive grid gap-4 grid-cols-1 md:grid-cols-2 xl:grid-cols-3 3xl:grid-cols-4 4xl:grid-cols-5 5xl:grid-cols-8\",\n  large: \"card-grid-responsive grid gap-4 grid-cols-1 md:grid-cols-2 xl:grid-cols-2 3xl:grid-cols-3 4xl:grid-cols-4 5xl:grid-cols-5\",\n};\n\n// Keep legacy exports for backwards compatibility during migration\nexport const STANDARD_GRID_CONTAINER_CLASSNAMES = STANDARD_GRID_DENSITIES.medium;\nexport const SCENE_GRID_CONTAINER_CLASSNAMES = SCENE_GRID_DENSITIES.medium;\n\n/** Helper to get grid classes for a density level */\nexport const getGridClasses = (gridType, density = \"medium\") =&gt; {\n  const densities = gridType === \"scene\" ? SCENE_GRID_DENSITIES : STANDARD_GRID_DENSITIES;\n  return densities[density] || densities.medium;\n};\n</code></pre> <p>Step 2: Verify file saves correctly</p> <p>Run: <code>cat client/src/constants/grids.js</code> Expected: File contains new density constants and helper function.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/constants/grids.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd grid density constants (S/M/L column configurations)\n\nAdds STANDARD_GRID_DENSITIES and SCENE_GRID_DENSITIES with small/medium/large\nvariants. Keeps legacy exports for backwards compatibility.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-2-add-default-density-settings-to-entity-config","title":"Task 2: Add Default Density Settings to Entity Config","text":"<p>Files: - Modify: <code>client/src/config/entityDisplayConfig.js</code></p> <p>Step 1: Add density settings to config</p> <p>Add <code>defaultGridDensity</code> and <code>defaultWallZoom</code> to each entity type's <code>defaultSettings</code> and <code>availableSettings</code>:</p> <p>For each entity in <code>ENTITY_DISPLAY_CONFIG</code>: - Add to <code>defaultSettings</code>: <code>defaultGridDensity: \"medium\"</code> and <code>defaultWallZoom: \"medium\"</code> - Add to <code>availableSettings</code> array (after <code>defaultViewMode</code>): <code>\"defaultGridDensity\"</code>, <code>\"defaultWallZoom\"</code></p> <p>Add to <code>SETTING_LABELS</code>: <pre><code>defaultGridDensity: \"Default grid density\",\ndefaultWallZoom: \"Default wall size\",\n</code></pre></p> <p>Step 2: Verify changes</p> <p>Run: <code>grep -n \"defaultGridDensity\" client/src/config/entityDisplayConfig.js</code> Expected: Multiple matches showing the new settings in each entity type.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/config/entityDisplayConfig.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd defaultGridDensity and defaultWallZoom to entity display config\n\nPer-entity-type default density settings for Grid and Wall views.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-3-update-basegrid-to-accept-density-prop","title":"Task 3: Update BaseGrid to Accept Density Prop","text":"<p>Files: - Modify: <code>client/src/components/ui/BaseGrid.jsx</code></p> <p>Step 1: Update BaseGrid component</p> <pre><code>import { getGridClasses, SCENE_GRID_CONTAINER_CLASSNAMES, STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\n// ... existing imports\n\nexport const BaseGrid = ({\n  items,\n  renderItem,\n  gridType = \"standard\",\n  density = \"medium\",  // NEW PROP\n  loading = false,\n  // ... rest of props\n}) =&gt; {\n  // Replace static class lookup with density-aware helper\n  const gridClasses = getGridClasses(gridType, density);\n\n  // ... rest of component unchanged\n};\n</code></pre> <p>Step 2: Verify changes</p> <p>Run: <code>grep -n \"density\" client/src/components/ui/BaseGrid.jsx</code> Expected: Shows density prop and usage.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/BaseGrid.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd density prop to BaseGrid component\n\nAccepts small/medium/large density, uses getGridClasses helper.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-4-add-griddensity-to-usefilterstate-hook","title":"Task 4: Add gridDensity to useFilterState Hook","text":"<p>Files: - Modify: <code>client/src/hooks/useFilterState.js</code></p> <p>Step 1: Add gridDensity state and actions</p> <p>Add alongside existing <code>zoomLevel</code>:</p> <ol> <li> <p>Add state: <code>const [gridDensity, setGridDensityState] = useState(\"medium\");</code></p> </li> <li> <p>Include in stateRef update: <code>stateRef.current = { filters, sort, pagination, searchText, viewMode, zoomLevel, gridDensity };</code></p> </li> <li> <p>Add to syncToUrlParams call object in each action</p> </li> <li> <p>Add setGridDensity action (copy pattern from setZoomLevel): <pre><code>const setGridDensity = useCallback((density) =&gt; {\n  setGridDensityState(density);\n  syncToUrlParams({\n    filters,\n    sort,\n    pagination,\n    searchText,\n    viewMode,\n    zoomLevel,\n    gridDensity: density,\n  });\n}, [filters, sort, pagination, searchText, viewMode, zoomLevel, syncToUrlParams]);\n</code></pre></p> </li> <li> <p>Add to return object: <code>gridDensity, setGridDensity</code></p> </li> <li> <p>Update initialize function to load gridDensity from URL/preset</p> </li> <li> <p>Update loadPreset to handle gridDensity</p> </li> </ol> <p>Step 2: Verify changes</p> <p>Run: <code>grep -n \"gridDensity\" client/src/hooks/useFilterState.js</code> Expected: Multiple matches showing state, actions, and sync.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/useFilterState.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd gridDensity state to useFilterState hook\n\nURL-synced grid density state with setGridDensity action.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-5-update-url-params-for-griddensity","title":"Task 5: Update URL Params for gridDensity","text":"<p>Files: - Modify: <code>client/src/utils/urlParams.js</code></p> <p>Step 1: Add gridDensity to buildSearchParams</p> <p>In the function parameters, add <code>gridDensity</code>: <pre><code>export const buildSearchParams = ({\n  searchText,\n  sortField,\n  sortDirection,\n  currentPage,\n  perPage,\n  filters,\n  filterOptions,\n  viewMode,\n  zoomLevel,\n  gridDensity,  // NEW\n}) =&gt; {\n</code></pre></p> <p>Add line to serialize: <pre><code>if (gridDensity &amp;&amp; gridDensity !== \"medium\") params.set(\"grid_density\", gridDensity);\n</code></pre></p> <p>Step 2: Add gridDensity to parseSearchParams</p> <pre><code>export const parseSearchParams = (searchParams, filterOptions, defaults = {}) =&gt; {\n  return {\n    // ... existing fields\n    gridDensity: searchParams.get(\"grid_density\") || defaults.gridDensity || \"medium\",\n    // ...\n  };\n};\n</code></pre> <p>Step 3: Verify changes</p> <p>Run: <code>grep -n \"gridDensity\\|grid_density\" client/src/utils/urlParams.js</code> Expected: Shows both parameter name variants.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/utils/urlParams.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd gridDensity to URL params serialization\n\nSyncs grid_density param to URL (omits if medium/default).\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-6-update-searchcontrols-to-show-density-toggle-for-grid","title":"Task 6: Update SearchControls to Show Density Toggle for Grid","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Add gridDensity to hook destructuring</p> <p>In the useFilterState destructure, add: <pre><code>gridDensity,\nsetGridDensity,\n</code></pre></p> <p>Step 2: Add ZoomSlider for grid view</p> <p>After the existing wall zoom slider block (around line 807-815), add:</p> <pre><code>{/* Grid Density Slider - Only shown in grid mode */}\n{viewMode === \"grid\" &amp;&amp; (\n  &lt;div\n    data-tv-search-item=\"grid-density\"\n    ref={(el) =&gt; searchZoneNav.setItemRef(6, el)}\n    className={searchZoneNav.isFocused(6) ? \"keyboard-focus\" : \"\"}\n  &gt;\n    &lt;ZoomSlider value={gridDensity} onChange={setGridDensity} /&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 3: Update children render prop</p> <p>Update the render prop call to include gridDensity: <pre><code>{typeof children === \"function\"\n  ? children({ viewMode, zoomLevel, gridDensity, wallPlayback, sortField, sortDirection, onSort: handleSortChange })\n  : children}\n</code></pre></p> <p>Step 4: Verify changes</p> <p>Run: <code>grep -n \"gridDensity\" client/src/components/ui/SearchControls.jsx</code> Expected: Shows destructuring, ZoomSlider usage, and render prop.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nShow density toggle in SearchControls when grid view active\n\nRenders ZoomSlider for grid density, passes to children render prop.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-7-update-contextsettings-to-show-default-density-below-view-mode","title":"Task 7: Update ContextSettings to Show Default Density Below View Mode","text":"<p>Files: - Modify: <code>client/src/components/ui/ContextSettings.jsx</code></p> <p>Step 1: Import ZoomSlider and density config</p> <pre><code>import ZoomSlider from \"./ZoomSlider.jsx\";\nimport { getViewModes } from \"../../config/entityDisplayConfig.js\";\n</code></pre> <p>Step 2: Add density control below view mode dropdown</p> <p>After the defaultViewMode select (around line 262-263), add:</p> <pre><code>{/* Default Density - shown for Grid or Wall view modes */}\n{(cardSettings?.defaultViewMode === \"grid\" || cardSettings?.defaultViewMode === \"wall\") &amp;&amp; (\n  &lt;div className=\"mt-2\"&gt;\n    &lt;label\n      className=\"block text-xs font-medium mb-1\"\n      style={{ color: \"var(--text-secondary)\" }}\n    &gt;\n      {cardSettings?.defaultViewMode === \"grid\" ? \"Default Grid Density\" : \"Default Wall Size\"}\n    &lt;/label&gt;\n    &lt;ZoomSlider\n      value={\n        cardSettings?.defaultViewMode === \"grid\"\n          ? (cardSettings?.defaultGridDensity || \"medium\")\n          : (cardSettings?.defaultWallZoom || \"medium\")\n      }\n      onChange={(density) =&gt;\n        handleCardSettingChange(\n          cardSettings?.defaultViewMode === \"grid\" ? \"defaultGridDensity\" : \"defaultWallZoom\",\n          density\n        )\n      }\n    /&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 3: Verify changes</p> <p>Run: <code>grep -n \"defaultGridDensity\\|defaultWallZoom\" client/src/components/ui/ContextSettings.jsx</code> Expected: Shows the conditional density control.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/ContextSettings.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nShow default density control below view mode in ContextSettings\n\nRenders ZoomSlider when Grid or Wall is the default view mode.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-8-update-carddisplaysettings-for-default-density","title":"Task 8: Update CardDisplaySettings for Default Density","text":"<p>Files: - Modify: <code>client/src/components/settings/CardDisplaySettings.jsx</code></p> <p>Step 1: Import ZoomSlider</p> <pre><code>import ZoomSlider from \"../ui/ZoomSlider.jsx\";\n</code></pre> <p>Step 2: Add density control in EntitySettingsSection</p> <p>After the Dropdown for defaultViewMode (around line 91), add:</p> <pre><code>{/* Default Density - shown for Grid or Wall view modes */}\n{(settings.defaultViewMode === \"grid\" || settings.defaultViewMode === \"wall\") &amp;&amp; (\n  &lt;div className=\"mt-2\"&gt;\n    &lt;label className=\"flex flex-col gap-1\"&gt;\n      &lt;span style={{ color: \"var(--text-primary)\" }}&gt;\n        {settings.defaultViewMode === \"grid\" ? \"Default Grid Density\" : \"Default Wall Size\"}\n      &lt;/span&gt;\n      &lt;ZoomSlider\n        value={\n          settings.defaultViewMode === \"grid\"\n            ? (settings.defaultGridDensity || \"medium\")\n            : (settings.defaultWallZoom || \"medium\")\n        }\n        onChange={(density) =&gt;\n          handleChange(\n            settings.defaultViewMode === \"grid\" ? \"defaultGridDensity\" : \"defaultWallZoom\",\n            density\n          )\n        }\n      /&gt;\n    &lt;/label&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 3: Verify changes</p> <p>Run: <code>grep -n \"ZoomSlider\\|defaultGridDensity\" client/src/components/settings/CardDisplaySettings.jsx</code> Expected: Shows import and usage.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/settings/CardDisplaySettings.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nShow default density control in CardDisplaySettings page\n\nRenders ZoomSlider below view mode dropdown for Grid/Wall modes.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-9-update-scenegrid-to-use-density","title":"Task 9: Update SceneGrid to Use Density","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneGrid.jsx</code></p> <p>Step 1: Update imports</p> <pre><code>import { getGridClasses } from \"../../constants/grids.js\";\n</code></pre> <p>Remove or keep the SCENE_GRID_CONTAINER_CLASSNAMES import (still used as fallback).</p> <p>Step 2: Add density prop and use it</p> <p>Add to component props: <pre><code>const SceneGrid = ({\n  scenes,\n  density = \"medium\",  // NEW PROP\n  loading = false,\n  // ... rest\n}) =&gt; {\n</code></pre></p> <p>Replace hardcoded classnames with dynamic: <pre><code>const gridClasses = getGridClasses(\"scene\", density);\n</code></pre></p> <p>Use <code>gridClasses</code> in both the loading skeleton div and the main grid div.</p> <p>Step 3: Verify changes</p> <p>Run: <code>grep -n \"density\\|getGridClasses\" client/src/components/scene-search/SceneGrid.jsx</code> Expected: Shows prop and usage.</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/scene-search/SceneGrid.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd density prop to SceneGrid component\n\nUses getGridClasses helper for density-aware column layout.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-10-update-scenesearch-to-pass-density-to-grid","title":"Task 10: Update SceneSearch to Pass Density to Grid","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Pass gridDensity to SceneGrid</p> <p>In the render prop callback, add gridDensity:</p> <pre><code>{({ viewMode, zoomLevel, gridDensity, wallPlayback, sortField, sortDirection, onSort }) =&gt;\n  // ... existing code ...\n  : (\n    &lt;SceneGrid\n      scenes={currentScenes || []}\n      density={gridDensity}  // NEW PROP\n      loading={isLoading}\n      // ... rest\n    /&gt;\n  )\n}\n</code></pre> <p>Step 2: Verify changes</p> <p>Run: <code>grep -n \"gridDensity\" client/src/components/scene-search/SceneSearch.jsx</code> Expected: Shows destructuring and prop passing.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nPass gridDensity to SceneGrid in SceneSearch\n\nConnects SearchControls density state to grid rendering.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-11-update-other-search-pages-performersearch-etc","title":"Task 11: Update Other Search Pages (PerformerSearch, etc.)","text":"<p>Files: - Modify: All other search pages that use grids</p> <p>Step 1: Identify all search pages using grids</p> <p>Run: <code>grep -rn \"BaseGrid\\|Grid.*density\" client/src/components/</code></p> <p>Common pages to update: - <code>client/src/components/performer-search/PerformerSearch.jsx</code> - <code>client/src/components/performer-search/PerformerGrid.jsx</code> - <code>client/src/components/studio-search/StudioSearch.jsx</code> - <code>client/src/components/studio-search/StudioGrid.jsx</code> - <code>client/src/components/tag-search/TagSearch.jsx</code> - <code>client/src/components/tag-search/TagGrid.jsx</code> - <code>client/src/components/gallery-search/GallerySearch.jsx</code> - <code>client/src/components/gallery-search/GalleryGrid.jsx</code> - <code>client/src/components/group-search/GroupSearch.jsx</code> - <code>client/src/components/group-search/GroupGrid.jsx</code> - <code>client/src/components/image-search/ImageSearch.jsx</code> - <code>client/src/components/image-search/ImageGrid.jsx</code></p> <p>Step 2: For each Grid component</p> <p>Add <code>density</code> prop and use <code>getGridClasses()</code> helper (same pattern as SceneGrid).</p> <p>Step 3: For each Search component</p> <p>Pass <code>gridDensity</code> from render prop to Grid component.</p> <p>Step 4: Verify all updates</p> <p>Run: <code>grep -rn \"density.*=\" client/src/components/*-search/*.jsx | grep -v node_modules</code> Expected: Shows density prop in all grid components.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/*-search/*.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nAdd density support to all entity grid components\n\nPerformerGrid, StudioGrid, TagGrid, GalleryGrid, GroupGrid, ImageGrid\nall now accept density prop and use getGridClasses helper.\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#task-12-test-and-verify","title":"Task 12: Test and Verify","text":"<p>Step 1: Run the development server</p> <pre><code>cd client &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Manual testing checklist</p> <ol> <li>Open Scenes page \u2192 verify S/M/L toggle appears in grid view</li> <li>Click S \u2192 verify more columns appear</li> <li>Click L \u2192 verify fewer columns appear</li> <li>Switch to Wall view \u2192 verify ZoomSlider still works</li> <li>Refresh page \u2192 verify density persists in URL</li> <li>Open Settings \u2192 Card Display \u2192 Scene \u2192 select Grid as default view mode</li> <li>Verify density toggle appears below the dropdown</li> <li>Change density \u2192 verify it saves</li> <li>Go back to Scenes page \u2192 verify new default density is applied</li> <li>Repeat for Performers, Studios, Tags, etc.</li> </ol> <p>Step 3: Check for console errors</p> <p>Open browser DevTools, verify no React errors or warnings related to the changes.</p>"},{"location":"plans/2026-01-18-grid-density-controls/#task-13-final-commit","title":"Task 13: Final Commit","text":"<p>Step 1: Review all changes</p> <pre><code>git status\ngit diff --stat main\n</code></pre> <p>Step 2: Create summary commit if needed</p> <p>If any files were missed or need cleanup, commit them now.</p> <p>Step 3: Push branch</p> <pre><code>git push -u origin feature/grid-density-controls\n</code></pre>"},{"location":"plans/2026-01-18-grid-density-controls/#files-summary","title":"Files Summary","text":"File Change <code>client/src/constants/grids.js</code> Add density variants, getGridClasses helper <code>client/src/config/entityDisplayConfig.js</code> Add defaultGridDensity, defaultWallZoom settings <code>client/src/components/ui/BaseGrid.jsx</code> Add density prop <code>client/src/hooks/useFilterState.js</code> Add gridDensity state and actions <code>client/src/utils/urlParams.js</code> Add gridDensity to URL serialization <code>client/src/components/ui/SearchControls.jsx</code> Show ZoomSlider for grid view <code>client/src/components/ui/ContextSettings.jsx</code> Show density below view mode dropdown <code>client/src/components/settings/CardDisplaySettings.jsx</code> Show density below view mode dropdown <code>client/src/components/scene-search/SceneGrid.jsx</code> Add density prop <code>client/src/components/scene-search/SceneSearch.jsx</code> Pass gridDensity to SceneGrid <code>client/src/components/*-search/*Grid.jsx</code> Add density prop (all entity grids) <code>client/src/components/*-search/*Search.jsx</code> Pass gridDensity (all entity searches)"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/","title":"Timeline UI Improvements Design","text":""},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#summary","title":"Summary","text":"<p>Improve the timeline component UX with: 1. Reorganized header bar (viewport range on left, zoom controls on right) 2. Wider bar spacing to reduce visual density 3. Edge navigation overlays with labeled scroll buttons 4. Fix selection \u2192 results connection so clicking bars filters content</p>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#design-details","title":"Design Details","text":""},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#1-header-bar-redesign","title":"1. Header Bar Redesign","text":"<p>Current: Zoom controls on left, selected period info on right.</p> <p>New layout: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Jan 1970 \u2014 Nov 1991                     [Years][Months][Weeks][Days] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <ul> <li>Left: Visible viewport range (updates live while scrolling)</li> <li>Right: Zoom level button group (moved from left)</li> <li>Single row, full width, accordion-collapsed styling</li> <li>Compute visible range by detecting which bars are in viewport using IntersectionObserver or scroll position + bar widths</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#2-bar-spacing-density","title":"2. Bar Spacing &amp; Density","text":"<p>Problem: Too many bars visible at once (1970-2001 = 31 years of months on 1080p).</p> <p>Solution: Increase minimum bar width based on zoom level: - Years: 48px - Months: 56px - Weeks: 48px - Days: 40px</p> <p>This reduces months view from ~372 potential bars to ~19 visible at once on 1080p, requiring horizontal scroll to see more.</p>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#3-edge-navigation-overlays","title":"3. Edge Navigation Overlays","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u2190 1965-1969    \u2502  [bars visible in viewport]  \u2502    2002+ \u2192     \u2502\n\u2502  (faded overlay)\u2502                              \u2502  (faded overlay)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Left overlay: Gradient fade (solid \u2192 transparent), button shows what's before</li> <li>Right overlay: Same, shows what's after</li> <li>Click: Scrolls by one viewport width in that direction</li> <li>Edge behavior: Overlay hidden when at start/end (no fade, no button)</li> <li>Styling: Semi-transparent theme background, history timeline aesthetic</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#4-selection-results-connection-bug-fix","title":"4. Selection \u2192 Results Connection (Bug Fix)","text":"<p>Problem: <code>TimelineView</code> receives <code>items</code> from parent but the parent (<code>SceneSearch</code>) doesn't know when timeline selection changes.</p> <p>Solution: 1. Add <code>onDateFilterChange</code> callback prop to <code>TimelineView</code> 2. When <code>selectedPeriod</code> changes, call <code>onDateFilterChange({ start, end })</code> 3. Parent incorporates date filter into its query</p> <p>Data flow: <pre><code>User clicks bar \u2192 selectPeriod() \u2192 selectedPeriod updates \u2192\n  \u2192 onDateFilterChange({ start: \"2024-01-01\", end: \"2024-01-31\" }) \u2192\n  \u2192 SceneSearch adds date filter to query \u2192 new results fetched\n</code></pre></p>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#timelinestripjsx","title":"TimelineStrip.jsx","text":"<ul> <li>Increase <code>min-w-[28px]</code> to zoom-level-specific widths</li> <li>Add scroll position tracking for visible range</li> <li>Add edge detection for overlay visibility</li> <li>Export visible range via callback</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#timelineviewjsx","title":"TimelineView.jsx","text":"<ul> <li>Restructure header: range display left, controls right</li> <li>Add edge navigation overlay components</li> <li>Add <code>onDateFilterChange</code> prop</li> <li>Call <code>onDateFilterChange</code> when <code>selectedPeriod</code> changes</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#scenesearchjsx-and-galleriesjsx-imagesjsx","title":"SceneSearch.jsx (and Galleries.jsx, Images.jsx)","text":"<ul> <li>Handle <code>onDateFilterChange</code> callback</li> <li>Merge timeline date filter with existing filters</li> <li>Re-fetch when date filter changes</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#new-timelineedgenavjsx-optional","title":"New: TimelineEdgeNav.jsx (optional)","text":"<ul> <li>Encapsulate edge overlay logic</li> <li>Gradient background, arrow button, label</li> <li>Click handler for page scroll</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-design/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Use <code>useRef</code> + scroll event listener for live viewport range updates</li> <li>Debounce is NOT needed per user preference (live updates)</li> <li>Edge labels should show contextual info (e.g., \"\u2190 1965-1969\" or \"\u2190 Earlier\" if range is large)</li> <li>Match table view's scrollable indicator styling but with arrows and labels</li> </ul>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/","title":"Timeline UI Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Improve timeline UX with reorganized header, wider spacing, edge navigation, and working selection filtering.</p> <p>Architecture: Modify existing timeline components, add new edge navigation component, wire up date filter callback to parent.</p> <p>Tech Stack: React, CSS custom properties, date-fns</p>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-1-fix-selection-results-connection-bug-fix","title":"Task 1: Fix Selection \u2192 Results Connection (Bug Fix)","text":"<p>This is the most critical fix - clicking bars should filter results.</p> <p>Files: - Modify: <code>client/src/components/timeline/TimelineView.jsx</code> - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code> - Modify: <code>client/src/components/pages/Galleries.jsx</code> - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Write failing test for onDateFilterChange callback</p> <p>In <code>client/tests/components/timeline/TimelineView.test.jsx</code>, add:</p> <pre><code>describe(\"Date Filter Callback\", () =&gt; {\n  it(\"calls onDateFilterChange when period is selected\", async () =&gt; {\n    const onDateFilterChange = vi.fn();\n    // ... render with onDateFilterChange prop\n    // ... click a bar\n    // ... expect onDateFilterChange to have been called with { start, end }\n  });\n\n  it(\"calls onDateFilterChange with null when selection is cleared\", async () =&gt; {\n    const onDateFilterChange = vi.fn();\n    // ... render with selected period and onDateFilterChange\n    // ... click same bar to deselect\n    // ... expect onDateFilterChange to have been called with null\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run tests/components/timeline/TimelineView.test.jsx</code> Expected: FAIL - onDateFilterChange prop doesn't exist</p> <p>Step 3: Add onDateFilterChange prop to TimelineView</p> <p>In <code>TimelineView.jsx</code>: - Add <code>onDateFilterChange</code> prop - Add <code>useEffect</code> that calls <code>onDateFilterChange</code> when <code>selectedPeriod</code> changes - Pass <code>{ start: selectedPeriod.start, end: selectedPeriod.end }</code> or <code>null</code></p> <p>Step 4: Run test to verify it passes</p> <p>Step 5: Wire up SceneSearch to use onDateFilterChange</p> <p>In <code>SceneSearch.jsx</code>: - Add state for timeline date filter - Pass <code>onDateFilterChange</code> to TimelineView - Merge timeline filter into query filters</p> <p>Step 6: Wire up Galleries.jsx and Images.jsx similarly</p> <p>Step 7: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"feat(timeline): wire up selection to filter results\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-2-increase-bar-spacing","title":"Task 2: Increase Bar Spacing","text":"<p>Files: - Modify: <code>client/src/components/timeline/TimelineStrip.jsx</code> - Modify: <code>client/tests/components/timeline/TimelineStrip.test.jsx</code></p> <p>Step 1: Write test for zoom-level-specific bar widths</p> <pre><code>describe(\"Bar Spacing\", () =&gt; {\n  it(\"uses wider spacing for months zoom level\", () =&gt; {\n    const { container } = render(&lt;TimelineStrip {...defaultProps} zoomLevel=\"months\" /&gt;);\n    const barContainer = container.querySelector('[class*=\"min-w-\"]');\n    // Check for larger min-width class\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Step 3: Add BAR_WIDTHS constant and apply zoom-level-specific widths</p> <pre><code>const BAR_WIDTHS = {\n  years: \"min-w-[48px]\",\n  months: \"min-w-[56px]\",\n  weeks: \"min-w-[48px]\",\n  days: \"min-w-[40px]\",\n};\n</code></pre> <p>Apply in the bar container div.</p> <p>Step 4: Run tests to verify pass</p> <p>Step 5: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"feat(timeline): increase bar spacing based on zoom level\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-3-add-visible-range-tracking","title":"Task 3: Add Visible Range Tracking","text":"<p>Files: - Modify: <code>client/src/components/timeline/TimelineStrip.jsx</code></p> <p>Step 1: Write test for onVisibleRangeChange callback</p> <pre><code>it(\"reports visible range on scroll\", () =&gt; {\n  const onVisibleRangeChange = vi.fn();\n  render(&lt;TimelineStrip {...defaultProps} onVisibleRangeChange={onVisibleRangeChange} /&gt;);\n  // Simulate scroll or initial render\n  expect(onVisibleRangeChange).toHaveBeenCalled();\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Step 3: Implement visible range tracking</p> <ul> <li>Add <code>onVisibleRangeChange</code> prop</li> <li>Use scroll event listener on container</li> <li>Calculate first/last visible bar indices based on scrollLeft and bar width</li> <li>Call <code>onVisibleRangeChange({ firstPeriod, lastPeriod })</code> on scroll and mount</li> </ul> <p>Step 4: Run tests to verify pass</p> <p>Step 5: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"feat(timeline): track visible range for header display\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-4-reorganize-header-bar","title":"Task 4: Reorganize Header Bar","text":"<p>Files: - Modify: <code>client/src/components/timeline/TimelineView.jsx</code></p> <p>Step 1: Write test for new header layout</p> <pre><code>it(\"displays visible range on left and controls on right\", () =&gt; {\n  render(&lt;TimelineView entityType=\"scene\" ... /&gt;);\n  const header = screen.getByRole(\"banner\") || container.querySelector('[class*=\"header\"]');\n  // Check that range text appears before controls in DOM order\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Step 3: Restructure header in TimelineView</p> <ul> <li>Add state for <code>visibleRange</code></li> <li>Pass <code>onVisibleRangeChange</code> to TimelineStrip</li> <li>Render: <code>[VisibleRange] -----spacer----- [ZoomControls]</code></li> <li>Format visible range as \"Jan 1970 \u2014 Nov 1991\"</li> </ul> <p>Step 4: Run tests to verify pass</p> <p>Step 5: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"feat(timeline): reorganize header with range on left, controls on right\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-5-add-edge-navigation-overlays","title":"Task 5: Add Edge Navigation Overlays","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineEdgeNav.jsx</code> - Modify: <code>client/src/components/timeline/TimelineStrip.jsx</code> - Create: <code>client/tests/components/timeline/TimelineEdgeNav.test.jsx</code></p> <p>Step 1: Write tests for TimelineEdgeNav component</p> <pre><code>describe(\"TimelineEdgeNav\", () =&gt; {\n  it(\"renders left arrow with label when not at start\", () =&gt; {});\n  it(\"renders right arrow with label when not at end\", () =&gt; {});\n  it(\"hides left overlay when at start\", () =&gt; {});\n  it(\"hides right overlay when at end\", () =&gt; {});\n  it(\"calls onScrollLeft when left button clicked\", () =&gt; {});\n  it(\"calls onScrollRight when right button clicked\", () =&gt; {});\n});\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Step 3: Implement TimelineEdgeNav component</p> <ul> <li>Props: <code>atStart</code>, <code>atEnd</code>, <code>leftLabel</code>, <code>rightLabel</code>, <code>onScrollLeft</code>, <code>onScrollRight</code></li> <li>Render gradient overlays with buttons</li> <li>Use CSS gradient: <code>linear-gradient(to right, var(--bg-primary), transparent)</code></li> <li>Style similar to table scroll indicators but with arrows and labels</li> </ul> <p>Step 4: Integrate into TimelineStrip</p> <ul> <li>Track scroll position to determine atStart/atEnd</li> <li>Calculate labels from distribution data</li> <li>Wire up scroll handlers to scroll by viewport width</li> </ul> <p>Step 5: Run tests to verify pass</p> <p>Step 6: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"feat(timeline): add edge navigation overlays\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-6-update-timelinestrip-tests","title":"Task 6: Update TimelineStrip Tests","text":"<p>Files: - Modify: <code>client/tests/components/timeline/TimelineStrip.test.jsx</code></p> <p>Step 1: Review and update any broken tests</p> <p>After all changes, ensure: - All existing tests still pass or are updated - New functionality is covered</p> <p>Step 2: Run full test suite</p> <pre><code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- --run tests/components/timeline/\n</code></pre> <p>Step 3: Fix any failures</p> <p>Step 4: Commit</p> <pre><code>git add -A &amp;&amp; git commit -m \"test(timeline): update tests for UI improvements\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-ui-improvements-plan/#task-7-final-integration-testing","title":"Task 7: Final Integration Testing","text":"<p>Step 1: Run all timeline tests</p> <pre><code>npm test -- --run tests/components/timeline/\n</code></pre> <p>Step 2: Manual verification</p> <ul> <li>Open browser to timeline view</li> <li>Verify bars are properly spaced</li> <li>Verify header shows range on left, controls on right</li> <li>Verify edge overlays appear/hide correctly</li> <li>Verify clicking a bar filters the results</li> <li>Verify scrolling updates the range display</li> </ul> <p>Step 3: Fix any issues found</p> <p>Step 4: Final commit if needed</p>"},{"location":"plans/2026-01-18-timeline-view-design/","title":"Timeline View Design","text":"<p>A new view mode for browsing scenes, galleries, and images by date on a horizontally scrollable timeline.</p>"},{"location":"plans/2026-01-18-timeline-view-design/#overview","title":"Overview","text":"<p>Timeline view adds a fourth view mode (alongside Grid, Wall, Table) for Scene, Gallery, and Image entities. It displays a horizontal timeline with density bars showing content distribution over time. Users select a time period to filter results shown below.</p>"},{"location":"plans/2026-01-18-timeline-view-design/#core-decisions","title":"Core Decisions","text":"Decision Choice Scope New view mode per entity (scenes, galleries, images) Items without dates Excluded from timeline view entirely Selection behavior Matches zoom granularity (click year = select year) Density visualization Vertical bars with count on hover Zoom control Segmented toggle: Years | Months | Weeks | Days Empty time periods Shown proportionally (gaps represent actual time) Default on load Most recent time period with content Desktop layout Fixed timeline header above scrollable results Mobile layout Compact timeline in draggable bottom sheet Navigation Full keyboard + TV remote support"},{"location":"plans/2026-01-18-timeline-view-design/#visual-design","title":"Visual Design","text":""},{"location":"plans/2026-01-18-timeline-view-design/#desktop-layout","title":"Desktop Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  [Years] [Months] [Weeks] [Days]                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    \u2502      \u2502\u2502   \u2502         \u2502\u2502\u2502        \u2502    \u2502                          \u2502\n\u2502    \u2502      \u2502\u2502   \u2502         \u2502\u2502\u2502        \u2502    \u2502        \u2190 density bars    \u2502\n\u2502    \u2502      \u2502\u2502   \u2502         \u2502\u2502\u2502        \u2502    \u2502                          \u2502\n\u2502  \u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2534\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500      \u2190 baseline        \u2502\n\u2502  2020    2021  2022      2023      2024  2025     \u2190 labels          \u2502\n\u2502                           \u25b2                                         \u2502\n\u2502                      [selected]                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510                               \u2502\n\u2502   \u2502     \u2502  \u2502     \u2502  \u2502     \u2502  \u2502     \u2502                               \u2502\n\u2502   \u2502     \u2502  \u2502     \u2502  \u2502     \u2502  \u2502     \u2502    \u2190 results grid             \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n\u2502                                                                     \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510                               \u2502\n\u2502   \u2502     \u2502  \u2502     \u2502  \u2502     \u2502  \u2502     \u2502                               \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n\u2502                                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-design/#mobile-layout","title":"Mobile Layout","text":"<p>Bottom sheet with three states:</p> <p>Minimized (default while browsing): ~48px <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u2501\u2501\u2501  March 2024 \u00b7 47 scenes  \u25b2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Expanded: ~200px with full timeline controls</p> <p>Gestures: - Swipe up on minimized bar to expand - Swipe down on expanded sheet to minimize - Tap period to select, auto-minimizes after selection</p>"},{"location":"plans/2026-01-18-timeline-view-design/#component-architecture","title":"Component Architecture","text":""},{"location":"plans/2026-01-18-timeline-view-design/#new-files","title":"New Files","text":"<pre><code>client/src/components/timeline/\n\u251c\u2500\u2500 TimelineView.jsx          # Main container, layout management\n\u251c\u2500\u2500 TimelineStrip.jsx         # Horizontal scrollable timeline with bars\n\u251c\u2500\u2500 TimelineControls.jsx      # Zoom level toggle (Years/Months/Weeks/Days)\n\u251c\u2500\u2500 TimelineBar.jsx           # Individual density bar component\n\u251c\u2500\u2500 TimelineMobileSheet.jsx   # Bottom sheet wrapper for mobile\n\u2514\u2500\u2500 useTimelineState.js       # State hook (zoom, selection, distribution)\n\nserver/\n\u251c\u2500\u2500 services/TimelineService.ts        # Date distribution queries\n\u2514\u2500\u2500 controllers/timelineController.ts  # API endpoint\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>client/src/config/entityDisplayConfig.js</code> - Add 'timeline' to view modes</li> <li><code>client/src/components/ui/ViewModeToggle.jsx</code> - Add timeline icon/option</li> <li><code>client/src/components/scene-search/SceneSearch.jsx</code> - Render TimelineView</li> <li><code>client/src/components/gallery-search/GallerySearch.jsx</code> - Same</li> <li><code>client/src/components/image-search/ImageSearch.jsx</code> - Same</li> <li><code>server/routes/api.ts</code> - Add distribution endpoint route</li> </ul>"},{"location":"plans/2026-01-18-timeline-view-design/#dependencies","title":"Dependencies","text":"<ul> <li>Bottom sheet package (e.g., <code>react-spring-bottom-sheet</code> or similar, styled to match app)</li> </ul>"},{"location":"plans/2026-01-18-timeline-view-design/#state-management","title":"State Management","text":""},{"location":"plans/2026-01-18-timeline-view-design/#usetimelinestate-hook","title":"useTimelineState Hook","text":"<pre><code>{\n  zoomLevel: 'months',        // 'years' | 'months' | 'weeks' | 'days'\n  selectedPeriod: {           // null if nothing selected\n    start: '2024-03-01',\n    end: '2024-03-31',\n    label: 'March 2024'\n  },\n  scrollPosition: 0.85,       // 0-1, percentage through timeline\n  distribution: [             // fetched density data\n    { period: '2024-01', count: 47, start: '...', end: '...' },\n    { period: '2024-02', count: 12, start: '...', end: '...' },\n  ]\n}\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-design/#filter-integration","title":"Filter Integration","text":"<p>Uses the permanent filter pattern from detail pages:</p> <pre><code>// Permanent filter: exclude items without dates\npermanentFilters={{\n  date: {\n    value: { modifier: 'NOT_NULL' },\n  }\n}}\n\n// Selection filter: added when a period is selected\nselectionFilter={{\n  date: {\n    value: selectedPeriod.start,\n    value2: selectedPeriod.end,\n    modifier: 'BETWEEN'\n  }\n}}\n</code></pre> <p>User-added filters (tags, performers, etc.) stack on top. Sorting affects results order but not the timeline.</p>"},{"location":"plans/2026-01-18-timeline-view-design/#api-design","title":"API Design","text":""},{"location":"plans/2026-01-18-timeline-view-design/#new-endpoint","title":"New Endpoint","text":"<pre><code>GET /api/{entityType}/date-distribution?granularity=months\n</code></pre> <p>Response: <pre><code>[\n  { \"period\": \"2024-01\", \"count\": 47 },\n  { \"period\": \"2024-02\", \"count\": 12 }\n]\n</code></pre></p>"},{"location":"plans/2026-01-18-timeline-view-design/#server-implementation","title":"Server Implementation","text":"<p>Follows existing <code>SceneQueryBuilder.ts</code> pattern with pre-computed exclusions:</p> <pre><code>private buildDateDistributionQuery(userId: number, granularity: string) {\n  return `\n    SELECT\n      strftime('${this.getStrftimeFormat(granularity)}', s.date) as period,\n      COUNT(*) as count\n    FROM StashScene s\n    LEFT JOIN UserExcludedEntity e\n      ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id\n    WHERE s.deletedAt IS NULL\n      AND e.id IS NULL           -- Exclude hidden/restricted\n      AND s.date IS NOT NULL     -- Only items with dates\n    GROUP BY period\n    ORDER BY period ASC\n  `;\n}\n</code></pre> <p>strftime formats: - years: <code>'%Y'</code> \u2192 <code>'2024'</code> - months: <code>'%Y-%m'</code> \u2192 <code>'2024-03'</code> - weeks: <code>'%Y-W%W'</code> \u2192 <code>'2024-W12'</code> - days: <code>'%Y-%m-%d'</code> \u2192 <code>'2024-03-15'</code></p> <p>Performance: JOIN to <code>UserExcludedEntity</code> uses index <code>(userId, entityType)</code>, efficient at 100k+ items.</p>"},{"location":"plans/2026-01-18-timeline-view-design/#interaction-behavior","title":"Interaction Behavior","text":""},{"location":"plans/2026-01-18-timeline-view-design/#timeline-strip","title":"Timeline Strip","text":"<ul> <li>Horizontal scroll via drag, touch swipe, or shift+scroll wheel</li> <li>Mousewheel over timeline (without shift) changes zoom level</li> <li>Pinch gesture on touch devices changes zoom level</li> <li>Click bar to select that time period</li> <li>Selected period highlighted visually</li> <li>Hover shows tooltip with count (\"47 scenes\")</li> <li>Smooth animated transitions when changing zoom levels</li> </ul>"},{"location":"plans/2026-01-18-timeline-view-design/#keyboard-navigation","title":"Keyboard Navigation","text":"Key Action <code>\u2190</code> / <code>\u2192</code> Move selection to previous/next period <code>+</code> / <code>-</code> Change zoom level <code>Enter</code> Confirm selection, focus results grid <code>Tab</code> Move focus: controls \u2192 timeline \u2192 results <code>Home</code> / <code>End</code> Jump to earliest/latest content"},{"location":"plans/2026-01-18-timeline-view-design/#tv-remote","title":"TV Remote","text":"<ul> <li>D-pad left/right: navigate periods</li> <li>D-pad up/down: zoom out/in</li> <li>Select: confirm selection</li> <li>Back: return focus to timeline</li> </ul>"},{"location":"plans/2026-01-18-timeline-view-design/#screen-reader","title":"Screen Reader","text":"<ul> <li>Announce: \"Timeline, March 2024, 47 scenes, 3 of 24 periods\"</li> <li>On navigation: \"April 2024, 12 scenes\"</li> <li>On selection: \"Selected March 2024, showing 47 scenes\"</li> </ul>"},{"location":"plans/2026-01-18-timeline-view-design/#open-questions","title":"Open Questions","text":"<p>None at this time. Design is approved and ready for implementation planning.</p>"},{"location":"plans/2026-01-18-timeline-view-implementation/","title":"Timeline View Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a Timeline view mode for browsing scenes, galleries, and images by date on a horizontally scrollable timeline with density bars.</p> <p>Architecture: New view mode integrating with existing SearchControls pattern. Backend provides date distribution via SQL aggregation with exclusion filtering. Frontend renders horizontal timeline with density bars, zoom controls, and mobile bottom sheet.</p> <p>Tech Stack: React 19, Vitest, Tailwind CSS, Prisma raw SQL, existing SearchControls/entityDisplayConfig patterns</p>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-1-backend-timelineservice-date-distribution-query","title":"Task 1: Backend - TimelineService Date Distribution Query","text":"<p>Files: - Create: <code>server/services/TimelineService.ts</code> - Test: <code>server/tests/services/TimelineService.test.ts</code></p> <p>Step 1: Write the failing test</p> <pre><code>// server/tests/services/TimelineService.test.ts\nimport { describe, it, expect, vi, beforeEach } from \"vitest\";\n\nvi.mock(\"../services/StashInstanceManager.js\", () =&gt; ({\n  stashInstanceManager: {\n    getDefaultConfig: vi.fn().mockReturnValue({\n      id: \"test-instance\",\n      name: \"Test Stash\",\n      url: \"http://localhost:9999/graphql\",\n      apiKey: \"test-api-key\",\n    }),\n    getAllConfigs: vi.fn().mockReturnValue([]),\n    loadFromDatabase: vi.fn().mockResolvedValue(undefined),\n  },\n}));\n\nimport { TimelineService } from \"../../services/TimelineService.js\";\n\ndescribe(\"TimelineService\", () =&gt; {\n  describe(\"getStrftimeFormat\", () =&gt; {\n    it(\"returns correct format for years granularity\", () =&gt; {\n      const service = new TimelineService();\n      expect(service.getStrftimeFormat(\"years\")).toBe(\"%Y\");\n    });\n\n    it(\"returns correct format for months granularity\", () =&gt; {\n      const service = new TimelineService();\n      expect(service.getStrftimeFormat(\"months\")).toBe(\"%Y-%m\");\n    });\n\n    it(\"returns correct format for weeks granularity\", () =&gt; {\n      const service = new TimelineService();\n      expect(service.getStrftimeFormat(\"weeks\")).toBe(\"%Y-W%W\");\n    });\n\n    it(\"returns correct format for days granularity\", () =&gt; {\n      const service = new TimelineService();\n      expect(service.getStrftimeFormat(\"days\")).toBe(\"%Y-%m-%d\");\n    });\n\n    it(\"defaults to months for invalid granularity\", () =&gt; {\n      const service = new TimelineService();\n      expect(service.getStrftimeFormat(\"invalid\" as any)).toBe(\"%Y-%m\");\n    });\n  });\n\n  describe(\"buildDistributionQuery\", () =&gt; {\n    it(\"builds SQL with exclusion JOIN for scenes\", () =&gt; {\n      const service = new TimelineService();\n      const { sql, params } = service.buildDistributionQuery(\"scene\", 1, \"months\");\n\n      expect(sql).toContain(\"SELECT\");\n      expect(sql).toContain(\"strftime('%Y-%m', s.date)\");\n      expect(sql).toContain(\"COUNT(*)\");\n      expect(sql).toContain(\"LEFT JOIN UserExcludedEntity\");\n      expect(sql).toContain(\"e.id IS NULL\");\n      expect(sql).toContain(\"s.date IS NOT NULL\");\n      expect(sql).toContain(\"GROUP BY period\");\n      expect(sql).toContain(\"ORDER BY period ASC\");\n      expect(params).toContain(1); // userId\n    });\n\n    it(\"builds SQL for galleries with correct table\", () =&gt; {\n      const service = new TimelineService();\n      const { sql } = service.buildDistributionQuery(\"gallery\", 1, \"years\");\n\n      expect(sql).toContain(\"FROM StashGallery\");\n      expect(sql).toContain(\"strftime('%Y', g.date)\");\n    });\n\n    it(\"builds SQL for images with correct table\", () =&gt; {\n      const service = new TimelineService();\n      const { sql } = service.buildDistributionQuery(\"image\", 1, \"days\");\n\n      expect(sql).toContain(\"FROM StashImage\");\n      expect(sql).toContain(\"strftime('%Y-%m-%d', i.date)\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test -- tests/services/TimelineService.test.ts</code> Expected: FAIL with \"Cannot find module '../../services/TimelineService.js'\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// server/services/TimelineService.ts\nimport { prisma } from \"../initializers/prisma.js\";\n\nexport type Granularity = \"years\" | \"months\" | \"weeks\" | \"days\";\nexport type TimelineEntityType = \"scene\" | \"gallery\" | \"image\";\n\nexport interface DistributionItem {\n  period: string;\n  count: number;\n}\n\ninterface QueryClause {\n  sql: string;\n  params: (string | number)[];\n}\n\nconst ENTITY_CONFIG: Record&lt;TimelineEntityType, { table: string; alias: string; dateField: string }&gt; = {\n  scene: { table: \"StashScene\", alias: \"s\", dateField: \"s.date\" },\n  gallery: { table: \"StashGallery\", alias: \"g\", dateField: \"g.date\" },\n  image: { table: \"StashImage\", alias: \"i\", dateField: \"i.date\" },\n};\n\nexport class TimelineService {\n  getStrftimeFormat(granularity: Granularity): string {\n    switch (granularity) {\n      case \"years\":\n        return \"%Y\";\n      case \"months\":\n        return \"%Y-%m\";\n      case \"weeks\":\n        return \"%Y-W%W\";\n      case \"days\":\n        return \"%Y-%m-%d\";\n      default:\n        return \"%Y-%m\";\n    }\n  }\n\n  buildDistributionQuery(\n    entityType: TimelineEntityType,\n    userId: number,\n    granularity: Granularity\n  ): QueryClause {\n    const config = ENTITY_CONFIG[entityType];\n    const format = this.getStrftimeFormat(granularity);\n\n    const sql = `\n      SELECT\n        strftime('${format}', ${config.dateField}) as period,\n        COUNT(*) as count\n      FROM ${config.table} ${config.alias}\n      LEFT JOIN UserExcludedEntity e\n        ON e.userId = ? AND e.entityType = '${entityType}' AND e.entityId = ${config.alias}.id\n      WHERE ${config.alias}.deletedAt IS NULL\n        AND e.id IS NULL\n        AND ${config.dateField} IS NOT NULL\n      GROUP BY period\n      ORDER BY period ASC\n    `.trim();\n\n    return { sql, params: [userId] };\n  }\n\n  async getDistribution(\n    entityType: TimelineEntityType,\n    userId: number,\n    granularity: Granularity\n  ): Promise&lt;DistributionItem[]&gt; {\n    const { sql, params } = this.buildDistributionQuery(entityType, userId, granularity);\n\n    const results = await prisma.$queryRawUnsafe&lt;Array&lt;{ period: string; count: bigint }&gt;&gt;(\n      sql,\n      ...params\n    );\n\n    return results.map((row) =&gt; ({\n      period: row.period,\n      count: Number(row.count),\n    }));\n  }\n}\n\nexport const timelineService = new TimelineService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test -- tests/services/TimelineService.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/TimelineService.ts server/tests/services/TimelineService.test.ts\ngit commit -m \"feat(server): add TimelineService for date distribution queries\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-2-backend-timeline-controller-and-route","title":"Task 2: Backend - Timeline Controller and Route","text":"<p>Files: - Create: <code>server/controllers/timelineController.ts</code> - Modify: <code>server/routes/api.ts</code> - Test: <code>server/tests/controllers/timelineController.test.ts</code></p> <p>Step 1: Write the failing test</p> <pre><code>// server/tests/controllers/timelineController.test.ts\nimport { describe, it, expect, vi, beforeEach } from \"vitest\";\n\nvi.mock(\"../../services/StashInstanceManager.js\", () =&gt; ({\n  stashInstanceManager: {\n    getDefaultConfig: vi.fn().mockReturnValue({\n      id: \"test-instance\",\n      name: \"Test Stash\",\n      url: \"http://localhost:9999/graphql\",\n      apiKey: \"test-api-key\",\n    }),\n    getAllConfigs: vi.fn().mockReturnValue([]),\n    loadFromDatabase: vi.fn().mockResolvedValue(undefined),\n  },\n}));\n\nvi.mock(\"../../services/TimelineService.js\", () =&gt; ({\n  timelineService: {\n    getDistribution: vi.fn(),\n  },\n}));\n\nimport { getDateDistribution } from \"../../controllers/timelineController.js\";\nimport { timelineService } from \"../../services/TimelineService.js\";\n\ndescribe(\"timelineController\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"getDateDistribution\", () =&gt; {\n    it(\"returns distribution for valid entity type and granularity\", async () =&gt; {\n      const mockDistribution = [\n        { period: \"2024-01\", count: 47 },\n        { period: \"2024-02\", count: 12 },\n      ];\n      vi.mocked(timelineService.getDistribution).mockResolvedValue(mockDistribution);\n\n      const req = {\n        params: { entityType: \"scene\" },\n        query: { granularity: \"months\" },\n        user: { id: 1 },\n      } as any;\n\n      const res = {\n        json: vi.fn(),\n        status: vi.fn().mockReturnThis(),\n      } as any;\n\n      await getDateDistribution(req, res);\n\n      expect(timelineService.getDistribution).toHaveBeenCalledWith(\"scene\", 1, \"months\");\n      expect(res.json).toHaveBeenCalledWith({ distribution: mockDistribution });\n    });\n\n    it(\"defaults granularity to months if not provided\", async () =&gt; {\n      vi.mocked(timelineService.getDistribution).mockResolvedValue([]);\n\n      const req = {\n        params: { entityType: \"scene\" },\n        query: {},\n        user: { id: 1 },\n      } as any;\n\n      const res = {\n        json: vi.fn(),\n        status: vi.fn().mockReturnThis(),\n      } as any;\n\n      await getDateDistribution(req, res);\n\n      expect(timelineService.getDistribution).toHaveBeenCalledWith(\"scene\", 1, \"months\");\n    });\n\n    it(\"returns 400 for invalid entity type\", async () =&gt; {\n      const req = {\n        params: { entityType: \"invalid\" },\n        query: { granularity: \"months\" },\n        user: { id: 1 },\n      } as any;\n\n      const res = {\n        json: vi.fn(),\n        status: vi.fn().mockReturnThis(),\n      } as any;\n\n      await getDateDistribution(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(400);\n      expect(res.json).toHaveBeenCalledWith({ error: \"Invalid entity type\" });\n    });\n\n    it(\"returns 400 for invalid granularity\", async () =&gt; {\n      const req = {\n        params: { entityType: \"scene\" },\n        query: { granularity: \"invalid\" },\n        user: { id: 1 },\n      } as any;\n\n      const res = {\n        json: vi.fn(),\n        status: vi.fn().mockReturnThis(),\n      } as any;\n\n      await getDateDistribution(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(400);\n      expect(res.json).toHaveBeenCalledWith({ error: \"Invalid granularity\" });\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test -- tests/controllers/timelineController.test.ts</code> Expected: FAIL with \"Cannot find module '../../controllers/timelineController.js'\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// server/controllers/timelineController.ts\nimport type { Response } from \"express\";\nimport type { AuthenticatedRequest } from \"../middleware/auth.js\";\nimport { timelineService, type Granularity, type TimelineEntityType } from \"../services/TimelineService.js\";\n\nconst VALID_ENTITY_TYPES: TimelineEntityType[] = [\"scene\", \"gallery\", \"image\"];\nconst VALID_GRANULARITIES: Granularity[] = [\"years\", \"months\", \"weeks\", \"days\"];\n\nexport async function getDateDistribution(\n  req: AuthenticatedRequest,\n  res: Response\n): Promise&lt;void&gt; {\n  const { entityType } = req.params;\n  const granularity = (req.query.granularity as string) || \"months\";\n  const userId = req.user!.id;\n\n  if (!VALID_ENTITY_TYPES.includes(entityType as TimelineEntityType)) {\n    res.status(400).json({ error: \"Invalid entity type\" });\n    return;\n  }\n\n  if (!VALID_GRANULARITIES.includes(granularity as Granularity)) {\n    res.status(400).json({ error: \"Invalid granularity\" });\n    return;\n  }\n\n  try {\n    const distribution = await timelineService.getDistribution(\n      entityType as TimelineEntityType,\n      userId,\n      granularity as Granularity\n    );\n    res.json({ distribution });\n  } catch (error) {\n    console.error(\"Error fetching date distribution:\", error);\n    res.status(500).json({ error: \"Failed to fetch date distribution\" });\n  }\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test -- tests/controllers/timelineController.test.ts</code> Expected: PASS</p> <p>Step 5: Add route to api.ts</p> <p>Locate the routes section in <code>server/routes/api.ts</code> and add:</p> <pre><code>// In imports section:\nimport { getDateDistribution } from \"../controllers/timelineController.js\";\n\n// In routes section (near other library routes):\nrouter.get(\"/timeline/:entityType/distribution\", authenticated(getDateDistribution));\n</code></pre> <p>Step 6: Run all server tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/timelineController.ts server/tests/controllers/timelineController.test.ts server/routes/api.ts\ngit commit -m \"feat(server): add timeline distribution endpoint\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-3-frontend-usetimelinestate-hook","title":"Task 3: Frontend - useTimelineState Hook","text":"<p>Files: - Create: <code>client/src/components/timeline/useTimelineState.js</code> - Test: <code>client/tests/hooks/useTimelineState.test.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/hooks/useTimelineState.test.jsx\nimport { renderHook, waitFor, act } from \"@testing-library/react\";\nimport { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { useTimelineState } from \"../../src/components/timeline/useTimelineState.js\";\n\nvi.mock(\"../../src/services/api.js\", () =&gt; ({\n  apiGet: vi.fn(),\n}));\n\nimport { apiGet } from \"../../src/services/api.js\";\n\ndescribe(\"useTimelineState\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"initialization\", () =&gt; {\n    it(\"initializes with default zoom level of months\", () =&gt; {\n      apiGet.mockResolvedValue({ distribution: [] });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      expect(result.current.zoomLevel).toBe(\"months\");\n    });\n\n    it(\"initializes with no selected period\", () =&gt; {\n      apiGet.mockResolvedValue({ distribution: [] });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      expect(result.current.selectedPeriod).toBeNull();\n    });\n\n    it(\"fetches distribution on mount\", async () =&gt; {\n      const mockDistribution = [\n        { period: \"2024-01\", count: 47 },\n        { period: \"2024-02\", count: 12 },\n      ];\n      apiGet.mockResolvedValue({ distribution: mockDistribution });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.distribution).toEqual(mockDistribution);\n      });\n\n      expect(apiGet).toHaveBeenCalledWith(\"/timeline/scene/distribution?granularity=months\");\n    });\n  });\n\n  describe(\"zoom level changes\", () =&gt; {\n    it(\"updates zoom level and refetches distribution\", async () =&gt; {\n      apiGet.mockResolvedValue({ distribution: [] });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      act(() =&gt; {\n        result.current.setZoomLevel(\"years\");\n      });\n\n      expect(result.current.zoomLevel).toBe(\"years\");\n\n      await waitFor(() =&gt; {\n        expect(apiGet).toHaveBeenCalledWith(\"/timeline/scene/distribution?granularity=years\");\n      });\n    });\n  });\n\n  describe(\"period selection\", () =&gt; {\n    it(\"selects a period and calculates date range\", async () =&gt; {\n      apiGet.mockResolvedValue({ distribution: [{ period: \"2024-03\", count: 47 }] });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      act(() =&gt; {\n        result.current.selectPeriod(\"2024-03\");\n      });\n\n      expect(result.current.selectedPeriod).toEqual({\n        period: \"2024-03\",\n        start: \"2024-03-01\",\n        end: \"2024-03-31\",\n        label: \"March 2024\",\n      });\n    });\n\n    it(\"clears selection when selecting same period\", async () =&gt; {\n      apiGet.mockResolvedValue({ distribution: [{ period: \"2024-03\", count: 47 }] });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\" })\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.isLoading).toBe(false);\n      });\n\n      act(() =&gt; {\n        result.current.selectPeriod(\"2024-03\");\n      });\n\n      act(() =&gt; {\n        result.current.selectPeriod(\"2024-03\");\n      });\n\n      expect(result.current.selectedPeriod).toBeNull();\n    });\n  });\n\n  describe(\"auto-select most recent\", () =&gt; {\n    it(\"auto-selects most recent period when autoSelectRecent is true\", async () =&gt; {\n      const mockDistribution = [\n        { period: \"2024-01\", count: 10 },\n        { period: \"2024-03\", count: 47 },\n      ];\n      apiGet.mockResolvedValue({ distribution: mockDistribution });\n\n      const { result } = renderHook(() =&gt;\n        useTimelineState({ entityType: \"scene\", autoSelectRecent: true })\n      );\n\n      await waitFor(() =&gt; {\n        expect(result.current.selectedPeriod).not.toBeNull();\n      });\n\n      expect(result.current.selectedPeriod?.period).toBe(\"2024-03\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/hooks/useTimelineState.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/components/timeline/useTimelineState.js\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\nimport { apiGet } from \"../../services/api.js\";\nimport {\n  startOfYear,\n  endOfYear,\n  startOfMonth,\n  endOfMonth,\n  startOfWeek,\n  endOfWeek,\n  startOfDay,\n  endOfDay,\n  format,\n  parse,\n} from \"date-fns\";\n\nconst ZOOM_LEVELS = [\"years\", \"months\", \"weeks\", \"days\"];\n\nfunction parsePeriodToDateRange(period, zoomLevel) {\n  let start, end, label;\n\n  switch (zoomLevel) {\n    case \"years\": {\n      const date = parse(period, \"yyyy\", new Date());\n      start = format(startOfYear(date), \"yyyy-MM-dd\");\n      end = format(endOfYear(date), \"yyyy-MM-dd\");\n      label = period;\n      break;\n    }\n    case \"months\": {\n      const date = parse(period, \"yyyy-MM\", new Date());\n      start = format(startOfMonth(date), \"yyyy-MM-dd\");\n      end = format(endOfMonth(date), \"yyyy-MM-dd\");\n      label = format(date, \"MMMM yyyy\");\n      break;\n    }\n    case \"weeks\": {\n      // Format: \"2024-W12\"\n      const [year, weekStr] = period.split(\"-W\");\n      const date = parse(`${year}-W${weekStr}-1`, \"RRRR-'W'II-i\", new Date());\n      start = format(startOfWeek(date, { weekStartsOn: 1 }), \"yyyy-MM-dd\");\n      end = format(endOfWeek(date, { weekStartsOn: 1 }), \"yyyy-MM-dd\");\n      label = `Week ${weekStr}, ${year}`;\n      break;\n    }\n    case \"days\": {\n      const date = parse(period, \"yyyy-MM-dd\", new Date());\n      start = format(startOfDay(date), \"yyyy-MM-dd\");\n      end = format(endOfDay(date), \"yyyy-MM-dd\");\n      label = format(date, \"MMMM d, yyyy\");\n      break;\n    }\n    default:\n      return null;\n  }\n\n  return { period, start, end, label };\n}\n\nexport function useTimelineState({ entityType, autoSelectRecent = false }) {\n  const [zoomLevel, setZoomLevel] = useState(\"months\");\n  const [selectedPeriod, setSelectedPeriod] = useState(null);\n  const [distribution, setDistribution] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Fetch distribution when entityType or zoomLevel changes\n  useEffect(() =&gt; {\n    let cancelled = false;\n\n    async function fetchDistribution() {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const response = await apiGet(\n          `/timeline/${entityType}/distribution?granularity=${zoomLevel}`\n        );\n\n        if (!cancelled) {\n          setDistribution(response.distribution || []);\n\n          // Auto-select most recent period if enabled and no selection\n          if (autoSelectRecent &amp;&amp; response.distribution?.length &gt; 0) {\n            const mostRecent = response.distribution[response.distribution.length - 1];\n            setSelectedPeriod(parsePeriodToDateRange(mostRecent.period, zoomLevel));\n          }\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err.message || \"Failed to fetch distribution\");\n          setDistribution([]);\n        }\n      } finally {\n        if (!cancelled) {\n          setIsLoading(false);\n        }\n      }\n    }\n\n    fetchDistribution();\n\n    return () =&gt; {\n      cancelled = true;\n    };\n  }, [entityType, zoomLevel, autoSelectRecent]);\n\n  const selectPeriod = useCallback(\n    (period) =&gt; {\n      if (selectedPeriod?.period === period) {\n        setSelectedPeriod(null);\n      } else {\n        setSelectedPeriod(parsePeriodToDateRange(period, zoomLevel));\n      }\n    },\n    [selectedPeriod, zoomLevel]\n  );\n\n  const clearSelection = useCallback(() =&gt; {\n    setSelectedPeriod(null);\n  }, []);\n\n  // Calculate max count for bar height scaling\n  const maxCount = useMemo(() =&gt; {\n    if (distribution.length === 0) return 0;\n    return Math.max(...distribution.map((d) =&gt; d.count));\n  }, [distribution]);\n\n  return {\n    zoomLevel,\n    setZoomLevel,\n    selectedPeriod,\n    selectPeriod,\n    clearSelection,\n    distribution,\n    maxCount,\n    isLoading,\n    error,\n    ZOOM_LEVELS,\n  };\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/hooks/useTimelineState.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/useTimelineState.js client/tests/hooks/useTimelineState.test.jsx\ngit commit -m \"feat(client): add useTimelineState hook for timeline state management\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-4-frontend-timelinecontrols-component","title":"Task 4: Frontend - TimelineControls Component","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineControls.jsx</code> - Test: <code>client/tests/components/timeline/TimelineControls.test.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/components/timeline/TimelineControls.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { createElement } from \"react\";\nimport TimelineControls from \"../../../src/components/timeline/TimelineControls.jsx\";\n\ndescribe(\"TimelineControls\", () =&gt; {\n  const defaultProps = {\n    zoomLevel: \"months\",\n    onZoomLevelChange: vi.fn(),\n    zoomLevels: [\"years\", \"months\", \"weeks\", \"days\"],\n  };\n\n  it(\"renders all zoom level buttons\", () =&gt; {\n    const element = createElement(TimelineControls, defaultProps);\n\n    expect(element).toBeDefined();\n    expect(element.props.zoomLevel).toBe(\"months\");\n    expect(element.props.zoomLevels).toHaveLength(4);\n  });\n\n  it(\"accepts onZoomLevelChange callback\", () =&gt; {\n    const onZoomLevelChange = vi.fn();\n    const element = createElement(TimelineControls, {\n      ...defaultProps,\n      onZoomLevelChange,\n    });\n\n    expect(element.props.onZoomLevelChange).toBe(onZoomLevelChange);\n  });\n\n  it(\"accepts custom className\", () =&gt; {\n    const element = createElement(TimelineControls, {\n      ...defaultProps,\n      className: \"custom-class\",\n    });\n\n    expect(element.props.className).toBe(\"custom-class\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineControls.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/components/timeline/TimelineControls.jsx\nimport { memo } from \"react\";\n\nconst ZOOM_LABELS = {\n  years: \"Years\",\n  months: \"Months\",\n  weeks: \"Weeks\",\n  days: \"Days\",\n};\n\nfunction TimelineControls({\n  zoomLevel,\n  onZoomLevelChange,\n  zoomLevels = [\"years\", \"months\", \"weeks\", \"days\"],\n  className = \"\",\n}) {\n  return (\n    &lt;div\n      className={`inline-flex rounded-md bg-bg-secondary ${className}`}\n      role=\"group\"\n      aria-label=\"Timeline zoom level\"\n    &gt;\n      {zoomLevels.map((level) =&gt; (\n        &lt;button\n          key={level}\n          type=\"button\"\n          onClick={() =&gt; onZoomLevelChange(level)}\n          className={`\n            px-3 py-1.5 text-sm font-medium transition-colors\n            first:rounded-l-md last:rounded-r-md\n            focus:outline-none focus:ring-2 focus:ring-accent-primary focus:ring-inset\n            ${\n              zoomLevel === level\n                ? \"bg-accent-primary text-white\"\n                : \"text-text-secondary hover:text-text-primary hover:bg-bg-tertiary\"\n            }\n          `}\n          aria-pressed={zoomLevel === level}\n        &gt;\n          {ZOOM_LABELS[level] || level}\n        &lt;/button&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nexport default memo(TimelineControls);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineControls.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/TimelineControls.jsx client/tests/components/timeline/TimelineControls.test.jsx\ngit commit -m \"feat(client): add TimelineControls zoom level toggle component\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-5-frontend-timelinebar-component","title":"Task 5: Frontend - TimelineBar Component","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineBar.jsx</code> - Test: <code>client/tests/components/timeline/TimelineBar.test.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/components/timeline/TimelineBar.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { createElement } from \"react\";\nimport TimelineBar from \"../../../src/components/timeline/TimelineBar.jsx\";\n\ndescribe(\"TimelineBar\", () =&gt; {\n  const defaultProps = {\n    period: \"2024-03\",\n    count: 47,\n    maxCount: 100,\n    isSelected: false,\n    isFocused: false,\n    onClick: vi.fn(),\n    label: \"March 2024\",\n  };\n\n  it(\"renders with correct period and count\", () =&gt; {\n    const element = createElement(TimelineBar, defaultProps);\n\n    expect(element).toBeDefined();\n    expect(element.props.period).toBe(\"2024-03\");\n    expect(element.props.count).toBe(47);\n  });\n\n  it(\"calculates height percentage from count and maxCount\", () =&gt; {\n    const element = createElement(TimelineBar, {\n      ...defaultProps,\n      count: 50,\n      maxCount: 100,\n    });\n\n    // Height should be 50% of max\n    expect(element.props.count / element.props.maxCount).toBe(0.5);\n  });\n\n  it(\"accepts isSelected prop for highlight styling\", () =&gt; {\n    const element = createElement(TimelineBar, {\n      ...defaultProps,\n      isSelected: true,\n    });\n\n    expect(element.props.isSelected).toBe(true);\n  });\n\n  it(\"accepts isFocused prop for keyboard navigation\", () =&gt; {\n    const element = createElement(TimelineBar, {\n      ...defaultProps,\n      isFocused: true,\n    });\n\n    expect(element.props.isFocused).toBe(true);\n  });\n\n  it(\"accepts onClick callback\", () =&gt; {\n    const onClick = vi.fn();\n    const element = createElement(TimelineBar, {\n      ...defaultProps,\n      onClick,\n    });\n\n    expect(element.props.onClick).toBe(onClick);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineBar.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/components/timeline/TimelineBar.jsx\nimport { memo, useState } from \"react\";\n\nconst MIN_BAR_HEIGHT = 4; // Minimum visible height in pixels\nconst MAX_BAR_HEIGHT = 60; // Maximum bar height in pixels\n\nfunction TimelineBar({\n  period,\n  count,\n  maxCount,\n  isSelected,\n  isFocused,\n  onClick,\n  label,\n  onKeyDown,\n  tabIndex = -1,\n}) {\n  const [showTooltip, setShowTooltip] = useState(false);\n\n  // Calculate bar height as percentage of max, with minimum visibility\n  const heightPercent = maxCount &gt; 0 ? (count / maxCount) * 100 : 0;\n  const barHeight = Math.max(\n    MIN_BAR_HEIGHT,\n    (heightPercent / 100) * MAX_BAR_HEIGHT\n  );\n\n  return (\n    &lt;div\n      className=\"relative flex flex-col items-center cursor-pointer group\"\n      onClick={() =&gt; onClick(period)}\n      onKeyDown={onKeyDown}\n      onMouseEnter={() =&gt; setShowTooltip(true)}\n      onMouseLeave={() =&gt; setShowTooltip(false)}\n      role=\"option\"\n      aria-selected={isSelected}\n      aria-label={`${label}: ${count} items`}\n      tabIndex={tabIndex}\n    &gt;\n      {/* Tooltip */}\n      {showTooltip &amp;&amp; (\n        &lt;div\n          className=\"absolute bottom-full mb-2 px-2 py-1 text-xs font-medium\n            bg-bg-primary text-text-primary rounded shadow-lg border border-border-primary\n            whitespace-nowrap z-10 pointer-events-none\"\n        &gt;\n          {count} {count === 1 ? \"item\" : \"items\"}\n        &lt;/div&gt;\n      )}\n\n      {/* Bar */}\n      &lt;div\n        className={`\n          w-3 rounded-t transition-all duration-150\n          ${isSelected ? \"bg-accent-primary\" : \"bg-accent-secondary group-hover:bg-accent-primary/70\"}\n          ${isFocused ? \"ring-2 ring-accent-primary ring-offset-1 ring-offset-bg-primary\" : \"\"}\n        `}\n        style={{ height: `${barHeight}px` }}\n      /&gt;\n\n      {/* Selection indicator */}\n      {isSelected &amp;&amp; (\n        &lt;div className=\"absolute -bottom-1 w-0 h-0 border-l-4 border-r-4 border-t-4\n          border-l-transparent border-r-transparent border-t-accent-primary\" /&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n\nexport default memo(TimelineBar);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineBar.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/TimelineBar.jsx client/tests/components/timeline/TimelineBar.test.jsx\ngit commit -m \"feat(client): add TimelineBar density bar component\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-6-frontend-timelinestrip-component","title":"Task 6: Frontend - TimelineStrip Component","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineStrip.jsx</code> - Test: <code>client/tests/components/timeline/TimelineStrip.test.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/components/timeline/TimelineStrip.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { createElement } from \"react\";\nimport TimelineStrip from \"../../../src/components/timeline/TimelineStrip.jsx\";\n\ndescribe(\"TimelineStrip\", () =&gt; {\n  const mockDistribution = [\n    { period: \"2024-01\", count: 47 },\n    { period: \"2024-02\", count: 12 },\n    { period: \"2024-03\", count: 85 },\n  ];\n\n  const defaultProps = {\n    distribution: mockDistribution,\n    maxCount: 85,\n    zoomLevel: \"months\",\n    selectedPeriod: null,\n    onSelectPeriod: vi.fn(),\n  };\n\n  it(\"renders distribution data as TimelineBar components\", () =&gt; {\n    const element = createElement(TimelineStrip, defaultProps);\n\n    expect(element).toBeDefined();\n    expect(element.props.distribution).toHaveLength(3);\n  });\n\n  it(\"passes maxCount to calculate bar heights\", () =&gt; {\n    const element = createElement(TimelineStrip, defaultProps);\n\n    expect(element.props.maxCount).toBe(85);\n  });\n\n  it(\"highlights selected period\", () =&gt; {\n    const element = createElement(TimelineStrip, {\n      ...defaultProps,\n      selectedPeriod: { period: \"2024-02\", start: \"2024-02-01\", end: \"2024-02-29\", label: \"February 2024\" },\n    });\n\n    expect(element.props.selectedPeriod.period).toBe(\"2024-02\");\n  });\n\n  it(\"accepts onSelectPeriod callback\", () =&gt; {\n    const onSelectPeriod = vi.fn();\n    const element = createElement(TimelineStrip, {\n      ...defaultProps,\n      onSelectPeriod,\n    });\n\n    expect(element.props.onSelectPeriod).toBe(onSelectPeriod);\n  });\n\n  it(\"renders empty state when no distribution\", () =&gt; {\n    const element = createElement(TimelineStrip, {\n      ...defaultProps,\n      distribution: [],\n      maxCount: 0,\n    });\n\n    expect(element.props.distribution).toHaveLength(0);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineStrip.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/components/timeline/TimelineStrip.jsx\nimport { memo, useRef, useState, useCallback, useEffect } from \"react\";\nimport TimelineBar from \"./TimelineBar.jsx\";\nimport { format, parse } from \"date-fns\";\n\nconst PERIOD_LABELS = {\n  years: (period) =&gt; period,\n  months: (period) =&gt; {\n    const date = parse(period, \"yyyy-MM\", new Date());\n    return format(date, \"MMM yyyy\");\n  },\n  weeks: (period) =&gt; {\n    const [year, week] = period.split(\"-W\");\n    return `W${week}`;\n  },\n  days: (period) =&gt; {\n    const date = parse(period, \"yyyy-MM-dd\", new Date());\n    return format(date, \"MMM d\");\n  },\n};\n\nfunction TimelineStrip({\n  distribution,\n  maxCount,\n  zoomLevel,\n  selectedPeriod,\n  onSelectPeriod,\n  onKeyboardNavigate,\n  className = \"\",\n}) {\n  const containerRef = useRef(null);\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n\n  const getLabel = useCallback(\n    (period) =&gt; {\n      const labelFn = PERIOD_LABELS[zoomLevel] || PERIOD_LABELS.months;\n      return labelFn(period);\n    },\n    [zoomLevel]\n  );\n\n  // Keyboard navigation\n  const handleKeyDown = useCallback(\n    (e) =&gt; {\n      if (distribution.length === 0) return;\n\n      switch (e.key) {\n        case \"ArrowLeft\":\n          e.preventDefault();\n          setFocusedIndex((prev) =&gt;\n            prev &lt;= 0 ? distribution.length - 1 : prev - 1\n          );\n          break;\n        case \"ArrowRight\":\n          e.preventDefault();\n          setFocusedIndex((prev) =&gt;\n            prev &gt;= distribution.length - 1 ? 0 : prev + 1\n          );\n          break;\n        case \"Home\":\n          e.preventDefault();\n          setFocusedIndex(0);\n          break;\n        case \"End\":\n          e.preventDefault();\n          setFocusedIndex(distribution.length - 1);\n          break;\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          if (focusedIndex &gt;= 0 &amp;&amp; focusedIndex &lt; distribution.length) {\n            onSelectPeriod(distribution[focusedIndex].period);\n          }\n          break;\n        default:\n          if (onKeyboardNavigate) {\n            onKeyboardNavigate(e);\n          }\n      }\n    },\n    [distribution, focusedIndex, onSelectPeriod, onKeyboardNavigate]\n  );\n\n  // Scroll focused bar into view\n  useEffect(() =&gt; {\n    if (focusedIndex &gt;= 0 &amp;&amp; containerRef.current) {\n      const bars = containerRef.current.querySelectorAll('[role=\"option\"]');\n      if (bars[focusedIndex]) {\n        bars[focusedIndex].scrollIntoView({\n          behavior: \"smooth\",\n          block: \"nearest\",\n          inline: \"center\",\n        });\n      }\n    }\n  }, [focusedIndex]);\n\n  if (distribution.length === 0) {\n    return (\n      &lt;div className={`flex items-center justify-center h-20 text-text-secondary ${className}`}&gt;\n        No dated content available\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div\n      ref={containerRef}\n      className={`\n        relative flex items-end gap-1 overflow-x-auto pb-6 pt-2 px-4\n        scrollbar-thin scrollbar-thumb-border-primary scrollbar-track-transparent\n        ${className}\n      `}\n      role=\"listbox\"\n      aria-label=\"Timeline\"\n      tabIndex={0}\n      onKeyDown={handleKeyDown}\n      onFocus={() =&gt; {\n        if (focusedIndex === -1 &amp;&amp; distribution.length &gt; 0) {\n          // Focus on selected period or last (most recent)\n          const selectedIndex = distribution.findIndex(\n            (d) =&gt; d.period === selectedPeriod?.period\n          );\n          setFocusedIndex(selectedIndex &gt;= 0 ? selectedIndex : distribution.length - 1);\n        }\n      }}\n    &gt;\n      {/* Baseline */}\n      &lt;div className=\"absolute bottom-6 left-4 right-4 h-px bg-border-primary\" /&gt;\n\n      {distribution.map((item, index) =&gt; (\n        &lt;div key={item.period} className=\"flex flex-col items-center min-w-[40px]\"&gt;\n          &lt;TimelineBar\n            period={item.period}\n            count={item.count}\n            maxCount={maxCount}\n            isSelected={selectedPeriod?.period === item.period}\n            isFocused={focusedIndex === index}\n            onClick={onSelectPeriod}\n            label={getLabel(item.period)}\n            tabIndex={-1}\n          /&gt;\n          {/* Period label */}\n          &lt;span\n            className={`\n              mt-1 text-xs whitespace-nowrap\n              ${selectedPeriod?.period === item.period ? \"text-accent-primary font-medium\" : \"text-text-secondary\"}\n            `}\n          &gt;\n            {getLabel(item.period)}\n          &lt;/span&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nexport default memo(TimelineStrip);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineStrip.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/TimelineStrip.jsx client/tests/components/timeline/TimelineStrip.test.jsx\ngit commit -m \"feat(client): add TimelineStrip scrollable timeline component\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-7-frontend-timelineview-main-component","title":"Task 7: Frontend - TimelineView Main Component","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineView.jsx</code> - Test: <code>client/tests/components/timeline/TimelineView.test.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/components/timeline/TimelineView.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { createElement } from \"react\";\nimport TimelineView from \"../../../src/components/timeline/TimelineView.jsx\";\n\nvi.mock(\"../../../src/services/api.js\", () =&gt; ({\n  apiGet: vi.fn().mockResolvedValue({ distribution: [] }),\n}));\n\ndescribe(\"TimelineView\", () =&gt; {\n  const defaultProps = {\n    entityType: \"scene\",\n    items: [],\n    renderItem: vi.fn(),\n    onItemClick: vi.fn(),\n  };\n\n  it(\"renders with entityType prop\", () =&gt; {\n    const element = createElement(TimelineView, defaultProps);\n\n    expect(element).toBeDefined();\n    expect(element.props.entityType).toBe(\"scene\");\n  });\n\n  it(\"accepts items array for results grid\", () =&gt; {\n    const items = [{ id: \"1\" }, { id: \"2\" }];\n    const element = createElement(TimelineView, {\n      ...defaultProps,\n      items,\n    });\n\n    expect(element.props.items).toHaveLength(2);\n  });\n\n  it(\"accepts renderItem function for custom card rendering\", () =&gt; {\n    const renderItem = vi.fn();\n    const element = createElement(TimelineView, {\n      ...defaultProps,\n      renderItem,\n    });\n\n    expect(element.props.renderItem).toBe(renderItem);\n  });\n\n  it(\"accepts loading state prop\", () =&gt; {\n    const element = createElement(TimelineView, {\n      ...defaultProps,\n      loading: true,\n    });\n\n    expect(element.props.loading).toBe(true);\n  });\n\n  it(\"accepts emptyMessage prop\", () =&gt; {\n    const element = createElement(TimelineView, {\n      ...defaultProps,\n      emptyMessage: \"No scenes found\",\n    });\n\n    expect(element.props.emptyMessage).toBe(\"No scenes found\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineView.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 3: Write minimal implementation</p> <pre><code>// client/src/components/timeline/TimelineView.jsx\nimport { memo, useMemo } from \"react\";\nimport TimelineControls from \"./TimelineControls.jsx\";\nimport TimelineStrip from \"./TimelineStrip.jsx\";\nimport { useTimelineState } from \"./useTimelineState.js\";\nimport { getGridClasses } from \"../../constants/grids.js\";\nimport Spinner from \"../ui/Spinner.jsx\";\n\nfunction TimelineView({\n  entityType,\n  items = [],\n  renderItem,\n  onItemClick,\n  loading = false,\n  emptyMessage = \"No items found\",\n  gridDensity = \"medium\",\n  className = \"\",\n}) {\n  const {\n    zoomLevel,\n    setZoomLevel,\n    selectedPeriod,\n    selectPeriod,\n    distribution,\n    maxCount,\n    isLoading: distributionLoading,\n    ZOOM_LEVELS,\n  } = useTimelineState({ entityType, autoSelectRecent: true });\n\n  // Build date filter from selected period\n  const dateFilter = useMemo(() =&gt; {\n    if (!selectedPeriod) return null;\n    return {\n      date: {\n        value: selectedPeriod.start,\n        value2: selectedPeriod.end,\n        modifier: \"BETWEEN\",\n      },\n    };\n  }, [selectedPeriod]);\n\n  const gridClasses = getGridClasses(\"standard\", gridDensity);\n\n  const isLoading = loading || distributionLoading;\n\n  return (\n    &lt;div className={`flex flex-col h-full ${className}`}&gt;\n      {/* Timeline Header - Fixed */}\n      &lt;div className=\"flex-shrink-0 border-b border-border-primary bg-bg-primary sticky top-0 z-10\"&gt;\n        {/* Controls Row */}\n        &lt;div className=\"flex items-center justify-between px-4 py-2\"&gt;\n          &lt;TimelineControls\n            zoomLevel={zoomLevel}\n            onZoomLevelChange={setZoomLevel}\n            zoomLevels={ZOOM_LEVELS}\n          /&gt;\n          {selectedPeriod &amp;&amp; (\n            &lt;div className=\"text-sm text-text-secondary\"&gt;\n              &lt;span className=\"font-medium text-text-primary\"&gt;{selectedPeriod.label}&lt;/span&gt;\n              {items.length &gt; 0 &amp;&amp; (\n                &lt;span className=\"ml-2\"&gt;({items.length} items)&lt;/span&gt;\n              )}\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n\n        {/* Timeline Strip */}\n        &lt;TimelineStrip\n          distribution={distribution}\n          maxCount={maxCount}\n          zoomLevel={zoomLevel}\n          selectedPeriod={selectedPeriod}\n          onSelectPeriod={selectPeriod}\n        /&gt;\n      &lt;/div&gt;\n\n      {/* Results Grid - Scrollable */}\n      &lt;div className=\"flex-1 overflow-y-auto p-4\"&gt;\n        {isLoading ? (\n          &lt;div className=\"flex items-center justify-center h-32\"&gt;\n            &lt;Spinner className=\"text-accent-primary\" /&gt;\n          &lt;/div&gt;\n        ) : !selectedPeriod ? (\n          &lt;div className=\"flex items-center justify-center h-32 text-text-secondary\"&gt;\n            Select a time period on the timeline above\n          &lt;/div&gt;\n        ) : items.length === 0 ? (\n          &lt;div className=\"flex items-center justify-center h-32 text-text-secondary\"&gt;\n            {emptyMessage}\n          &lt;/div&gt;\n        ) : (\n          &lt;div className={gridClasses}&gt;\n            {items.map((item, index) =&gt;\n              renderItem(item, index, { onItemClick, dateFilter })\n            )}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default memo(TimelineView);\n\n// Export dateFilter for parent components to use\nexport { TimelineView };\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineView.test.jsx</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/TimelineView.jsx client/tests/components/timeline/TimelineView.test.jsx\ngit commit -m \"feat(client): add TimelineView main container component\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-8-frontend-add-timeline-to-entity-display-config","title":"Task 8: Frontend - Add Timeline to Entity Display Config","text":"<p>Files: - Modify: <code>client/src/config/entityDisplayConfig.js</code> - Test: <code>client/tests/config/entityDisplayConfig.test.js</code> (create if doesn't exist)</p> <p>Step 1: Write the failing test</p> <pre><code>// client/tests/config/entityDisplayConfig.test.js\nimport { describe, it, expect } from \"vitest\";\nimport { ENTITY_DISPLAY_CONFIG, getViewModes } from \"../../src/config/entityDisplayConfig.js\";\n\ndescribe(\"entityDisplayConfig\", () =&gt; {\n  describe(\"timeline view mode\", () =&gt; {\n    it(\"scene entity includes timeline view mode\", () =&gt; {\n      const sceneModes = getViewModes(\"scene\");\n      const timelineMode = sceneModes.find((m) =&gt; m.id === \"timeline\");\n\n      expect(timelineMode).toBeDefined();\n      expect(timelineMode.label).toBe(\"Timeline\");\n    });\n\n    it(\"gallery entity includes timeline view mode\", () =&gt; {\n      const galleryModes = getViewModes(\"gallery\");\n      const timelineMode = galleryModes.find((m) =&gt; m.id === \"timeline\");\n\n      expect(timelineMode).toBeDefined();\n      expect(timelineMode.label).toBe(\"Timeline\");\n    });\n\n    it(\"image entity includes timeline view mode\", () =&gt; {\n      const imageModes = getViewModes(\"image\");\n      const timelineMode = imageModes.find((m) =&gt; m.id === \"timeline\");\n\n      expect(timelineMode).toBeDefined();\n      expect(timelineMode.label).toBe(\"Timeline\");\n    });\n\n    it(\"performer entity does NOT include timeline view mode\", () =&gt; {\n      const performerModes = getViewModes(\"performer\");\n      const timelineMode = performerModes.find((m) =&gt; m.id === \"timeline\");\n\n      expect(timelineMode).toBeUndefined();\n    });\n\n    it(\"tag entity does NOT include timeline view mode\", () =&gt; {\n      const tagModes = getViewModes(\"tag\");\n      const timelineMode = tagModes.find((m) =&gt; m.id === \"timeline\");\n\n      expect(timelineMode).toBeUndefined();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/config/entityDisplayConfig.test.js</code> Expected: FAIL with timeline mode not found</p> <p>Step 3: Modify entityDisplayConfig.js</p> <p>Read the file first, then add timeline to scene, gallery, and image viewModes arrays:</p> <pre><code>// In scene config viewModes array, add:\n{ id: \"timeline\", label: \"Timeline\" },\n\n// In gallery config viewModes array, add:\n{ id: \"timeline\", label: \"Timeline\" },\n\n// In image config viewModes array, add:\n{ id: \"timeline\", label: \"Timeline\" },\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/config/entityDisplayConfig.test.js</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/config/entityDisplayConfig.js client/tests/config/entityDisplayConfig.test.js\ngit commit -m \"feat(client): add timeline view mode to scene, gallery, image entities\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-9-frontend-add-timeline-icon-to-viewmodetoggle","title":"Task 9: Frontend - Add Timeline Icon to ViewModeToggle","text":"<p>Files: - Modify: <code>client/src/components/ui/ViewModeToggle.jsx</code></p> <p>Step 1: Read current ViewModeToggle implementation</p> <p>Read <code>client/src/components/ui/ViewModeToggle.jsx</code> to understand MODE_ICONS structure.</p> <p>Step 2: Add timeline icon</p> <p>Add to MODE_ICONS object:</p> <pre><code>import { Calendar as LucideCalendar } from \"lucide-react\";\n\n// In MODE_ICONS:\ntimeline: LucideCalendar,\n</code></pre> <p>Step 3: Run existing ViewModeToggle tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/ui/ViewModeToggle.test.jsx</code> Expected: PASS (no breaking changes)</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/ViewModeToggle.jsx\ngit commit -m \"feat(client): add timeline icon to ViewModeToggle\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-10-frontend-integrate-timeline-into-scenesearch","title":"Task 10: Frontend - Integrate Timeline into SceneSearch","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Read current SceneSearch implementation</p> <p>Read <code>client/src/components/scene-search/SceneSearch.jsx</code> to understand view mode switching pattern.</p> <p>Step 2: Add TimelineView import and rendering</p> <pre><code>// Add import at top:\nimport TimelineView from \"../timeline/TimelineView.jsx\";\n\n// In VIEW_MODES array, add:\n{ id: \"timeline\", label: \"Timeline view\" },\n\n// In the render function children, add timeline case:\nviewMode === \"timeline\" ? (\n  &lt;TimelineView\n    entityType=\"scene\"\n    items={currentScenes}\n    renderItem={(scene, index, { onItemClick }) =&gt; (\n      &lt;SceneCard\n        key={scene.id}\n        scene={scene}\n        onClick={() =&gt; onItemClick?.(scene)}\n        tabIndex={0}\n      /&gt;\n    )}\n    onItemClick={handleSceneClick}\n    loading={isLoading}\n    emptyMessage=\"No scenes found for this time period\"\n    gridDensity={gridDensity}\n  /&gt;\n) : viewMode === \"table\" ? (\n  // existing table code...\n)\n</code></pre> <p>Step 3: Run all client tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"feat(client): integrate TimelineView into SceneSearch\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-11-frontend-integrate-timeline-into-gallerysearch","title":"Task 11: Frontend - Integrate Timeline into GallerySearch","text":"<p>Files: - Modify: <code>client/src/components/gallery-search/GallerySearch.jsx</code></p> <p>Step 1: Read current GallerySearch implementation</p> <p>Read <code>client/src/components/gallery-search/GallerySearch.jsx</code>.</p> <p>Step 2: Add TimelineView import and rendering</p> <p>Follow same pattern as SceneSearch:</p> <pre><code>// Add import:\nimport TimelineView from \"../timeline/TimelineView.jsx\";\n\n// Add to VIEW_MODES if not using entityDisplayConfig\n// Add timeline case in render function\n</code></pre> <p>Step 3: Run all client tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/gallery-search/GallerySearch.jsx\ngit commit -m \"feat(client): integrate TimelineView into GallerySearch\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-12-frontend-integrate-timeline-into-imagesearch","title":"Task 12: Frontend - Integrate Timeline into ImageSearch","text":"<p>Files: - Modify: <code>client/src/components/image-search/ImageSearch.jsx</code></p> <p>Step 1: Read current ImageSearch implementation</p> <p>Read <code>client/src/components/image-search/ImageSearch.jsx</code>.</p> <p>Step 2: Add TimelineView import and rendering</p> <p>Follow same pattern as SceneSearch.</p> <p>Step 3: Run all client tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/image-search/ImageSearch.jsx\ngit commit -m \"feat(client): integrate TimelineView into ImageSearch\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-13-frontend-mobile-bottom-sheet-component","title":"Task 13: Frontend - Mobile Bottom Sheet Component","text":"<p>Files: - Create: <code>client/src/components/timeline/TimelineMobileSheet.jsx</code> - Test: <code>client/tests/components/timeline/TimelineMobileSheet.test.jsx</code></p> <p>Step 1: Install bottom sheet package</p> <pre><code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm install react-spring-bottom-sheet\n</code></pre> <p>Step 2: Write the failing test</p> <pre><code>// client/tests/components/timeline/TimelineMobileSheet.test.jsx\nimport { describe, it, expect, vi } from \"vitest\";\nimport { createElement } from \"react\";\nimport TimelineMobileSheet from \"../../../src/components/timeline/TimelineMobileSheet.jsx\";\n\ndescribe(\"TimelineMobileSheet\", () =&gt; {\n  const defaultProps = {\n    isOpen: true,\n    onDismiss: vi.fn(),\n    selectedPeriod: { period: \"2024-03\", label: \"March 2024\" },\n    itemCount: 47,\n    children: null,\n  };\n\n  it(\"renders with isOpen prop\", () =&gt; {\n    const element = createElement(TimelineMobileSheet, defaultProps);\n\n    expect(element).toBeDefined();\n    expect(element.props.isOpen).toBe(true);\n  });\n\n  it(\"shows selected period label in minimized state\", () =&gt; {\n    const element = createElement(TimelineMobileSheet, defaultProps);\n\n    expect(element.props.selectedPeriod.label).toBe(\"March 2024\");\n  });\n\n  it(\"shows item count in minimized state\", () =&gt; {\n    const element = createElement(TimelineMobileSheet, defaultProps);\n\n    expect(element.props.itemCount).toBe(47);\n  });\n\n  it(\"accepts children for expanded content\", () =&gt; {\n    const children = createElement(\"div\", null, \"Timeline content\");\n    const element = createElement(TimelineMobileSheet, {\n      ...defaultProps,\n      children,\n    });\n\n    expect(element.props.children).toBeDefined();\n  });\n});\n</code></pre> <p>Step 3: Run test to verify it fails</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineMobileSheet.test.jsx</code> Expected: FAIL with \"Cannot find module\"</p> <p>Step 4: Write minimal implementation</p> <pre><code>// client/src/components/timeline/TimelineMobileSheet.jsx\nimport { memo, useState, useCallback } from \"react\";\nimport { BottomSheet } from \"react-spring-bottom-sheet\";\nimport \"react-spring-bottom-sheet/dist/style.css\";\nimport { ChevronUp } from \"lucide-react\";\n\nconst SNAP_POINTS = {\n  minimized: 48,\n  expanded: 200,\n};\n\nfunction TimelineMobileSheet({\n  isOpen,\n  onDismiss,\n  selectedPeriod,\n  itemCount,\n  children,\n}) {\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  const handleSnap = useCallback((snapIndex) =&gt; {\n    setIsExpanded(snapIndex === 1);\n  }, []);\n\n  const snapPoints = useCallback(\n    ({ maxHeight }) =&gt; [SNAP_POINTS.minimized, Math.min(SNAP_POINTS.expanded, maxHeight * 0.4)],\n    []\n  );\n\n  return (\n    &lt;BottomSheet\n      open={isOpen}\n      onDismiss={onDismiss}\n      snapPoints={snapPoints}\n      defaultSnap={({ snapPoints }) =&gt; snapPoints[0]}\n      onSpringEnd={handleSnap}\n      blocking={false}\n      className=\"timeline-bottom-sheet\"\n    &gt;\n      {/* Minimized Header - Always visible */}\n      &lt;div\n        className=\"flex items-center justify-between px-4 py-3 cursor-pointer\"\n        onClick={() =&gt; setIsExpanded(!isExpanded)}\n      &gt;\n        &lt;div className=\"flex items-center gap-2\"&gt;\n          {/* Drag handle */}\n          &lt;div className=\"w-8 h-1 bg-border-primary rounded-full\" /&gt;\n\n          {selectedPeriod ? (\n            &lt;span className=\"text-sm font-medium text-text-primary\"&gt;\n              {selectedPeriod.label}\n              {itemCount &gt; 0 &amp;&amp; (\n                &lt;span className=\"ml-2 text-text-secondary\"&gt;\n                  \u00b7 {itemCount} {itemCount === 1 ? \"item\" : \"items\"}\n                &lt;/span&gt;\n              )}\n            &lt;/span&gt;\n          ) : (\n            &lt;span className=\"text-sm text-text-secondary\"&gt;\n              Select a time period\n            &lt;/span&gt;\n          )}\n        &lt;/div&gt;\n\n        &lt;ChevronUp\n          size={20}\n          className={`text-text-secondary transition-transform ${isExpanded ? \"rotate-180\" : \"\"}`}\n        /&gt;\n      &lt;/div&gt;\n\n      {/* Expanded Content */}\n      &lt;div className={`overflow-hidden transition-all ${isExpanded ? \"max-h-[200px]\" : \"max-h-0\"}`}&gt;\n        {children}\n      &lt;/div&gt;\n    &lt;/BottomSheet&gt;\n  );\n}\n\nexport default memo(TimelineMobileSheet);\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- tests/components/timeline/TimelineMobileSheet.test.jsx</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/timeline/TimelineMobileSheet.jsx client/tests/components/timeline/TimelineMobileSheet.test.jsx package.json package-lock.json\ngit commit -m \"feat(client): add TimelineMobileSheet bottom sheet component\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-14-frontend-add-mobile-detection-and-sheet-integration","title":"Task 14: Frontend - Add Mobile Detection and Sheet Integration","text":"<p>Files: - Modify: <code>client/src/components/timeline/TimelineView.jsx</code></p> <p>Step 1: Read useMediaQuery or similar hook</p> <p>Check for existing mobile detection hooks in the codebase.</p> <p>Step 2: Integrate mobile bottom sheet</p> <pre><code>// Add imports:\nimport TimelineMobileSheet from \"./TimelineMobileSheet.jsx\";\nimport { useMediaQuery } from \"../../hooks/useMediaQuery.js\"; // or create if needed\n\n// In component:\nconst isMobile = useMediaQuery(\"(max-width: 768px)\");\n\n// Conditional rendering:\n{isMobile ? (\n  &lt;TimelineMobileSheet\n    isOpen={true}\n    selectedPeriod={selectedPeriod}\n    itemCount={items.length}\n  &gt;\n    &lt;TimelineControls ... /&gt;\n    &lt;TimelineStrip ... /&gt;\n  &lt;/TimelineMobileSheet&gt;\n) : (\n  // Desktop layout (existing)\n)}\n</code></pre> <p>Step 3: Run all client tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/timeline/TimelineView.jsx\ngit commit -m \"feat(client): add mobile bottom sheet layout to TimelineView\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-15-integration-test-timeline-api-endpoint","title":"Task 15: Integration Test - Timeline API Endpoint","text":"<p>Files: - Create: <code>server/integration/api/timeline.integration.test.ts</code></p> <p>Step 1: Write integration test</p> <pre><code>// server/integration/api/timeline.integration.test.ts\nimport { describe, it, expect, beforeAll } from \"vitest\";\nimport { adminClient, guestClient } from \"../helpers/testClient.js\";\nimport { TEST_ADMIN } from \"../fixtures/testEntities.js\";\n\ninterface DistributionResponse {\n  distribution: Array&lt;{\n    period: string;\n    count: number;\n  }&gt;;\n}\n\ndescribe(\"Timeline API\", () =&gt; {\n  beforeAll(async () =&gt; {\n    await adminClient.login(TEST_ADMIN.username, TEST_ADMIN.password);\n  });\n\n  describe(\"GET /api/timeline/:entityType/distribution\", () =&gt; {\n    it(\"rejects unauthenticated requests\", async () =&gt; {\n      const response = await guestClient.get(\"/api/timeline/scene/distribution\");\n\n      expect(response.status).toBe(401);\n    });\n\n    it(\"returns distribution for scenes with default granularity\", async () =&gt; {\n      const response = await adminClient.get&lt;DistributionResponse&gt;(\n        \"/api/timeline/scene/distribution\"\n      );\n\n      expect(response.ok).toBe(true);\n      expect(response.data.distribution).toBeDefined();\n      expect(Array.isArray(response.data.distribution)).toBe(true);\n    });\n\n    it(\"returns distribution for galleries\", async () =&gt; {\n      const response = await adminClient.get&lt;DistributionResponse&gt;(\n        \"/api/timeline/gallery/distribution?granularity=years\"\n      );\n\n      expect(response.ok).toBe(true);\n      expect(response.data.distribution).toBeDefined();\n    });\n\n    it(\"returns distribution for images\", async () =&gt; {\n      const response = await adminClient.get&lt;DistributionResponse&gt;(\n        \"/api/timeline/image/distribution?granularity=days\"\n      );\n\n      expect(response.ok).toBe(true);\n      expect(response.data.distribution).toBeDefined();\n    });\n\n    it(\"returns 400 for invalid entity type\", async () =&gt; {\n      const response = await adminClient.get(\"/api/timeline/invalid/distribution\");\n\n      expect(response.status).toBe(400);\n    });\n\n    it(\"returns 400 for invalid granularity\", async () =&gt; {\n      const response = await adminClient.get(\n        \"/api/timeline/scene/distribution?granularity=invalid\"\n      );\n\n      expect(response.status).toBe(400);\n    });\n\n    it(\"distribution items have period and count\", async () =&gt; {\n      const response = await adminClient.get&lt;DistributionResponse&gt;(\n        \"/api/timeline/scene/distribution?granularity=months\"\n      );\n\n      expect(response.ok).toBe(true);\n\n      if (response.data.distribution.length &gt; 0) {\n        const item = response.data.distribution[0];\n        expect(item.period).toBeDefined();\n        expect(typeof item.period).toBe(\"string\");\n        expect(item.count).toBeDefined();\n        expect(typeof item.count).toBe(\"number\");\n      }\n    });\n  });\n});\n</code></pre> <p>Step 2: Run integration test</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run test:integration -- timeline.integration.test.ts</code> Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/api/timeline.integration.test.ts\ngit commit -m \"test(server): add timeline API integration tests\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-16-manual-testing-polish","title":"Task 16: Manual Testing &amp; Polish","text":"<p>Step 1: Start dev servers</p> <pre><code># Terminal 1 - Server\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run dev\n\n# Terminal 2 - Client\ncd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Manual test checklist</p> <ul> <li> Navigate to Scenes page</li> <li> Switch to Timeline view mode</li> <li> Verify timeline strip renders with bars</li> <li> Click zoom level buttons (Years/Months/Weeks/Days)</li> <li> Click a bar to select time period</li> <li> Verify results grid updates with filtered scenes</li> <li> Test keyboard navigation (arrow keys, Enter)</li> <li> Test on mobile viewport (resize browser or use DevTools)</li> <li> Verify bottom sheet expands/collapses</li> <li> Repeat for Galleries and Images pages</li> </ul> <p>Step 3: Fix any visual issues found</p> <p>Address any styling or UX issues discovered during manual testing.</p> <p>Step 4: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: polish timeline view styling and interactions\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#task-17-run-full-test-suite-final-commit","title":"Task 17: Run Full Test Suite &amp; Final Commit","text":"<p>Step 1: Run all tests</p> <pre><code># Server unit tests\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test\n\n# Server integration tests\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run test:integration\n\n# Client tests\ncd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test\n</code></pre> <p>Step 2: Verify all pass</p> <p>Expected: All tests PASS</p> <p>Step 3: Create index export file</p> <pre><code>// client/src/components/timeline/index.js\nexport { default as TimelineView } from \"./TimelineView.jsx\";\nexport { default as TimelineStrip } from \"./TimelineStrip.jsx\";\nexport { default as TimelineControls } from \"./TimelineControls.jsx\";\nexport { default as TimelineBar } from \"./TimelineBar.jsx\";\nexport { default as TimelineMobileSheet } from \"./TimelineMobileSheet.jsx\";\nexport { useTimelineState } from \"./useTimelineState.js\";\n</code></pre> <p>Step 4: Final commit</p> <pre><code>git add client/src/components/timeline/index.js\ngit commit -m \"feat: complete timeline view implementation\"\n</code></pre>"},{"location":"plans/2026-01-18-timeline-view-implementation/#summary","title":"Summary","text":"<p>This plan implements the Timeline View feature in 17 tasks:</p> Task Component Type 1 TimelineService Backend 2 Timeline Controller + Route Backend 3 useTimelineState hook Frontend 4 TimelineControls Frontend 5 TimelineBar Frontend 6 TimelineStrip Frontend 7 TimelineView Frontend 8 entityDisplayConfig Frontend 9 ViewModeToggle icon Frontend 10 SceneSearch integration Frontend 11 GallerySearch integration Frontend 12 ImageSearch integration Frontend 13 TimelineMobileSheet Frontend 14 Mobile detection integration Frontend 15 Integration tests Testing 16 Manual testing QA 17 Final test suite QA <p>Each task follows TDD with explicit test \u2192 fail \u2192 implement \u2192 pass \u2192 commit steps.</p>"},{"location":"plans/2026-01-19-folder-view-design/","title":"Folder View Design","text":"<p>Date: 2026-01-19 Status: Implemented Issue: #223 Goal: Add a \"Folder\" view mode that lets users browse content by navigating through the tag hierarchy visually, similar to Fossify Gallery's folder browsing experience.</p>"},{"location":"plans/2026-01-19-folder-view-design/#context","title":"Context","text":"<p>Users with large, organized collections want to navigate content by drilling down through a hierarchy rather than using filters/search. The current Tag Hierarchy view shows tags in a tree structure, but users want to browse content organized by tags - tapping through folders of thumbnails to reach their content.</p>"},{"location":"plans/2026-01-19-folder-view-design/#user-request-from-223","title":"User Request (from #223)","text":"<p>In a folder-based app like Fossify Gallery it's easy to just tap several times to find /Photos/Color/Category1/Category2/Performer1/. In Peek or Stash you could go into Images or Galleries &gt; hunt for specific gallery or Performers &gt; search for tags associated with the categories.</p>"},{"location":"plans/2026-01-19-folder-view-design/#how-this-differs-from-tag-hierarchy-view","title":"How This Differs from Tag Hierarchy View","text":"Tag Hierarchy View Folder View Shows tags themselves in a tree Shows content organized by tag hierarchy Purpose: manage/explore tag structure Purpose: browse content via tag navigation Lives on Tags page Lives on Scenes, Galleries, Images pages Output: tags Output: scenes/galleries/images grouped by tags"},{"location":"plans/2026-01-19-folder-view-design/#design","title":"Design","text":""},{"location":"plans/2026-01-19-folder-view-design/#core-concept","title":"Core Concept","text":"<p>Folder view is a presentation layer on top of the existing query/filter system:</p> <pre><code>User applies filters \u2192 API returns filtered content \u2192\n  \u2192 Folder view groups results by tag hierarchy \u2192\n    \u2192 Display: folders first (with counts), then leaf content\n</code></pre> <p>This means: - No new API endpoints needed - Reuses all existing filter/sort logic - Folder view is purely client-side organization - Works with any active filters (studio, performer, date range, etc.) - Content with multiple tags appears in multiple folders (expected behavior)</p>"},{"location":"plans/2026-01-19-folder-view-design/#entity-types","title":"Entity Types","text":"<p>Folder view applies to: - Scenes - Galleries - Images</p>"},{"location":"plans/2026-01-19-folder-view-design/#hierarchy-source","title":"Hierarchy Source","text":"<p>Uses tag hierarchy (parent/child relationships from Stash), not filesystem paths.</p> <p>Root level: All top-level tags (tags with no parent) + \"Untagged\" folder</p> <p>Untagged folder: Contains content that has no tags. Displayed alongside top-level tag folders.</p>"},{"location":"plans/2026-01-19-folder-view-design/#layout","title":"Layout","text":""},{"location":"plans/2026-01-19-folder-view-design/#desktop-split-pane","title":"Desktop (Split-pane)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Scenes    [Search...]  [Filters]  Grid | Wall | Folder    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                 \u2502                                           \u2502\n\u2502  \u25bc Root         \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502    \u25bc Color      \u2502  \u2502     \u2502 \u2502     \u2502 \u2502     \u2502 \u2502     \u2502        \u2502\n\u2502        Cat1  \u2190  \u2502  \u2502Cat2 \u2502 \u2502Perf1\u2502 \u2502Scene\u2502 \u2502Scene\u2502        \u2502\n\u2502        Cat2     \u2502  \u2502 \ud83d\udcc1  \u2502 \u2502 \ud83d\udcc1  \u2502 \u2502 \u25b6\ufe0f  \u2502 \u2502 \u25b6\ufe0f  \u2502        \u2502\n\u2502      BW         \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502    Category     \u2502                                           \u2502\n\u2502    Performer    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502                 \u2502  \u2502Scene\u2502 \u2502Scene\u2502 \u2502Scene\u2502                 \u2502\n\u2502                 \u2502  \u2502 \u25b6\ufe0f  \u2502 \u2502 \u25b6\ufe0f  \u2502 \u2502 \u25b6\ufe0f  \u2502                 \u2502\n\u2502                 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Left panel: Collapsible tree showing current position in hierarchy - Highlights current location - Click to jump to any level - Can be collapsed to maximize content area</p> <p>Right panel: Grid showing current level contents - Child tag folders first (sorted alphabetically) - Then leaf content (sorted by current sort setting)</p>"},{"location":"plans/2026-01-19-folder-view-design/#mobile-stacked","title":"Mobile (Stacked)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Scenes         Folder \u25bc\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Root &gt; Color &gt; Cat1    \u2502  \u2190 Breadcrumb (tappable)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502         \u2502 \u2502         \u2502\u2502\n\u2502  \u2502  Cat2   \u2502 \u2502  Perf1  \u2502\u2502\n\u2502  \u2502   \ud83d\udcc1 12 \u2502 \u2502   \ud83d\udcc1 8  \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502         \u2502 \u2502         \u2502\u2502\n\u2502  \u2502  Scene  \u2502 \u2502  Scene  \u2502\u2502\n\u2502  \u2502    \u25b6\ufe0f   \u2502 \u2502    \u25b6\ufe0f   \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>No tree sidebar - takes too much space on mobile</p> <p>Breadcrumb navigation: - Shows path: <code>Root &gt; Color &gt; Cat1</code> - Tap any segment to jump back to that level - Tap \"Root\" to return to top level</p> <p>Grid: Same mixed display - folders first, then content</p>"},{"location":"plans/2026-01-19-folder-view-design/#folder-cards","title":"Folder Cards","text":""},{"location":"plans/2026-01-19-folder-view-design/#appearance","title":"Appearance","text":"<p>Folder cards are visually distinct from content cards:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 \u2502\n\u2502   [thumbnail]   \u2502\n\u2502                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \ud83d\udcc1 Tag Name     \u2502\n\u2502    24 items     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Thumbnail source (in order of preference): 1. Tag's image from Stash (if set) 2. First item's thumbnail within that tag (recursive) 3. Generic folder placeholder</p> <p>Count: Shows recursive total of all content within that tag and its children (so users know there's content somewhere down the tree)</p>"},{"location":"plans/2026-01-19-folder-view-design/#interaction","title":"Interaction","text":"<ul> <li>Tap/click: Drill down into that tag (update breadcrumb, show children)</li> <li>Long-press/right-click: Could show context menu (future: \"Open in new tab\", \"Pin to home\")</li> </ul>"},{"location":"plans/2026-01-19-folder-view-design/#sorting-display","title":"Sorting &amp; Display","text":""},{"location":"plans/2026-01-19-folder-view-design/#sort-order","title":"Sort Order","text":"<ol> <li>Folders first (sorted alphabetically by tag name)</li> <li>Content second (sorted by current page sort setting: date, name, rating, etc.)</li> </ol>"},{"location":"plans/2026-01-19-folder-view-design/#empty-states","title":"Empty States","text":"<ul> <li>Tag with children but no direct content: Show only child folders, no empty message</li> <li>Tag with no children and no content: Hide from view (filtered out)</li> <li>No content matches filters: Show \"No results\" as normal</li> </ul>"},{"location":"plans/2026-01-19-folder-view-design/#filter-interaction","title":"Filter Interaction","text":"<p>Folder view respects all active filters: - If studio filter \"Vixen\" is active, only Vixen content appears - Folders with no matching content are hidden - Counts reflect filtered totals</p> <p>Example: User has 100 scenes tagged \"Color\", but only 10 are from Vixen. With Vixen filter active, \"Color\" folder shows \"10 items\".</p>"},{"location":"plans/2026-01-19-folder-view-design/#navigation","title":"Navigation","text":""},{"location":"plans/2026-01-19-folder-view-design/#desktop","title":"Desktop","text":"<ul> <li>Click folder \u2192 drill down</li> <li>Click tree item \u2192 jump to that level</li> <li>Click breadcrumb \u2192 jump to that level</li> <li>Browser back button \u2192 works naturally (URL includes current path)</li> </ul>"},{"location":"plans/2026-01-19-folder-view-design/#mobile","title":"Mobile","text":"<ul> <li>Tap folder \u2192 drill down</li> <li>Tap breadcrumb segment \u2192 jump to that level</li> <li>Swipe right \u2192 go up one level (optional, nice-to-have)</li> <li>Browser back button \u2192 works naturally</li> </ul>"},{"location":"plans/2026-01-19-folder-view-design/#url-structure","title":"URL Structure","text":"<p>Include current path in URL for bookmarking/sharing:</p> <pre><code>/scenes?view=folder&amp;path=color,cat1,performer1\n</code></pre> <p>Or using tag IDs for stability: <pre><code>/scenes?view=folder&amp;path=123,456,789\n</code></pre></p>"},{"location":"plans/2026-01-19-folder-view-design/#implementation-considerations","title":"Implementation Considerations","text":""},{"location":"plans/2026-01-19-folder-view-design/#data-requirements","title":"Data Requirements","text":"<p>Need tag hierarchy data loaded: - Already available via StashCacheManager - Tags include <code>parent_id</code> for hierarchy - May need to ensure all tag relationships are cached</p>"},{"location":"plans/2026-01-19-folder-view-design/#client-side-grouping","title":"Client-side Grouping","text":"<pre><code>interface FolderNode {\n  tag: Tag | null;  // null for \"Untagged\" pseudo-folder\n  children: FolderNode[];\n  content: (Scene | Gallery | Image)[];\n  totalCount: number;  // recursive count\n}\n\nfunction buildFolderTree(\n  items: ContentItem[],\n  tags: Tag[],\n  currentPath: string[]\n): FolderNode\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-design/#performance","title":"Performance","text":"<ul> <li>Large result sets: May need virtualization for the grid</li> <li>Deep hierarchies: Lazy-load children? Or pre-compute full tree?</li> <li>Many tags: Consider pagination of folders at each level?</li> </ul>"},{"location":"plans/2026-01-19-folder-view-design/#responsive-breakpoints","title":"Responsive Breakpoints","text":"Breakpoint Layout &lt; 768px Mobile: breadcrumb + grid, no sidebar &gt;= 768px Desktop: collapsible sidebar + grid <p>Sidebar default state: - Desktop wide (&gt;1200px): sidebar open - Desktop narrow (768-1200px): sidebar collapsed by default</p>"},{"location":"plans/2026-01-19-folder-view-design/#view-mode-integration","title":"View Mode Integration","text":""},{"location":"plans/2026-01-19-folder-view-design/#selector-ui","title":"Selector UI","text":"<p>Add \"Folder\" to existing view mode selector:</p> <pre><code>Grid | Wall | Table | Folder\n \u25a1     \u25a1      \u25a1       \ud83d\udcc1\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-design/#persistence","title":"Persistence","text":"<p>View mode preference stored per entity type (existing pattern): - <code>viewMode.scenes = 'folder'</code> - <code>viewMode.galleries = 'grid'</code> - etc.</p>"},{"location":"plans/2026-01-19-folder-view-design/#density","title":"Density","text":"<p>Folder view should respect the existing density setting (S/M/L) for both folder cards and content cards.</p>"},{"location":"plans/2026-01-19-folder-view-design/#out-of-scope-future-enhancements","title":"Out of Scope (Future Enhancements)","text":"<ol> <li>Filesystem path navigation - This design only uses tag hierarchy</li> <li>Folder\u2192Tag import tool - Separate tagManager plugin feature</li> <li>Pinning tags to homepage - Could be a separate feature</li> <li>Custom folder ordering - Alphabetical only for now</li> <li>Multi-select across folders - Complex interaction, defer</li> </ol>"},{"location":"plans/2026-01-19-folder-view-design/#design-decisions","title":"Design Decisions","text":"<ol> <li> <p>Mobile swipe gesture: No swipe-right gesture. Breadcrumb navigation only. Swipe-right conflicts with browser back gesture on mobile, and breadcrumb is the established pattern (Google Drive, Files app).</p> </li> <li> <p>Folder thumbnail caching: Compute thumbnails when building the folder tree, store on the FolderNode object. One-time cost per tree build, not per-card render. Optimize later if needed for large libraries.</p> </li> <li> <p>URL path format: Use tag IDs (<code>?path=123,456,789</code>) for stability. Tag names break if renamed. Breadcrumb displays human-readable names regardless of URL format.</p> </li> </ol>"},{"location":"plans/2026-01-19-folder-view-design/#references","title":"References","text":"<ul> <li>Issue #223 - Original request</li> <li>Fossify Gallery - UX reference for folder grid navigation</li> <li>docs/plans/2025-01-11-view-mode-options-brainstorm.md - View modes overview</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/","title":"Folder View Hierarchy Fix","text":""},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#problem","title":"Problem","text":"<p>When opening folder view, all 23,000+ scenes appear at the top level alongside tag folders. The folder view is intended to be a hierarchy drilling view where items only appear when directly attached to the currently selected tag.</p>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#desired-behavior","title":"Desired Behavior","text":""},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#root-level","title":"Root Level","text":"<ul> <li>Show only root-level tag folders (tags with no parents)</li> <li>Show \"Untagged\" folder containing items with zero tags</li> <li>Show NO loose items</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#inside-a-tag-folder","title":"Inside a Tag Folder","text":"<ul> <li>Show child tag folders (sorted alphabetically, always displayed first)</li> <li>Show items that have this exact tag directly AND do not have any child tag of this folder</li> <li>Items \"sink\" to their most specific tag level</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#multi-tag-items","title":"Multi-Tag Items","text":"<ul> <li>Items appear in all folders where they have a direct tag match</li> <li>Example: A scene tagged \"Action\" and \"Comedy\" appears in both folders</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#nested-tag-handling","title":"Nested Tag Handling","text":"<ul> <li>If an item has both a parent tag and a child tag, it only appears in the child folder</li> <li>Items only surface at the exact tag level they're tagged with</li> <li>Example: Scene tagged \"Slasher\" (child of \"Horror\") only appears when viewing \"Slasher\", not when viewing \"Horror\"</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#folder-counts","title":"Folder Counts","text":"<ul> <li>Folder cards continue to show recursive total count (all items in folder and descendants)</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#untagged-folder","title":"\"Untagged\" Folder","text":"<ul> <li>Only appears at root level</li> <li>Contains items with zero tags</li> </ul>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#algorithm","title":"Algorithm","text":"<pre><code>At ROOT level:\n  - Show folders for each root-level tag (tags with no parents)\n  - Show \"Untagged\" folder containing items with zero tags\n  - Show NO loose items\n\nInside a TAG folder (currentTagId):\n  - Get child tags of currentTagId\n  - For each item in results:\n    - Does item have currentTagId directly?\n      - YES: Does item also have ANY child tag of currentTagId?\n        - YES \u2192 item belongs in that child folder (don't show here)\n        - NO \u2192 item is a loose item at this level\n      - NO \u2192 item shouldn't appear here (it's here via deeper descendant)\n  - Show child tag folders (sorted alphabetically, always first)\n  - Show loose items (after folders)\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#files-to-change","title":"Files to Change","text":"File Change <code>client/src/utils/buildFolderTree.js</code> Rewrite core grouping algorithm <code>client/src/utils/buildFolderTree.test.js</code> Update tests for new behavior"},{"location":"plans/2026-01-19-folder-view-hierarchy-design/#files-not-changing","title":"Files NOT Changing","text":"<ul> <li><code>FolderView.jsx</code> - component logic unchanged</li> <li><code>FolderCard.jsx</code>, <code>FolderBreadcrumb.jsx</code>, <code>FolderTreeSidebar.jsx</code> - display unchanged</li> <li>API endpoints - filtering behavior unchanged</li> <li>Page integrations (Galleries, SceneSearch, Images) - already wired correctly</li> </ul> <p>The fix is isolated to client-side grouping logic in <code>buildFolderTree.js</code>.</p>"},{"location":"plans/2026-01-19-folder-view-implementation/","title":"Folder View Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a \"Folder\" view mode that lets users browse content (Scenes, Galleries, Images) by navigating through the tag hierarchy visually, similar to Fossify Gallery's folder browsing.</p> <p>Architecture: Folder view is a client-side presentation layer. Filtered content is fetched normally via existing APIs, then grouped by tag hierarchy for display. Desktop uses split-pane layout (tree sidebar + content grid); mobile uses stacked layout (breadcrumb + grid). Tag IDs in URL enable bookmarking/sharing.</p> <p>Tech Stack: React, existing tag hierarchy utils (<code>buildTagTree.js</code>), Tailwind CSS, Lucide icons</p> <p>Design doc: <code>docs/plans/2026-01-19-folder-view-design.md</code></p>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-1-add-folder-icon-to-viewmodetoggle","title":"Task 1: Add Folder Icon to ViewModeToggle","text":"<p>Files: - Modify: <code>client/src/components/ui/ViewModeToggle.jsx:11-17</code></p> <p>Step 1: Add folder icon to MODE_ICONS</p> <p>Add <code>LucideFolderOpen</code> import and mapping:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { LucideGrid2X2, LucideSquare, LucideNetwork, LucideList, LucideCalendar, LucideFolderOpen } from \"lucide-react\";\n\n// Default modes for backward compatibility\nconst DEFAULT_MODES = [\n  { id: \"grid\", icon: LucideGrid2X2, label: \"Grid view\" },\n  { id: \"wall\", icon: LucideSquare, label: \"Wall view\" },\n];\n\n// Icon mapping for custom mode definitions\nconst MODE_ICONS = {\n  grid: LucideGrid2X2,\n  wall: LucideSquare,\n  hierarchy: LucideNetwork,\n  table: LucideList,\n  timeline: LucideCalendar,\n  folder: LucideFolderOpen,\n};\n</code></pre> <p>Step 2: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/ViewModeToggle.jsx\ngit commit -m \"feat: add folder icon to ViewModeToggle icon mapping\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-2-add-folder-view-mode-to-entity-config","title":"Task 2: Add Folder View Mode to Entity Config","text":"<p>Files: - Modify: <code>client/src/config/entityDisplayConfig.js:10-15, 50-55, 88-92</code></p> <p>Step 1: Add folder mode to scene config</p> <p>Update scene viewModes array (after timeline):</p> <pre><code>  scene: {\n    label: \"Scene\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n      { id: \"timeline\", label: \"Timeline\" },\n      { id: \"folder\", label: \"Folder\" },\n    ],\n</code></pre> <p>Step 2: Add folder mode to gallery config</p> <p>Update gallery viewModes array (after timeline):</p> <pre><code>  gallery: {\n    label: \"Gallery\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"table\", label: \"Table\" },\n      { id: \"timeline\", label: \"Timeline\" },\n      { id: \"folder\", label: \"Folder\" },\n    ],\n</code></pre> <p>Step 3: Add folder mode to image config</p> <p>Update image viewModes array (after timeline):</p> <pre><code>  image: {\n    label: \"Image\",\n    viewModes: [\n      { id: \"grid\", label: \"Grid\" },\n      { id: \"wall\", label: \"Wall\" },\n      { id: \"timeline\", label: \"Timeline\" },\n      { id: \"folder\", label: \"Folder\" },\n    ],\n</code></pre> <p>Step 4: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/config/entityDisplayConfig.js\ngit commit -m \"feat: add folder view mode to scene, gallery, image entity configs\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-3-create-foldernode-type-and-tree-builder-utility","title":"Task 3: Create FolderNode Type and Tree Builder Utility","text":"<p>Files: - Create: <code>client/src/utils/buildFolderTree.js</code> - Create: <code>client/src/utils/buildFolderTree.test.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/utils/buildFolderTree.test.js\nimport { describe, it, expect } from \"vitest\";\nimport { buildFolderTree, UNTAGGED_FOLDER_ID } from \"./buildFolderTree.js\";\n\ndescribe(\"buildFolderTree\", () =&gt; {\n  const mockTags = [\n    { id: \"1\", name: \"Color\", parents: [], children: [{ id: \"2\" }, { id: \"3\" }], image_path: \"/tag1.jpg\" },\n    { id: \"2\", name: \"Red\", parents: [{ id: \"1\" }], children: [], image_path: null },\n    { id: \"3\", name: \"Blue\", parents: [{ id: \"1\" }], children: [], image_path: \"/tag3.jpg\" },\n    { id: \"4\", name: \"Size\", parents: [], children: [], image_path: null },\n  ];\n\n  describe(\"buildFolderTree at root level\", () =&gt; {\n    it(\"returns top-level tags as folders at root\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [{ id: \"2\", name: \"Red\" }] },\n      ];\n      const result = buildFolderTree(items, mockTags, []);\n\n      // Should have Color, Size folders + Untagged\n      const folderIds = result.folders.map((f) =&gt; f.tag?.id || f.id);\n      expect(folderIds).toContain(\"1\"); // Color (parent of Red)\n      expect(folderIds).toContain(\"4\"); // Size (no content but is root tag)\n      expect(folderIds).toContain(UNTAGGED_FOLDER_ID);\n    });\n\n    it(\"calculates recursive item count for folders\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [{ id: \"2\", name: \"Red\" }] },\n        { id: \"s2\", tags: [{ id: \"2\", name: \"Red\" }] },\n        { id: \"s3\", tags: [{ id: \"3\", name: \"Blue\" }] },\n      ];\n      const result = buildFolderTree(items, mockTags, []);\n\n      const colorFolder = result.folders.find((f) =&gt; f.tag?.id === \"1\");\n      expect(colorFolder.totalCount).toBe(3); // 2 Red + 1 Blue\n    });\n\n    it(\"puts untagged items in Untagged folder\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [] },\n        { id: \"s2\", tags: [{ id: \"2\", name: \"Red\" }] },\n      ];\n      const result = buildFolderTree(items, mockTags, []);\n\n      const untaggedFolder = result.folders.find((f) =&gt; f.id === UNTAGGED_FOLDER_ID);\n      expect(untaggedFolder.totalCount).toBe(1);\n    });\n\n    it(\"hides folders with no matching content\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [{ id: \"2\", name: \"Red\" }] },\n      ];\n      const result = buildFolderTree(items, mockTags, []);\n\n      // Size has no content, should be hidden\n      const sizeFolder = result.folders.find((f) =&gt; f.tag?.id === \"4\");\n      expect(sizeFolder).toBeUndefined();\n    });\n  });\n\n  describe(\"buildFolderTree with path navigation\", () =&gt; {\n    it(\"shows child folders and content when navigating into a tag\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [{ id: \"1\", name: \"Color\" }, { id: \"2\", name: \"Red\" }] },\n        { id: \"s2\", tags: [{ id: \"1\", name: \"Color\" }] }, // Tagged with Color but not a child\n      ];\n      const result = buildFolderTree(items, mockTags, [\"1\"]); // Navigate into Color\n\n      // Should show Red, Blue as child folders\n      const folderIds = result.folders.map((f) =&gt; f.tag?.id);\n      expect(folderIds).toContain(\"2\"); // Red\n      expect(folderIds).toContain(\"3\"); // Blue\n\n      // s2 is directly tagged with Color (leaf content at this level)\n      expect(result.items).toContainEqual(expect.objectContaining({ id: \"s2\" }));\n    });\n\n    it(\"returns breadcrumb path for navigation\", () =&gt; {\n      const items = [{ id: \"s1\", tags: [{ id: \"2\", name: \"Red\" }] }];\n      const result = buildFolderTree(items, mockTags, [\"1\", \"2\"]); // Color &gt; Red\n\n      expect(result.breadcrumbs).toEqual([\n        { id: \"1\", name: \"Color\" },\n        { id: \"2\", name: \"Red\" },\n      ]);\n    });\n  });\n\n  describe(\"folder thumbnail\", () =&gt; {\n    it(\"uses tag image_path if available\", () =&gt; {\n      const items = [{ id: \"s1\", tags: [{ id: \"1\", name: \"Color\" }] }];\n      const result = buildFolderTree(items, mockTags, []);\n\n      const colorFolder = result.folders.find((f) =&gt; f.tag?.id === \"1\");\n      expect(colorFolder.thumbnail).toBe(\"/tag1.jpg\");\n    });\n\n    it(\"falls back to first item thumbnail if no tag image\", () =&gt; {\n      const items = [\n        { id: \"s1\", tags: [{ id: \"4\", name: \"Size\" }], paths: { screenshot: \"/scene1.jpg\" } },\n      ];\n      const result = buildFolderTree(items, mockTags, []);\n\n      const sizeFolder = result.folders.find((f) =&gt; f.tag?.id === \"4\");\n      expect(sizeFolder.thumbnail).toBe(\"/scene1.jpg\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- buildFolderTree.test.js --run</code> Expected: FAIL - module not found</p> <p>Step 3: Write the implementation</p> <pre><code>// client/src/utils/buildFolderTree.js\n\nexport const UNTAGGED_FOLDER_ID = \"__untagged__\";\n\n/**\n * Get thumbnail from an item (scene, gallery, or image)\n */\nconst getItemThumbnail = (item) =&gt; {\n  // Scene\n  if (item.paths?.screenshot) return item.paths.screenshot;\n  // Gallery\n  if (item.cover?.paths?.thumbnail) return item.cover.paths.thumbnail;\n  // Image\n  if (item.paths?.thumbnail) return item.paths.thumbnail;\n  return null;\n};\n\n/**\n * Build a folder tree structure from items and tag hierarchy.\n *\n * @param {Array} items - Content items (scenes, galleries, images) with tags array\n * @param {Array} tags - All tags with hierarchy (parents/children arrays)\n * @param {Array} currentPath - Array of tag IDs representing current navigation path\n * @returns {Object} { folders: FolderNode[], items: Item[], breadcrumbs: Breadcrumb[] }\n */\nexport function buildFolderTree(items, tags, currentPath = []) {\n  if (!items || !tags) {\n    return { folders: [], items: [], breadcrumbs: [] };\n  }\n\n  // Build tag lookup map\n  const tagMap = new Map();\n  tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n\n  // Build breadcrumbs from path\n  const breadcrumbs = currentPath.map((id) =&gt; {\n    const tag = tagMap.get(id);\n    return { id, name: tag?.name || \"Unknown\" };\n  });\n\n  // Determine which tags to show as folders at this level\n  const currentTagId = currentPath[currentPath.length - 1] || null;\n  const currentTag = currentTagId ? tagMap.get(currentTagId) : null;\n\n  // Get child tag IDs for current level\n  let childTagIds;\n  if (currentTag) {\n    // Inside a tag - show its children\n    childTagIds = new Set((currentTag.children || []).map((c) =&gt; c.id));\n  } else {\n    // At root - show top-level tags (no parents)\n    childTagIds = new Set(\n      tags.filter((t) =&gt; !t.parents || t.parents.length === 0).map((t) =&gt; t.id)\n    );\n  }\n\n  // Group items by which folder they belong to at this level\n  const folderContents = new Map(); // tagId -&gt; items[]\n  const leafItems = []; // Items that are \"directly\" at this level\n  const untaggedItems = [];\n\n  items.forEach((item) =&gt; {\n    const itemTagIds = new Set((item.tags || []).map((t) =&gt; t.id));\n\n    // Check if item has no tags\n    if (itemTagIds.size === 0) {\n      if (currentPath.length === 0) {\n        // Only show untagged at root\n        untaggedItems.push(item);\n      }\n      return;\n    }\n\n    // Check if item belongs to any child folder at this level\n    let belongsToChildFolder = false;\n    childTagIds.forEach((childId) =&gt; {\n      // Item belongs to this folder if it has the tag or any descendant\n      if (itemHasTagOrDescendant(item, childId, tagMap)) {\n        if (!folderContents.has(childId)) {\n          folderContents.set(childId, []);\n        }\n        folderContents.get(childId).push(item);\n        belongsToChildFolder = true;\n      }\n    });\n\n    // If at root and item doesn't belong to any root-level folder, it's a leaf\n    // If inside a tag and item is directly tagged with current tag but not children, it's a leaf\n    if (!belongsToChildFolder) {\n      if (currentTagId &amp;&amp; itemTagIds.has(currentTagId)) {\n        leafItems.push(item);\n      } else if (!currentTagId) {\n        // At root with tags but none are root-level tags - treat as leaf\n        leafItems.push(item);\n      }\n    }\n  });\n\n  // Build folder nodes (only folders with content)\n  const folders = [];\n\n  childTagIds.forEach((tagId) =&gt; {\n    const tag = tagMap.get(tagId);\n    if (!tag) return;\n\n    const folderItems = folderContents.get(tagId) || [];\n    if (folderItems.length === 0) return; // Hide empty folders\n\n    // Calculate total count (recursive)\n    const totalCount = folderItems.length;\n\n    // Get thumbnail\n    const thumbnail = tag.image_path || getItemThumbnail(folderItems[0]) || null;\n\n    folders.push({\n      id: tagId,\n      tag,\n      name: tag.name,\n      thumbnail,\n      totalCount,\n      isFolder: true,\n    });\n  });\n\n  // Add untagged folder if at root and has items\n  if (currentPath.length === 0 &amp;&amp; untaggedItems.length &gt; 0) {\n    folders.push({\n      id: UNTAGGED_FOLDER_ID,\n      tag: null,\n      name: \"Untagged\",\n      thumbnail: getItemThumbnail(untaggedItems[0]),\n      totalCount: untaggedItems.length,\n      isFolder: true,\n    });\n  }\n\n  // Sort folders alphabetically\n  folders.sort((a, b) =&gt; a.name.localeCompare(b.name));\n\n  // Combine leaf items with untagged if at root\n  const displayItems = currentPath.length === 0\n    ? [...leafItems, ...untaggedItems]\n    : leafItems;\n\n  return {\n    folders,\n    items: displayItems,\n    breadcrumbs,\n  };\n}\n\n/**\n * Check if an item has a tag or any of its descendants\n */\nfunction itemHasTagOrDescendant(item, tagId, tagMap, visited = new Set()) {\n  if (visited.has(tagId)) return false;\n  visited.add(tagId);\n\n  const itemTagIds = new Set((item.tags || []).map((t) =&gt; t.id));\n\n  // Direct match\n  if (itemTagIds.has(tagId)) return true;\n\n  // Check descendants\n  const tag = tagMap.get(tagId);\n  if (tag?.children) {\n    for (const child of tag.children) {\n      if (itemHasTagOrDescendant(item, child.id, tagMap, visited)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd client &amp;&amp; npm test -- buildFolderTree.test.js --run</code> Expected: PASS (all tests)</p> <p>Step 5: Commit</p> <pre><code>git add client/src/utils/buildFolderTree.js client/src/utils/buildFolderTree.test.js\ngit commit -m \"feat: add buildFolderTree utility for folder view grouping\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-4-create-foldercard-component","title":"Task 4: Create FolderCard Component","text":"<p>Files: - Create: <code>client/src/components/folder/FolderCard.jsx</code></p> <p>Step 1: Create FolderCard component</p> <pre><code>// client/src/components/folder/FolderCard.jsx\nimport { LucideFolder, LucideTag } from \"lucide-react\";\nimport { UNTAGGED_FOLDER_ID } from \"../../utils/buildFolderTree.js\";\n\n/**\n * Card component for displaying a folder (tag) in folder view.\n * Shows thumbnail, folder name, and item count.\n */\nconst FolderCard = ({ folder, onClick, className = \"\" }) =&gt; {\n  const { name, thumbnail, totalCount, id } = folder;\n  const isUntagged = id === UNTAGGED_FOLDER_ID;\n\n  return (\n    &lt;button\n      type=\"button\"\n      onClick={() =&gt; onClick(folder)}\n      className={`group relative rounded-lg overflow-hidden transition-all hover:ring-2 hover:ring-[var(--accent-primary)] focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)] ${className}`}\n      style={{ backgroundColor: \"var(--bg-secondary)\" }}\n    &gt;\n      {/* Thumbnail area */}\n      &lt;div className=\"aspect-video relative overflow-hidden\"&gt;\n        {thumbnail ? (\n          &lt;img\n            src={thumbnail}\n            alt={name}\n            className=\"w-full h-full object-cover transition-transform group-hover:scale-105\"\n            loading=\"lazy\"\n          /&gt;\n        ) : (\n          &lt;div\n            className=\"w-full h-full flex items-center justify-center\"\n            style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n          &gt;\n            {isUntagged ? (\n              &lt;LucideTag size={48} style={{ color: \"var(--text-tertiary)\" }} /&gt;\n            ) : (\n              &lt;LucideFolder size={48} style={{ color: \"var(--text-tertiary)\" }} /&gt;\n            )}\n          &lt;/div&gt;\n        )}\n\n        {/* Folder overlay icon */}\n        &lt;div\n          className=\"absolute bottom-2 right-2 p-1.5 rounded-md\"\n          style={{ backgroundColor: \"rgba(0,0,0,0.6)\" }}\n        &gt;\n          &lt;LucideFolder size={16} className=\"text-white\" /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Label area */}\n      &lt;div className=\"p-3\"&gt;\n        &lt;h3\n          className=\"font-medium truncate text-left\"\n          style={{ color: \"var(--text-primary)\" }}\n        &gt;\n          {name}\n        &lt;/h3&gt;\n        &lt;p\n          className=\"text-sm text-left\"\n          style={{ color: \"var(--text-secondary)\" }}\n        &gt;\n          {totalCount} {totalCount === 1 ? \"item\" : \"items\"}\n        &lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/button&gt;\n  );\n};\n\nexport default FolderCard;\n</code></pre> <p>Step 2: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/folder/FolderCard.jsx\ngit commit -m \"feat: add FolderCard component for folder view\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-5-create-breadcrumb-component","title":"Task 5: Create Breadcrumb Component","text":"<p>Files: - Create: <code>client/src/components/folder/FolderBreadcrumb.jsx</code></p> <p>Step 1: Create breadcrumb component</p> <pre><code>// client/src/components/folder/FolderBreadcrumb.jsx\nimport { LucideChevronRight, LucideHome } from \"lucide-react\";\n\n/**\n * Breadcrumb navigation for folder view.\n * Shows current path and allows jumping to any level.\n */\nconst FolderBreadcrumb = ({ breadcrumbs, onNavigate, className = \"\" }) =&gt; {\n  return (\n    &lt;nav\n      className={`flex items-center gap-1 text-sm flex-wrap ${className}`}\n      aria-label=\"Folder navigation\"\n    &gt;\n      {/* Root/Home */}\n      &lt;button\n        type=\"button\"\n        onClick={() =&gt; onNavigate([])}\n        className=\"flex items-center gap-1 px-2 py-1 rounded hover:bg-[var(--bg-tertiary)] transition-colors\"\n        style={{ color: breadcrumbs.length === 0 ? \"var(--text-primary)\" : \"var(--text-secondary)\" }}\n      &gt;\n        &lt;LucideHome size={14} /&gt;\n        &lt;span&gt;All&lt;/span&gt;\n      &lt;/button&gt;\n\n      {breadcrumbs.map((crumb, index) =&gt; {\n        const isLast = index === breadcrumbs.length - 1;\n        const pathToHere = breadcrumbs.slice(0, index + 1).map((b) =&gt; b.id);\n\n        return (\n          &lt;span key={crumb.id} className=\"flex items-center gap-1\"&gt;\n            &lt;LucideChevronRight\n              size={14}\n              style={{ color: \"var(--text-tertiary)\" }}\n            /&gt;\n            &lt;button\n              type=\"button\"\n              onClick={() =&gt; onNavigate(pathToHere)}\n              className=\"px-2 py-1 rounded hover:bg-[var(--bg-tertiary)] transition-colors truncate max-w-[150px]\"\n              style={{ color: isLast ? \"var(--text-primary)\" : \"var(--text-secondary)\" }}\n              title={crumb.name}\n            &gt;\n              {crumb.name}\n            &lt;/button&gt;\n          &lt;/span&gt;\n        );\n      })}\n    &lt;/nav&gt;\n  );\n};\n\nexport default FolderBreadcrumb;\n</code></pre> <p>Step 2: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/folder/FolderBreadcrumb.jsx\ngit commit -m \"feat: add FolderBreadcrumb component for folder navigation\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-6-create-foldertreesidebar-component-desktop","title":"Task 6: Create FolderTreeSidebar Component (Desktop)","text":"<p>Files: - Create: <code>client/src/components/folder/FolderTreeSidebar.jsx</code></p> <p>Step 1: Create tree sidebar component</p> <pre><code>// client/src/components/folder/FolderTreeSidebar.jsx\nimport { useState, useMemo } from \"react\";\nimport { LucideChevronRight, LucideChevronDown, LucideFolder, LucideFolderOpen } from \"lucide-react\";\nimport { buildTagTree } from \"../../utils/buildTagTree.js\";\n\n/**\n * Collapsible tree sidebar for folder view on desktop.\n * Shows tag hierarchy with expand/collapse controls.\n */\nconst FolderTreeSidebar = ({ tags, currentPath, onNavigate, className = \"\" }) =&gt; {\n  // Build tree from tags\n  const tree = useMemo(() =&gt; buildTagTree(tags, { sortField: \"name\", sortDirection: \"ASC\" }), [tags]);\n\n  // Track expanded nodes\n  const [expanded, setExpanded] = useState(() =&gt; {\n    // Auto-expand nodes in current path\n    return new Set(currentPath);\n  });\n\n  const toggleExpanded = (tagId) =&gt; {\n    setExpanded((prev) =&gt; {\n      const next = new Set(prev);\n      if (next.has(tagId)) {\n        next.delete(tagId);\n      } else {\n        next.add(tagId);\n      }\n      return next;\n    });\n  };\n\n  const handleNodeClick = (tagId) =&gt; {\n    // Build path to this node\n    const path = findPathToTag(tree, tagId);\n    onNavigate(path);\n  };\n\n  return (\n    &lt;div\n      className={`overflow-y-auto ${className}`}\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        borderRight: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {/* Root level */}\n      &lt;button\n        type=\"button\"\n        onClick={() =&gt; onNavigate([])}\n        className={`w-full flex items-center gap-2 px-3 py-2 text-left hover:bg-[var(--bg-tertiary)] transition-colors ${\n          currentPath.length === 0 ? \"bg-[var(--bg-tertiary)]\" : \"\"\n        }`}\n        style={{ color: \"var(--text-primary)\" }}\n      &gt;\n        &lt;LucideFolderOpen size={16} /&gt;\n        &lt;span className=\"font-medium\"&gt;All Content&lt;/span&gt;\n      &lt;/button&gt;\n\n      {/* Tree nodes */}\n      &lt;div className=\"pb-4\"&gt;\n        {tree.map((node) =&gt; (\n          &lt;TreeNode\n            key={node.id}\n            node={node}\n            depth={0}\n            expanded={expanded}\n            toggleExpanded={toggleExpanded}\n            currentPath={currentPath}\n            onNavigate={handleNodeClick}\n          /&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst TreeNode = ({ node, depth, expanded, toggleExpanded, currentPath, onNavigate }) =&gt; {\n  const hasChildren = node.children &amp;&amp; node.children.length &gt; 0;\n  const isExpanded = expanded.has(node.id);\n  const isInPath = currentPath.includes(node.id);\n  const isCurrentNode = currentPath[currentPath.length - 1] === node.id;\n\n  return (\n    &lt;div&gt;\n      &lt;div\n        className={`flex items-center hover:bg-[var(--bg-tertiary)] transition-colors ${\n          isCurrentNode ? \"bg-[var(--bg-tertiary)]\" : \"\"\n        }`}\n        style={{ paddingLeft: `${(depth + 1) * 12 + 8}px` }}\n      &gt;\n        {/* Expand/collapse button */}\n        &lt;button\n          type=\"button\"\n          onClick={(e) =&gt; {\n            e.stopPropagation();\n            toggleExpanded(node.id);\n          }}\n          className=\"p-1 hover:bg-[var(--bg-primary)] rounded\"\n          style={{ visibility: hasChildren ? \"visible\" : \"hidden\" }}\n        &gt;\n          {isExpanded ? (\n            &lt;LucideChevronDown size={14} style={{ color: \"var(--text-tertiary)\" }} /&gt;\n          ) : (\n            &lt;LucideChevronRight size={14} style={{ color: \"var(--text-tertiary)\" }} /&gt;\n          )}\n        &lt;/button&gt;\n\n        {/* Node button */}\n        &lt;button\n          type=\"button\"\n          onClick={() =&gt; onNavigate(node.id)}\n          className=\"flex-1 flex items-center gap-2 py-1.5 pr-3 text-left truncate\"\n          style={{\n            color: isInPath ? \"var(--accent-primary)\" : \"var(--text-primary)\",\n            fontWeight: isCurrentNode ? 600 : 400,\n          }}\n        &gt;\n          {isExpanded ? (\n            &lt;LucideFolderOpen size={14} /&gt;\n          ) : (\n            &lt;LucideFolder size={14} /&gt;\n          )}\n          &lt;span className=\"truncate\"&gt;{node.name}&lt;/span&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n\n      {/* Children */}\n      {hasChildren &amp;&amp; isExpanded &amp;&amp; (\n        &lt;div&gt;\n          {node.children.map((child) =&gt; (\n            &lt;TreeNode\n              key={child.id}\n              node={child}\n              depth={depth + 1}\n              expanded={expanded}\n              toggleExpanded={toggleExpanded}\n              currentPath={currentPath}\n              onNavigate={onNavigate}\n            /&gt;\n          ))}\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\n/**\n * Find path from root to a given tag ID\n */\nfunction findPathToTag(tree, targetId, currentPath = []) {\n  for (const node of tree) {\n    if (node.id === targetId) {\n      return [...currentPath, node.id];\n    }\n    if (node.children &amp;&amp; node.children.length &gt; 0) {\n      const found = findPathToTag(node.children, targetId, [...currentPath, node.id]);\n      if (found) return found;\n    }\n  }\n  return null;\n}\n\nexport default FolderTreeSidebar;\n</code></pre> <p>Step 2: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/folder/FolderTreeSidebar.jsx\ngit commit -m \"feat: add FolderTreeSidebar component for desktop folder view\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-7-create-main-folderview-component","title":"Task 7: Create Main FolderView Component","text":"<p>Files: - Create: <code>client/src/components/folder/FolderView.jsx</code> - Create: <code>client/src/components/folder/index.js</code></p> <p>Step 1: Create FolderView component</p> <pre><code>// client/src/components/folder/FolderView.jsx\nimport { useState, useMemo, useCallback, useEffect } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport { getGridClasses } from \"../../constants/grids.js\";\nimport { buildFolderTree } from \"../../utils/buildFolderTree.js\";\nimport FolderCard from \"./FolderCard.jsx\";\nimport FolderBreadcrumb from \"./FolderBreadcrumb.jsx\";\nimport FolderTreeSidebar from \"./FolderTreeSidebar.jsx\";\n\n/**\n * Folder view for browsing content by tag hierarchy.\n * Desktop: Split-pane with tree sidebar + content grid\n * Mobile: Stacked with breadcrumb + content grid\n */\nconst FolderView = ({\n  items,\n  tags,\n  entityType,\n  renderItem,\n  gridDensity = \"medium\",\n  loading = false,\n  emptyMessage = \"No items found\",\n}) =&gt; {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  // Parse path from URL\n  const currentPath = useMemo(() =&gt; {\n    const pathParam = searchParams.get(\"folderPath\");\n    return pathParam ? pathParam.split(\",\").filter(Boolean) : [];\n  }, [searchParams]);\n\n  // Update URL when path changes\n  const setCurrentPath = useCallback(\n    (newPath) =&gt; {\n      setSearchParams((prev) =&gt; {\n        const next = new URLSearchParams(prev);\n        if (newPath.length &gt; 0) {\n          next.set(\"folderPath\", newPath.join(\",\"));\n        } else {\n          next.delete(\"folderPath\");\n        }\n        return next;\n      });\n    },\n    [setSearchParams]\n  );\n\n  // Build folder tree from items and tags\n  const { folders, items: leafItems, breadcrumbs } = useMemo(\n    () =&gt; buildFolderTree(items, tags, currentPath),\n    [items, tags, currentPath]\n  );\n\n  // Handle folder click - navigate into folder\n  const handleFolderClick = useCallback(\n    (folder) =&gt; {\n      if (folder.id === \"__untagged__\") {\n        // Can't navigate into untagged\n        return;\n      }\n      setCurrentPath([...currentPath, folder.id]);\n    },\n    [currentPath, setCurrentPath]\n  );\n\n  // Handle breadcrumb navigation\n  const handleBreadcrumbNavigate = useCallback(\n    (path) =&gt; {\n      setCurrentPath(path);\n    },\n    [setCurrentPath]\n  );\n\n  // Sidebar collapsed state (desktop only)\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n\n  // Check if we're on mobile\n  const [isMobile, setIsMobile] = useState(false);\n  useEffect(() =&gt; {\n    const checkMobile = () =&gt; setIsMobile(window.innerWidth &lt; 768);\n    checkMobile();\n    window.addEventListener(\"resize\", checkMobile);\n    return () =&gt; window.removeEventListener(\"resize\", checkMobile);\n  }, []);\n\n  const gridClasses = getGridClasses(\"standard\", gridDensity);\n\n  // Loading state\n  if (loading) {\n    return (\n      &lt;div className={gridClasses}&gt;\n        {[...Array(12)].map((_, i) =&gt; (\n          &lt;div\n            key={i}\n            className=\"rounded-lg animate-pulse\"\n            style={{\n              backgroundColor: \"var(--bg-tertiary)\",\n              height: \"12rem\",\n            }}\n          /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  // Mobile layout\n  if (isMobile) {\n    return (\n      &lt;div className=\"space-y-4\"&gt;\n        {/* Breadcrumb */}\n        &lt;FolderBreadcrumb\n          breadcrumbs={breadcrumbs}\n          onNavigate={handleBreadcrumbNavigate}\n        /&gt;\n\n        {/* Content grid */}\n        &lt;div className={gridClasses}&gt;\n          {/* Folders first */}\n          {folders.map((folder) =&gt; (\n            &lt;FolderCard\n              key={folder.id}\n              folder={folder}\n              onClick={handleFolderClick}\n            /&gt;\n          ))}\n\n          {/* Then leaf items */}\n          {leafItems.map((item) =&gt; renderItem(item))}\n        &lt;/div&gt;\n\n        {/* Empty state */}\n        {folders.length === 0 &amp;&amp; leafItems.length === 0 &amp;&amp; (\n          &lt;div\n            className=\"text-center py-12\"\n            style={{ color: \"var(--text-secondary)\" }}\n          &gt;\n            {emptyMessage}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    );\n  }\n\n  // Desktop layout with sidebar\n  return (\n    &lt;div className=\"flex gap-0 -mx-4 sm:-mx-6 lg:-mx-8\"&gt;\n      {/* Sidebar */}\n      {!sidebarCollapsed &amp;&amp; (\n        &lt;FolderTreeSidebar\n          tags={tags}\n          currentPath={currentPath}\n          onNavigate={setCurrentPath}\n          className=\"w-64 flex-shrink-0 h-[calc(100vh-200px)] sticky top-4\"\n        /&gt;\n      )}\n\n      {/* Main content */}\n      &lt;div className=\"flex-1 px-4 sm:px-6 lg:px-8\"&gt;\n        {/* Breadcrumb + collapse toggle */}\n        &lt;div className=\"flex items-center gap-4 mb-4\"&gt;\n          &lt;button\n            type=\"button\"\n            onClick={() =&gt; setSidebarCollapsed(!sidebarCollapsed)}\n            className=\"p-2 rounded hover:bg-[var(--bg-tertiary)] transition-colors\"\n            title={sidebarCollapsed ? \"Show sidebar\" : \"Hide sidebar\"}\n          &gt;\n            &lt;svg\n              width=\"16\"\n              height=\"16\"\n              viewBox=\"0 0 16 16\"\n              fill=\"currentColor\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              &lt;rect x=\"1\" y=\"2\" width=\"4\" height=\"12\" rx=\"1\" /&gt;\n              &lt;rect x=\"7\" y=\"2\" width=\"8\" height=\"12\" rx=\"1\" opacity=\"0.5\" /&gt;\n            &lt;/svg&gt;\n          &lt;/button&gt;\n\n          &lt;FolderBreadcrumb\n            breadcrumbs={breadcrumbs}\n            onNavigate={handleBreadcrumbNavigate}\n            className=\"flex-1\"\n          /&gt;\n        &lt;/div&gt;\n\n        {/* Content grid */}\n        &lt;div className={gridClasses}&gt;\n          {/* Folders first */}\n          {folders.map((folder) =&gt; (\n            &lt;FolderCard\n              key={folder.id}\n              folder={folder}\n              onClick={handleFolderClick}\n            /&gt;\n          ))}\n\n          {/* Then leaf items */}\n          {leafItems.map((item) =&gt; renderItem(item))}\n        &lt;/div&gt;\n\n        {/* Empty state */}\n        {folders.length === 0 &amp;&amp; leafItems.length === 0 &amp;&amp; (\n          &lt;div\n            className=\"text-center py-12\"\n            style={{ color: \"var(--text-secondary)\" }}\n          &gt;\n            {emptyMessage}\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FolderView;\n</code></pre> <p>Step 2: Create index export</p> <pre><code>// client/src/components/folder/index.js\nexport { default as FolderView } from \"./FolderView.jsx\";\nexport { default as FolderCard } from \"./FolderCard.jsx\";\nexport { default as FolderBreadcrumb } from \"./FolderBreadcrumb.jsx\";\nexport { default as FolderTreeSidebar } from \"./FolderTreeSidebar.jsx\";\n</code></pre> <p>Step 3: Verify changes</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/folder/\ngit commit -m \"feat: add FolderView component with desktop/mobile layouts\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-8-create-hook-for-fetching-all-tags","title":"Task 8: Create Hook for Fetching All Tags","text":"<p>Files: - Create: <code>client/src/hooks/useFolderViewTags.js</code></p> <p>Step 1: Create the hook</p> <pre><code>// client/src/hooks/useFolderViewTags.js\nimport { useState, useEffect, useRef } from \"react\";\nimport { libraryApi } from \"../services/api.js\";\n\n/**\n * Hook to fetch all tags with hierarchy for folder view.\n * Only fetches when folder view is active.\n */\nexport function useFolderViewTags(isActive) {\n  const [tags, setTags] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const fetchedRef = useRef(false);\n\n  useEffect(() =&gt; {\n    if (!isActive || fetchedRef.current) return;\n\n    const fetchTags = async () =&gt; {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const result = await libraryApi.findTags({\n          filter: {\n            per_page: -1,\n            sort: \"name\",\n            direction: \"ASC\",\n          },\n        });\n\n        const fetchedTags = result?.findTags?.tags || [];\n        setTags(fetchedTags);\n        fetchedRef.current = true;\n      } catch (err) {\n        console.error(\"Failed to fetch tags for folder view:\", err);\n        setError(err);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchTags();\n  }, [isActive]);\n\n  return { tags, isLoading, error };\n}\n</code></pre> <p>Step 2: Verify change</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/useFolderViewTags.js\ngit commit -m \"feat: add useFolderViewTags hook for folder view\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-9-integrate-folder-view-into-galleries-page","title":"Task 9: Integrate Folder View into Galleries Page","text":"<p>Files: - Modify: <code>client/src/components/pages/Galleries.jsx</code></p> <p>Step 1: Add imports</p> <p>Add at top of file after existing imports:</p> <pre><code>import { FolderView } from \"../folder/index.js\";\nimport { useFolderViewTags } from \"../../hooks/useFolderViewTags.js\";\n</code></pre> <p>Step 2: Add folder view mode to VIEW_MODES array</p> <p>Update the VIEW_MODES constant:</p> <pre><code>// View modes available for galleries page\nconst VIEW_MODES = [\n  { id: \"grid\", label: \"Grid view\" },\n  { id: \"wall\", label: \"Wall view\" },\n  { id: \"table\", label: \"Table view\" },\n  { id: \"timeline\", label: \"Timeline view\" },\n  { id: \"folder\", label: \"Folder view\" },\n];\n</code></pre> <p>Step 3: Add useFolderViewTags hook</p> <p>Inside the Galleries component, after the useTableColumns hook:</p> <pre><code>  // Fetch tags for folder view (only when folder view is active)\n  const { tags: folderTags, isLoading: tagsLoading } = useFolderViewTags(\n    currentViewMode === \"folder\"\n  );\n</code></pre> <p>Step 4: Add folder view rendering</p> <p>In the render function, add folder view case after timeline and before the loading/grid fallback. Find the section that starts with <code>viewMode === \"timeline\" ?</code> and add after its closing paren:</p> <pre><code>            ) : viewMode === \"folder\" ? (\n              &lt;FolderView\n                items={currentGalleries}\n                tags={folderTags}\n                entityType=\"gallery\"\n                gridDensity={gridDensity}\n                loading={isLoading || tagsLoading}\n                emptyMessage=\"No galleries found\"\n                renderItem={(gallery) =&gt; (\n                  &lt;GalleryCard\n                    key={gallery.id}\n                    gallery={gallery}\n                    fromPageTitle=\"Galleries\"\n                    tabIndex={0}\n                  /&gt;\n                )}\n              /&gt;\n</code></pre> <p>Step 5: Verify changes</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/pages/Galleries.jsx\ngit commit -m \"feat: integrate folder view into Galleries page\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-10-integrate-folder-view-into-scenesearch-page","title":"Task 10: Integrate Folder View into SceneSearch Page","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Add imports</p> <p>Add after existing imports:</p> <pre><code>import { FolderView } from \"../folder/index.js\";\nimport { useFolderViewTags } from \"../../hooks/useFolderViewTags.js\";\n</code></pre> <p>Step 2: Add folder view mode to VIEW_MODES array</p> <p>Find and update the VIEW_MODES constant to include folder:</p> <pre><code>const VIEW_MODES = [\n  { id: \"grid\", label: \"Grid view\" },\n  { id: \"wall\", label: \"Wall view\" },\n  { id: \"table\", label: \"Table view\" },\n  { id: \"timeline\", label: \"Timeline view\" },\n  { id: \"folder\", label: \"Folder view\" },\n];\n</code></pre> <p>Step 3: Add useFolderViewTags hook</p> <p>Inside the component, add the hook call (you'll need to track current view mode state first if not already tracked):</p> <pre><code>  // Fetch tags for folder view\n  const { tags: folderTags, isLoading: tagsLoading } = useFolderViewTags(\n    viewMode === \"folder\"\n  );\n</code></pre> <p>Step 4: Add folder view rendering</p> <p>Add folder view case in the render function after timeline view.</p> <p>Step 5: Verify changes</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"feat: integrate folder view into SceneSearch page\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-11-integrate-folder-view-into-images-page","title":"Task 11: Integrate Folder View into Images Page","text":"<p>Files: - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Add imports</p> <p>Add after existing imports:</p> <pre><code>import { FolderView } from \"../folder/index.js\";\nimport { useFolderViewTags } from \"../../hooks/useFolderViewTags.js\";\n</code></pre> <p>Step 2: Add folder view mode to VIEW_MODES array</p> <p>Update the VIEW_MODES constant:</p> <pre><code>const VIEW_MODES = [\n  { id: \"grid\", label: \"Grid view\" },\n  { id: \"wall\", label: \"Wall view\" },\n  { id: \"timeline\", label: \"Timeline view\" },\n  { id: \"folder\", label: \"Folder view\" },\n];\n</code></pre> <p>Step 3: Add useFolderViewTags hook</p> <p>Inside the component:</p> <pre><code>  // Fetch tags for folder view\n  const { tags: folderTags, isLoading: tagsLoading } = useFolderViewTags(\n    currentViewMode === \"folder\"\n  );\n</code></pre> <p>Step 4: Add folder view rendering</p> <p>Add folder view case in the render function after timeline view.</p> <p>Step 5: Verify changes</p> <p>Run: <code>cd client &amp;&amp; npm run lint -- --quiet</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"feat: integrate folder view into Images page\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-12-manual-testing-and-bug-fixes","title":"Task 12: Manual Testing and Bug Fixes","text":"<p>Step 1: Start dev environment</p> <p>Run: <code>docker-compose up --build -d</code></p> <p>Step 2: Test folder view on Galleries</p> <ol> <li>Navigate to Galleries page</li> <li>Click folder view icon in view mode toggle</li> <li>Verify folders appear for tags that have galleries</li> <li>Click a folder to drill down</li> <li>Verify breadcrumb shows path</li> <li>Click breadcrumb to navigate back</li> <li>Test on mobile viewport (resize browser)</li> </ol> <p>Step 3: Test folder view on Scenes</p> <p>Repeat same tests for Scenes page.</p> <p>Step 4: Test folder view on Images</p> <p>Repeat same tests for Images page.</p> <p>Step 5: Test filter interaction</p> <ol> <li>Apply a filter (e.g., studio filter)</li> <li>Verify only folders with matching content appear</li> <li>Verify counts reflect filtered totals</li> </ol> <p>Step 6: Test URL persistence</p> <ol> <li>Navigate into a folder</li> <li>Copy URL</li> <li>Refresh page</li> <li>Verify same folder is shown</li> </ol> <p>Step 7: Fix any bugs discovered</p> <p>Document and fix any issues found during testing.</p> <p>Step 8: Commit fixes</p> <pre><code>git add -A\ngit commit -m \"fix: address folder view bugs from manual testing\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#task-13-final-cleanup-and-pr-preparation","title":"Task 13: Final Cleanup and PR Preparation","text":"<p>Step 1: Run full lint check</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors or warnings</p> <p>Step 2: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run</code> Expected: All tests pass</p> <p>Step 3: Update design doc status</p> <p>Change status from \"Design\" to \"Implemented\" in <code>docs/plans/2026-01-19-folder-view-design.md</code>.</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"docs: mark folder view design as implemented\"\n</code></pre> <p>Step 5: Create PR</p> <pre><code>gh pr create --title \"feat: Add folder view mode for browsing content by tag hierarchy\" --body \"$(cat &lt;&lt;'EOF'\n## Summary\n- Adds new \"Folder\" view mode to Scenes, Galleries, and Images pages\n- Browse content by navigating through tag hierarchy visually (like Fossify Gallery)\n- Desktop: Split-pane layout with collapsible tree sidebar\n- Mobile: Breadcrumb navigation with stacked grid\n\n## Changes\n- New `FolderView` component with responsive layouts\n- New `FolderCard`, `FolderBreadcrumb`, `FolderTreeSidebar` components\n- New `buildFolderTree` utility for grouping items by tag hierarchy\n- New `useFolderViewTags` hook for fetching tag data\n- Integration into Galleries, SceneSearch, Images pages\n\n## Test plan\n- [ ] Test folder navigation on Galleries page\n- [ ] Test folder navigation on Scenes page\n- [ ] Test folder navigation on Images page\n- [ ] Test with filters applied\n- [ ] Test URL persistence (refresh maintains folder path)\n- [ ] Test desktop layout with sidebar toggle\n- [ ] Test mobile layout with breadcrumb\n- [ ] Test empty states and untagged folder\n\nCloses #223\n\n\ud83e\udd16 Generated with [Claude Code](https://claude.com/claude-code)\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-19-folder-view-implementation/#summary","title":"Summary","text":"Task Description Files 1 Add folder icon to ViewModeToggle ViewModeToggle.jsx 2 Add folder mode to entity config entityDisplayConfig.js 3 Create buildFolderTree utility + tests buildFolderTree.js, test 4 Create FolderCard component FolderCard.jsx 5 Create FolderBreadcrumb component FolderBreadcrumb.jsx 6 Create FolderTreeSidebar component FolderTreeSidebar.jsx 7 Create main FolderView component FolderView.jsx, index.js 8 Create useFolderViewTags hook useFolderViewTags.js 9 Integrate into Galleries page Galleries.jsx 10 Integrate into SceneSearch page SceneSearch.jsx 11 Integrate into Images page Images.jsx 12 Manual testing and bug fixes Various 13 Final cleanup and PR docs, PR"},{"location":"plans/2026-01-20-admin-user-modal-implementation/","title":"Admin User Management Modal Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace inline user action buttons with a comprehensive edit modal showing basic info, groups, permissions with inheritance labels, and account actions.</p> <p>Architecture: Create a new UserEditModal component that consolidates user management into a single modal with sections for basic info (username/role), group memberships, permissions with inheritance visualization, and account actions (reset password, delete). The modal will use existing API endpoints for most operations and display permission inheritance sources from PermissionService.</p> <p>Tech Stack: React, Lucide icons, existing Paper/Button UI components, existing API endpoints</p>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#design-reference","title":"Design Reference","text":"<p>From the design document (<code>docs/plans/2026-01-20-v3.3-user-management-sharing-design.md:396-458</code>):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Edit User: username                         [X] \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                 \u2502\n\u2502 Basic Info                                      \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 Username: [username]                        \u2502 \u2502\n\u2502 \u2502 Role: [Admin \u25bc]                             \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                 \u2502\n\u2502 Groups                                          \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 [x] Family                                  \u2502 \u2502\n\u2502 \u2502 [ ] Friends                                 \u2502 \u2502\n\u2502 \u2502 [x] Close Friends                           \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                 \u2502\n\u2502 Permissions                                     \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 Can share playlists                         \u2502 \u2502\n\u2502 \u2502 [x] Enabled    Inherited from: Family       \u2502 \u2502\n\u2502 \u2502                                             \u2502 \u2502\n\u2502 \u2502 Can download files                          \u2502 \u2502\n\u2502 \u2502 [ ] Disabled   Overridden (Group default:on)\u2502 \u2502\n\u2502 \u2502                                             \u2502 \u2502\n\u2502 \u2502 Can download playlists                      \u2502 \u2502\n\u2502 \u2502 [x] Enabled    Inherited from: Close Friends\u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                 \u2502\n\u2502 Account Actions                                 \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 [Reset Password]  [Regenerate Recovery Key] \u2502 \u2502\n\u2502 \u2502 [Disable Account]                           \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                      [Cancel]  [Save Changes]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-1-create-usereditmodal-component-shell","title":"Task 1: Create UserEditModal Component Shell","text":"<p>Files: - Create: <code>client/src/components/settings/UserEditModal.jsx</code></p> <p>Step 1: Create basic modal structure</p> <p>Create the modal with all sections outlined but minimal functionality:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport { User, X, Shield, Users, Key, Trash2 } from \"lucide-react\";\nimport { Button, Paper } from \"../ui/index.js\";\n\n/**\n * UserEditModal - Comprehensive user management modal\n *\n * @param {Object} props\n * @param {Object} props.user - User object to edit\n * @param {Array} props.groups - List of all groups\n * @param {Function} props.onClose - Callback when modal is closed\n * @param {Function} props.onSave - Callback when changes are saved\n * @param {Function} props.onMessage - Callback for success messages\n * @param {Function} props.onError - Callback for error messages\n * @param {Object} props.api - API instance for requests\n */\nconst UserEditModal = ({\n  user,\n  groups = [],\n  onClose,\n  onSave,\n  onMessage,\n  onError,\n  api,\n}) =&gt; {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Form state\n  const [role, setRole] = useState(user?.role || \"USER\");\n  const [userGroups, setUserGroups] = useState([]);\n  const [permissions, setPermissions] = useState(null);\n\n  // Track what has changed for save\n  const [hasChanges, setHasChanges] = useState(false);\n\n  if (!user) return null;\n\n  const handleClose = () =&gt; {\n    if (hasChanges) {\n      if (!confirm(\"You have unsaved changes. Discard them?\")) {\n        return;\n      }\n    }\n    onClose();\n  };\n\n  return (\n    &lt;div\n      className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50\"\n      onClick={handleClose}\n    &gt;\n      &lt;Paper\n        className=\"max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto\"\n        onClick={(e) =&gt; e.stopPropagation()}\n      &gt;\n        &lt;Paper.Header&gt;\n          &lt;div className=\"flex items-center justify-between\"&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;User className=\"w-5 h-5\" style={{ color: \"var(--text-secondary)\" }} /&gt;\n              &lt;Paper.Title&gt;Edit User: {user.username}&lt;/Paper.Title&gt;\n            &lt;/div&gt;\n            &lt;button\n              onClick={handleClose}\n              className=\"p-1 rounded hover:bg-opacity-80 transition-colors\"\n              style={{ color: \"var(--text-muted)\" }}\n            &gt;\n              &lt;X className=\"w-5 h-5\" /&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/Paper.Header&gt;\n\n        &lt;Paper.Body&gt;\n          &lt;div className=\"space-y-6\"&gt;\n            {/* Error display */}\n            {error &amp;&amp; (\n              &lt;div\n                className=\"p-3 rounded-lg text-sm\"\n                style={{\n                  backgroundColor: \"rgba(239, 68, 68, 0.1)\",\n                  color: \"rgb(239, 68, 68)\",\n                }}\n              &gt;\n                {error}\n              &lt;/div&gt;\n            )}\n\n            {/* Section 1: Basic Info */}\n            &lt;section&gt;\n              &lt;h3\n                className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n                style={{ color: \"var(--text-secondary)\" }}\n              &gt;\n                &lt;User size={16} /&gt;\n                Basic Info\n              &lt;/h3&gt;\n              &lt;div\n                className=\"p-4 rounded-lg space-y-4\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  border: \"1px solid var(--border-color)\",\n                }}\n              &gt;\n                {/* Username (read-only) */}\n                &lt;div&gt;\n                  &lt;label\n                    className=\"block text-sm font-medium mb-1\"\n                    style={{ color: \"var(--text-secondary)\" }}\n                  &gt;\n                    Username\n                  &lt;/label&gt;\n                  &lt;div\n                    className=\"px-3 py-2 rounded-lg text-sm\"\n                    style={{\n                      backgroundColor: \"var(--bg-tertiary)\",\n                      color: \"var(--text-primary)\",\n                    }}\n                  &gt;\n                    {user.username}\n                  &lt;/div&gt;\n                &lt;/div&gt;\n\n                {/* Role dropdown */}\n                &lt;div&gt;\n                  &lt;label\n                    className=\"block text-sm font-medium mb-1\"\n                    style={{ color: \"var(--text-secondary)\" }}\n                  &gt;\n                    Role\n                  &lt;/label&gt;\n                  &lt;select\n                    value={role}\n                    onChange={(e) =&gt; {\n                      setRole(e.target.value);\n                      setHasChanges(true);\n                    }}\n                    className=\"w-full px-3 py-2 rounded-lg text-sm\"\n                    style={{\n                      backgroundColor: \"var(--bg-tertiary)\",\n                      border: \"1px solid var(--border-color)\",\n                      color: \"var(--text-primary)\",\n                    }}\n                  &gt;\n                    &lt;option value=\"USER\"&gt;User&lt;/option&gt;\n                    &lt;option value=\"ADMIN\"&gt;Admin&lt;/option&gt;\n                  &lt;/select&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n\n            {/* Section 2: Groups - placeholder */}\n            &lt;section&gt;\n              &lt;h3\n                className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n                style={{ color: \"var(--text-secondary)\" }}\n              &gt;\n                &lt;Users size={16} /&gt;\n                Groups\n              &lt;/h3&gt;\n              &lt;div\n                className=\"p-4 rounded-lg\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  border: \"1px solid var(--border-color)\",\n                }}\n              &gt;\n                &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n                  Groups section - to be implemented\n                &lt;/p&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n\n            {/* Section 3: Permissions - placeholder */}\n            &lt;section&gt;\n              &lt;h3\n                className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n                style={{ color: \"var(--text-secondary)\" }}\n              &gt;\n                &lt;Shield size={16} /&gt;\n                Permissions\n              &lt;/h3&gt;\n              &lt;div\n                className=\"p-4 rounded-lg\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  border: \"1px solid var(--border-color)\",\n                }}\n              &gt;\n                &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n                  Permissions section - to be implemented\n                &lt;/p&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n\n            {/* Section 4: Account Actions - placeholder */}\n            &lt;section&gt;\n              &lt;h3\n                className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n                style={{ color: \"var(--text-secondary)\" }}\n              &gt;\n                &lt;Key size={16} /&gt;\n                Account Actions\n              &lt;/h3&gt;\n              &lt;div\n                className=\"p-4 rounded-lg\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  border: \"1px solid var(--border-color)\",\n                }}\n              &gt;\n                &lt;div className=\"flex flex-wrap gap-2\"&gt;\n                  &lt;Button variant=\"secondary\" size=\"sm\" disabled&gt;\n                    Reset Password\n                  &lt;/Button&gt;\n                  &lt;Button variant=\"destructive\" size=\"sm\" disabled&gt;\n                    &lt;Trash2 size={14} className=\"mr-1\" /&gt;\n                    Delete User\n                  &lt;/Button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/section&gt;\n          &lt;/div&gt;\n        &lt;/Paper.Body&gt;\n\n        {/* Footer with action buttons */}\n        &lt;div\n          className=\"px-6 py-4 flex justify-end gap-3\"\n          style={{ borderTop: \"1px solid var(--border-color)\" }}\n        &gt;\n          &lt;Button variant=\"secondary\" onClick={handleClose}&gt;\n            Cancel\n          &lt;/Button&gt;\n          &lt;Button\n            variant=\"primary\"\n            disabled={!hasChanges || loading}\n            loading={loading}\n          &gt;\n            Save Changes\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/Paper&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UserEditModal;\n</code></pre> <p>Step 2: Run linter to verify</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors for new file</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.jsx\ngit commit -m \"feat(user-modal): create UserEditModal shell with basic sections\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-2-wire-modal-into-usermanagementsection","title":"Task 2: Wire Modal into UserManagementSection","text":"<p>Files: - Modify: <code>client/src/components/settings/UserManagementSection.jsx</code></p> <p>Step 1: Add import and state</p> <p>Add at top of file after other imports: <pre><code>import UserEditModal from \"./UserEditModal.jsx\";\n</code></pre></p> <p>Add state for edit modal user: <pre><code>const [editingUser, setEditingUser] = useState(null);\n</code></pre></p> <p>Step 2: Add Edit button to user row</p> <p>Replace the current actions cell buttons with an Edit button that opens the modal. Find the actions <code>&lt;td&gt;</code> in the user table (around line 550) and add an Edit button at the start:</p> <pre><code>&lt;Button\n  onClick={() =&gt; setEditingUser(user)}\n  variant=\"secondary\"\n  size=\"sm\"\n  icon={&lt;Edit2 size={14} /&gt;}\n  className=\"px-3 py-1 text-sm whitespace-nowrap\"\n&gt;\n  Edit\n&lt;/Button&gt;\n</code></pre> <p>Step 3: Add modal render</p> <p>Add after the GroupModal render (around line 672):</p> <pre><code>{editingUser &amp;&amp; (\n  &lt;UserEditModal\n    user={editingUser}\n    groups={groups}\n    onClose={() =&gt; setEditingUser(null)}\n    onSave={() =&gt; {\n      setEditingUser(null);\n      onMessage(`User \"${editingUser.username}\" updated successfully`);\n      onUsersChanged();\n      loadGroups();\n    }}\n    onMessage={onMessage}\n    onError={onError}\n    api={api}\n  /&gt;\n)}\n</code></pre> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/settings/UserManagementSection.jsx\ngit commit -m \"feat(user-modal): wire UserEditModal into UserManagementSection\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-3-implement-groups-section","title":"Task 3: Implement Groups Section","text":"<p>Files: - Modify: <code>client/src/components/settings/UserEditModal.jsx</code></p> <p>Step 1: Load user's current group memberships</p> <p>Add useEffect to load user's groups on mount. First, add the API import at top: <pre><code>import { getUserGroupMemberships, addGroupMember, removeGroupMember } from \"../../services/api.js\";\n</code></pre></p> <p>Add loading effect after existing state declarations: <pre><code>// Load user's current group memberships\nuseEffect(() =&gt; {\n  const loadUserGroups = async () =&gt; {\n    try {\n      const response = await getUserGroupMemberships(user.id);\n      const memberGroupIds = (response.groups || []).map((g) =&gt; g.id);\n      setUserGroups(memberGroupIds);\n    } catch (err) {\n      console.error(\"Failed to load user groups:\", err);\n    }\n  };\n\n  if (user?.id) {\n    loadUserGroups();\n  }\n}, [user?.id]);\n</code></pre></p> <p>Step 2: Implement group checkbox handler</p> <p>Add handler for toggling group membership: <pre><code>const handleGroupToggle = async (groupId, isCurrentlyMember) =&gt; {\n  try {\n    if (isCurrentlyMember) {\n      await removeGroupMember(groupId, user.id);\n      setUserGroups((prev) =&gt; prev.filter((id) =&gt; id !== groupId));\n      onMessage?.(`Removed ${user.username} from group`);\n    } else {\n      await addGroupMember(groupId, user.id);\n      setUserGroups((prev) =&gt; [...prev, groupId]);\n      onMessage?.(`Added ${user.username} to group`);\n    }\n    // Mark that permissions may have changed\n    setHasChanges(true);\n  } catch (err) {\n    setError(err.message || \"Failed to update group membership\");\n  }\n};\n</code></pre></p> <p>Step 3: Replace Groups section placeholder</p> <p>Replace the Groups section with: <pre><code>{/* Section 2: Groups */}\n&lt;section&gt;\n  &lt;h3\n    className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n    style={{ color: \"var(--text-secondary)\" }}\n  &gt;\n    &lt;Users size={16} /&gt;\n    Groups\n  &lt;/h3&gt;\n  &lt;div\n    className=\"p-4 rounded-lg\"\n    style={{\n      backgroundColor: \"var(--bg-secondary)\",\n      border: \"1px solid var(--border-color)\",\n    }}\n  &gt;\n    {groups.length === 0 ? (\n      &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n        No groups available. Create a group first to assign users.\n      &lt;/p&gt;\n    ) : (\n      &lt;div className=\"space-y-2\"&gt;\n        {groups.map((group) =&gt; {\n          const isMember = userGroups.includes(group.id);\n          return (\n            &lt;label\n              key={group.id}\n              className=\"flex items-center gap-3 cursor-pointer p-2 rounded hover:bg-opacity-50\"\n              style={{ backgroundColor: isMember ? \"rgba(59, 130, 246, 0.05)\" : \"transparent\" }}\n            &gt;\n              &lt;input\n                type=\"checkbox\"\n                checked={isMember}\n                onChange={() =&gt; handleGroupToggle(group.id, isMember)}\n                className=\"w-4 h-4 rounded cursor-pointer\"\n                style={{ accentColor: \"var(--primary-color)\" }}\n              /&gt;\n              &lt;div className=\"flex-1\"&gt;\n                &lt;span\n                  className=\"text-sm font-medium\"\n                  style={{ color: \"var(--text-primary)\" }}\n                &gt;\n                  {group.name}\n                &lt;/span&gt;\n                {group.description &amp;&amp; (\n                  &lt;p\n                    className=\"text-xs mt-0.5\"\n                    style={{ color: \"var(--text-muted)\" }}\n                  &gt;\n                    {group.description}\n                  &lt;/p&gt;\n                )}\n              &lt;/div&gt;\n            &lt;/label&gt;\n          );\n        })}\n      &lt;/div&gt;\n    )}\n  &lt;/div&gt;\n&lt;/section&gt;\n</code></pre></p> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.jsx\ngit commit -m \"feat(user-modal): implement Groups section with membership toggle\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-4-add-getusergroupmemberships-api-function","title":"Task 4: Add getUserGroupMemberships API Function","text":"<p>Files: - Modify: <code>client/src/services/api.js</code></p> <p>Step 1: Add API function</p> <p>Find the groups API section (after <code>removeGroupMember</code>) and add:</p> <pre><code>/**\n * Get group memberships for a specific user (admin only)\n * @param {number} userId - User ID\n * @returns {Promise&lt;{groups: Array}&gt;}\n */\nexport const getUserGroupMemberships = (userId) =&gt;\n  apiGet(`/user/${userId}/groups`);\n</code></pre> <p>Step 2: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/services/api.js\ngit commit -m \"feat(api): add getUserGroupMemberships function\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-5-add-backend-endpoint-for-user-group-memberships","title":"Task 5: Add Backend Endpoint for User Group Memberships","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> - Modify: <code>server/routes/user.ts</code></p> <p>Step 1: Add controller function</p> <p>Add to <code>server/controllers/user.ts</code> before the closing of the file:</p> <pre><code>/**\n * Get user's group memberships (admin only)\n */\nexport const getUserGroupMemberships = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const userId = parseInt(req.params.userId);\n    if (isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid user ID\" });\n    }\n\n    const memberships = await prisma.userGroupMembership.findMany({\n      where: { userId },\n      include: {\n        group: {\n          select: {\n            id: true,\n            name: true,\n            description: true,\n            canShare: true,\n            canDownloadFiles: true,\n            canDownloadPlaylists: true,\n          },\n        },\n      },\n    });\n\n    res.json({\n      groups: memberships.map((m) =&gt; m.group),\n    });\n  } catch (error) {\n    console.error(\"Error getting user group memberships:\", error);\n    res.status(500).json({ error: \"Failed to get user group memberships\" });\n  }\n};\n</code></pre> <p>Step 2: Add route</p> <p>Add to <code>server/routes/user.ts</code> after the permissions routes (around line 84):</p> <pre><code>import { getUserGroupMemberships } from \"../controllers/user.js\";\n</code></pre> <p>Then add route: <pre><code>router.get(\n  \"/:userId/groups\",\n  requireAdmin,\n  authenticated(getUserGroupMemberships)\n);\n</code></pre></p> <p>Step 3: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/user.ts server/routes/user.ts\ngit commit -m \"feat(api): add endpoint for user group memberships\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-6-implement-permissions-section-with-inheritance-display","title":"Task 6: Implement Permissions Section with Inheritance Display","text":"<p>Files: - Modify: <code>client/src/components/settings/UserEditModal.jsx</code></p> <p>Step 1: Load permissions on mount</p> <p>Add API import at top: <pre><code>import { getUserPermissions, updateUserPermissionOverrides } from \"../../services/api.js\";\n</code></pre></p> <p>Add permissions loading in the existing useEffect or create new one: <pre><code>// Load user's permissions\nuseEffect(() =&gt; {\n  const loadPermissions = async () =&gt; {\n    try {\n      const response = await getUserPermissions(user.id);\n      setPermissions(response.permissions);\n    } catch (err) {\n      console.error(\"Failed to load user permissions:\", err);\n    }\n  };\n\n  if (user?.id) {\n    loadPermissions();\n  }\n}, [user?.id, userGroups]); // Re-fetch when groups change\n</code></pre></p> <p>Step 2: Add permission override handler</p> <pre><code>const handlePermissionOverride = async (permissionKey, newValue) =&gt; {\n  try {\n    const overrideKey = `${permissionKey}Override`;\n    const response = await updateUserPermissionOverrides(user.id, {\n      [overrideKey]: newValue,\n    });\n    setPermissions(response.permissions);\n    onMessage?.(`Permission updated for ${user.username}`);\n    setHasChanges(true);\n  } catch (err) {\n    setError(err.message || \"Failed to update permission\");\n  }\n};\n</code></pre> <p>Step 3: Add helper to render inheritance label</p> <pre><code>const renderInheritanceLabel = (source, currentValue) =&gt; {\n  if (source === \"override\") {\n    return (\n      &lt;span className=\"text-xs\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Overridden (user-level)\n      &lt;/span&gt;\n    );\n  }\n  if (source === \"default\") {\n    return (\n      &lt;span className=\"text-xs\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Default (no groups grant this)\n      &lt;/span&gt;\n    );\n  }\n  return (\n    &lt;span className=\"text-xs\" style={{ color: \"rgb(59, 130, 246)\" }}&gt;\n      Inherited from: {source}\n    &lt;/span&gt;\n  );\n};\n</code></pre> <p>Step 4: Replace Permissions section placeholder</p> <pre><code>{/* Section 3: Permissions */}\n&lt;section&gt;\n  &lt;h3\n    className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n    style={{ color: \"var(--text-secondary)\" }}\n  &gt;\n    &lt;Shield size={16} /&gt;\n    Permissions\n  &lt;/h3&gt;\n  &lt;div\n    className=\"p-4 rounded-lg space-y-4\"\n    style={{\n      backgroundColor: \"var(--bg-secondary)\",\n      border: \"1px solid var(--border-color)\",\n    }}\n  &gt;\n    {!permissions ? (\n      &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n        Loading permissions...\n      &lt;/p&gt;\n    ) : (\n      &lt;&gt;\n        {/* Can Share */}\n        &lt;div className=\"flex items-start justify-between gap-4\"&gt;\n          &lt;div className=\"flex-1\"&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;span\n                className=\"text-sm font-medium\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Can share playlists\n              &lt;/span&gt;\n            &lt;/div&gt;\n            {renderInheritanceLabel(permissions.sources.canShare, permissions.canShare)}\n          &lt;/div&gt;\n          &lt;div className=\"flex items-center gap-2\"&gt;\n            &lt;select\n              value={\n                permissions.sources.canShare === \"override\"\n                  ? String(permissions.canShare)\n                  : \"inherit\"\n              }\n              onChange={(e) =&gt; {\n                const val = e.target.value;\n                handlePermissionOverride(\n                  \"canShare\",\n                  val === \"inherit\" ? null : val === \"true\"\n                );\n              }}\n              className=\"px-2 py-1 rounded text-sm\"\n              style={{\n                backgroundColor: \"var(--bg-tertiary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"inherit\"&gt;Inherit from groups&lt;/option&gt;\n              &lt;option value=\"true\"&gt;Force enabled&lt;/option&gt;\n              &lt;option value=\"false\"&gt;Force disabled&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;span\n              className={`w-3 h-3 rounded-full ${permissions.canShare ? \"bg-green-500\" : \"bg-gray-400\"}`}\n            /&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        {/* Can Download Files */}\n        &lt;div className=\"flex items-start justify-between gap-4\"&gt;\n          &lt;div className=\"flex-1\"&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;span\n                className=\"text-sm font-medium\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Can download files\n              &lt;/span&gt;\n            &lt;/div&gt;\n            {renderInheritanceLabel(permissions.sources.canDownloadFiles, permissions.canDownloadFiles)}\n          &lt;/div&gt;\n          &lt;div className=\"flex items-center gap-2\"&gt;\n            &lt;select\n              value={\n                permissions.sources.canDownloadFiles === \"override\"\n                  ? String(permissions.canDownloadFiles)\n                  : \"inherit\"\n              }\n              onChange={(e) =&gt; {\n                const val = e.target.value;\n                handlePermissionOverride(\n                  \"canDownloadFiles\",\n                  val === \"inherit\" ? null : val === \"true\"\n                );\n              }}\n              className=\"px-2 py-1 rounded text-sm\"\n              style={{\n                backgroundColor: \"var(--bg-tertiary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"inherit\"&gt;Inherit from groups&lt;/option&gt;\n              &lt;option value=\"true\"&gt;Force enabled&lt;/option&gt;\n              &lt;option value=\"false\"&gt;Force disabled&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;span\n              className={`w-3 h-3 rounded-full ${permissions.canDownloadFiles ? \"bg-green-500\" : \"bg-gray-400\"}`}\n            /&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        {/* Can Download Playlists */}\n        &lt;div className=\"flex items-start justify-between gap-4\"&gt;\n          &lt;div className=\"flex-1\"&gt;\n            &lt;div className=\"flex items-center gap-2\"&gt;\n              &lt;span\n                className=\"text-sm font-medium\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                Can download playlists\n              &lt;/span&gt;\n            &lt;/div&gt;\n            {renderInheritanceLabel(permissions.sources.canDownloadPlaylists, permissions.canDownloadPlaylists)}\n          &lt;/div&gt;\n          &lt;div className=\"flex items-center gap-2\"&gt;\n            &lt;select\n              value={\n                permissions.sources.canDownloadPlaylists === \"override\"\n                  ? String(permissions.canDownloadPlaylists)\n                  : \"inherit\"\n              }\n              onChange={(e) =&gt; {\n                const val = e.target.value;\n                handlePermissionOverride(\n                  \"canDownloadPlaylists\",\n                  val === \"inherit\" ? null : val === \"true\"\n                );\n              }}\n              className=\"px-2 py-1 rounded text-sm\"\n              style={{\n                backgroundColor: \"var(--bg-tertiary)\",\n                border: \"1px solid var(--border-color)\",\n                color: \"var(--text-primary)\",\n              }}\n            &gt;\n              &lt;option value=\"inherit\"&gt;Inherit from groups&lt;/option&gt;\n              &lt;option value=\"true\"&gt;Force enabled&lt;/option&gt;\n              &lt;option value=\"false\"&gt;Force disabled&lt;/option&gt;\n            &lt;/select&gt;\n            &lt;span\n              className={`w-3 h-3 rounded-full ${permissions.canDownloadPlaylists ? \"bg-green-500\" : \"bg-gray-400\"}`}\n            /&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/&gt;\n    )}\n  &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <p>Step 5: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.jsx\ngit commit -m \"feat(user-modal): implement Permissions section with inheritance display\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-7-implement-account-actions-section","title":"Task 7: Implement Account Actions Section","text":"<p>Files: - Modify: <code>client/src/components/settings/UserEditModal.jsx</code></p> <p>Step 1: Add state for tracking current user</p> <p>Add prop for currentUser to know if editing self: <pre><code>const UserEditModal = ({\n  user,\n  groups = [],\n  currentUser, // Add this prop\n  onClose,\n  onSave,\n  onMessage,\n  onError,\n  api,\n}) =&gt; {\n</code></pre></p> <p>Add check: <pre><code>const isCurrentUser = user?.id === currentUser?.id;\n</code></pre></p> <p>Step 2: Implement role change handler</p> <pre><code>const handleRoleChange = async (newRole) =&gt; {\n  if (isCurrentUser) {\n    setError(\"You cannot change your own role\");\n    return;\n  }\n\n  try {\n    await api.put(`/user/${user.id}/role`, { role: newRole });\n    onMessage?.(`Role changed to ${newRole} for ${user.username}`);\n    setHasChanges(true);\n  } catch (err) {\n    setError(err.response?.data?.error || \"Failed to change role\");\n  }\n};\n</code></pre> <p>Update role dropdown onChange to use this handler.</p> <p>Step 3: Implement delete user handler</p> <pre><code>const handleDeleteUser = async () =&gt; {\n  if (isCurrentUser) {\n    setError(\"You cannot delete your own account\");\n    return;\n  }\n\n  if (!confirm(`Are you sure you want to delete user \"${user.username}\"?\\n\\nThis action cannot be undone.`)) {\n    return;\n  }\n\n  try {\n    setLoading(true);\n    await api.delete(`/user/${user.id}`);\n    onMessage?.(`User \"${user.username}\" deleted`);\n    onClose();\n    onSave?.();\n  } catch (err) {\n    setError(err.response?.data?.error || \"Failed to delete user\");\n  } finally {\n    setLoading(false);\n  }\n};\n</code></pre> <p>Step 4: Replace Account Actions section</p> <pre><code>{/* Section 4: Account Actions */}\n&lt;section&gt;\n  &lt;h3\n    className=\"text-sm font-medium mb-3 flex items-center gap-2\"\n    style={{ color: \"var(--text-secondary)\" }}\n  &gt;\n    &lt;Key size={16} /&gt;\n    Account Actions\n  &lt;/h3&gt;\n  &lt;div\n    className=\"p-4 rounded-lg\"\n    style={{\n      backgroundColor: \"var(--bg-secondary)\",\n      border: \"1px solid var(--border-color)\",\n    }}\n  &gt;\n    {isCurrentUser ? (\n      &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n        You cannot modify your own account from this modal. Use the account settings page instead.\n      &lt;/p&gt;\n    ) : (\n      &lt;div className=\"flex flex-wrap gap-2\"&gt;\n        &lt;Button\n          variant=\"secondary\"\n          size=\"sm\"\n          disabled\n          title=\"Coming in future release\"\n        &gt;\n          Reset Password\n        &lt;/Button&gt;\n        &lt;Button\n          variant=\"destructive\"\n          size=\"sm\"\n          onClick={handleDeleteUser}\n          disabled={loading}\n        &gt;\n          &lt;Trash2 size={14} className=\"mr-1\" /&gt;\n          Delete User\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    )}\n  &lt;/div&gt;\n&lt;/section&gt;\n</code></pre> <p>Step 5: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.jsx\ngit commit -m \"feat(user-modal): implement Account Actions section with delete user\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-8-update-usermanagementsection-to-pass-currentuser","title":"Task 8: Update UserManagementSection to Pass currentUser","text":"<p>Files: - Modify: <code>client/src/components/settings/UserManagementSection.jsx</code></p> <p>Step 1: Update modal props</p> <p>Update the UserEditModal render to pass currentUser:</p> <pre><code>{editingUser &amp;&amp; (\n  &lt;UserEditModal\n    user={editingUser}\n    groups={groups}\n    currentUser={currentUser}\n    onClose={() =&gt; setEditingUser(null)}\n    onSave={() =&gt; {\n      setEditingUser(null);\n      onMessage(`User \"${editingUser.username}\" updated successfully`);\n      onUsersChanged();\n      loadGroups();\n    }}\n    onMessage={onMessage}\n    onError={onError}\n    api={api}\n  /&gt;\n)}\n</code></pre> <p>Step 2: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/UserManagementSection.jsx\ngit commit -m \"feat(user-modal): pass currentUser to UserEditModal\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-9-write-tests-for-usereditmodal","title":"Task 9: Write Tests for UserEditModal","text":"<p>Files: - Create: <code>client/src/components/settings/UserEditModal.test.jsx</code></p> <p>Step 1: Create test file</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\nimport UserEditModal from \"./UserEditModal.jsx\";\n\n// Mock API functions\nvi.mock(\"../../services/api.js\", () =&gt; ({\n  getUserGroupMemberships: vi.fn(),\n  addGroupMember: vi.fn(),\n  removeGroupMember: vi.fn(),\n  getUserPermissions: vi.fn(),\n  updateUserPermissionOverrides: vi.fn(),\n}));\n\nimport {\n  getUserGroupMemberships,\n  addGroupMember,\n  removeGroupMember,\n  getUserPermissions,\n  updateUserPermissionOverrides,\n} from \"../../services/api.js\";\n\ndescribe(\"UserEditModal\", () =&gt; {\n  const mockUser = {\n    id: 1,\n    username: \"testuser\",\n    role: \"USER\",\n  };\n\n  const mockCurrentUser = {\n    id: 2,\n    username: \"admin\",\n    role: \"ADMIN\",\n  };\n\n  const mockGroups = [\n    { id: 1, name: \"Family\", description: \"Family members\", canShare: true },\n    { id: 2, name: \"Friends\", description: null, canDownloadFiles: true },\n  ];\n\n  const mockPermissions = {\n    canShare: true,\n    canDownloadFiles: false,\n    canDownloadPlaylists: false,\n    sources: {\n      canShare: \"Family\",\n      canDownloadFiles: \"default\",\n      canDownloadPlaylists: \"default\",\n    },\n  };\n\n  const mockApi = {\n    put: vi.fn(),\n    delete: vi.fn(),\n  };\n\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n    getUserGroupMemberships.mockResolvedValue({ groups: [{ id: 1 }] });\n    getUserPermissions.mockResolvedValue({ permissions: mockPermissions });\n  });\n\n  it(\"renders user info correctly\", async () =&gt; {\n    render(\n      &lt;UserEditModal\n        user={mockUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={vi.fn()}\n        onSave={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    expect(screen.getByText(\"Edit User: testuser\")).toBeInTheDocument();\n    expect(screen.getByText(\"testuser\")).toBeInTheDocument();\n  });\n\n  it(\"displays groups with correct membership state\", async () =&gt; {\n    render(\n      &lt;UserEditModal\n        user={mockUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={vi.fn()}\n        onSave={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Family\")).toBeInTheDocument();\n      expect(screen.getByText(\"Friends\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"shows inheritance label for permissions\", async () =&gt; {\n    render(\n      &lt;UserEditModal\n        user={mockUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={vi.fn()}\n        onSave={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(/Inherited from: Family/)).toBeInTheDocument();\n    });\n  });\n\n  it(\"disables delete for current user\", async () =&gt; {\n    render(\n      &lt;UserEditModal\n        user={mockCurrentUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={vi.fn()}\n        onSave={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    expect(\n      screen.getByText(/cannot modify your own account/)\n    ).toBeInTheDocument();\n  });\n\n  it(\"calls onClose when cancel is clicked\", async () =&gt; {\n    const onClose = vi.fn();\n    render(\n      &lt;UserEditModal\n        user={mockUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={onClose}\n        onSave={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    fireEvent.click(screen.getByText(\"Cancel\"));\n    expect(onClose).toHaveBeenCalled();\n  });\n\n  it(\"toggles group membership\", async () =&gt; {\n    addGroupMember.mockResolvedValue({});\n\n    render(\n      &lt;UserEditModal\n        user={mockUser}\n        groups={mockGroups}\n        currentUser={mockCurrentUser}\n        onClose={vi.fn()}\n        onSave={vi.fn()}\n        onMessage={vi.fn()}\n        api={mockApi}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Friends\")).toBeInTheDocument();\n    });\n\n    // Find the Friends checkbox (unchecked initially since user is only in group 1)\n    const checkboxes = screen.getAllByRole(\"checkbox\");\n    // Friends is the second group\n    fireEvent.click(checkboxes[1]);\n\n    await waitFor(() =&gt; {\n      expect(addGroupMember).toHaveBeenCalledWith(2, 1);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test -- UserEditModal.test</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.test.jsx\ngit commit -m \"test(user-modal): add tests for UserEditModal\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-10-simplify-user-table-actions","title":"Task 10: Simplify User Table Actions","text":"<p>Files: - Modify: <code>client/src/components/settings/UserManagementSection.jsx</code></p> <p>Step 1: Remove redundant action buttons</p> <p>Now that the modal handles these actions, simplify the user row actions. Keep only the Edit button and the \"Sync from Stash\" button (which is a specialized action):</p> <p>Replace the current actions cell content (around line 550-600) with:</p> <pre><code>&lt;td className=\"px-6 py-4 text-right\"&gt;\n  &lt;div className=\"flex justify-end gap-2 flex-wrap\"&gt;\n    &lt;Button\n      onClick={() =&gt; openSyncModal(user)}\n      variant=\"tertiary\"\n      size=\"sm\"\n      className=\"px-3 py-1 text-sm whitespace-nowrap\"\n    &gt;\n      Sync from Stash\n    &lt;/Button&gt;\n    &lt;Button\n      onClick={() =&gt; setEditingUser(user)}\n      variant=\"secondary\"\n      size=\"sm\"\n      icon={&lt;Edit2 size={14} /&gt;}\n      className=\"px-3 py-1 text-sm whitespace-nowrap\"\n    &gt;\n      Edit\n    &lt;/Button&gt;\n  &lt;/div&gt;\n&lt;/td&gt;\n</code></pre> <p>Step 2: Remove unused functions</p> <p>Remove the following functions that are now handled by the modal: - <code>deleteUser</code> - <code>changeUserRole</code></p> <p>Also remove the \"Content Restrictions\" and \"Groups\" buttons since those features can be accessed from the Edit modal (or we can add them to the modal later).</p> <p>Step 3: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/settings/UserManagementSection.jsx\ngit commit -m \"refactor(user-management): simplify user row actions, delegate to Edit modal\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#task-11-final-testing-and-cleanup","title":"Task 11: Final Testing and Cleanup","text":"<p>Files: - All modified files</p> <p>Step 1: Run full client lint</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 2: Run full server lint</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Run client tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Run server tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Manual verification checklist</p> <ul> <li> Open Settings \u2192 User Management</li> <li> Click Edit on a user \u2192 modal opens</li> <li> Basic Info section shows username (read-only) and role dropdown</li> <li> Groups section shows checkboxes for all groups</li> <li> Toggling a group checkbox updates membership immediately</li> <li> Permissions section shows inheritance labels (e.g., \"Inherited from: Family\")</li> <li> Changing permission override updates the display</li> <li> Delete User button works (with confirmation)</li> <li> Cannot delete yourself (shows message)</li> <li> Cancel button closes modal</li> <li> Clicking outside modal closes it (with unsaved changes warning if applicable)</li> </ul> <p>Step 6: Commit any final fixes</p> <pre><code>git add -A\ngit commit -m \"fix(user-modal): final cleanup and fixes\"\n</code></pre>"},{"location":"plans/2026-01-20-admin-user-modal-implementation/#summary","title":"Summary","text":"<p>This implementation creates a comprehensive User Edit Modal that consolidates user management into a single, well-organized interface. Key features:</p> <ol> <li>Basic Info: Read-only username, editable role</li> <li>Groups: Checkbox list with instant membership toggle</li> <li>Permissions: Three-state selector (inherit/force on/force off) with inheritance source labels</li> <li>Account Actions: Delete user (with confirmation)</li> </ol> <p>The modal follows the design spec from the v3.3 planning document and uses existing API endpoints where possible, adding only one new endpoint (<code>GET /user/:userId/groups</code>) for fetching user group memberships.</p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/","title":"Filtered Timeline &amp; Folder Views Design","text":"<p>Date: 2026-01-20 Branch: <code>fix/filtered-timeline-folder-views</code></p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#problem","title":"Problem","text":"<p>When timeline or folder views appear on detail pages (e.g., PerformerDetail &gt; Scenes tab), the permanent filters (like <code>performers: [id]</code>) correctly filter the results, but the timeline distribution and folder tag tree are fetched globally. This causes:</p> <ul> <li>Timeline: Shows date counts for ALL scenes, so clicking most dates shows \"no scenes found\"</li> <li>Folder: Shows ALL tags in the library, most of which are empty for that performer</li> </ul>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#solution","title":"Solution","text":"<p>Pass the permanent filters to the backend endpoints so they return context-aware distributions and tag trees:</p> <ol> <li>Timeline: <code>/api/timeline/:entityType/distribution</code> accepts optional filter params, joins through junction tables to count only matching entities</li> <li>Folder/Tags: <code>/api/tags</code> accepts optional filter params, returns only tags that exist on matching scenes (plus their parent hierarchy)</li> </ol>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#backend-changes","title":"Backend Changes","text":""},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#1-timeline-service-serverservicestimelineservicets","title":"1. Timeline Service (<code>server/services/TimelineService.ts</code>)","text":"<p>Current behavior: Queries <code>StashScene</code> (or gallery/image) directly, groups by date, returns counts.</p> <p>New behavior: Accept optional filters object. When filters are present:</p> <ul> <li>Join through junction tables (<code>ScenePerformer</code>, <code>SceneTag</code>, <code>SceneGroup</code>, <code>GalleryPerformer</code>, <code>ImagePerformer</code>, etc.)</li> <li>Apply WHERE clauses based on filter type:</li> <li><code>performers: [id]</code> \u2192 JOIN <code>ScenePerformer</code> WHERE <code>performerId IN (...)</code></li> <li><code>tags: [id]</code> \u2192 JOIN <code>SceneTag</code> WHERE <code>tagId IN (...)</code></li> <li><code>studios: [id]</code> \u2192 WHERE <code>studioId IN (...)</code></li> <li><code>groups: [id]</code> \u2192 JOIN <code>SceneGroup</code> WHERE <code>groupId IN (...)</code></li> <li>Continue to respect user exclusions and date validity checks</li> <li>Return the same <code>{ period, count }[]</code> format</li> </ul>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#2-tags-endpoint-servercontrollerstagsts-or-similar","title":"2. Tags Endpoint (<code>server/controllers/tags.ts</code> or similar)","text":"<p>Current behavior: Returns all tags from <code>StashTag</code>.</p> <p>New behavior: Accept optional <code>sceneFilter</code> query param. When present:</p> <ul> <li>Find all scene IDs matching the filter (using same junction table logic)</li> <li>Get distinct tag IDs from <code>SceneTag</code> for those scenes</li> <li>Expand to include parent tags (walk <code>parentIds</code> field) to preserve hierarchy</li> <li>Return only those tags</li> </ul>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#frontend-changes","title":"Frontend Changes","text":""},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#1-timeline-distribution-fetching-clientsrccomponentstimelineusetimelinestatejs","title":"1. Timeline Distribution Fetching (<code>client/src/components/timeline/useTimelineState.js</code>)","text":"<p>Current behavior: Fetches <code>/api/timeline/${entityType}/distribution?granularity=${zoomLevel}</code></p> <p>New behavior: - Accept a <code>filters</code> prop containing the permanent filters - Serialize relevant filter fields into query params - Fetch <code>/api/timeline/${entityType}/distribution?granularity=${zoomLevel}&amp;performerId=123</code> (or similar)</p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#2-folder-tag-fetching-clientsrchooksusefolderviewtagsjs","title":"2. Folder Tag Fetching (<code>client/src/hooks/useFolderViewTags.js</code>)","text":"<p>Current behavior: Fetches all tags with <code>per_page: -1</code></p> <p>New behavior: - Accept a <code>filters</code> prop containing the permanent filters - Pass filter params to the tags API - Fetch only tags relevant to the filtered context</p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#3-scenesearch-detail-pages","title":"3. SceneSearch &amp; Detail Pages","text":"<p>Current behavior: <code>SceneSearch</code> passes <code>permanentFilters</code> to filter results, but timeline/folder components don't receive them.</p> <p>New behavior: - <code>SceneSearch</code> passes <code>permanentFilters</code> down to <code>TimelineView</code> and <code>FolderView</code> - These components pass filters to their respective data-fetching hooks - No changes needed to detail pages themselves - they already pass <code>permanentFilters</code> to <code>SceneSearch</code></p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#api-parameter-format","title":"API Parameter Format","text":"<p>For simplicity, use flat query params rather than serializing the full filter object:</p> <p>Timeline endpoint: <pre><code>GET /api/timeline/scene/distribution?granularity=months&amp;performerId=123\nGET /api/timeline/scene/distribution?granularity=months&amp;tagId=456\nGET /api/timeline/scene/distribution?granularity=months&amp;studioId=789\nGET /api/timeline/scene/distribution?granularity=months&amp;groupId=101\n</code></pre></p> <p>Tags endpoint: <pre><code>GET /api/tags?scenePerformerId=123\nGET /api/tags?sceneTagId=456\nGET /api/tags?sceneStudioId=789\n</code></pre></p> <p>Multiple filters can be combined (AND logic): <pre><code>GET /api/timeline/scene/distribution?granularity=months&amp;performerId=123&amp;studioId=789\n</code></pre></p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#files-to-modify","title":"Files to Modify","text":"File Changes <code>server/services/TimelineService.ts</code> Add filter params, join through junction tables <code>server/controllers/timelineController.ts</code> Parse filter query params, pass to service <code>server/controllers/tags.ts</code> Add scene filter params, filter returned tags <code>client/src/components/timeline/useTimelineState.js</code> Accept filters prop, include in API call <code>client/src/hooks/useFolderViewTags.js</code> Accept filters prop, include in API call <code>client/src/components/timeline/TimelineView.jsx</code> Pass filters to hook <code>client/src/components/folder/FolderView.jsx</code> Pass filters to hook <code>client/src/components/search/SceneSearch.jsx</code> Pass permanentFilters to timeline/folder views"},{"location":"plans/2026-01-20-filtered-timeline-folder-views-design/#scope","title":"Scope","text":"<ul> <li>Applies to all entity types: scenes, galleries, images</li> <li>Works on both detail pages (with permanent filters) and main search pages (no permanent filters = global view)</li> </ul>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/","title":"Filtered Timeline &amp; Folder Views Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Make timeline and folder views respect permanent filters on detail pages, showing only relevant date distributions and tags for the filtered context.</p> <p>Architecture: Extend backend endpoints to accept filter parameters, then pass permanent filters from SceneSearch down to TimelineView and FolderView components which forward them to their data-fetching hooks.</p> <p>Tech Stack: TypeScript (server), React/JavaScript (client), Prisma raw SQL queries, Express REST API</p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-1-extend-timelineservice-to-accept-filters","title":"Task 1: Extend TimelineService to Accept Filters","text":"<p>Files: - Modify: <code>server/services/TimelineService.ts</code></p> <p>Step 1: Add filter types</p> <p>Add new interface for timeline filters after the existing interfaces (around line 14):</p> <pre><code>export interface TimelineFilters {\n  performerId?: string;\n  tagId?: string;\n  studioId?: string;\n  groupId?: string;\n}\n</code></pre> <p>Step 2: Update buildDistributionQuery signature</p> <p>Change <code>buildDistributionQuery</code> method signature (line 38) to accept filters:</p> <pre><code>buildDistributionQuery(\n  entityType: TimelineEntityType,\n  userId: number,\n  granularity: Granularity,\n  filters?: TimelineFilters\n): QueryClause {\n</code></pre> <p>Step 3: Add join clauses for scene filters</p> <p>Inside <code>buildDistributionQuery</code>, add logic to build JOIN clauses based on filters. After getting <code>config</code> and <code>format</code> (around line 44), add:</p> <pre><code>const joins: string[] = [];\nconst whereConditions: string[] = [];\nlet paramIndex = 2; // userId is param 1\n\nif (entityType === \"scene\") {\n  if (filters?.performerId) {\n    joins.push(`INNER JOIN ScenePerformer sp ON sp.sceneId = ${config.alias}.id`);\n    whereConditions.push(`sp.performerId = ?`);\n  }\n  if (filters?.tagId) {\n    joins.push(`INNER JOIN SceneTag st ON st.sceneId = ${config.alias}.id`);\n    whereConditions.push(`st.tagId = ?`);\n  }\n  if (filters?.studioId) {\n    whereConditions.push(`${config.alias}.studioId = ?`);\n  }\n  if (filters?.groupId) {\n    joins.push(`INNER JOIN SceneGroup sg ON sg.sceneId = ${config.alias}.id`);\n    whereConditions.push(`sg.groupId = ?`);\n  }\n} else if (entityType === \"gallery\") {\n  if (filters?.performerId) {\n    joins.push(`INNER JOIN GalleryPerformer gp ON gp.galleryId = ${config.alias}.id`);\n    whereConditions.push(`gp.performerId = ?`);\n  }\n  if (filters?.tagId) {\n    joins.push(`INNER JOIN GalleryTag gt ON gt.galleryId = ${config.alias}.id`);\n    whereConditions.push(`gt.tagId = ?`);\n  }\n  if (filters?.studioId) {\n    whereConditions.push(`${config.alias}.studioId = ?`);\n  }\n} else if (entityType === \"image\") {\n  if (filters?.performerId) {\n    joins.push(`INNER JOIN ImagePerformer ip ON ip.imageId = ${config.alias}.id`);\n    whereConditions.push(`ip.performerId = ?`);\n  }\n  if (filters?.tagId) {\n    joins.push(`INNER JOIN ImageTag it ON it.imageId = ${config.alias}.id`);\n    whereConditions.push(`it.tagId = ?`);\n  }\n  if (filters?.studioId) {\n    whereConditions.push(`${config.alias}.studioId = ?`);\n  }\n}\n\nconst joinClause = joins.length &gt; 0 ? joins.join(\"\\n      \") : \"\";\nconst extraWhere = whereConditions.length &gt; 0 ? `AND ${whereConditions.join(\" AND \")}` : \"\";\n</code></pre> <p>Step 4: Update SQL query to use joins and extra conditions</p> <p>Replace the SQL template (lines 48-62) with:</p> <pre><code>const sql = `\n  SELECT\n    strftime('${format}', ${config.dateField}) as period,\n    COUNT(DISTINCT ${config.alias}.id) as count\n  FROM ${config.table} ${config.alias}\n  ${joinClause}\n  LEFT JOIN UserExcludedEntity e\n    ON e.userId = ? AND e.entityType = '${entityType}' AND e.entityId = ${config.alias}.id\n  WHERE ${config.alias}.deletedAt IS NULL\n    AND e.id IS NULL\n    AND ${config.dateField} IS NOT NULL\n    AND ${config.dateField} LIKE '____-__-__'\n    ${extraWhere}\n  GROUP BY period\n  HAVING period IS NOT NULL AND period NOT LIKE '-%'\n  ORDER BY period ASC\n`.trim();\n</code></pre> <p>Step 5: Build params array with filter values</p> <p>Replace the return statement (line 64) with:</p> <pre><code>const params: (string | number)[] = [userId];\nif (filters?.performerId) params.push(filters.performerId);\nif (filters?.tagId) params.push(filters.tagId);\nif (filters?.studioId) params.push(filters.studioId);\nif (filters?.groupId) params.push(filters.groupId);\n\nreturn { sql, params };\n</code></pre> <p>Step 6: Update getDistribution to pass filters</p> <p>Update <code>getDistribution</code> method signature (line 67) and call:</p> <pre><code>async getDistribution(\n  entityType: TimelineEntityType,\n  userId: number,\n  granularity: Granularity,\n  filters?: TimelineFilters\n): Promise&lt;DistributionItem[]&gt; {\n  const { sql, params } = this.buildDistributionQuery(entityType, userId, granularity, filters);\n  // ... rest unchanged\n}\n</code></pre> <p>Step 7: Verify no TypeScript errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 8: Commit</p> <pre><code>git add server/services/TimelineService.ts\ngit commit -m \"feat(timeline): add filter support to TimelineService\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-2-update-timeline-controller-to-parse-filter-params","title":"Task 2: Update Timeline Controller to Parse Filter Params","text":"<p>Files: - Modify: <code>server/controllers/timelineController.ts</code></p> <p>Step 1: Import TimelineFilters type</p> <p>Update import (line 4) to include the new type:</p> <pre><code>import { timelineService, type Granularity, type TimelineEntityType, type TimelineFilters } from \"../services/TimelineService.js\";\n</code></pre> <p>Step 2: Parse filter query params</p> <p>In <code>getDateDistribution</code>, after extracting <code>granularity</code> (line 15), add:</p> <pre><code>// Parse optional filter params\nconst filters: TimelineFilters = {};\nif (req.query.performerId) filters.performerId = req.query.performerId as string;\nif (req.query.tagId) filters.tagId = req.query.tagId as string;\nif (req.query.studioId) filters.studioId = req.query.studioId as string;\nif (req.query.groupId) filters.groupId = req.query.groupId as string;\n</code></pre> <p>Step 3: Pass filters to service</p> <p>Update the service call (lines 29-33) to include filters:</p> <pre><code>const distribution = await timelineService.getDistribution(\n  entityType as TimelineEntityType,\n  userId,\n  granularity as Granularity,\n  Object.keys(filters).length &gt; 0 ? filters : undefined\n);\n</code></pre> <p>Step 4: Verify no TypeScript errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/timelineController.ts\ngit commit -m \"feat(timeline): parse filter query params in controller\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-3-add-tags-endpoint-for-filtered-tag-fetching","title":"Task 3: Add Tags Endpoint for Filtered Tag Fetching","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/routes/library/tags.ts</code></p> <p>Step 1: Add new endpoint function in tags controller</p> <p>Add after <code>findTagsMinimal</code> function (around line 572):</p> <pre><code>/**\n * Get tags that exist on scenes matching the given filters.\n * Used by folder view to show only relevant tags.\n */\nexport const findTagsForScenes = async (\n  req: TypedAuthRequest&lt;{ performerId?: string; tagId?: string; studioId?: string; groupId?: string }&gt;,\n  res: TypedResponse&lt;{ tags: Array&lt;{ id: string; name: string; parent_ids?: string[] }&gt; } | ApiErrorResponse&gt;\n) =&gt; {\n  try {\n    const { performerId, tagId, studioId, groupId } = req.body;\n    const userId = req.user?.id;\n    const requestingUser = req.user;\n\n    // Build query to find distinct tag IDs from matching scenes\n    let sceneTagQuery = `\n      SELECT DISTINCT st.tagId\n      FROM SceneTag st\n      INNER JOIN StashScene s ON s.id = st.sceneId\n      LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id\n      WHERE s.deletedAt IS NULL AND e.id IS NULL\n    `;\n    const params: (string | number)[] = [userId!];\n\n    if (performerId) {\n      sceneTagQuery += ` AND EXISTS (SELECT 1 FROM ScenePerformer sp WHERE sp.sceneId = s.id AND sp.performerId = ?)`;\n      params.push(performerId);\n    }\n    if (tagId) {\n      sceneTagQuery += ` AND EXISTS (SELECT 1 FROM SceneTag st2 WHERE st2.sceneId = s.id AND st2.tagId = ?)`;\n      params.push(tagId);\n    }\n    if (studioId) {\n      sceneTagQuery += ` AND s.studioId = ?`;\n      params.push(studioId);\n    }\n    if (groupId) {\n      sceneTagQuery += ` AND EXISTS (SELECT 1 FROM SceneGroup sg WHERE sg.sceneId = s.id AND sg.groupId = ?)`;\n      params.push(groupId);\n    }\n\n    const tagIdResults = await prisma.$queryRawUnsafe&lt;Array&lt;{ tagId: string }&gt;&gt;(sceneTagQuery, ...params);\n    const tagIds = new Set(tagIdResults.map(r =&gt; r.tagId));\n\n    if (tagIds.size === 0) {\n      return res.json({ tags: [] });\n    }\n\n    // Get all tags to build hierarchy\n    let allTags = await stashEntityService.getAllTags();\n\n    // Apply exclusions for non-admins\n    if (requestingUser?.role !== \"ADMIN\") {\n      allTags = await entityExclusionHelper.filterExcluded(allTags, userId, \"tag\");\n    }\n\n    // Expand to include parent tags for hierarchy\n    const expandedTagIds = new Set(tagIds);\n    const tagMap = new Map(allTags.map(t =&gt; [t.id, t]));\n\n    // Walk up parent chains\n    for (const tagId of tagIds) {\n      const tag = tagMap.get(tagId);\n      if (tag?.parent_ids) {\n        for (const parentId of tag.parent_ids) {\n          expandedTagIds.add(parentId);\n          // Also add grandparents, etc.\n          let parent = tagMap.get(parentId);\n          while (parent?.parent_ids) {\n            for (const gpId of parent.parent_ids) {\n              expandedTagIds.add(gpId);\n            }\n            // Get first parent to continue chain (tags can have multiple parents)\n            parent = parent.parent_ids[0] ? tagMap.get(parent.parent_ids[0]) : undefined;\n          }\n        }\n      }\n    }\n\n    // Filter to only expanded tags\n    const filteredTags = allTags\n      .filter(t =&gt; expandedTagIds.has(t.id))\n      .map(t =&gt; ({ id: t.id, name: t.name, parent_ids: t.parent_ids }));\n\n    res.json({ tags: filteredTags });\n  } catch (error) {\n    logger.error(\"Error in findTagsForScenes\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find tags for scenes\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 2: Add import for stashEntityService if not present</p> <p>Check imports at top of file - <code>stashEntityService</code> should already be imported.</p> <p>Step 3: Add route in tags.ts</p> <p>In <code>server/routes/library/tags.ts</code>, add import for the new function (line 4):</p> <pre><code>import {\n  findTags,\n  findTagsMinimal,\n  findTagsForScenes,\n  updateTag,\n} from \"../../controllers/library/tags.js\";\n</code></pre> <p>Step 4: Add route definition</p> <p>After the <code>/tags/minimal</code> route (around line 19), add:</p> <pre><code>// Tags filtered by scene criteria (for folder view)\nrouter.post(\"/tags/for-scenes\", requireCacheReady, authenticated(findTagsForScenes));\n</code></pre> <p>Step 5: Verify no TypeScript errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/controllers/library/tags.ts server/routes/library/tags.ts\ngit commit -m \"feat(tags): add endpoint for filtered tag fetching\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-4-update-usetimelinestate-hook-to-accept-and-use-filters","title":"Task 4: Update useTimelineState Hook to Accept and Use Filters","text":"<p>Files: - Modify: <code>client/src/components/timeline/useTimelineState.js</code></p> <p>Step 1: Add filters to hook parameters</p> <p>Update the hook function signature (line 71) to accept filters:</p> <pre><code>export function useTimelineState({ entityType, autoSelectRecent = false, initialPeriod = null, filters = null }) {\n</code></pre> <p>Step 2: Build query string with filters</p> <p>Update the <code>fetchDistribution</code> function inside the useEffect (around line 117) to include filter params:</p> <pre><code>async function fetchDistribution() {\n  setIsLoading(true);\n  setError(null);\n\n  try {\n    // Build query params\n    const params = new URLSearchParams({ granularity: zoomLevel });\n    if (filters?.performerId) params.set(\"performerId\", filters.performerId);\n    if (filters?.tagId) params.set(\"tagId\", filters.tagId);\n    if (filters?.studioId) params.set(\"studioId\", filters.studioId);\n    if (filters?.groupId) params.set(\"groupId\", filters.groupId);\n\n    const response = await apiGet(\n      `/timeline/${entityType}/distribution?${params.toString()}`\n    );\n    // ... rest unchanged\n</code></pre> <p>Step 3: Add filters to useEffect dependencies</p> <p>Update the dependency array (line 153) to include filters:</p> <pre><code>}, [entityType, zoomLevel, autoSelectRecent, filters]);\n</code></pre> <p>Step 4: Memoize filters to prevent unnecessary refetches</p> <p>Add a memoized filter key at the top of the hook (after the state declarations, around line 94):</p> <pre><code>// Memoize filter key to prevent unnecessary refetches\nconst filterKey = useMemo(() =&gt; {\n  if (!filters) return null;\n  return JSON.stringify(filters);\n}, [filters]);\n</code></pre> <p>Then use <code>filterKey</code> in the dependency array instead of <code>filters</code>:</p> <pre><code>}, [entityType, zoomLevel, autoSelectRecent, filterKey]);\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add client/src/components/timeline/useTimelineState.js\ngit commit -m \"feat(timeline): add filter support to useTimelineState hook\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-5-update-usefolderviewtags-hook-to-accept-and-use-filters","title":"Task 5: Update useFolderViewTags Hook to Accept and Use Filters","text":"<p>Files: - Modify: <code>client/src/hooks/useFolderViewTags.js</code></p> <p>Step 1: Update hook signature to accept filters</p> <p>Change the function signature (line 9) to accept filters:</p> <pre><code>export function useFolderViewTags(isActive, filters = null) {\n</code></pre> <p>Step 2: Import libraryApi POST method</p> <p>Update the import to also include a method for POST requests. Check if <code>libraryApi</code> already has a suitable method. Looking at the code, it uses <code>libraryApi.findTags</code> which is POST-based. We need to add a new method or use fetch directly.</p> <p>Add at the top of the file, after existing imports:</p> <pre><code>import { apiPost } from \"../services/api.js\";\n</code></pre> <p>Step 3: Update fetchTags to use filtered endpoint when filters present</p> <p>Replace the <code>fetchTags</code> function (lines 18-33) with:</p> <pre><code>const fetchTags = async () =&gt; {\n  setIsLoading(true);\n  setError(null);\n\n  try {\n    let fetchedTags;\n\n    // Use filtered endpoint if filters are provided\n    if (filters &amp;&amp; (filters.performerId || filters.tagId || filters.studioId || filters.groupId)) {\n      const result = await apiPost(\"/library/tags/for-scenes\", {\n        performerId: filters.performerId,\n        tagId: filters.tagId,\n        studioId: filters.studioId,\n        groupId: filters.groupId,\n      });\n      fetchedTags = result?.tags || [];\n    } else {\n      // Fetch all tags (existing behavior)\n      const result = await libraryApi.findTags({\n        filter: {\n          per_page: -1,\n          sort: \"name\",\n          direction: \"ASC\",\n        },\n      });\n      fetchedTags = result?.findTags?.tags || [];\n    }\n\n    setTags(fetchedTags);\n    fetchedRef.current = true;\n  } catch (err) {\n    console.error(\"Failed to fetch tags for folder view:\", err);\n    setError(err);\n  } finally {\n    setIsLoading(false);\n  }\n};\n</code></pre> <p>Step 4: Reset fetchedRef when filters change</p> <p>We need to refetch when filters change. Update the useEffect to:</p> <pre><code>useEffect(() =&gt; {\n  // Reset fetched flag if filters change\n  if (filters) {\n    fetchedRef.current = false;\n  }\n\n  if (!isActive || fetchedRef.current) return;\n\n  const fetchTags = async () =&gt; {\n    // ... fetchTags implementation from Step 3\n  };\n\n  fetchTags();\n}, [isActive, filters]);\n</code></pre> <p>Step 5: Use a stable filter key for comparison</p> <p>To properly detect filter changes, add memoization:</p> <pre><code>// Add at top of hook\nconst filterKey = useMemo(() =&gt; {\n  if (!filters) return null;\n  return JSON.stringify(filters);\n}, [filters]);\n\n// Add a ref to track last filter key\nconst lastFilterKeyRef = useRef(null);\n</code></pre> <p>Then update the useEffect:</p> <pre><code>useEffect(() =&gt; {\n  // Reset fetched flag if filters change\n  if (filterKey !== lastFilterKeyRef.current) {\n    fetchedRef.current = false;\n    lastFilterKeyRef.current = filterKey;\n  }\n\n  if (!isActive || fetchedRef.current) return;\n  // ... rest of fetchTags\n}, [isActive, filterKey]);\n</code></pre> <p>Step 6: Commit</p> <pre><code>git add client/src/hooks/useFolderViewTags.js\ngit commit -m \"feat(folder): add filter support to useFolderViewTags hook\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-6-update-timelineview-to-accept-and-pass-filters","title":"Task 6: Update TimelineView to Accept and Pass Filters","text":"<p>Files: - Modify: <code>client/src/components/timeline/TimelineView.jsx</code></p> <p>Step 1: Add filters prop</p> <p>Update the component props (line 11) to include filters:</p> <pre><code>function TimelineView({\n  entityType,\n  items = [],\n  renderItem,\n  onItemClick,\n  onDateFilterChange,\n  onPeriodChange,\n  initialPeriod = null,\n  loading = false,\n  emptyMessage = \"No items found\",\n  gridDensity = \"medium\",\n  className = \"\",\n  filters = null, // New prop for permanent filters\n}) {\n</code></pre> <p>Step 2: Pass filters to useTimelineState</p> <p>Update the hook call (line 24-33) to pass filters:</p> <pre><code>const {\n  zoomLevel,\n  setZoomLevel,\n  selectedPeriod,\n  selectPeriod,\n  distribution,\n  maxCount,\n  isLoading: distributionLoading,\n  ZOOM_LEVELS,\n} = useTimelineState({ entityType, autoSelectRecent: !initialPeriod, initialPeriod, filters });\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/timeline/TimelineView.jsx\ngit commit -m \"feat(timeline): pass filters prop to useTimelineState\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-7-update-folderview-to-accept-and-pass-filters","title":"Task 7: Update FolderView to Accept and Pass Filters","text":"<p>Files: - Modify: <code>client/src/components/folder/FolderView.jsx</code></p> <p>Step 1: Add filters prop</p> <p>Update the component props (line 15) to include filters:</p> <pre><code>const FolderView = ({\n  items,\n  tags,\n  renderItem,\n  gridDensity = \"medium\",\n  loading = false,\n  emptyMessage = \"No items found\",\n  onFolderPathChange,\n  filters = null, // New prop for permanent filters\n}) =&gt; {\n</code></pre> <p>Note: FolderView receives tags as a prop from SceneSearch, so we don't need to change FolderView itself to fetch tags. The filtering happens in useFolderViewTags which is called in SceneSearch.</p> <p>Step 2: Commit</p> <pre><code>git add client/src/components/folder/FolderView.jsx\ngit commit -m \"feat(folder): add filters prop to FolderView\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-8-update-scenesearch-to-pass-filters-to-timeline-and-folder-views","title":"Task 8: Update SceneSearch to Pass Filters to Timeline and Folder Views","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Extract filter values from permanentFilters</p> <p>Add a helper to extract filter IDs from permanentFilters. After the <code>contextSettings</code> useMemo (around line 123), add:</p> <pre><code>// Extract filter IDs for timeline/folder views\nconst viewFilters = useMemo(() =&gt; {\n  const filters = {};\n\n  // Extract performer ID\n  if (permanentFilters.performers?.value?.length &gt; 0) {\n    filters.performerId = String(permanentFilters.performers.value[0]);\n  }\n\n  // Extract tag ID\n  if (permanentFilters.tags?.value?.length &gt; 0) {\n    filters.tagId = String(permanentFilters.tags.value[0]);\n  }\n\n  // Extract studio ID\n  if (permanentFilters.studios?.value?.length &gt; 0) {\n    filters.studioId = String(permanentFilters.studios.value[0]);\n  }\n\n  // Extract group ID\n  if (permanentFilters.groups?.value?.length &gt; 0) {\n    filters.groupId = String(permanentFilters.groups.value[0]);\n  }\n\n  return Object.keys(filters).length &gt; 0 ? filters : null;\n}, [permanentFilters]);\n</code></pre> <p>Step 2: Pass filters to useFolderViewTags</p> <p>Update the useFolderViewTags call (lines 89-91) to pass filters:</p> <pre><code>const { tags: folderTags, isLoading: tagsLoading } = useFolderViewTags(\n  currentViewMode === \"folder\",\n  viewFilters\n);\n</code></pre> <p>Step 3: Pass filters to TimelineView</p> <p>Update the TimelineView component (lines 274-294) to include the filters prop:</p> <pre><code>&lt;TimelineView\n  entityType=\"scene\"\n  items={currentScenes}\n  renderItem={(scene) =&gt; (\n    &lt;SceneCard\n      key={scene.id}\n      scene={scene}\n      onHideSuccess={handleHideSuccess}\n      fromPageTitle={fromPageTitle}\n      tabIndex={0}\n    /&gt;\n  )}\n  onItemClick={handleSceneClick}\n  onDateFilterChange={setTimelineDateFilter}\n  onPeriodChange={setTimelinePeriod}\n  initialPeriod={timelinePeriod}\n  loading={isLoading}\n  emptyMessage=\"No scenes found for this time period\"\n  gridDensity={gridDensity}\n  filters={viewFilters}\n/&gt;\n</code></pre> <p>Step 4: Pass filters to FolderView</p> <p>Update the FolderView component (lines 295-312) to include the filters prop:</p> <pre><code>&lt;FolderView\n  items={currentScenes}\n  tags={folderTags}\n  gridDensity={gridDensity}\n  loading={isLoading || tagsLoading}\n  emptyMessage=\"No scenes found\"\n  onFolderPathChange={setFolderTagFilter}\n  filters={viewFilters}\n  renderItem={(scene) =&gt; (\n    &lt;SceneCard\n      key={scene.id}\n      scene={scene}\n      onHideSuccess={handleHideSuccess}\n      fromPageTitle={fromPageTitle}\n      tabIndex={0}\n    /&gt;\n  )}\n/&gt;\n</code></pre> <p>Step 5: Verify no lint errors</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (or only unrelated warnings)</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"feat(search): pass permanent filters to timeline and folder views\"\n</code></pre>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-9-manual-testing","title":"Task 9: Manual Testing","text":"<p>Step 1: Start development environment</p> <p>Run: <code>docker-compose up --build -d</code></p> <p>Step 2: Test timeline on performer detail page</p> <ol> <li>Navigate to a performer detail page (e.g., <code>/performer/123</code>)</li> <li>Click the Scenes tab</li> <li>Switch to Timeline view</li> <li>Verify the timeline shows only dates where that performer has scenes</li> <li>Click a date - should show scenes for that performer on that date</li> </ol> <p>Step 3: Test folder on performer detail page</p> <ol> <li>On the same performer detail page</li> <li>Switch to Folder view</li> <li>Verify only tags that appear on that performer's scenes are shown</li> <li>Navigate into a folder - scenes should be filtered by both performer AND tag</li> </ol> <p>Step 4: Test timeline on tag detail page</p> <ol> <li>Navigate to a tag detail page (e.g., <code>/tag/456</code>)</li> <li>Click the Scenes tab</li> <li>Switch to Timeline view</li> <li>Verify the timeline shows only dates where scenes with that tag exist</li> </ol> <p>Step 5: Test folder on tag detail page</p> <ol> <li>On the same tag detail page</li> <li>Switch to Folder view</li> <li>Verify only relevant tags are shown in the tree</li> </ol> <p>Step 6: Test on main scenes page (no filters)</p> <ol> <li>Navigate to <code>/scenes</code></li> <li>Switch to Timeline view - should show all dates (global)</li> <li>Switch to Folder view - should show all tags (global)</li> </ol> <p>Step 7: Commit any fixes if needed</p>"},{"location":"plans/2026-01-20-filtered-timeline-folder-views/#task-10-final-verification-and-cleanup","title":"Task 10: Final Verification and Cleanup","text":"<p>Step 1: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint &amp;&amp; cd ../server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 2: Run TypeScript checks</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit final changes</p> <pre><code>git add -A\ngit commit -m \"chore: fix any lint/type errors from timeline/folder filter implementation\"\n</code></pre> <p>Step 4: Push branch</p> <pre><code>git push -u origin fix/filtered-timeline-folder-views\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/","title":"Recovery Key &amp; Password Reset Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add self-service password recovery via recovery keys, plus admin password reset functionality.</p> <p>Architecture: Recovery keys are 28-character random strings stored plaintext in the database (for user viewing). Keys are auto-generated on login if missing. Users can view/regenerate their key in Settings &gt; Account. Self-service recovery via <code>/forgot-password</code> page. Admins can reset passwords and regenerate keys from UserEditModal.</p> <p>Tech Stack: React, Express, Prisma, bcryptjs, crypto (for key generation)</p>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#database-changes","title":"Database Changes","text":"<p>Add to User model: <pre><code>model User {\n  // ... existing fields\n\n  // Recovery key for password reset (stored plaintext for user viewing)\n  recoveryKey String?\n}\n</code></pre></p>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-1-add-recoverykey-field-to-user-model","title":"Task 1: Add recoveryKey field to User model","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add recoveryKey field</p> <p>Add after the permission override fields (around line 67): <pre><code>  // Recovery key for password reset (stored plaintext for user viewing)\n  recoveryKey String?\n</code></pre></p> <p>Step 2: Create migration</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npx prisma migrate dev --name add_recovery_key</code></p> <p>Step 3: Commit</p> <pre><code>git add server/prisma/\ngit commit -m \"feat(db): add recoveryKey field to User model\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-2-add-recovery-key-generation-utility","title":"Task 2: Add recovery key generation utility","text":"<p>Files: - Create: <code>server/utils/recoveryKey.ts</code></p> <p>Step 1: Create utility file</p> <pre><code>import crypto from \"crypto\";\n\n/**\n * Generate a 28-character recovery key\n * Format: XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX (without dashes in storage)\n * Uses uppercase alphanumeric, excluding similar chars (0/O, 1/I/L)\n */\nexport function generateRecoveryKey(): string {\n  const chars = \"ABCDEFGHJKMNPQRSTUVWXYZ23456789\";\n  const bytes = crypto.randomBytes(28);\n  let key = \"\";\n  for (let i = 0; i &lt; 28; i++) {\n    key += chars[bytes[i] % chars.length];\n  }\n  return key;\n}\n\n/**\n * Format recovery key for display (add dashes)\n */\nexport function formatRecoveryKey(key: string): string {\n  return key.match(/.{1,4}/g)?.join(\"-\") || key;\n}\n\n/**\n * Normalize recovery key for comparison (remove dashes, uppercase)\n */\nexport function normalizeRecoveryKey(key: string): string {\n  return key.replace(/-/g, \"\").toUpperCase();\n}\n</code></pre> <p>Step 2: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code></p> <p>Step 3: Commit</p> <pre><code>git add server/utils/recoveryKey.ts\ngit commit -m \"feat(utils): add recovery key generation utility\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-3-generate-recovery-key-on-login","title":"Task 3: Generate recovery key on login","text":"<p>Files: - Modify: <code>server/routes/auth.ts</code></p> <p>Step 1: Import utility</p> <p>Add import at top: <pre><code>import { generateRecoveryKey } from \"../utils/recoveryKey.js\";\n</code></pre></p> <p>Step 2: Generate key if missing</p> <p>In the login route, after successful password verification and before creating the token, add:</p> <pre><code>// Generate recovery key if user doesn't have one\nif (!user.recoveryKey) {\n  const recoveryKey = generateRecoveryKey();\n  await prisma.user.update({\n    where: { id: user.id },\n    data: { recoveryKey },\n  });\n  user.recoveryKey = recoveryKey;\n}\n</code></pre> <p>Step 3: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code></p> <p>Step 4: Commit</p> <pre><code>git add server/routes/auth.ts\ngit commit -m \"feat(auth): auto-generate recovery key on login\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-4-add-forgot-password-api-endpoints","title":"Task 4: Add forgot password API endpoints","text":"<p>Files: - Modify: <code>server/routes/auth.ts</code></p> <p>Step 1: Add init endpoint</p> <p>Add endpoint to check if user exists and has recovery key:</p> <pre><code>// Forgot password - check username and get recovery method\nrouter.post(\"/forgot-password/init\", async (req, res) =&gt; {\n  try {\n    const { username } = req.body;\n\n    if (!username) {\n      return res.status(400).json({ error: \"Username is required\" });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { username },\n      select: { id: true, recoveryKey: true },\n    });\n\n    if (!user) {\n      // Don't reveal if user exists\n      return res.json({ hasRecoveryKey: false });\n    }\n\n    res.json({ hasRecoveryKey: !!user.recoveryKey });\n  } catch (error) {\n    console.error(\"Forgot password init error:\", error);\n    res.status(500).json({ error: \"Server error\" });\n  }\n});\n</code></pre> <p>Step 2: Add verify and reset endpoint</p> <pre><code>// Forgot password - verify recovery key and set new password\nrouter.post(\"/forgot-password/reset\", async (req, res) =&gt; {\n  try {\n    const { username, recoveryKey, newPassword } = req.body;\n\n    if (!username || !recoveryKey || !newPassword) {\n      return res.status(400).json({ error: \"All fields are required\" });\n    }\n\n    if (newPassword.length &lt; 6) {\n      return res.status(400).json({ error: \"Password must be at least 6 characters\" });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { username },\n      select: { id: true, recoveryKey: true },\n    });\n\n    if (!user || !user.recoveryKey) {\n      return res.status(401).json({ error: \"Invalid username or recovery key\" });\n    }\n\n    // Normalize and compare recovery key\n    const normalizedInput = recoveryKey.replace(/-/g, \"\").toUpperCase();\n    if (normalizedInput !== user.recoveryKey) {\n      return res.status(401).json({ error: \"Invalid username or recovery key\" });\n    }\n\n    // Hash new password and update\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    await prisma.user.update({\n      where: { id: user.id },\n      data: { password: hashedPassword },\n    });\n\n    res.json({ success: true });\n  } catch (error) {\n    console.error(\"Forgot password reset error:\", error);\n    res.status(500).json({ error: \"Server error\" });\n  }\n});\n</code></pre> <p>Step 3: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code></p> <p>Step 4: Commit</p> <pre><code>git add server/routes/auth.ts\ngit commit -m \"feat(auth): add forgot password API endpoints\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-5-add-user-recovery-key-endpoints","title":"Task 5: Add user recovery key endpoints","text":"<p>Files: - Modify: <code>server/routes/user.ts</code> - Modify: <code>server/controllers/user.ts</code></p> <p>Step 1: Add getRecoveryKey controller</p> <p>In user.ts controller, add:</p> <pre><code>/**\n * Get current user's recovery key (formatted for display)\n */\nexport const getRecoveryKey = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const userId = req.user?.id;\n    if (!userId) {\n      return res.status(401).json({ error: \"Not authenticated\" });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: { recoveryKey: true },\n    });\n\n    if (!user?.recoveryKey) {\n      return res.json({ recoveryKey: null });\n    }\n\n    // Format for display\n    const formatted = user.recoveryKey.match(/.{1,4}/g)?.join(\"-\") || user.recoveryKey;\n    res.json({ recoveryKey: formatted });\n  } catch (error) {\n    console.error(\"Error getting recovery key:\", error);\n    res.status(500).json({ error: \"Failed to get recovery key\" });\n  }\n};\n</code></pre> <p>Step 2: Add regenerateRecoveryKey controller</p> <pre><code>import { generateRecoveryKey } from \"../utils/recoveryKey.js\";\n\n/**\n * Regenerate current user's recovery key\n */\nexport const regenerateRecoveryKey = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const userId = req.user?.id;\n    if (!userId) {\n      return res.status(401).json({ error: \"Not authenticated\" });\n    }\n\n    const newKey = generateRecoveryKey();\n    await prisma.user.update({\n      where: { id: userId },\n      data: { recoveryKey: newKey },\n    });\n\n    // Format for display\n    const formatted = newKey.match(/.{1,4}/g)?.join(\"-\") || newKey;\n    res.json({ recoveryKey: formatted });\n  } catch (error) {\n    console.error(\"Error regenerating recovery key:\", error);\n    res.status(500).json({ error: \"Failed to regenerate recovery key\" });\n  }\n};\n</code></pre> <p>Step 3: Add routes</p> <p>In routes/user.ts, add after change-password route:</p> <pre><code>import { getRecoveryKey, regenerateRecoveryKey } from \"../controllers/user.js\";\n\n// Recovery key routes\nrouter.get(\"/recovery-key\", authenticated(getRecoveryKey));\nrouter.post(\"/recovery-key/regenerate\", authenticated(regenerateRecoveryKey));\n</code></pre> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code></p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/user.ts server/routes/user.ts\ngit commit -m \"feat(user): add recovery key view and regenerate endpoints\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-6-add-admin-password-reset-and-recovery-key-regeneration","title":"Task 6: Add admin password reset and recovery key regeneration","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> - Modify: <code>server/routes/user.ts</code></p> <p>Step 1: Add adminResetPassword controller</p> <pre><code>/**\n * Admin: Reset a user's password\n */\nexport const adminResetPassword = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const userId = parseInt(req.params.userId);\n    if (isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid user ID\" });\n    }\n\n    const { newPassword } = req.body;\n    if (!newPassword || newPassword.length &lt; 6) {\n      return res.status(400).json({ error: \"Password must be at least 6 characters\" });\n    }\n\n    // Check user exists\n    const user = await prisma.user.findUnique({ where: { id: userId } });\n    if (!user) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    // Hash and update password\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    await prisma.user.update({\n      where: { id: userId },\n      data: { password: hashedPassword },\n    });\n\n    res.json({ success: true });\n  } catch (error) {\n    console.error(\"Error resetting password:\", error);\n    res.status(500).json({ error: \"Failed to reset password\" });\n  }\n};\n</code></pre> <p>Step 2: Add adminRegenerateRecoveryKey controller</p> <pre><code>/**\n * Admin: Regenerate a user's recovery key\n */\nexport const adminRegenerateRecoveryKey = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const userId = parseInt(req.params.userId);\n    if (isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid user ID\" });\n    }\n\n    // Check user exists\n    const user = await prisma.user.findUnique({ where: { id: userId } });\n    if (!user) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    const newKey = generateRecoveryKey();\n    await prisma.user.update({\n      where: { id: userId },\n      data: { recoveryKey: newKey },\n    });\n\n    // Format for display\n    const formatted = newKey.match(/.{1,4}/g)?.join(\"-\") || newKey;\n    res.json({ recoveryKey: formatted });\n  } catch (error) {\n    console.error(\"Error regenerating recovery key:\", error);\n    res.status(500).json({ error: \"Failed to regenerate recovery key\" });\n  }\n};\n</code></pre> <p>Step 3: Add routes</p> <p>In routes/user.ts, add in admin section:</p> <pre><code>import { adminResetPassword, adminRegenerateRecoveryKey } from \"../controllers/user.js\";\n\n// Admin: reset user password\nrouter.post(\n  \"/:userId/reset-password\",\n  requireAdmin,\n  authenticated(adminResetPassword)\n);\n\n// Admin: regenerate user recovery key\nrouter.post(\n  \"/:userId/regenerate-recovery-key\",\n  requireAdmin,\n  authenticated(adminRegenerateRecoveryKey)\n);\n</code></pre> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint -- --fix</code></p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/user.ts server/routes/user.ts\ngit commit -m \"feat(admin): add password reset and recovery key regeneration\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-7-add-api-functions-to-client","title":"Task 7: Add API functions to client","text":"<p>Files: - Modify: <code>client/src/services/api.js</code></p> <p>Step 1: Add recovery key API functions</p> <p>Add in user section:</p> <pre><code>/**\n * Get current user's recovery key\n * @returns {Promise&lt;{recoveryKey: string | null}&gt;}\n */\nexport const getRecoveryKey = () =&gt; apiGet(\"/user/recovery-key\");\n\n/**\n * Regenerate current user's recovery key\n * @returns {Promise&lt;{recoveryKey: string}&gt;}\n */\nexport const regenerateRecoveryKey = () =&gt; apiPost(\"/user/recovery-key/regenerate\");\n\n/**\n * Forgot password - check if user has recovery key\n * @param {string} username\n * @returns {Promise&lt;{hasRecoveryKey: boolean}&gt;}\n */\nexport const forgotPasswordInit = (username) =&gt;\n  apiPost(\"/auth/forgot-password/init\", { username });\n\n/**\n * Forgot password - reset with recovery key\n * @param {string} username\n * @param {string} recoveryKey\n * @param {string} newPassword\n * @returns {Promise&lt;{success: boolean}&gt;}\n */\nexport const forgotPasswordReset = (username, recoveryKey, newPassword) =&gt;\n  apiPost(\"/auth/forgot-password/reset\", { username, recoveryKey, newPassword });\n\n/**\n * Admin: Reset user's password\n * @param {number} userId\n * @param {string} newPassword\n * @returns {Promise&lt;{success: boolean}&gt;}\n */\nexport const adminResetPassword = (userId, newPassword) =&gt;\n  apiPost(`/user/${userId}/reset-password`, { newPassword });\n\n/**\n * Admin: Regenerate user's recovery key\n * @param {number} userId\n * @returns {Promise&lt;{recoveryKey: string}&gt;}\n */\nexport const adminRegenerateRecoveryKey = (userId) =&gt;\n  apiPost(`/user/${userId}/regenerate-recovery-key`);\n</code></pre> <p>Step 2: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code></p> <p>Step 3: Commit</p> <pre><code>git add client/src/services/api.js\ngit commit -m \"feat(api): add recovery key and password reset API functions\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-8-add-recovery-key-section-to-accounttab","title":"Task 8: Add Recovery Key section to AccountTab","text":"<p>Files: - Modify: <code>client/src/components/settings/tabs/AccountTab.jsx</code></p> <p>Step 1: Add state and effects</p> <p>Add imports and state: <pre><code>import { useState, useEffect } from \"react\";\nimport { Copy, RefreshCw, Eye, EyeOff } from \"lucide-react\";\nimport { getRecoveryKey, regenerateRecoveryKey } from \"../../../services/api.js\";\n\n// Add state in component:\nconst [recoveryKey, setRecoveryKey] = useState(null);\nconst [showRecoveryKey, setShowRecoveryKey] = useState(false);\nconst [keyLoading, setKeyLoading] = useState(true);\nconst [regenerating, setRegenerating] = useState(false);\n</code></pre></p> <p>Add useEffect to load key: <pre><code>useEffect(() =&gt; {\n  const loadRecoveryKey = async () =&gt; {\n    try {\n      const response = await getRecoveryKey();\n      setRecoveryKey(response.recoveryKey);\n    } catch (err) {\n      console.error(\"Failed to load recovery key:\", err);\n    } finally {\n      setKeyLoading(false);\n    }\n  };\n  loadRecoveryKey();\n}, []);\n</code></pre></p> <p>Step 2: Add regenerate handler</p> <pre><code>const handleRegenerateKey = async () =&gt; {\n  if (!confirm(\"Are you sure you want to regenerate your recovery key?\\n\\nYour old key will no longer work for password recovery.\")) {\n    return;\n  }\n\n  try {\n    setRegenerating(true);\n    const response = await regenerateRecoveryKey();\n    setRecoveryKey(response.recoveryKey);\n    setShowRecoveryKey(true);\n    showSuccess(\"Recovery key regenerated\");\n  } catch (err) {\n    showError(\"Failed to regenerate recovery key\");\n  } finally {\n    setRegenerating(false);\n  }\n};\n\nconst copyToClipboard = () =&gt; {\n  navigator.clipboard.writeText(recoveryKey);\n  showSuccess(\"Recovery key copied to clipboard\");\n};\n</code></pre> <p>Step 3: Add Recovery Key UI section</p> <p>Add after the Change Password section: <pre><code>{/* Recovery Key Section */}\n&lt;div\n  className=\"p-6 rounded-lg border mt-6\"\n  style={{\n    backgroundColor: \"var(--bg-card)\",\n    borderColor: \"var(--border-color)\",\n  }}\n&gt;\n  &lt;h3\n    className=\"text-lg font-semibold mb-2\"\n    style={{ color: \"var(--text-primary)\" }}\n  &gt;\n    Recovery Key\n  &lt;/h3&gt;\n  &lt;p\n    className=\"text-sm mb-4\"\n    style={{ color: \"var(--text-muted)\" }}\n  &gt;\n    Use this key to reset your password if you forget it. Keep it somewhere safe.\n  &lt;/p&gt;\n\n  {keyLoading ? (\n    &lt;p style={{ color: \"var(--text-muted)\" }}&gt;Loading...&lt;/p&gt;\n  ) : recoveryKey ? (\n    &lt;div className=\"space-y-4\"&gt;\n      &lt;div className=\"flex items-center gap-2\"&gt;\n        &lt;div\n          className=\"flex-1 px-4 py-3 rounded-lg font-mono text-sm\"\n          style={{\n            backgroundColor: \"var(--bg-secondary)\",\n            border: \"1px solid var(--border-color)\",\n            color: \"var(--text-primary)\",\n          }}\n        &gt;\n          {showRecoveryKey ? recoveryKey : \"\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022-\u2022\u2022\u2022\u2022\"}\n        &lt;/div&gt;\n        &lt;Button\n          variant=\"secondary\"\n          size=\"sm\"\n          onClick={() =&gt; setShowRecoveryKey(!showRecoveryKey)}\n          title={showRecoveryKey ? \"Hide key\" : \"Show key\"}\n        &gt;\n          {showRecoveryKey ? &lt;EyeOff size={16} /&gt; : &lt;Eye size={16} /&gt;}\n        &lt;/Button&gt;\n        &lt;Button\n          variant=\"secondary\"\n          size=\"sm\"\n          onClick={copyToClipboard}\n          disabled={!showRecoveryKey}\n          title=\"Copy to clipboard\"\n        &gt;\n          &lt;Copy size={16} /&gt;\n        &lt;/Button&gt;\n      &lt;/div&gt;\n      &lt;div className=\"flex justify-end\"&gt;\n        &lt;Button\n          variant=\"tertiary\"\n          size=\"sm\"\n          onClick={handleRegenerateKey}\n          disabled={regenerating}\n          loading={regenerating}\n        &gt;\n          &lt;RefreshCw size={14} className=\"mr-1\" /&gt;\n          Regenerate Key\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  ) : (\n    &lt;p style={{ color: \"var(--text-muted)\" }}&gt;\n      No recovery key set. Log out and back in to generate one.\n    &lt;/p&gt;\n  )}\n&lt;/div&gt;\n</code></pre></p> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/settings/tabs/AccountTab.jsx\ngit commit -m \"feat(account): add recovery key view and regenerate UI\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-9-create-forgotpasswordpage-component","title":"Task 9: Create ForgotPasswordPage component","text":"<p>Files: - Create: <code>client/src/components/pages/ForgotPasswordPage.jsx</code></p> <p>Step 1: Create the page component</p> <pre><code>import { useState } from \"react\";\nimport { useNavigate, Link } from \"react-router-dom\";\nimport { forgotPasswordInit, forgotPasswordReset } from \"../../services/api.js\";\nimport { Button } from \"../ui/index.js\";\n\nconst ForgotPasswordPage = () =&gt; {\n  const navigate = useNavigate();\n  const [step, setStep] = useState(1); // 1: username, 2: recovery key + new password\n  const [username, setUsername] = useState(\"\");\n  const [recoveryKey, setRecoveryKey] = useState(\"\");\n  const [newPassword, setNewPassword] = useState(\"\");\n  const [confirmPassword, setConfirmPassword] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(false);\n\n  const handleUsernameSubmit = async (e) =&gt; {\n    e.preventDefault();\n    setError(null);\n    setLoading(true);\n\n    try {\n      const response = await forgotPasswordInit(username);\n      if (response.hasRecoveryKey) {\n        setStep(2);\n      } else {\n        setError(\"This account does not have a recovery key set. Please contact an administrator.\");\n      }\n    } catch (err) {\n      setError(\"Failed to check username. Please try again.\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleResetSubmit = async (e) =&gt; {\n    e.preventDefault();\n    setError(null);\n\n    if (newPassword !== confirmPassword) {\n      setError(\"Passwords do not match\");\n      return;\n    }\n\n    if (newPassword.length &lt; 6) {\n      setError(\"Password must be at least 6 characters\");\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      await forgotPasswordReset(username, recoveryKey, newPassword);\n      setSuccess(true);\n    } catch (err) {\n      setError(err.response?.data?.error || \"Invalid recovery key or username\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (success) {\n    return (\n      &lt;div className=\"min-h-screen flex items-center justify-center p-4\" style={{ backgroundColor: \"var(--bg-primary)\" }}&gt;\n        &lt;div className=\"w-full max-w-md p-8 rounded-lg\" style={{ backgroundColor: \"var(--bg-card)\", border: \"1px solid var(--border-color)\" }}&gt;\n          &lt;h1 className=\"text-2xl font-bold mb-4 text-center\" style={{ color: \"var(--text-primary)\" }}&gt;\n            Password Reset Successful\n          &lt;/h1&gt;\n          &lt;p className=\"text-center mb-6\" style={{ color: \"var(--text-secondary)\" }}&gt;\n            Your password has been reset. You can now log in with your new password.\n          &lt;/p&gt;\n          &lt;Button variant=\"primary\" className=\"w-full\" onClick={() =&gt; navigate(\"/login\")}&gt;\n            Go to Login\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"min-h-screen flex items-center justify-center p-4\" style={{ backgroundColor: \"var(--bg-primary)\" }}&gt;\n      &lt;div className=\"w-full max-w-md p-8 rounded-lg\" style={{ backgroundColor: \"var(--bg-card)\", border: \"1px solid var(--border-color)\" }}&gt;\n        &lt;h1 className=\"text-2xl font-bold mb-6 text-center\" style={{ color: \"var(--text-primary)\" }}&gt;\n          Forgot Password\n        &lt;/h1&gt;\n\n        {error &amp;&amp; (\n          &lt;div className=\"p-3 rounded-lg mb-4 text-sm\" style={{ backgroundColor: \"rgba(239, 68, 68, 0.1)\", color: \"rgb(239, 68, 68)\" }}&gt;\n            {error}\n          &lt;/div&gt;\n        )}\n\n        {step === 1 ? (\n          &lt;form onSubmit={handleUsernameSubmit}&gt;\n            &lt;div className=\"mb-4\"&gt;\n              &lt;label htmlFor=\"username\" className=\"block text-sm font-medium mb-2\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                Username\n              &lt;/label&gt;\n              &lt;input\n                type=\"text\"\n                id=\"username\"\n                value={username}\n                onChange={(e) =&gt; setUsername(e.target.value)}\n                className=\"w-full px-4 py-2 rounded-lg\"\n                style={{ backgroundColor: \"var(--bg-secondary)\", border: \"1px solid var(--border-color)\", color: \"var(--text-primary)\" }}\n                required\n                autoFocus\n              /&gt;\n            &lt;/div&gt;\n            &lt;Button type=\"submit\" variant=\"primary\" className=\"w-full\" disabled={loading} loading={loading}&gt;\n              Continue\n            &lt;/Button&gt;\n            &lt;div className=\"mt-4 text-center\"&gt;\n              &lt;Link to=\"/login\" className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n                Back to Login\n              &lt;/Link&gt;\n            &lt;/div&gt;\n          &lt;/form&gt;\n        ) : (\n          &lt;form onSubmit={handleResetSubmit}&gt;\n            &lt;p className=\"text-sm mb-4\" style={{ color: \"var(--text-muted)\" }}&gt;\n              Enter your recovery key and choose a new password.\n            &lt;/p&gt;\n            &lt;div className=\"mb-4\"&gt;\n              &lt;label htmlFor=\"recoveryKey\" className=\"block text-sm font-medium mb-2\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                Recovery Key\n              &lt;/label&gt;\n              &lt;input\n                type=\"text\"\n                id=\"recoveryKey\"\n                value={recoveryKey}\n                onChange={(e) =&gt; setRecoveryKey(e.target.value)}\n                placeholder=\"XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX\"\n                className=\"w-full px-4 py-2 rounded-lg font-mono\"\n                style={{ backgroundColor: \"var(--bg-secondary)\", border: \"1px solid var(--border-color)\", color: \"var(--text-primary)\" }}\n                required\n                autoFocus\n              /&gt;\n            &lt;/div&gt;\n            &lt;div className=\"mb-4\"&gt;\n              &lt;label htmlFor=\"newPassword\" className=\"block text-sm font-medium mb-2\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                New Password\n              &lt;/label&gt;\n              &lt;input\n                type=\"password\"\n                id=\"newPassword\"\n                value={newPassword}\n                onChange={(e) =&gt; setNewPassword(e.target.value)}\n                className=\"w-full px-4 py-2 rounded-lg\"\n                style={{ backgroundColor: \"var(--bg-secondary)\", border: \"1px solid var(--border-color)\", color: \"var(--text-primary)\" }}\n                required\n                minLength={6}\n              /&gt;\n            &lt;/div&gt;\n            &lt;div className=\"mb-6\"&gt;\n              &lt;label htmlFor=\"confirmPassword\" className=\"block text-sm font-medium mb-2\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                Confirm New Password\n              &lt;/label&gt;\n              &lt;input\n                type=\"password\"\n                id=\"confirmPassword\"\n                value={confirmPassword}\n                onChange={(e) =&gt; setConfirmPassword(e.target.value)}\n                className=\"w-full px-4 py-2 rounded-lg\"\n                style={{ backgroundColor: \"var(--bg-secondary)\", border: \"1px solid var(--border-color)\", color: \"var(--text-primary)\" }}\n                required\n                minLength={6}\n              /&gt;\n            &lt;/div&gt;\n            &lt;Button type=\"submit\" variant=\"primary\" className=\"w-full\" disabled={loading} loading={loading}&gt;\n              Reset Password\n            &lt;/Button&gt;\n            &lt;div className=\"mt-4 text-center\"&gt;\n              &lt;button type=\"button\" onClick={() =&gt; { setStep(1); setError(null); }} className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n                Back\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/form&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ForgotPasswordPage;\n</code></pre> <p>Step 2: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code></p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/ForgotPasswordPage.jsx\ngit commit -m \"feat(auth): create ForgotPasswordPage component\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-10-add-forgot-password-route-and-login-link","title":"Task 10: Add forgot password route and login link","text":"<p>Files: - Modify: <code>client/src/App.jsx</code> - Modify: <code>client/src/components/pages/Login.jsx</code></p> <p>Step 1: Add route to App.jsx</p> <p>Import and add route: <pre><code>import ForgotPasswordPage from \"./components/pages/ForgotPasswordPage.jsx\";\n\n// In routes, add before the catch-all:\n&lt;Route path=\"/forgot-password\" element={&lt;ForgotPasswordPage /&gt;} /&gt;\n</code></pre></p> <p>Step 2: Add link to Login page</p> <p>In Login.jsx, add link below the login button: <pre><code>&lt;div className=\"mt-4 text-center\"&gt;\n  &lt;Link to=\"/forgot-password\" className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n    Forgot your password?\n  &lt;/Link&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Step 3: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code></p> <p>Step 4: Commit</p> <pre><code>git add client/src/App.jsx client/src/components/pages/Login.jsx\ngit commit -m \"feat(auth): add forgot password route and login link\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-11-add-admin-password-reset-to-usereditmodal","title":"Task 11: Add admin password reset to UserEditModal","text":"<p>Files: - Modify: <code>client/src/components/settings/UserEditModal.jsx</code></p> <p>Step 1: Add imports and state</p> <p>Add imports: <pre><code>import { adminResetPassword, adminRegenerateRecoveryKey } from \"../../services/api.js\";\n</code></pre></p> <p>Add state in UserEditModalContent: <pre><code>const [showPasswordReset, setShowPasswordReset] = useState(false);\nconst [newPassword, setNewPassword] = useState(\"\");\nconst [generatedKey, setGeneratedKey] = useState(null);\n</code></pre></p> <p>Step 2: Add password reset handler</p> <pre><code>const handleResetPassword = async () =&gt; {\n  if (newPassword.length &lt; 6) {\n    setError(\"Password must be at least 6 characters\");\n    return;\n  }\n\n  try {\n    setLoading(true);\n    await adminResetPassword(user.id, newPassword);\n    onMessage?.(`Password reset for ${user.username}`);\n    setShowPasswordReset(false);\n    setNewPassword(\"\");\n  } catch (err) {\n    setError(err.response?.data?.error || \"Failed to reset password\");\n  } finally {\n    setLoading(false);\n  }\n};\n\nconst handleRegenerateRecoveryKey = async () =&gt; {\n  if (!confirm(`Regenerate recovery key for \"${user.username}\"?\\n\\nTheir old key will no longer work.`)) {\n    return;\n  }\n\n  try {\n    setLoading(true);\n    const response = await adminRegenerateRecoveryKey(user.id);\n    setGeneratedKey(response.recoveryKey);\n    onMessage?.(`Recovery key regenerated for ${user.username}`);\n  } catch (err) {\n    setError(err.response?.data?.error || \"Failed to regenerate recovery key\");\n  } finally {\n    setLoading(false);\n  }\n};\n</code></pre> <p>Step 3: Update Account Actions section</p> <p>Replace the placeholder Reset Password button with working UI: <pre><code>{/* Account Actions */}\n&lt;section&gt;\n  {/* ... header ... */}\n  &lt;div className=\"p-4 rounded-lg\" style={{ backgroundColor: \"var(--bg-secondary)\", border: \"1px solid var(--border-color)\" }}&gt;\n    {isCurrentUser ? (\n      &lt;p className=\"text-sm\" style={{ color: \"var(--text-muted)\" }}&gt;\n        You cannot modify your own account from this modal. Use the account settings page instead.\n      &lt;/p&gt;\n    ) : (\n      &lt;div className=\"space-y-4\"&gt;\n        {/* Password Reset */}\n        {showPasswordReset ? (\n          &lt;div className=\"flex items-center gap-2\"&gt;\n            &lt;input\n              type=\"password\"\n              value={newPassword}\n              onChange={(e) =&gt; setNewPassword(e.target.value)}\n              placeholder=\"New password (min 6 chars)\"\n              className=\"flex-1 px-3 py-2 rounded text-sm\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\", border: \"1px solid var(--border-color)\", color: \"var(--text-primary)\" }}\n            /&gt;\n            &lt;Button variant=\"primary\" size=\"sm\" onClick={handleResetPassword} disabled={loading}&gt;\n              Set\n            &lt;/Button&gt;\n            &lt;Button variant=\"secondary\" size=\"sm\" onClick={() =&gt; { setShowPasswordReset(false); setNewPassword(\"\"); }}&gt;\n              Cancel\n            &lt;/Button&gt;\n          &lt;/div&gt;\n        ) : (\n          &lt;div className=\"flex flex-wrap gap-2\"&gt;\n            &lt;Button variant=\"secondary\" size=\"sm\" onClick={() =&gt; setShowPasswordReset(true)}&gt;\n              Reset Password\n            &lt;/Button&gt;\n            &lt;Button variant=\"secondary\" size=\"sm\" onClick={handleRegenerateRecoveryKey} disabled={loading}&gt;\n              &lt;Key size={14} className=\"mr-1\" /&gt;\n              Regenerate Recovery Key\n            &lt;/Button&gt;\n            &lt;Button variant=\"destructive\" size=\"sm\" onClick={handleDeleteUser} disabled={loading}&gt;\n              &lt;Trash2 size={14} className=\"mr-1\" /&gt;\n              Delete User\n            &lt;/Button&gt;\n          &lt;/div&gt;\n        )}\n\n        {/* Show generated key */}\n        {generatedKey &amp;&amp; (\n          &lt;div className=\"p-3 rounded\" style={{ backgroundColor: \"var(--bg-tertiary)\", border: \"1px solid var(--border-color)\" }}&gt;\n            &lt;p className=\"text-xs mb-1\" style={{ color: \"var(--text-muted)\" }}&gt;New recovery key (show to user):&lt;/p&gt;\n            &lt;code className=\"text-sm font-mono\" style={{ color: \"var(--text-primary)\" }}&gt;{generatedKey}&lt;/code&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    )}\n  &lt;/div&gt;\n&lt;/section&gt;\n</code></pre></p> <p>Step 4: Run linter</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint -- --fix</code></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/settings/UserEditModal.jsx\ngit commit -m \"feat(admin): add password reset and recovery key regeneration to UserEditModal\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-12-write-tests","title":"Task 12: Write tests","text":"<p>Files: - Create: <code>server/tests/utils/recoveryKey.test.ts</code> - Create: <code>client/tests/components/pages/ForgotPasswordPage.test.jsx</code></p> <p>Step 1: Create server tests</p> <pre><code>import { describe, it, expect } from \"vitest\";\nimport { generateRecoveryKey, formatRecoveryKey, normalizeRecoveryKey } from \"../../utils/recoveryKey.js\";\n\ndescribe(\"recoveryKey utils\", () =&gt; {\n  describe(\"generateRecoveryKey\", () =&gt; {\n    it(\"generates 28 character key\", () =&gt; {\n      const key = generateRecoveryKey();\n      expect(key).toHaveLength(28);\n    });\n\n    it(\"uses only valid characters\", () =&gt; {\n      const key = generateRecoveryKey();\n      const validChars = /^[ABCDEFGHJKMNPQRSTUVWXYZ23456789]+$/;\n      expect(key).toMatch(validChars);\n    });\n\n    it(\"generates unique keys\", () =&gt; {\n      const keys = new Set();\n      for (let i = 0; i &lt; 100; i++) {\n        keys.add(generateRecoveryKey());\n      }\n      expect(keys.size).toBe(100);\n    });\n  });\n\n  describe(\"formatRecoveryKey\", () =&gt; {\n    it(\"formats key with dashes\", () =&gt; {\n      const key = \"ABCD1234EFGH5678IJKL9012MNOP\";\n      expect(formatRecoveryKey(key)).toBe(\"ABCD-1234-EFGH-5678-IJKL-9012-MNOP\");\n    });\n  });\n\n  describe(\"normalizeRecoveryKey\", () =&gt; {\n    it(\"removes dashes and uppercases\", () =&gt; {\n      const input = \"abcd-1234-efgh-5678-ijkl-9012-mnop\";\n      expect(normalizeRecoveryKey(input)).toBe(\"ABCD1234EFGH5678IJKL9012MNOP\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Create client tests</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\n\nconst mockForgotPasswordInit = vi.fn();\nconst mockForgotPasswordReset = vi.fn();\n\nvi.mock(\"../../src/services/api.js\", () =&gt; ({\n  forgotPasswordInit: (...args) =&gt; mockForgotPasswordInit(...args),\n  forgotPasswordReset: (...args) =&gt; mockForgotPasswordReset(...args),\n}));\n\nimport ForgotPasswordPage from \"../../src/components/pages/ForgotPasswordPage.jsx\";\n\nconst renderPage = () =&gt; {\n  return render(\n    &lt;BrowserRouter&gt;\n      &lt;ForgotPasswordPage /&gt;\n    &lt;/BrowserRouter&gt;\n  );\n};\n\ndescribe(\"ForgotPasswordPage\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  it(\"renders username form initially\", () =&gt; {\n    renderPage();\n    expect(screen.getByLabelText(\"Username\")).toBeInTheDocument();\n    expect(screen.getByRole(\"button\", { name: \"Continue\" })).toBeInTheDocument();\n  });\n\n  it(\"shows error when user has no recovery key\", async () =&gt; {\n    mockForgotPasswordInit.mockResolvedValue({ hasRecoveryKey: false });\n    renderPage();\n\n    fireEvent.change(screen.getByLabelText(\"Username\"), { target: { value: \"testuser\" } });\n    fireEvent.click(screen.getByRole(\"button\", { name: \"Continue\" }));\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(/does not have a recovery key/)).toBeInTheDocument();\n    });\n  });\n\n  it(\"proceeds to step 2 when user has recovery key\", async () =&gt; {\n    mockForgotPasswordInit.mockResolvedValue({ hasRecoveryKey: true });\n    renderPage();\n\n    fireEvent.change(screen.getByLabelText(\"Username\"), { target: { value: \"testuser\" } });\n    fireEvent.click(screen.getByRole(\"button\", { name: \"Continue\" }));\n\n    await waitFor(() =&gt; {\n      expect(screen.getByLabelText(\"Recovery Key\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"shows success message after password reset\", async () =&gt; {\n    mockForgotPasswordInit.mockResolvedValue({ hasRecoveryKey: true });\n    mockForgotPasswordReset.mockResolvedValue({ success: true });\n    renderPage();\n\n    // Step 1\n    fireEvent.change(screen.getByLabelText(\"Username\"), { target: { value: \"testuser\" } });\n    fireEvent.click(screen.getByRole(\"button\", { name: \"Continue\" }));\n\n    await waitFor(() =&gt; {\n      expect(screen.getByLabelText(\"Recovery Key\")).toBeInTheDocument();\n    });\n\n    // Step 2\n    fireEvent.change(screen.getByLabelText(\"Recovery Key\"), { target: { value: \"ABCD-1234\" } });\n    fireEvent.change(screen.getByLabelText(\"New Password\"), { target: { value: \"newpassword\" } });\n    fireEvent.change(screen.getByLabelText(\"Confirm New Password\"), { target: { value: \"newpassword\" } });\n    fireEvent.click(screen.getByRole(\"button\", { name: \"Reset Password\" }));\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Password Reset Successful\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <code>cd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test</code> Run: <code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test</code></p> <p>Step 4: Commit</p> <pre><code>git add server/tests/ client/tests/\ngit commit -m \"test: add tests for recovery key and forgot password\"\n</code></pre>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#task-13-final-testing-and-cleanup","title":"Task 13: Final testing and cleanup","text":"<p>Step 1: Run all linters</p> <pre><code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm run lint\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm run lint\n</code></pre> <p>Step 2: Run all tests</p> <pre><code>cd /home/carrot/code/peek-stash-browser/client &amp;&amp; npm test\ncd /home/carrot/code/peek-stash-browser/server &amp;&amp; npm test\n</code></pre> <p>Step 3: Manual testing checklist</p> <ul> <li> Log in as user without recovery key \u2192 key generated</li> <li> View recovery key in Settings &gt; Account</li> <li> Copy recovery key</li> <li> Regenerate recovery key</li> <li> Log out, go to /forgot-password</li> <li> Enter username, see recovery key form</li> <li> Reset password with recovery key</li> <li> Log in with new password</li> <li> Admin: reset user password from UserEditModal</li> <li> Admin: regenerate user recovery key from UserEditModal</li> </ul>"},{"location":"plans/2026-01-20-recovery-key-password-reset/#summary","title":"Summary","text":"<p>This implementation provides:</p> <ol> <li>Auto-generated recovery keys on login (if missing)</li> <li>Self-service password recovery via <code>/forgot-password</code></li> <li>User key management in Settings &gt; Account (view, copy, regenerate)</li> <li>Admin tools in UserEditModal (reset password, regenerate recovery key)</li> </ol> <p>Key decisions: - Recovery keys stored plaintext (for user viewing) - 28-char keys using unambiguous characters (no 0/O/1/I/L) - Keys formatted with dashes for display (XXXX-XXXX-...) - Regeneration invalidates old key immediately</p>"},{"location":"plans/2026-01-20-user-groups-implementation/","title":"User Groups Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Implement User Groups as a first-class entity to enable group-based permissions and playlist sharing.</p> <p>Architecture: Two new Prisma models (<code>UserGroup</code>, <code>UserGroupMembership</code>) with a permission service that resolves effective permissions using \"most permissive wins\" logic. Admin UI for CRUD operations on groups and managing memberships. User-level permission overrides stored on the User model.</p> <p>Tech Stack: Prisma/SQLite, Express controllers, React components with existing Paper/Modal patterns.</p>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-1-database-schema-usergroup-and-usergroupmembership","title":"Task 1: Database Schema - UserGroup and UserGroupMembership","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add UserGroup model to schema</p> <p>Add after the <code>User</code> model (around line 69):</p> <pre><code>model UserGroup {\n  id          Int      @id @default(autoincrement())\n  name        String   @unique\n  description String?\n\n  // Permission defaults for group members\n  canShare             Boolean @default(false)\n  canDownloadFiles     Boolean @default(false)\n  canDownloadPlaylists Boolean @default(false)\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  members UserGroupMembership[]\n}\n\nmodel UserGroupMembership {\n  id      Int       @id @default(autoincrement())\n  userId  Int\n  groupId Int\n  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  group   UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  createdAt DateTime @default(now())\n\n  @@unique([userId, groupId])\n  @@index([userId])\n  @@index([groupId])\n}\n</code></pre> <p>Step 2: Add permission override fields to User model</p> <p>Add these fields to the <code>User</code> model (after <code>hideConfirmationDisabled</code> around line 61):</p> <pre><code>  // Permission overrides (null = inherit from groups, true/false = explicit override)\n  canShareOverride             Boolean?\n  canDownloadFilesOverride     Boolean?\n  canDownloadPlaylistsOverride Boolean?\n\n  // Group memberships relation\n  groupMemberships UserGroupMembership[]\n</code></pre> <p>Step 3: Generate and run migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add_user_groups</code></p> <p>Expected: Migration created and applied successfully.</p> <p>Step 4: Verify schema</p> <p>Run: <code>cd server &amp;&amp; npx prisma generate</code></p> <p>Expected: Prisma client regenerated with new types.</p> <p>Step 5: Commit</p> <pre><code>git add server/prisma/schema.prisma server/prisma/migrations/\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(db): add UserGroup and UserGroupMembership models\n\nIntroduces user groups for permission inheritance and sharing scope.\n- UserGroup: stores group name, description, and default permissions\n- UserGroupMembership: many-to-many join between users and groups\n- User permission overrides: canShareOverride, canDownloadFilesOverride, canDownloadPlaylistsOverride\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-2-permission-resolution-service","title":"Task 2: Permission Resolution Service","text":"<p>Files: - Create: <code>server/services/PermissionService.ts</code> - Test: <code>server/tests/services/PermissionService.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Create <code>server/tests/services/PermissionService.test.ts</code>:</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\n\n// Mock prisma before importing the service\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    user: {\n      findUnique: vi.fn(),\n    },\n    userGroup: {\n      findMany: vi.fn(),\n    },\n    userGroupMembership: {\n      findMany: vi.fn(),\n    },\n  },\n}));\n\nimport { resolveUserPermissions, type UserPermissions } from \"../../services/PermissionService.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nconst mockPrisma = vi.mocked(prisma);\n\ndescribe(\"PermissionService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"resolveUserPermissions\", () =&gt; {\n    it(\"should return all false when user has no groups and no overrides\", async () =&gt; {\n      mockPrisma.user.findUnique.mockResolvedValue({\n        id: 1,\n        canShareOverride: null,\n        canDownloadFilesOverride: null,\n        canDownloadPlaylistsOverride: null,\n        groupMemberships: [],\n      } as never);\n\n      const result = await resolveUserPermissions(1);\n\n      expect(result).toEqual({\n        canShare: false,\n        canDownloadFiles: false,\n        canDownloadPlaylists: false,\n        sources: {\n          canShare: \"default\",\n          canDownloadFiles: \"default\",\n          canDownloadPlaylists: \"default\",\n        },\n      });\n    });\n\n    it(\"should inherit permissions from single group\", async () =&gt; {\n      mockPrisma.user.findUnique.mockResolvedValue({\n        id: 1,\n        canShareOverride: null,\n        canDownloadFilesOverride: null,\n        canDownloadPlaylistsOverride: null,\n        groupMemberships: [\n          {\n            group: {\n              id: 1,\n              name: \"Family\",\n              canShare: true,\n              canDownloadFiles: false,\n              canDownloadPlaylists: true,\n            },\n          },\n        ],\n      } as never);\n\n      const result = await resolveUserPermissions(1);\n\n      expect(result).toEqual({\n        canShare: true,\n        canDownloadFiles: false,\n        canDownloadPlaylists: true,\n        sources: {\n          canShare: \"Family\",\n          canDownloadFiles: \"default\",\n          canDownloadPlaylists: \"Family\",\n        },\n      });\n    });\n\n    it(\"should use most permissive when user belongs to multiple groups\", async () =&gt; {\n      mockPrisma.user.findUnique.mockResolvedValue({\n        id: 1,\n        canShareOverride: null,\n        canDownloadFilesOverride: null,\n        canDownloadPlaylistsOverride: null,\n        groupMemberships: [\n          {\n            group: {\n              id: 1,\n              name: \"Family\",\n              canShare: true,\n              canDownloadFiles: false,\n              canDownloadPlaylists: false,\n            },\n          },\n          {\n            group: {\n              id: 2,\n              name: \"Friends\",\n              canShare: false,\n              canDownloadFiles: true,\n              canDownloadPlaylists: false,\n            },\n          },\n        ],\n      } as never);\n\n      const result = await resolveUserPermissions(1);\n\n      expect(result).toEqual({\n        canShare: true,\n        canDownloadFiles: true,\n        canDownloadPlaylists: false,\n        sources: {\n          canShare: \"Family\",\n          canDownloadFiles: \"Friends\",\n          canDownloadPlaylists: \"default\",\n        },\n      });\n    });\n\n    it(\"should let user override take precedence over group permissions\", async () =&gt; {\n      mockPrisma.user.findUnique.mockResolvedValue({\n        id: 1,\n        canShareOverride: false, // Explicit override to disable\n        canDownloadFilesOverride: true, // Explicit override to enable\n        canDownloadPlaylistsOverride: null, // Inherit from group\n        groupMemberships: [\n          {\n            group: {\n              id: 1,\n              name: \"Family\",\n              canShare: true,\n              canDownloadFiles: false,\n              canDownloadPlaylists: true,\n            },\n          },\n        ],\n      } as never);\n\n      const result = await resolveUserPermissions(1);\n\n      expect(result).toEqual({\n        canShare: false,\n        canDownloadFiles: true,\n        canDownloadPlaylists: true,\n        sources: {\n          canShare: \"override\",\n          canDownloadFiles: \"override\",\n          canDownloadPlaylists: \"Family\",\n        },\n      });\n    });\n\n    it(\"should return null for non-existent user\", async () =&gt; {\n      mockPrisma.user.findUnique.mockResolvedValue(null);\n\n      const result = await resolveUserPermissions(999);\n\n      expect(result).toBeNull();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- PermissionService.test.ts</code></p> <p>Expected: FAIL - module not found</p> <p>Step 3: Write the implementation</p> <p>Create <code>server/services/PermissionService.ts</code>:</p> <pre><code>import prisma from \"../prisma/singleton.js\";\n\nexport interface UserPermissions {\n  canShare: boolean;\n  canDownloadFiles: boolean;\n  canDownloadPlaylists: boolean;\n  sources: {\n    canShare: string; // \"default\", \"override\", or group name\n    canDownloadFiles: string;\n    canDownloadPlaylists: string;\n  };\n}\n\ntype PermissionKey = \"canShare\" | \"canDownloadFiles\" | \"canDownloadPlaylists\";\ntype OverrideKey =\n  | \"canShareOverride\"\n  | \"canDownloadFilesOverride\"\n  | \"canDownloadPlaylistsOverride\";\n\nconst PERMISSION_KEYS: { permission: PermissionKey; override: OverrideKey }[] = [\n  { permission: \"canShare\", override: \"canShareOverride\" },\n  { permission: \"canDownloadFiles\", override: \"canDownloadFilesOverride\" },\n  { permission: \"canDownloadPlaylists\", override: \"canDownloadPlaylistsOverride\" },\n];\n\nexport async function resolveUserPermissions(\n  userId: number\n): Promise&lt;UserPermissions | null&gt; {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: {\n      canShareOverride: true,\n      canDownloadFilesOverride: true,\n      canDownloadPlaylistsOverride: true,\n      groupMemberships: {\n        select: {\n          group: {\n            select: {\n              id: true,\n              name: true,\n              canShare: true,\n              canDownloadFiles: true,\n              canDownloadPlaylists: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!user) {\n    return null;\n  }\n\n  const result: UserPermissions = {\n    canShare: false,\n    canDownloadFiles: false,\n    canDownloadPlaylists: false,\n    sources: {\n      canShare: \"default\",\n      canDownloadFiles: \"default\",\n      canDownloadPlaylists: \"default\",\n    },\n  };\n\n  const groups = user.groupMemberships.map((m) =&gt; m.group);\n\n  for (const { permission, override } of PERMISSION_KEYS) {\n    const overrideValue = user[override];\n\n    // User override takes precedence\n    if (overrideValue !== null) {\n      result[permission] = overrideValue;\n      result.sources[permission] = \"override\";\n      continue;\n    }\n\n    // Find first group that grants permission (most permissive wins)\n    const grantingGroup = groups.find((g) =&gt; g[permission] === true);\n    if (grantingGroup) {\n      result[permission] = true;\n      result.sources[permission] = grantingGroup.name;\n    }\n    // Otherwise stays false with \"default\" source\n  }\n\n  return result;\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- PermissionService.test.ts</code></p> <p>Expected: All 5 tests PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/PermissionService.ts server/tests/services/PermissionService.test.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(server): add PermissionService for group-based permission resolution\n\nImplements \"most permissive wins\" logic:\n- User with no groups and no overrides gets all permissions false\n- Permissions inherit from any group the user belongs to\n- If multiple groups, first group granting permission wins\n- User-level overrides always take precedence\n\nReturns source information for UI display (which group granted permission).\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-3-admin-api-group-crud-endpoints","title":"Task 3: Admin API - Group CRUD Endpoints","text":"<p>Files: - Create: <code>server/controllers/groups.ts</code> - Create: <code>server/routes/groups.ts</code> - Modify: <code>server/initializers/api.ts</code> - Test: <code>server/tests/controllers/groups.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Create <code>server/tests/controllers/groups.test.ts</code>:</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\nimport type { Response } from \"express\";\nimport type { AuthenticatedRequest } from \"../../middleware/auth.js\";\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    userGroup: {\n      findMany: vi.fn(),\n      findUnique: vi.fn(),\n      create: vi.fn(),\n      update: vi.fn(),\n      delete: vi.fn(),\n    },\n    userGroupMembership: {\n      create: vi.fn(),\n      delete: vi.fn(),\n      findUnique: vi.fn(),\n    },\n  },\n}));\n\nimport {\n  getAllGroups,\n  getGroup,\n  createGroup,\n  updateGroup,\n  deleteGroup,\n  addMember,\n  removeMember,\n} from \"../../controllers/groups.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nconst mockPrisma = vi.mocked(prisma);\n\ndescribe(\"Groups Controller\", () =&gt; {\n  let mockRequest: Partial&lt;AuthenticatedRequest&gt;;\n  let mockResponse: Partial&lt;Response&gt;;\n  let responseJson: ReturnType&lt;typeof vi.fn&gt;;\n  let responseStatus: ReturnType&lt;typeof vi.fn&gt;;\n\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n    responseJson = vi.fn();\n    responseStatus = vi.fn(() =&gt; ({ json: responseJson }));\n    mockResponse = { json: responseJson, status: responseStatus };\n  });\n\n  describe(\"getAllGroups\", () =&gt; {\n    it(\"should return 403 if user is not admin\", async () =&gt; {\n      mockRequest = { user: { id: 1, role: \"USER\" } };\n\n      await getAllGroups(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(responseStatus).toHaveBeenCalledWith(403);\n    });\n\n    it(\"should return all groups with member counts\", async () =&gt; {\n      mockRequest = { user: { id: 1, role: \"ADMIN\" } };\n      mockPrisma.userGroup.findMany.mockResolvedValue([\n        {\n          id: 1,\n          name: \"Family\",\n          description: \"Family members\",\n          canShare: true,\n          canDownloadFiles: false,\n          canDownloadPlaylists: false,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          _count: { members: 3 },\n        },\n      ] as never);\n\n      await getAllGroups(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(responseJson).toHaveBeenCalledWith({\n        groups: expect.arrayContaining([\n          expect.objectContaining({ name: \"Family\", memberCount: 3 }),\n        ]),\n      });\n    });\n  });\n\n  describe(\"createGroup\", () =&gt; {\n    it(\"should return 400 if name is missing\", async () =&gt; {\n      mockRequest = { user: { id: 1, role: \"ADMIN\" }, body: {} };\n\n      await createGroup(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(responseStatus).toHaveBeenCalledWith(400);\n    });\n\n    it(\"should return 409 if name already exists\", async () =&gt; {\n      mockRequest = { user: { id: 1, role: \"ADMIN\" }, body: { name: \"Family\" } };\n      mockPrisma.userGroup.findUnique.mockResolvedValue({ id: 1 } as never);\n\n      await createGroup(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(responseStatus).toHaveBeenCalledWith(409);\n    });\n\n    it(\"should create group with permissions\", async () =&gt; {\n      mockRequest = {\n        user: { id: 1, role: \"ADMIN\" },\n        body: {\n          name: \"Friends\",\n          description: \"Close friends\",\n          canShare: true,\n          canDownloadFiles: true,\n        },\n      };\n      mockPrisma.userGroup.findUnique.mockResolvedValue(null);\n      mockPrisma.userGroup.create.mockResolvedValue({\n        id: 2,\n        name: \"Friends\",\n        description: \"Close friends\",\n        canShare: true,\n        canDownloadFiles: true,\n        canDownloadPlaylists: false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      } as never);\n\n      await createGroup(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(mockPrisma.userGroup.create).toHaveBeenCalledWith({\n        data: expect.objectContaining({\n          name: \"Friends\",\n          canShare: true,\n          canDownloadFiles: true,\n        }),\n      });\n      expect(responseStatus).toHaveBeenCalledWith(201);\n    });\n  });\n\n  describe(\"deleteGroup\", () =&gt; {\n    it(\"should delete group by id\", async () =&gt; {\n      mockRequest = { user: { id: 1, role: \"ADMIN\" }, params: { id: \"1\" } };\n      mockPrisma.userGroup.findUnique.mockResolvedValue({ id: 1, name: \"Family\" } as never);\n      mockPrisma.userGroup.delete.mockResolvedValue({ id: 1 } as never);\n\n      await deleteGroup(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(mockPrisma.userGroup.delete).toHaveBeenCalledWith({ where: { id: 1 } });\n      expect(responseJson).toHaveBeenCalledWith({ success: true });\n    });\n  });\n\n  describe(\"addMember\", () =&gt; {\n    it(\"should add user to group\", async () =&gt; {\n      mockRequest = {\n        user: { id: 1, role: \"ADMIN\" },\n        params: { id: \"1\" },\n        body: { userId: 2 },\n      };\n      mockPrisma.userGroup.findUnique.mockResolvedValue({ id: 1 } as never);\n      mockPrisma.userGroupMembership.findUnique.mockResolvedValue(null);\n      mockPrisma.userGroupMembership.create.mockResolvedValue({\n        id: 1,\n        userId: 2,\n        groupId: 1,\n      } as never);\n\n      await addMember(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(mockPrisma.userGroupMembership.create).toHaveBeenCalledWith({\n        data: { userId: 2, groupId: 1 },\n      });\n      expect(responseStatus).toHaveBeenCalledWith(201);\n    });\n\n    it(\"should return 409 if user already in group\", async () =&gt; {\n      mockRequest = {\n        user: { id: 1, role: \"ADMIN\" },\n        params: { id: \"1\" },\n        body: { userId: 2 },\n      };\n      mockPrisma.userGroup.findUnique.mockResolvedValue({ id: 1 } as never);\n      mockPrisma.userGroupMembership.findUnique.mockResolvedValue({ id: 1 } as never);\n\n      await addMember(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(responseStatus).toHaveBeenCalledWith(409);\n    });\n  });\n\n  describe(\"removeMember\", () =&gt; {\n    it(\"should remove user from group\", async () =&gt; {\n      mockRequest = {\n        user: { id: 1, role: \"ADMIN\" },\n        params: { id: \"1\", userId: \"2\" },\n      };\n      mockPrisma.userGroupMembership.findUnique.mockResolvedValue({ id: 1 } as never);\n      mockPrisma.userGroupMembership.delete.mockResolvedValue({ id: 1 } as never);\n\n      await removeMember(mockRequest as AuthenticatedRequest, mockResponse as Response);\n\n      expect(mockPrisma.userGroupMembership.delete).toHaveBeenCalled();\n      expect(responseJson).toHaveBeenCalledWith({ success: true });\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- groups.test.ts</code></p> <p>Expected: FAIL - module not found</p> <p>Step 3: Write the controller implementation</p> <p>Create <code>server/controllers/groups.ts</code>:</p> <pre><code>import { Response } from \"express\";\nimport prisma from \"../prisma/singleton.js\";\nimport { AuthenticatedRequest } from \"../middleware/auth.js\";\n\nexport const getAllGroups = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groups = await prisma.userGroup.findMany({\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        canShare: true,\n        canDownloadFiles: true,\n        canDownloadPlaylists: true,\n        createdAt: true,\n        updatedAt: true,\n        _count: { select: { members: true } },\n      },\n      orderBy: { name: \"asc\" },\n    });\n\n    res.json({\n      groups: groups.map((g) =&gt; ({\n        ...g,\n        memberCount: g._count.members,\n        _count: undefined,\n      })),\n    });\n  } catch (error) {\n    console.error(\"Error getting groups:\", error);\n    res.status(500).json({ error: \"Failed to get groups\" });\n  }\n};\n\nexport const getGroup = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groupId = parseInt(req.params.id);\n    if (isNaN(groupId)) {\n      return res.status(400).json({ error: \"Invalid group ID\" });\n    }\n\n    const group = await prisma.userGroup.findUnique({\n      where: { id: groupId },\n      include: {\n        members: {\n          select: {\n            user: {\n              select: { id: true, username: true, role: true },\n            },\n          },\n        },\n      },\n    });\n\n    if (!group) {\n      return res.status(404).json({ error: \"Group not found\" });\n    }\n\n    res.json({\n      group: {\n        ...group,\n        members: group.members.map((m) =&gt; m.user),\n      },\n    });\n  } catch (error) {\n    console.error(\"Error getting group:\", error);\n    res.status(500).json({ error: \"Failed to get group\" });\n  }\n};\n\nexport const createGroup = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const { name, description, canShare, canDownloadFiles, canDownloadPlaylists } =\n      req.body;\n\n    if (!name || typeof name !== \"string\" || name.trim().length === 0) {\n      return res.status(400).json({ error: \"Group name is required\" });\n    }\n\n    const existing = await prisma.userGroup.findUnique({\n      where: { name: name.trim() },\n    });\n\n    if (existing) {\n      return res.status(409).json({ error: \"Group name already exists\" });\n    }\n\n    const group = await prisma.userGroup.create({\n      data: {\n        name: name.trim(),\n        description: description?.trim() || null,\n        canShare: canShare === true,\n        canDownloadFiles: canDownloadFiles === true,\n        canDownloadPlaylists: canDownloadPlaylists === true,\n      },\n    });\n\n    res.status(201).json({ success: true, group });\n  } catch (error) {\n    console.error(\"Error creating group:\", error);\n    res.status(500).json({ error: \"Failed to create group\" });\n  }\n};\n\nexport const updateGroup = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groupId = parseInt(req.params.id);\n    if (isNaN(groupId)) {\n      return res.status(400).json({ error: \"Invalid group ID\" });\n    }\n\n    const existing = await prisma.userGroup.findUnique({\n      where: { id: groupId },\n    });\n\n    if (!existing) {\n      return res.status(404).json({ error: \"Group not found\" });\n    }\n\n    const { name, description, canShare, canDownloadFiles, canDownloadPlaylists } =\n      req.body;\n\n    // Check for name collision if name is being changed\n    if (name &amp;&amp; name.trim() !== existing.name) {\n      const nameExists = await prisma.userGroup.findUnique({\n        where: { name: name.trim() },\n      });\n      if (nameExists) {\n        return res.status(409).json({ error: \"Group name already exists\" });\n      }\n    }\n\n    const group = await prisma.userGroup.update({\n      where: { id: groupId },\n      data: {\n        ...(name !== undefined &amp;&amp; { name: name.trim() }),\n        ...(description !== undefined &amp;&amp; { description: description?.trim() || null }),\n        ...(canShare !== undefined &amp;&amp; { canShare }),\n        ...(canDownloadFiles !== undefined &amp;&amp; { canDownloadFiles }),\n        ...(canDownloadPlaylists !== undefined &amp;&amp; { canDownloadPlaylists }),\n      },\n    });\n\n    res.json({ success: true, group });\n  } catch (error) {\n    console.error(\"Error updating group:\", error);\n    res.status(500).json({ error: \"Failed to update group\" });\n  }\n};\n\nexport const deleteGroup = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groupId = parseInt(req.params.id);\n    if (isNaN(groupId)) {\n      return res.status(400).json({ error: \"Invalid group ID\" });\n    }\n\n    const existing = await prisma.userGroup.findUnique({\n      where: { id: groupId },\n    });\n\n    if (!existing) {\n      return res.status(404).json({ error: \"Group not found\" });\n    }\n\n    await prisma.userGroup.delete({ where: { id: groupId } });\n\n    res.json({ success: true });\n  } catch (error) {\n    console.error(\"Error deleting group:\", error);\n    res.status(500).json({ error: \"Failed to delete group\" });\n  }\n};\n\nexport const addMember = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groupId = parseInt(req.params.id);\n    const { userId } = req.body;\n\n    if (isNaN(groupId)) {\n      return res.status(400).json({ error: \"Invalid group ID\" });\n    }\n\n    if (!userId || typeof userId !== \"number\") {\n      return res.status(400).json({ error: \"User ID is required\" });\n    }\n\n    const group = await prisma.userGroup.findUnique({ where: { id: groupId } });\n    if (!group) {\n      return res.status(404).json({ error: \"Group not found\" });\n    }\n\n    const existingMembership = await prisma.userGroupMembership.findUnique({\n      where: { userId_groupId: { userId, groupId } },\n    });\n\n    if (existingMembership) {\n      return res.status(409).json({ error: \"User is already a member of this group\" });\n    }\n\n    const membership = await prisma.userGroupMembership.create({\n      data: { userId, groupId },\n    });\n\n    res.status(201).json({ success: true, membership });\n  } catch (error) {\n    console.error(\"Error adding member:\", error);\n    res.status(500).json({ error: \"Failed to add member\" });\n  }\n};\n\nexport const removeMember = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const groupId = parseInt(req.params.id);\n    const userId = parseInt(req.params.userId);\n\n    if (isNaN(groupId) || isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid group or user ID\" });\n    }\n\n    const membership = await prisma.userGroupMembership.findUnique({\n      where: { userId_groupId: { userId, groupId } },\n    });\n\n    if (!membership) {\n      return res.status(404).json({ error: \"Membership not found\" });\n    }\n\n    await prisma.userGroupMembership.delete({\n      where: { userId_groupId: { userId, groupId } },\n    });\n\n    res.json({ success: true });\n  } catch (error) {\n    console.error(\"Error removing member:\", error);\n    res.status(500).json({ error: \"Failed to remove member\" });\n  }\n};\n\n// User-facing: get groups the current user belongs to\nexport const getUserGroups = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    if (!req.user) {\n      return res.status(401).json({ error: \"Not authenticated\" });\n    }\n\n    const memberships = await prisma.userGroupMembership.findMany({\n      where: { userId: req.user.id },\n      select: {\n        group: {\n          select: {\n            id: true,\n            name: true,\n            description: true,\n          },\n        },\n      },\n    });\n\n    res.json({\n      groups: memberships.map((m) =&gt; m.group),\n    });\n  } catch (error) {\n    console.error(\"Error getting user groups:\", error);\n    res.status(500).json({ error: \"Failed to get user groups\" });\n  }\n};\n</code></pre> <p>Step 4: Create the routes file</p> <p>Create <code>server/routes/groups.ts</code>:</p> <pre><code>import { Router } from \"express\";\nimport { authenticate, requireAdmin, authenticated } from \"../middleware/auth.js\";\nimport {\n  getAllGroups,\n  getGroup,\n  createGroup,\n  updateGroup,\n  deleteGroup,\n  addMember,\n  removeMember,\n  getUserGroups,\n} from \"../controllers/groups.js\";\n\nconst router = Router();\n\nrouter.use(authenticate);\n\n// Admin routes\nrouter.get(\"/\", requireAdmin, authenticated(getAllGroups));\nrouter.get(\"/:id\", requireAdmin, authenticated(getGroup));\nrouter.post(\"/\", requireAdmin, authenticated(createGroup));\nrouter.put(\"/:id\", requireAdmin, authenticated(updateGroup));\nrouter.delete(\"/:id\", requireAdmin, authenticated(deleteGroup));\n\n// Membership management\nrouter.post(\"/:id/members\", requireAdmin, authenticated(addMember));\nrouter.delete(\"/:id/members/:userId\", requireAdmin, authenticated(removeMember));\n\n// User-facing route\nrouter.get(\"/user/mine\", authenticated(getUserGroups));\n\nexport default router;\n</code></pre> <p>Step 5: Register the routes</p> <p>Modify <code>server/initializers/api.ts</code> - add after the user routes import:</p> <pre><code>import groupRoutes from \"../routes/groups.js\";\n</code></pre> <p>And add in the route registration section:</p> <pre><code>app.use(\"/api/groups\", groupRoutes);\n</code></pre> <p>Step 6: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- groups.test.ts</code></p> <p>Expected: All tests PASS</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/groups.ts server/routes/groups.ts server/initializers/api.ts server/tests/controllers/groups.test.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(api): add group CRUD endpoints\n\nAdmin endpoints:\n- GET /api/groups - list all groups with member counts\n- GET /api/groups/:id - get group with members\n- POST /api/groups - create group\n- PUT /api/groups/:id - update group\n- DELETE /api/groups/:id - delete group\n- POST /api/groups/:id/members - add user to group\n- DELETE /api/groups/:id/members/:userId - remove user from group\n\nUser endpoint:\n- GET /api/groups/user/mine - get current user's groups (for sharing UI)\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-4-add-user-permissions-endpoint","title":"Task 4: Add User Permissions Endpoint","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> - Modify: <code>server/routes/user.ts</code></p> <p>Step 1: Add permissions endpoint to user controller</p> <p>Add to <code>server/controllers/user.ts</code>:</p> <pre><code>import { resolveUserPermissions } from \"../services/PermissionService.js\";\n\nexport const getUserPermissions = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (!req.user) {\n      return res.status(401).json({ error: \"Not authenticated\" });\n    }\n\n    const permissions = await resolveUserPermissions(req.user.id);\n\n    if (!permissions) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    res.json({ permissions });\n  } catch (error) {\n    console.error(\"Error getting user permissions:\", error);\n    res.status(500).json({ error: \"Failed to get permissions\" });\n  }\n};\n\n// Admin endpoint to get any user's permissions\nexport const getAnyUserPermissions = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const userId = parseInt(req.params.userId);\n    if (isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid user ID\" });\n    }\n\n    const permissions = await resolveUserPermissions(userId);\n\n    if (!permissions) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    res.json({ permissions });\n  } catch (error) {\n    console.error(\"Error getting user permissions:\", error);\n    res.status(500).json({ error: \"Failed to get permissions\" });\n  }\n};\n\n// Admin endpoint to update user permission overrides\nexport const updateUserPermissionOverrides = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    if (req.user?.role !== \"ADMIN\") {\n      return res.status(403).json({ error: \"Forbidden: Admin access required\" });\n    }\n\n    const userId = parseInt(req.params.userId);\n    if (isNaN(userId)) {\n      return res.status(400).json({ error: \"Invalid user ID\" });\n    }\n\n    const { canShareOverride, canDownloadFilesOverride, canDownloadPlaylistsOverride } =\n      req.body;\n\n    // Validate values (must be boolean or null)\n    const validateOverride = (value: unknown): boolean | null | undefined =&gt; {\n      if (value === undefined) return undefined;\n      if (value === null) return null;\n      if (typeof value === \"boolean\") return value;\n      throw new Error(\"Invalid override value\");\n    };\n\n    try {\n      const updates: Record&lt;string, boolean | null&gt; = {};\n\n      const shareOverride = validateOverride(canShareOverride);\n      if (shareOverride !== undefined) updates.canShareOverride = shareOverride;\n\n      const filesOverride = validateOverride(canDownloadFilesOverride);\n      if (filesOverride !== undefined) updates.canDownloadFilesOverride = filesOverride;\n\n      const playlistsOverride = validateOverride(canDownloadPlaylistsOverride);\n      if (playlistsOverride !== undefined) updates.canDownloadPlaylistsOverride = playlistsOverride;\n\n      if (Object.keys(updates).length === 0) {\n        return res.status(400).json({ error: \"No valid updates provided\" });\n      }\n\n      await prisma.user.update({\n        where: { id: userId },\n        data: updates,\n      });\n\n      // Return updated permissions\n      const permissions = await resolveUserPermissions(userId);\n      res.json({ success: true, permissions });\n    } catch {\n      return res.status(400).json({ error: \"Invalid override value - must be true, false, or null\" });\n    }\n  } catch (error) {\n    console.error(\"Error updating permission overrides:\", error);\n    res.status(500).json({ error: \"Failed to update permission overrides\" });\n  }\n};\n</code></pre> <p>Step 2: Add routes</p> <p>Add to <code>server/routes/user.ts</code>:</p> <pre><code>import { getUserPermissions, getAnyUserPermissions, updateUserPermissionOverrides } from \"../controllers/user.js\";\n\n// User's own permissions\nrouter.get(\"/permissions\", authenticated(getUserPermissions));\n\n// Admin: get/update any user's permissions\nrouter.get(\"/:userId/permissions\", requireAdmin, authenticated(getAnyUserPermissions));\nrouter.put(\"/:userId/permissions\", requireAdmin, authenticated(updateUserPermissionOverrides));\n</code></pre> <p>Step 3: Run the linter</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/user.ts server/routes/user.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(api): add user permission endpoints\n\n- GET /api/user/permissions - get current user's resolved permissions\n- GET /api/user/:userId/permissions - admin get any user's permissions\n- PUT /api/user/:userId/permissions - admin update permission overrides\n\nOverrides can be true (force enable), false (force disable), or null (inherit from groups).\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-5-frontend-api-service","title":"Task 5: Frontend API Service","text":"<p>Files: - Modify: <code>client/src/services/api.js</code></p> <p>Step 1: Add group and permission API methods</p> <p>Add to <code>client/src/services/api.js</code> in the appropriate section:</p> <pre><code>// ============================================================================\n// Groups API\n// ============================================================================\n\n// Admin: Get all groups\nexport const getGroups = () =&gt; api.get(\"/groups\");\n\n// Admin: Get single group with members\nexport const getGroup = (groupId) =&gt; api.get(`/groups/${groupId}`);\n\n// Admin: Create group\nexport const createGroup = (data) =&gt; api.post(\"/groups\", data);\n\n// Admin: Update group\nexport const updateGroup = (groupId, data) =&gt; api.put(`/groups/${groupId}`, data);\n\n// Admin: Delete group\nexport const deleteGroup = (groupId) =&gt; api.delete(`/groups/${groupId}`);\n\n// Admin: Add user to group\nexport const addGroupMember = (groupId, userId) =&gt;\n  api.post(`/groups/${groupId}/members`, { userId });\n\n// Admin: Remove user from group\nexport const removeGroupMember = (groupId, userId) =&gt;\n  api.delete(`/groups/${groupId}/members/${userId}`);\n\n// User: Get my groups (for sharing UI)\nexport const getMyGroups = () =&gt; api.get(\"/groups/user/mine\");\n\n// ============================================================================\n// Permissions API\n// ============================================================================\n\n// User: Get my resolved permissions\nexport const getMyPermissions = () =&gt; api.get(\"/user/permissions\");\n\n// Admin: Get any user's resolved permissions\nexport const getUserPermissions = (userId) =&gt; api.get(`/user/${userId}/permissions`);\n\n// Admin: Update user permission overrides\nexport const updateUserPermissionOverrides = (userId, overrides) =&gt;\n  api.put(`/user/${userId}/permissions`, overrides);\n</code></pre> <p>Step 2: Run the linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/services/api.js\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(client): add group and permission API methods\n\nGroup methods for admin:\n- getGroups, getGroup, createGroup, updateGroup, deleteGroup\n- addGroupMember, removeGroupMember\n\nUser methods:\n- getMyGroups (for sharing UI)\n- getMyPermissions, getUserPermissions, updateUserPermissionOverrides\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-6-admin-ui-groups-list-tab","title":"Task 6: Admin UI - Groups List Tab","text":"<p>Files: - Create: <code>client/src/components/settings/tabs/GroupsTab.jsx</code> - Modify: <code>client/src/components/pages/SettingsPage.jsx</code></p> <p>Step 1: Create the GroupsTab component</p> <p>Create <code>client/src/components/settings/tabs/GroupsTab.jsx</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport Paper from \"../../ui/Paper\";\nimport Button from \"../../ui/Button\";\nimport { getGroups, deleteGroup } from \"../../../services/api\";\nimport GroupModal from \"../GroupModal\";\nimport { Users, Edit2, Trash2, Shield, Download, Share2 } from \"lucide-react\";\n\nconst GroupsTab = () =&gt; {\n  const [groups, setGroups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [message, setMessage] = useState(null);\n  const [showModal, setShowModal] = useState(false);\n  const [editingGroup, setEditingGroup] = useState(null);\n\n  useEffect(() =&gt; {\n    loadGroups();\n  }, []);\n\n  const loadGroups = async () =&gt; {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await getGroups();\n      setGroups(response.data.groups || []);\n    } catch (err) {\n      setError(err.response?.data?.error || \"Failed to load groups\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const showMessage = (msg) =&gt; {\n    setMessage(msg);\n    setTimeout(() =&gt; setMessage(null), 3000);\n  };\n\n  const handleCreate = () =&gt; {\n    setEditingGroup(null);\n    setShowModal(true);\n  };\n\n  const handleEdit = (group) =&gt; {\n    setEditingGroup(group);\n    setShowModal(true);\n  };\n\n  const handleDelete = async (group) =&gt; {\n    if (\n      !confirm(\n        `Delete group \"${group.name}\"? Members will lose permissions granted by this group.`\n      )\n    ) {\n      return;\n    }\n\n    try {\n      await deleteGroup(group.id);\n      showMessage(`Group \"${group.name}\" deleted`);\n      loadGroups();\n    } catch (err) {\n      setError(err.response?.data?.error || \"Failed to delete group\");\n    }\n  };\n\n  const handleModalClose = (saved) =&gt; {\n    setShowModal(false);\n    setEditingGroup(null);\n    if (saved) {\n      loadGroups();\n      showMessage(editingGroup ? \"Group updated\" : \"Group created\");\n    }\n  };\n\n  const PermissionBadge = ({ enabled, icon: Icon, label }) =&gt; (\n    &lt;span\n      className=\"inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs\"\n      style={{\n        backgroundColor: enabled\n          ? \"rgba(34, 197, 94, 0.15)\"\n          : \"rgba(100, 100, 100, 0.15)\",\n        color: enabled ? \"rgb(34, 197, 94)\" : \"var(--text-secondary)\",\n      }}\n      title={label}\n    &gt;\n      &lt;Icon size={12} /&gt;\n    &lt;/span&gt;\n  );\n\n  if (loading) {\n    return (\n      &lt;Paper&gt;\n        &lt;Paper.Body&gt;\n          &lt;p className=\"text-center py-8\" style={{ color: \"var(--text-secondary)\" }}&gt;\n            Loading groups...\n          &lt;/p&gt;\n        &lt;/Paper.Body&gt;\n      &lt;/Paper&gt;\n    );\n  }\n\n  return (\n    &lt;div&gt;\n      {message &amp;&amp; (\n        &lt;div\n          className=\"mb-6 p-4 rounded-lg\"\n          style={{ backgroundColor: \"rgba(34, 197, 94, 0.1)\", color: \"rgb(34, 197, 94)\" }}\n        &gt;\n          {message}\n        &lt;/div&gt;\n      )}\n\n      {error &amp;&amp; (\n        &lt;div\n          className=\"mb-6 p-4 rounded-lg\"\n          style={{ backgroundColor: \"rgba(239, 68, 68, 0.1)\", color: \"rgb(239, 68, 68)\" }}\n        &gt;\n          {error}\n        &lt;/div&gt;\n      )}\n\n      &lt;Paper&gt;\n        &lt;Paper.Header&gt;\n          &lt;div className=\"flex justify-between items-center\"&gt;\n            &lt;div&gt;\n              &lt;Paper.Title&gt;User Groups&lt;/Paper.Title&gt;\n              &lt;Paper.Subtitle&gt;\n                Manage groups for permission inheritance and playlist sharing\n              &lt;/Paper.Subtitle&gt;\n            &lt;/div&gt;\n            &lt;Button onClick={handleCreate} variant=\"primary\"&gt;\n              + Create Group\n            &lt;/Button&gt;\n          &lt;/div&gt;\n        &lt;/Paper.Header&gt;\n\n        &lt;Paper.Body padding=\"none\"&gt;\n          {groups.length === 0 ? (\n            &lt;div className=\"px-6 py-12 text-center\"&gt;\n              &lt;Users size={48} className=\"mx-auto mb-4\" style={{ color: \"var(--text-secondary)\" }} /&gt;\n              &lt;p style={{ color: \"var(--text-secondary)\" }}&gt;\n                No groups yet. Create a group to enable sharing and permission inheritance.\n              &lt;/p&gt;\n            &lt;/div&gt;\n          ) : (\n            &lt;div className=\"overflow-x-auto\"&gt;\n              &lt;table className=\"w-full\" style={{ minWidth: \"700px\" }}&gt;\n                &lt;thead&gt;\n                  &lt;tr style={{ borderBottom: \"1px solid var(--border-color)\" }}&gt;\n                    &lt;th className=\"text-left px-6 py-4 font-medium\"&gt;Name&lt;/th&gt;\n                    &lt;th className=\"text-left px-6 py-4 font-medium\"&gt;Description&lt;/th&gt;\n                    &lt;th className=\"text-center px-6 py-4 font-medium\"&gt;Members&lt;/th&gt;\n                    &lt;th className=\"text-center px-6 py-4 font-medium\"&gt;Permissions&lt;/th&gt;\n                    &lt;th className=\"text-right px-6 py-4 font-medium\"&gt;Actions&lt;/th&gt;\n                  &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                  {groups.map((group) =&gt; (\n                    &lt;tr\n                      key={group.id}\n                      style={{ borderBottom: \"1px solid var(--border-color)\" }}\n                    &gt;\n                      &lt;td className=\"px-6 py-4 font-medium\"&gt;{group.name}&lt;/td&gt;\n                      &lt;td\n                        className=\"px-6 py-4\"\n                        style={{ color: \"var(--text-secondary)\" }}\n                      &gt;\n                        {group.description || \"\u2014\"}\n                      &lt;/td&gt;\n                      &lt;td className=\"px-6 py-4 text-center\"&gt;\n                        &lt;span\n                          className=\"inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-sm\"\n                          style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n                        &gt;\n                          &lt;Users size={14} /&gt;\n                          {group.memberCount}\n                        &lt;/span&gt;\n                      &lt;/td&gt;\n                      &lt;td className=\"px-6 py-4 text-center\"&gt;\n                        &lt;div className=\"flex justify-center gap-1.5\"&gt;\n                          &lt;PermissionBadge\n                            enabled={group.canShare}\n                            icon={Share2}\n                            label=\"Can share playlists\"\n                          /&gt;\n                          &lt;PermissionBadge\n                            enabled={group.canDownloadFiles}\n                            icon={Download}\n                            label=\"Can download files\"\n                          /&gt;\n                          &lt;PermissionBadge\n                            enabled={group.canDownloadPlaylists}\n                            icon={Shield}\n                            label=\"Can download playlists\"\n                          /&gt;\n                        &lt;/div&gt;\n                      &lt;/td&gt;\n                      &lt;td className=\"px-6 py-4 text-right\"&gt;\n                        &lt;div className=\"flex justify-end gap-2\"&gt;\n                          &lt;button\n                            onClick={() =&gt; handleEdit(group)}\n                            className=\"p-2 rounded hover:bg-white/10 transition-colors\"\n                            title=\"Edit group\"\n                          &gt;\n                            &lt;Edit2 size={16} /&gt;\n                          &lt;/button&gt;\n                          &lt;button\n                            onClick={() =&gt; handleDelete(group)}\n                            className=\"p-2 rounded hover:bg-red-500/20 text-red-400 transition-colors\"\n                            title=\"Delete group\"\n                          &gt;\n                            &lt;Trash2 size={16} /&gt;\n                          &lt;/button&gt;\n                        &lt;/div&gt;\n                      &lt;/td&gt;\n                    &lt;/tr&gt;\n                  ))}\n                &lt;/tbody&gt;\n              &lt;/table&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/Paper.Body&gt;\n      &lt;/Paper&gt;\n\n      {showModal &amp;&amp; (\n        &lt;GroupModal group={editingGroup} onClose={handleModalClose} /&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default GroupsTab;\n</code></pre> <p>Step 2: Add to SettingsPage</p> <p>Modify <code>client/src/components/pages/SettingsPage.jsx</code> - add to SERVER_TABS:</p> <pre><code>{ id: \"groups\", label: \"Groups\" },\n</code></pre> <p>And add the tab content rendering (in the switch or conditional):</p> <pre><code>import GroupsTab from \"../settings/tabs/GroupsTab\";\n\n// In the render section where tabs are conditionally shown:\n{activeTab === \"groups\" &amp;&amp; &lt;GroupsTab /&gt;}\n</code></pre> <p>Step 3: Run the linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No errors (or only the expected missing GroupModal warning)</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/settings/tabs/GroupsTab.jsx client/src/components/pages/SettingsPage.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(ui): add Groups tab to server settings\n\n- Lists all groups with member counts\n- Shows permission badges (share, download files, download playlists)\n- Create/edit/delete buttons\n- Empty state with helpful message\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-7-admin-ui-group-modal-createedit","title":"Task 7: Admin UI - Group Modal (Create/Edit)","text":"<p>Files: - Create: <code>client/src/components/settings/GroupModal.jsx</code></p> <p>Step 1: Create the GroupModal component</p> <p>Create <code>client/src/components/settings/GroupModal.jsx</code>:</p> <pre><code>import { useState, useEffect } from \"react\";\nimport Modal from \"../ui/Modal\";\nimport Button from \"../ui/Button\";\nimport { createGroup, updateGroup, getGroup, addGroupMember, removeGroupMember } from \"../../services/api\";\nimport { Users, X } from \"lucide-react\";\n\nconst GroupModal = ({ group, onClose }) =&gt; {\n  const [name, setName] = useState(group?.name || \"\");\n  const [description, setDescription] = useState(group?.description || \"\");\n  const [canShare, setCanShare] = useState(group?.canShare || false);\n  const [canDownloadFiles, setCanDownloadFiles] = useState(group?.canDownloadFiles || false);\n  const [canDownloadPlaylists, setCanDownloadPlaylists] = useState(group?.canDownloadPlaylists || false);\n  const [members, setMembers] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [loadingMembers, setLoadingMembers] = useState(!!group);\n  const [error, setError] = useState(null);\n\n  const isEditing = !!group;\n\n  useEffect(() =&gt; {\n    if (group) {\n      loadGroupDetails();\n    }\n  }, [group]);\n\n  const loadGroupDetails = async () =&gt; {\n    try {\n      setLoadingMembers(true);\n      const response = await getGroup(group.id);\n      setMembers(response.data.group.members || []);\n    } catch (err) {\n      console.error(\"Failed to load group members:\", err);\n    } finally {\n      setLoadingMembers(false);\n    }\n  };\n\n  const handleSubmit = async (e) =&gt; {\n    e.preventDefault();\n    setError(null);\n\n    if (!name.trim()) {\n      setError(\"Group name is required\");\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      const data = {\n        name: name.trim(),\n        description: description.trim() || null,\n        canShare,\n        canDownloadFiles,\n        canDownloadPlaylists,\n      };\n\n      if (isEditing) {\n        await updateGroup(group.id, data);\n      } else {\n        await createGroup(data);\n      }\n\n      onClose(true);\n    } catch (err) {\n      setError(err.response?.data?.error || \"Failed to save group\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleRemoveMember = async (userId, username) =&gt; {\n    if (!confirm(`Remove ${username} from this group?`)) return;\n\n    try {\n      await removeGroupMember(group.id, userId);\n      setMembers((prev) =&gt; prev.filter((m) =&gt; m.id !== userId));\n    } catch (err) {\n      setError(err.response?.data?.error || \"Failed to remove member\");\n    }\n  };\n\n  const PermissionToggle = ({ label, description, checked, onChange }) =&gt; (\n    &lt;label className=\"flex items-start gap-3 cursor-pointer py-2\"&gt;\n      &lt;input\n        type=\"checkbox\"\n        checked={checked}\n        onChange={(e) =&gt; onChange(e.target.checked)}\n        className=\"mt-1 w-4 h-4 rounded\"\n      /&gt;\n      &lt;div&gt;\n        &lt;div className=\"font-medium\"&gt;{label}&lt;/div&gt;\n        &lt;div className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n          {description}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/label&gt;\n  );\n\n  return (\n    &lt;Modal onClose={() =&gt; onClose(false)}&gt;\n      &lt;Modal.Header&gt;\n        &lt;Modal.Title&gt;{isEditing ? `Edit Group: ${group.name}` : \"Create Group\"}&lt;/Modal.Title&gt;\n      &lt;/Modal.Header&gt;\n\n      &lt;form onSubmit={handleSubmit}&gt;\n        &lt;Modal.Body&gt;\n          {error &amp;&amp; (\n            &lt;div\n              className=\"mb-4 p-3 rounded-lg text-sm\"\n              style={{ backgroundColor: \"rgba(239, 68, 68, 0.1)\", color: \"rgb(239, 68, 68)\" }}\n            &gt;\n              {error}\n            &lt;/div&gt;\n          )}\n\n          &lt;div className=\"space-y-4\"&gt;\n            {/* Name */}\n            &lt;div&gt;\n              &lt;label className=\"block text-sm font-medium mb-1\"&gt;Name&lt;/label&gt;\n              &lt;input\n                type=\"text\"\n                value={name}\n                onChange={(e) =&gt; setName(e.target.value)}\n                className=\"w-full px-3 py-2 rounded-lg border\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  borderColor: \"var(--border-color)\",\n                }}\n                placeholder=\"e.g., Family, Friends\"\n                autoFocus\n              /&gt;\n            &lt;/div&gt;\n\n            {/* Description */}\n            &lt;div&gt;\n              &lt;label className=\"block text-sm font-medium mb-1\"&gt;Description&lt;/label&gt;\n              &lt;input\n                type=\"text\"\n                value={description}\n                onChange={(e) =&gt; setDescription(e.target.value)}\n                className=\"w-full px-3 py-2 rounded-lg border\"\n                style={{\n                  backgroundColor: \"var(--bg-secondary)\",\n                  borderColor: \"var(--border-color)\",\n                }}\n                placeholder=\"Optional description\"\n              /&gt;\n            &lt;/div&gt;\n\n            {/* Permissions */}\n            &lt;div&gt;\n              &lt;label className=\"block text-sm font-medium mb-2\"&gt;Default Permissions&lt;/label&gt;\n              &lt;div\n                className=\"rounded-lg p-3\"\n                style={{ backgroundColor: \"var(--bg-secondary)\" }}\n              &gt;\n                &lt;PermissionToggle\n                  label=\"Can share playlists\"\n                  description=\"Members can share their playlists with other groups\"\n                  checked={canShare}\n                  onChange={setCanShare}\n                /&gt;\n                &lt;PermissionToggle\n                  label=\"Can download files\"\n                  description=\"Members can download individual scenes and images\"\n                  checked={canDownloadFiles}\n                  onChange={setCanDownloadFiles}\n                /&gt;\n                &lt;PermissionToggle\n                  label=\"Can download playlists\"\n                  description=\"Members can download entire playlists as zip files\"\n                  checked={canDownloadPlaylists}\n                  onChange={setCanDownloadPlaylists}\n                /&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n\n            {/* Members (only when editing) */}\n            {isEditing &amp;&amp; (\n              &lt;div&gt;\n                &lt;label className=\"block text-sm font-medium mb-2\"&gt;\n                  Members ({members.length})\n                &lt;/label&gt;\n                &lt;div\n                  className=\"rounded-lg p-3 max-h-48 overflow-y-auto\"\n                  style={{ backgroundColor: \"var(--bg-secondary)\" }}\n                &gt;\n                  {loadingMembers ? (\n                    &lt;p className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                      Loading members...\n                    &lt;/p&gt;\n                  ) : members.length === 0 ? (\n                    &lt;p className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                      No members yet. Add members from the User Management tab.\n                    &lt;/p&gt;\n                  ) : (\n                    &lt;div className=\"space-y-2\"&gt;\n                      {members.map((member) =&gt; (\n                        &lt;div\n                          key={member.id}\n                          className=\"flex items-center justify-between py-1.5 px-2 rounded hover:bg-white/5\"\n                        &gt;\n                          &lt;div className=\"flex items-center gap-2\"&gt;\n                            &lt;Users size={14} style={{ color: \"var(--text-secondary)\" }} /&gt;\n                            &lt;span&gt;{member.username}&lt;/span&gt;\n                            {member.role === \"ADMIN\" &amp;&amp; (\n                              &lt;span\n                                className=\"text-xs px-1.5 py-0.5 rounded\"\n                                style={{ backgroundColor: \"rgba(59, 130, 246, 0.2)\", color: \"rgb(59, 130, 246)\" }}\n                              &gt;\n                                Admin\n                              &lt;/span&gt;\n                            )}\n                          &lt;/div&gt;\n                          &lt;button\n                            type=\"button\"\n                            onClick={() =&gt; handleRemoveMember(member.id, member.username)}\n                            className=\"p-1 rounded hover:bg-red-500/20 text-red-400\"\n                            title=\"Remove from group\"\n                          &gt;\n                            &lt;X size={14} /&gt;\n                          &lt;/button&gt;\n                        &lt;/div&gt;\n                      ))}\n                    &lt;/div&gt;\n                  )}\n                &lt;/div&gt;\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n        &lt;/Modal.Body&gt;\n\n        &lt;Modal.Footer&gt;\n          &lt;Button type=\"button\" variant=\"secondary\" onClick={() =&gt; onClose(false)}&gt;\n            Cancel\n          &lt;/Button&gt;\n          &lt;Button type=\"submit\" variant=\"primary\" disabled={loading}&gt;\n            {loading ? \"Saving...\" : isEditing ? \"Save Changes\" : \"Create Group\"}\n          &lt;/Button&gt;\n        &lt;/Modal.Footer&gt;\n      &lt;/form&gt;\n    &lt;/Modal&gt;\n  );\n};\n\nexport default GroupModal;\n</code></pre> <p>Step 2: Run the linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Test manually</p> <p>Run: <code>docker-compose up --build -d &amp;&amp; docker-compose logs -f peek-client</code></p> <p>Navigate to Settings &gt; Server &gt; Groups tab and verify: - Create group button opens modal - Can fill in name, description, permissions - Save creates group and shows in list - Edit opens modal with existing values - Delete prompts and removes group</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/settings/GroupModal.jsx\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(ui): add GroupModal for create/edit groups\n\n- Name and description fields\n- Permission toggles with descriptions\n- Member list when editing (with remove button)\n- Validation and error handling\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-8-user-management-add-group-membership-ui","title":"Task 8: User Management - Add Group Membership UI","text":"<p>Files: - Modify: <code>client/src/components/settings/UserManagementSection.jsx</code></p> <p>Step 1: Add group membership to user row</p> <p>Modify <code>client/src/components/settings/UserManagementSection.jsx</code> to:</p> <ol> <li>Fetch groups on mount</li> <li>Show group tags on each user row</li> <li>Add \"Manage Groups\" button that opens a modal to toggle group memberships</li> </ol> <p>This involves adding:</p> <pre><code>// Add imports\nimport { getGroups, addGroupMember, removeGroupMember } from \"../../services/api\";\n\n// Add state\nconst [groups, setGroups] = useState([]);\nconst [groupModalUser, setGroupModalUser] = useState(null);\n\n// Load groups on mount\nuseEffect(() =&gt; {\n  loadGroups();\n}, []);\n\nconst loadGroups = async () =&gt; {\n  try {\n    const response = await getGroups();\n    setGroups(response.data.groups || []);\n  } catch (err) {\n    console.error(\"Failed to load groups:\", err);\n  }\n};\n\n// Add column header for Groups\n&lt;th className=\"text-left px-6 py-4\"&gt;Groups&lt;/th&gt;\n\n// Add cell showing user's groups\n&lt;td className=\"px-6 py-4\"&gt;\n  &lt;div className=\"flex flex-wrap gap-1\"&gt;\n    {user.groups?.map((g) =&gt; (\n      &lt;span\n        key={g.id}\n        className=\"text-xs px-2 py-0.5 rounded-full\"\n        style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n      &gt;\n        {g.name}\n      &lt;/span&gt;\n    )) || \"\u2014\"}\n  &lt;/div&gt;\n&lt;/td&gt;\n\n// Add button in actions\n&lt;button onClick={() =&gt; setGroupModalUser(user)} title=\"Manage groups\"&gt;\n  &lt;Users size={16} /&gt;\n&lt;/button&gt;\n\n// Add modal for group management\n{groupModalUser &amp;&amp; (\n  &lt;UserGroupsModal\n    user={groupModalUser}\n    groups={groups}\n    onClose={() =&gt; {\n      setGroupModalUser(null);\n      loadUsers(); // Refresh to show updated groups\n    }}\n  /&gt;\n)}\n</code></pre> <p>Step 2: Update the user fetch to include groups</p> <p>Modify the backend <code>getAllUsers</code> in <code>server/controllers/user.ts</code> to include group memberships:</p> <pre><code>const users = await prisma.user.findMany({\n  select: {\n    id: true,\n    username: true,\n    role: true,\n    syncToStash: true,\n    createdAt: true,\n    updatedAt: true,\n    groupMemberships: {\n      select: {\n        group: {\n          select: { id: true, name: true },\n        },\n      },\n    },\n  },\n  orderBy: { createdAt: \"desc\" },\n});\n\nres.json({\n  users: users.map((u) =&gt; ({\n    ...u,\n    groups: u.groupMemberships.map((m) =&gt; m.group),\n    groupMemberships: undefined,\n  })),\n});\n</code></pre> <p>Step 3: Create UserGroupsModal</p> <p>Create <code>client/src/components/settings/UserGroupsModal.jsx</code>:</p> <pre><code>import { useState } from \"react\";\nimport Modal from \"../ui/Modal\";\nimport Button from \"../ui/Button\";\nimport { addGroupMember, removeGroupMember } from \"../../services/api\";\n\nconst UserGroupsModal = ({ user, groups, onClose }) =&gt; {\n  const [userGroups, setUserGroups] = useState(\n    new Set(user.groups?.map((g) =&gt; g.id) || [])\n  );\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const handleToggle = async (groupId, groupName) =&gt; {\n    setLoading(true);\n    setError(null);\n\n    try {\n      if (userGroups.has(groupId)) {\n        await removeGroupMember(groupId, user.id);\n        setUserGroups((prev) =&gt; {\n          const next = new Set(prev);\n          next.delete(groupId);\n          return next;\n        });\n      } else {\n        await addGroupMember(groupId, user.id);\n        setUserGroups((prev) =&gt; new Set([...prev, groupId]));\n      }\n    } catch (err) {\n      setError(err.response?.data?.error || `Failed to update ${groupName} membership`);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    &lt;Modal onClose={onClose}&gt;\n      &lt;Modal.Header&gt;\n        &lt;Modal.Title&gt;Manage Groups: {user.username}&lt;/Modal.Title&gt;\n      &lt;/Modal.Header&gt;\n\n      &lt;Modal.Body&gt;\n        {error &amp;&amp; (\n          &lt;div\n            className=\"mb-4 p-3 rounded-lg text-sm\"\n            style={{ backgroundColor: \"rgba(239, 68, 68, 0.1)\", color: \"rgb(239, 68, 68)\" }}\n          &gt;\n            {error}\n          &lt;/div&gt;\n        )}\n\n        {groups.length === 0 ? (\n          &lt;p style={{ color: \"var(--text-secondary)\" }}&gt;\n            No groups exist. Create groups in the Groups tab first.\n          &lt;/p&gt;\n        ) : (\n          &lt;div className=\"space-y-2\"&gt;\n            {groups.map((group) =&gt; (\n              &lt;label\n                key={group.id}\n                className=\"flex items-center gap-3 p-3 rounded-lg cursor-pointer hover:bg-white/5\"\n                style={{ backgroundColor: \"var(--bg-secondary)\" }}\n              &gt;\n                &lt;input\n                  type=\"checkbox\"\n                  checked={userGroups.has(group.id)}\n                  onChange={() =&gt; handleToggle(group.id, group.name)}\n                  disabled={loading}\n                  className=\"w-4 h-4 rounded\"\n                /&gt;\n                &lt;div className=\"flex-1\"&gt;\n                  &lt;div className=\"font-medium\"&gt;{group.name}&lt;/div&gt;\n                  {group.description &amp;&amp; (\n                    &lt;div className=\"text-sm\" style={{ color: \"var(--text-secondary)\" }}&gt;\n                      {group.description}\n                    &lt;/div&gt;\n                  )}\n                &lt;/div&gt;\n              &lt;/label&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n      &lt;/Modal.Body&gt;\n\n      &lt;Modal.Footer&gt;\n        &lt;Button variant=\"primary\" onClick={onClose}&gt;\n          Done\n        &lt;/Button&gt;\n      &lt;/Modal.Footer&gt;\n    &lt;/Modal&gt;\n  );\n};\n\nexport default UserGroupsModal;\n</code></pre> <p>Step 4: Run the linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint &amp;&amp; cd ../server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/settings/UserManagementSection.jsx client/src/components/settings/UserGroupsModal.jsx server/controllers/user.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\nfeat(ui): add group membership management to user list\n\n- User list now shows group tags for each user\n- \"Manage groups\" button opens modal to toggle memberships\n- Checkboxes update membership immediately via API\n- Backend getAllUsers now includes group memberships\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-9-integration-test","title":"Task 9: Integration Test","text":"<p>Files: - Modify: <code>server/integration/groups.integration.test.ts</code> (create if needed)</p> <p>Step 1: Write integration test</p> <p>Create <code>server/integration/groups.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeAll, afterAll } from \"vitest\";\nimport request from \"supertest\";\nimport { app } from \"../initializers/api.js\";\nimport prisma from \"../prisma/singleton.js\";\n\ndescribe(\"Groups Integration\", () =&gt; {\n  let adminToken: string;\n  let testGroupId: number;\n\n  beforeAll(async () =&gt; {\n    // Login as admin\n    const loginRes = await request(app)\n      .post(\"/api/auth/login\")\n      .send({ username: \"admin\", password: process.env.TEST_ADMIN_PASSWORD });\n\n    adminToken = loginRes.headers[\"set-cookie\"]?.[0] || \"\";\n  });\n\n  afterAll(async () =&gt; {\n    // Cleanup test group\n    if (testGroupId) {\n      await prisma.userGroup.delete({ where: { id: testGroupId } }).catch(() =&gt; {});\n    }\n  });\n\n  it(\"should create a group\", async () =&gt; {\n    const res = await request(app)\n      .post(\"/api/groups\")\n      .set(\"Cookie\", adminToken)\n      .send({\n        name: \"Test Group\",\n        description: \"Integration test group\",\n        canShare: true,\n        canDownloadFiles: false,\n        canDownloadPlaylists: true,\n      });\n\n    expect(res.status).toBe(201);\n    expect(res.body.group.name).toBe(\"Test Group\");\n    expect(res.body.group.canShare).toBe(true);\n    testGroupId = res.body.group.id;\n  });\n\n  it(\"should list groups\", async () =&gt; {\n    const res = await request(app)\n      .get(\"/api/groups\")\n      .set(\"Cookie\", adminToken);\n\n    expect(res.status).toBe(200);\n    expect(res.body.groups).toBeInstanceOf(Array);\n    expect(res.body.groups.some((g: { name: string }) =&gt; g.name === \"Test Group\")).toBe(true);\n  });\n\n  it(\"should update a group\", async () =&gt; {\n    const res = await request(app)\n      .put(`/api/groups/${testGroupId}`)\n      .set(\"Cookie\", adminToken)\n      .send({ canDownloadFiles: true });\n\n    expect(res.status).toBe(200);\n    expect(res.body.group.canDownloadFiles).toBe(true);\n  });\n\n  it(\"should delete a group\", async () =&gt; {\n    const res = await request(app)\n      .delete(`/api/groups/${testGroupId}`)\n      .set(\"Cookie\", adminToken);\n\n    expect(res.status).toBe(200);\n    testGroupId = 0; // Mark as deleted\n  });\n});\n</code></pre> <p>Step 2: Run integration tests</p> <p>Run: <code>cd server &amp;&amp; npm run test:integration</code></p> <p>Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/integration/groups.integration.test.ts\ngit commit -m \"$(cat &lt;&lt;'EOF'\ntest: add groups integration tests\n\nTests CRUD operations for user groups:\n- Create group with permissions\n- List groups\n- Update group permissions\n- Delete group\n\nPart of #319\n\nCo-Authored-By: Claude Opus 4.5 &lt;noreply@anthropic.com&gt;\nEOF\n)\"\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#task-10-final-verification-and-cleanup","title":"Task 10: Final Verification and Cleanup","text":"<p>Step 1: Run all tests</p> <p>Run: <code>cd server &amp;&amp; npm test &amp;&amp; npm run lint</code></p> <p>Expected: All tests pass, no lint errors</p> <p>Step 2: Run client linter</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No lint errors</p> <p>Step 3: Manual testing checklist</p> <ul> <li> Create a new group with all permissions enabled</li> <li> Edit the group to change permissions</li> <li> Add a user to the group via User Management</li> <li> Verify user's group shows in user list</li> <li> Remove user from group</li> <li> Delete the group</li> <li> Verify no orphan memberships remain</li> </ul> <p>Step 4: Create feature branch and final commit</p> <pre><code>git checkout -b feature/319-user-groups\ngit push -u origin feature/319-user-groups\n</code></pre>"},{"location":"plans/2026-01-20-user-groups-implementation/#summary","title":"Summary","text":"<p>This plan implements User Groups (#319) as the foundation for v3.3's sharing and permission features:</p> Task Description Key Files 1 Database schema <code>schema.prisma</code> 2 Permission service <code>PermissionService.ts</code> 3 Group CRUD API <code>groups.ts</code> controller + routes 4 User permissions API <code>user.ts</code> endpoints 5 Frontend API service <code>api.js</code> 6 Groups list UI <code>GroupsTab.jsx</code> 7 Group modal <code>GroupModal.jsx</code> 8 User membership UI <code>UserGroupsModal.jsx</code> 9 Integration tests <code>groups.integration.test.ts</code> 10 Verification Manual testing <p>The implementation follows existing patterns found in the codebase and sets up the permission inheritance system that Downloads (#295) and Playlist Sharing (#294) will build upon.</p>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/","title":"User Stats Ranking Formula Design","text":""},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#problem-statement","title":"Problem Statement","text":"<p>The current \"top\" rankings on the user stats page use simple <code>playCount DESC</code> sorting, which produces misleading results:</p> <ol> <li>Male performers dominate - They appear in 3-5x more scenes on average, so they accumulate more plays by sheer exposure</li> <li>Ubiquitous tags rank unfairly high - \"Blowjob\" (41% of library) will always beat niche tags regardless of actual preference</li> <li>Large studios have inherent advantage - More scenes = more opportunity for plays</li> <li>No quality signal - A scene watched for 5 seconds counts the same as one watched fully with engagement</li> </ol>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#solution-bayesian-weighted-normalized-engagement-score","title":"Solution: Bayesian-Weighted Normalized Engagement Score","text":"<p>Combine three proven techniques:</p> <ol> <li>Weighted engagement metrics - O-count matters most, then duration, then play count</li> <li>Library presence normalization - Score relative to available content</li> <li>Bayesian dampening - Prevent small sample sizes from dominating</li> </ol>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#the-formula","title":"The Formula","text":"<p>For performers, tags, and studios:</p> <pre><code>rawEngagement = (oCount \u00d7 5) + (normalizedDuration \u00d7 1) + (playCount \u00d7 1)\n\nengagementRate = rawEngagement / libraryPresence\n\nfinalScore = (plays / (plays + m)) \u00d7 engagementRate + (m / (plays + m)) \u00d7 globalAvgRate\n</code></pre> <p>For scenes (no library presence to normalize against):</p> <pre><code>finalScore = (oCount \u00d7 5) + (normalizedDuration \u00d7 1) + (playCount \u00d7 1)\n</code></pre>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#variables-explained","title":"Variables Explained","text":"Variable Description Source <code>oCount</code> Number of Os recorded <code>UserPerformerStats.oCounter</code>, <code>WatchHistory.oCount</code>, etc. <code>normalizedDuration</code> Watch time normalized by average scene length <code>SUM(playDuration) / avgSceneDuration</code> <code>playCount</code> Number of times played <code>UserPerformerStats.playCount</code>, etc. <code>libraryPresence</code> Scenes available in library Count of scenes with this performer/tag/studio <code>plays</code> Total play events for this entity Same as playCount <code>m</code> Bayesian dampening threshold Tunable constant (recommend: 5) <code>globalAvgRate</code> Average engagement rate across all entities of this type Computed per-user"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#weight-rationale","title":"Weight Rationale","text":"Metric Weight Reasoning O-count 5 Strongest signal of genuine enjoyment Duration 1 Time spent indicates interest, but longer scenes shouldn't dominate Play count 1 Returning to content matters, but less than completion/enjoyment"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#bayesian-dampening","title":"Bayesian Dampening","text":"<p>The formula <code>(plays / (plays + m)) \u00d7 score + (m / (plays + m)) \u00d7 globalAvg</code> works as follows:</p> <ul> <li>With 0 plays: Score = 100% global average (no personal signal)</li> <li>With <code>m</code> plays: Score = 50% personal + 50% global average</li> <li>With <code>2m</code> plays: Score = 67% personal + 33% global average</li> <li>With <code>10m</code> plays: Score = 91% personal + 9% global average</li> </ul> <p>This prevents a performer with 2 scenes (both watched with Os) from unfairly beating a performer with 100 scenes (40 watched, 10 with Os). The small-catalog performer needs more engagement to prove they're truly a favorite.</p>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#example-calculations","title":"Example Calculations","text":"<p>Scenario: Phoenix's top performers</p> Performer Gender Library Scenes Plays Os Duration (norm) Raw Engagement Engagement Rate Bayesian Score Lexi Belle F 109 5 3 2.5 22.5 0.206 0.146 Scott Nails M 208 8 2 4.0 22.0 0.106 0.088 Evan Stone M 491 7 5 3.5 35.5 0.072 0.063 <p>Assuming m=5, globalAvgRate=0.05, avgSceneDuration=1200s</p> <p>With normalization + Bayesian dampening, Lexi Belle (female, smaller catalog, higher engagement rate) ranks above male performers with more raw plays.</p>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#implementation","title":"Implementation","text":""},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#database-changes","title":"Database Changes","text":"<p>None required - all data already exists in: - <code>WatchHistory</code> (scenes) - <code>UserPerformerStats</code>, <code>UserStudioStats</code>, <code>UserTagStats</code> (aggregated stats) - <code>StashScene</code>, <code>ScenePerformer</code>, <code>SceneTag</code> (library presence counts)</p>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#service-changes","title":"Service Changes","text":"<p>Modify <code>UserStatsAggregationService.ts</code>:</p> <ol> <li>Add helper to compute <code>globalAvgRate</code> per entity type</li> <li>Add helper to compute <code>avgSceneDuration</code> for normalization</li> <li>Update <code>getTopPerformers()</code>, <code>getTopStudios()</code>, <code>getTopTags()</code>, <code>getTopScenes()</code> to use new formula</li> <li>Return the computed score in API response for transparency</li> </ol>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#api-response-changes","title":"API Response Changes","text":"<p>Add <code>score</code> field to each top item so the UI can display it if desired:</p> <pre><code>interface TopPerformer {\n  id: string;\n  name: string;\n  imageUrl: string | null;\n  playCount: number;\n  playDuration: number;\n  oCount: number;\n  score: number;  // NEW: computed ranking score\n}\n</code></pre>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#configuration","title":"Configuration","text":"<p>Add tunable constants (could be environment variables or hardcoded initially):</p> <pre><code>const RANKING_CONFIG = {\n  weights: {\n    oCount: 5,\n    duration: 1,\n    playCount: 1,\n  },\n  bayesianThreshold: 5,  // 'm' in the formula\n};\n</code></pre>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>Unit tests for score calculation with known inputs</li> <li>Integration tests comparing old vs new rankings</li> <li>Manual verification with Phoenix user data - do rankings \"feel right\"?</li> </ol>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>User-configurable weights via settings</li> <li>Recency weighting (recent engagement matters more)</li> <li>Separate \"trending\" vs \"all-time\" rankings</li> <li>A/B testing different weight configurations</li> </ul>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#recommendations-page-integration-pending-validation","title":"Recommendations Page Integration (Pending Validation)","text":"<p>Once the user stats ranking formula is validated, these learnings can improve the Recommendations page (<code>RecommendationScoringService.ts</code>):</p>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#current-gaps-in-recommendations","title":"Current Gaps in Recommendations","text":"<ol> <li>No watch history data - Only uses explicit ratings/favorites, ignores actual viewing behavior</li> <li>No library presence normalization - Male performers / ubiquitous tags could dominate derived weights</li> <li>No small-sample dampening - A single favorited scene gives its performers full weight</li> </ol>"},{"location":"plans/2026-01-20-user-stats-ranking-formula-design/#proposed-improvements","title":"Proposed Improvements","text":"<ol> <li> <p>Hybrid scoring - Blend explicit preferences (current) with implicit engagement (this formula) for derived weights</p> </li> <li> <p>Engagement-weighted scene derivation - Currently a favorited scene propagates weight to all its performers equally. Weight by actual engagement instead: a performer in a scene watched 5x with 3 Os gets more derived weight than one in a scene favorited but barely watched.</p> </li> <li> <p>Library presence normalization for derived weights - When accumulating <code>derivedPerformerWeights</code>, divide by performer's library presence so niche performers with deep engagement rank higher.</p> </li> </ol> <p>Status: Pending validation of user stats formula. Test there first, then apply to recommendations.</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/","title":"UI/UX and Data/Backend Fixes Design","text":"<p>Date: 2026-02-01 Status: Draft</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#overview","title":"Overview","text":"<p>Two branches addressing user-reported issues and improvements. Branch 1 focuses on UI/UX fixes, Branch 2 on data/backend issues.</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#branch-1-uiux-issues","title":"Branch 1: UI/UX Issues","text":""},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#11-entity-select-dropdown-refactor","title":"1.1 Entity Select Dropdown Refactor","text":"<p>Problem: - Wrong entity data appears when switching between filter dropdowns (performers showing in tags) - Flicker on initial load (placeholder shows before names load) - Cache keys don't account for <code>countFilterContext</code></p> <p>Root Cause: <code>SearchableSelect.jsx</code> doesn't reset <code>options</code> state when <code>entityType</code> changes. Old data from previous entity type displays until a search triggers a fresh load.</p> <p>Fix:</p> <p>SearchableSelect.jsx: - Add useEffect to clear <code>options</code> when <code>entityType</code> or <code>countFilterContext</code> changes - Add <code>isLoadingInitial</code> state to show spinner instead of placeholder during load - Update options-loading condition to account for loading state</p> <p>filterCache.js: - Update getCache/setCache to accept optional context parameter - Build cache keys dynamically: <code>entityType</code> or <code>entityType_context</code></p> <p>Files: - <code>client/src/components/ui/SearchableSelect.jsx</code> - <code>client/src/utils/filterCache.js</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#12-carousel-card-height-consistency","title":"1.2 Carousel Card Height Consistency","text":"<p>Problem: Cards in carousels have inconsistent heights when metadata is missing.</p> <p>Root Cause: Carousel uses flexbox with no height constraints. Grid views use CSS Grid which auto-aligns row heights.</p> <p>Fix: Change carousel from flexbox to CSS Grid with horizontal flow.</p> <pre><code>// Before\n&lt;div className=\"flex gap-4 overflow-x-auto ...\"&gt;\n\n// After\n&lt;div className=\"grid grid-flow-col auto-cols-[280px] gap-4 overflow-x-auto ...\"&gt;\n</code></pre> <p>Files: - <code>client/src/components/ui/SceneCarousel.jsx</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#13-per-page-free-typing","title":"1.3 Per Page Free-Typing","text":"<p>Problem: Per Page control is a dropdown with fixed options. Users want to type custom values.</p> <p>Fix: - Replace <code>&lt;select&gt;</code> with editable number input - Validation: min 1, max 500, positive integers only - Submit on Enter or blur (debounced) - Optional: preset quick-select buttons for common values</p> <p>Files: - <code>client/src/components/ui/Pagination.jsx</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#14-per-page-value-in-presets","title":"1.4 Per Page Value in Presets","text":"<p>Problem: Filter presets don't save the perPage value.</p> <p>Fix: - Add <code>perPage</code> to preset object when saving - Apply <code>perPage</code> when loading preset (call <code>onPerPageChange</code>) - Backward compatible: old presets without perPage continue to work</p> <p>Files: - <code>client/src/components/ui/FilterPresets.jsx</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#branch-2-databackend-issues","title":"Branch 2: Data/Backend Issues","text":""},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#21-content-restriction-option-missing","title":"2.1 Content Restriction Option Missing","text":"<p>Problem: Content Restrictions button was removed when UserEditModal replaced inline buttons.</p> <p>Fix: Add Content Restrictions section to UserEditModal.</p> <pre><code>// Add to UserEditModal.jsx\nimport ContentRestrictionsModal from \"./ContentRestrictionsModal.jsx\";\n\n// Add state\nconst [showContentRestrictionsModal, setShowContentRestrictionsModal] = useState(false);\n\n// Add Section 5: Content Restrictions (after Account Actions)\n// - Brief description\n// - Button to open modal\n// - Render modal when open\n</code></pre> <p>Files: - <code>client/src/components/settings/UserEditModal.jsx</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#22-clips-count-mismatch-investigation","title":"2.2 Clips Count Mismatch (Investigation)","text":"<p>Problem: User sees 847 clips but server shows 9489 synced.</p> <p>Analysis: - Default filter <code>isGenerated=true</code> hides ungenerated clips - feederbox's markergen plugin triggers async preview generation - Incremental sync doesn't re-probe clips (Stash doesn't update <code>updated_at</code> on preview generation)</p> <p>Actions: 1. Verify with user: Are previews actually generated in Stash? 2. Verify placeholder hash is still accurate for current Stash versions 3. Consider adding \"Re-probe ungenerated clips\" option</p> <p>Files (potential): - <code>server/services/ClipPreviewProber.ts</code> - verify/update placeholder hash - <code>server/services/StashSyncService.ts</code> - add re-probe option</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#23-stats-page-ordering","title":"2.3 Stats Page Ordering","text":"<p>Problem: Top lists display o-count and play count but order by percentileRank (composite engagement score). Users see items ordered \"incorrectly\" relative to displayed values.</p> <p>Fix: 1. Display the engagement/percentile score so users understand the ranking 2. Add sort toggle: Engagement / O-Count / Play Count</p> <p>Files: - <code>client/src/components/pages/UserStats/components/TopList.jsx</code> - display score, add toggle - <code>server/services/UserStatsAggregationService.ts</code> - support sort parameter</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#24-playlist-items-on-scene-merges","title":"2.4 Playlist Items on Scene Merges","text":"<p>Problem: MergeReconciliationService handles WatchHistory and SceneRating but not PlaylistItem. Playlist items become orphaned when source scene is deleted.</p> <p>Fix: Add PlaylistItem handling to <code>transferUserData()</code>:</p> <pre><code>// Find playlist items pointing to source scene\nconst playlistItems = await prisma.playlistItem.findMany({\n  where: { sceneId: sourceSceneId }\n});\n\nfor (const item of playlistItems) {\n  // Check if target already in playlist\n  const existing = await prisma.playlistItem.findFirst({\n    where: { playlistId: item.playlistId, sceneId: targetSceneId }\n  });\n\n  if (existing) {\n    // Delete orphaned item (target already present)\n    await prisma.playlistItem.delete({ where: { id: item.id } });\n  } else {\n    // Update to point to target\n    await prisma.playlistItem.update({\n      where: { id: item.id },\n      data: { sceneId: targetSceneId, instanceId: targetInstanceId }\n    });\n  }\n}\n</code></pre> <p>Files: - <code>server/services/MergeReconciliationService.ts</code></p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#25-video-tag-images","title":"2.5 Video Tag Images","text":"<p>Problem: feederbox's tag-import plugin stores video files (.mp4, .webm) as tag images. Peek renders with <code>&lt;img&gt;</code> which can't play videos.</p> <p>Fix: Create MediaImage component that detects video content and renders appropriately.</p> <pre><code>// MediaImage.jsx\nconst MediaImage = ({ src, alt, className, ...props }) =&gt; {\n  const [isVideo, setIsVideo] = useState(false);\n  const [error, setError] = useState(false);\n\n  const handleError = async () =&gt; {\n    // Check Content-Type via HEAD request\n    try {\n      const res = await fetch(src, { method: 'HEAD' });\n      const contentType = res.headers.get('Content-Type');\n      if (contentType?.startsWith('video/')) {\n        setIsVideo(true);\n        return;\n      }\n    } catch {}\n    setError(true);\n  };\n\n  if (isVideo) {\n    return &lt;video src={src} autoPlay loop muted className={className} {...props} /&gt;;\n  }\n\n  if (error) {\n    return &lt;FallbackPlaceholder /&gt;;\n  }\n\n  return &lt;img src={src} alt={alt} className={className} onError={handleError} {...props} /&gt;;\n};\n</code></pre> <p>Files: - Create: <code>client/src/components/ui/MediaImage.jsx</code> - Update: Tag card components to use MediaImage</p>"},{"location":"plans/2026-02-01-ui-and-data-fixes-design/#implementation-order","title":"Implementation Order","text":"<p>Branch 1 (UI/UX): 1. Dropdown refactor (most impactful bug fix) 2. Carousel heights 3. Per Page free-typing 4. Per Page in presets</p> <p>Branch 2 (Data/Backend): 1. Content Restriction option (quick fix) 2. Playlist items on merge 3. Stats page ordering 4. Video tag images 5. Clips count (investigation, may defer)</p>"},{"location":"plans/2026-02-01-ui-ux-improvements/","title":"UI/UX Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix entity select dropdown bugs (wrong items, flicker), carousel card height inconsistency, and add per-page free-typing with preset saving.</p> <p>Architecture: Four independent UI fixes that can be committed separately. Each fix is isolated to 1-2 files with no cross-dependencies.</p> <p>Tech Stack: React 19, Tailwind CSS, localStorage caching</p>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-1-fix-entity-select-dropdown-reset-options-on-entitytype-change","title":"Task 1: Fix Entity Select Dropdown - Reset Options on EntityType Change","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx:28-32</code> (add state) - Modify: <code>client/src/components/ui/SearchableSelect.jsx:228-232</code> (fix useEffect)</p> <p>Problem: When switching between filter dropdowns (e.g., performers to tags), the <code>options</code> state retains old data. The condition <code>options.length === 0</code> is false, so new options aren't loaded.</p> <p>Step 1: Add state to track previous entityType/context</p> <p>In <code>SearchableSelect.jsx</code>, add a ref after the existing state declarations (around line 42):</p> <pre><code>// Add after line 42 (after dropdownRef)\nconst prevEntityTypeRef = useRef(entityType);\nconst prevCountFilterContextRef = useRef(countFilterContext);\n</code></pre> <p>Step 2: Add useEffect to reset options when entityType or countFilterContext changes</p> <p>Add this new useEffect after the existing useEffects (around line 232):</p> <pre><code>// Reset options when entityType or countFilterContext changes\nuseEffect(() =&gt; {\n  if (\n    prevEntityTypeRef.current !== entityType ||\n    prevCountFilterContextRef.current !== countFilterContext\n  ) {\n    // Clear options to force reload\n    setOptions([]);\n    setSelectedItems([]);\n    setSearchTerm(\"\");\n\n    // Update refs\n    prevEntityTypeRef.current = entityType;\n    prevCountFilterContextRef.current = countFilterContext;\n  }\n}, [entityType, countFilterContext]);\n</code></pre> <p>Step 3: Verify the fix manually</p> <ol> <li>Start dev environment: <code>docker-compose up -d</code></li> <li>Navigate to Scenes page, open Filters</li> <li>Open Performers dropdown, note the items</li> <li>Close it, open Tags dropdown</li> <li>Verify tags appear (not performers)</li> </ol> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx\ngit commit -m \"fix(SearchableSelect): reset options when entityType changes\n\nPreviously, switching between filter dropdowns (e.g., performers to tags)\nwould show stale data from the previous entity type until a search was\nperformed. This was because the options array wasn't being cleared when\nthe entityType prop changed.\n\nFixes the bug where performers appeared in the tags dropdown.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-2-fix-entity-select-dropdown-fix-cache-key-mismatch","title":"Task 2: Fix Entity Select Dropdown - Fix Cache Key Mismatch","text":"<p>Files: - Modify: <code>client/src/utils/filterCache.js:6-12</code> (update CACHE_KEYS) - Modify: <code>client/src/utils/filterCache.js:30-32</code> (update getCache) - Modify: <code>client/src/utils/filterCache.js:60-62</code> (update setCache)</p> <p>Problem: <code>SearchableSelect</code> builds cache keys like <code>\"tags_scenes\"</code> but <code>filterCache.js</code> only knows about simple keys like <code>\"tags\"</code>, so context-filtered cache lookups always fail.</p> <p>Step 1: Update getCache to handle dynamic keys</p> <p>Replace the <code>getCache</code> function (lines 30-53):</p> <pre><code>/**\n * Get cached data for an entity type\n * @param {string} cacheKey - Cache key (e.g., \"tags\" or \"tags_scenes\")\n * @returns {{data: Array, timestamp: number}|null} Cached data or null if stale/missing\n */\nexport const getCache = (cacheKey) =&gt; {\n  try {\n    // Support both simple keys (via CACHE_KEYS lookup) and composite keys (direct)\n    const storageKey = CACHE_KEYS[cacheKey] || `peek-${cacheKey}-cache`;\n    const cached = localStorage.getItem(storageKey);\n\n    if (!cached) {\n      return null;\n    }\n\n    const parsed = JSON.parse(cached);\n\n    // Check if cache is still fresh\n    if (!isCacheFresh(parsed.timestamp)) {\n      // Remove stale cache\n      localStorage.removeItem(storageKey);\n      return null;\n    }\n\n    return parsed;\n  } catch (error) {\n    console.error(`Error reading ${cacheKey} cache:`, error);\n    return null;\n  }\n};\n</code></pre> <p>Step 2: Update setCache to handle dynamic keys</p> <p>Replace the <code>setCache</code> function (lines 60-76):</p> <pre><code>/**\n * Set cache for an entity type\n * @param {string} cacheKey - Cache key (e.g., \"tags\" or \"tags_scenes\")\n * @param {Array} data - Array of {id, name} objects\n */\nexport const setCache = (cacheKey, data) =&gt; {\n  try {\n    // Support both simple keys (via CACHE_KEYS lookup) and composite keys (direct)\n    const storageKey = CACHE_KEYS[cacheKey] || `peek-${cacheKey}-cache`;\n    const cacheData = {\n      timestamp: Date.now(),\n      data,\n    };\n\n    localStorage.setItem(storageKey, JSON.stringify(cacheData));\n  } catch (error) {\n    console.error(`Error setting ${cacheKey} cache:`, error);\n    // If quota exceeded, try to clear old caches\n    if (error.name === \"QuotaExceededError\") {\n      clearAllCaches();\n    }\n  }\n};\n</code></pre> <p>Step 3: Verify the fix</p> <ol> <li>Open browser DevTools &gt; Application &gt; Local Storage</li> <li>Navigate to Scenes page, open Tags filter with scenes context</li> <li>Verify a key like <code>peek-tags_scenes-cache</code> appears</li> <li>Close and reopen - data should load from cache (no network request)</li> </ol> <p>Step 4: Commit</p> <pre><code>git add client/src/utils/filterCache.js\ngit commit -m \"fix(filterCache): support composite cache keys with context\n\nSearchableSelect builds cache keys like 'tags_scenes' for context-filtered\ndropdowns, but filterCache only knew about simple keys. Now both simple\nkeys (via CACHE_KEYS lookup) and composite keys (direct) are supported.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-3-fix-entity-select-dropdown-add-loading-state","title":"Task 3: Fix Entity Select Dropdown - Add Loading State","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx:31</code> (add state) - Modify: <code>client/src/components/ui/SearchableSelect.jsx:165-218</code> (update loadOptions) - Modify: <code>client/src/components/ui/SearchableSelect.jsx:309-311</code> (update placeholder display)</p> <p>Problem: When the component mounts with selected values, it shows the placeholder briefly before names load (flicker).</p> <p>Step 1: Add isLoadingInitial state</p> <p>After line 31 (<code>const [loading, setLoading] = useState(false);</code>), add:</p> <pre><code>const [isLoadingInitial, setIsLoadingInitial] = useState(false);\n</code></pre> <p>Step 2: Update the loadSelectedNames effect to use loading state</p> <p>Replace the <code>loadSelectedNames</code> async function inside the useEffect (lines 109-143):</p> <pre><code>const loadSelectedNames = async () =&gt; {\n  const valueArray = multi ? value : [value];\n\n  // First, try to find in already-loaded options\n  if (options.length &gt; 0) {\n    const selected = options.filter((opt) =&gt; valueArray.includes(opt.id));\n    if (selected.length === valueArray.length) {\n      setSelectedItems(selected);\n      return;\n    }\n  }\n\n  // Try localStorage cache\n  try {\n    // Build cache key including count filter context\n    const cacheKey = countFilterContext\n      ? `${entityType}_${countFilterContext}`\n      : entityType;\n    const cached = getCache(cacheKey);\n    if (cached?.data) {\n      const selected = cached.data.filter((opt) =&gt;\n        valueArray.includes(opt.id)\n      );\n\n      // If we found all items in cache, use them\n      if (selected.length === valueArray.length) {\n        setSelectedItems(selected);\n        return;\n      }\n    }\n\n    // Cache miss or incomplete - fetch by IDs from API\n    setIsLoadingInitial(true);\n    const results = await fetchItemsByIds(valueArray);\n    if (results &amp;&amp; results.length &gt; 0) {\n      setSelectedItems(results);\n    }\n  } catch (error) {\n    console.error(\"Error loading selected names:\", error);\n  } finally {\n    setIsLoadingInitial(false);\n  }\n};\n</code></pre> <p>Step 3: Update placeholder display to show loading indicator</p> <p>Replace lines 309-311 (the placeholder span inside the selectedItems display):</p> <pre><code>{selectedItems.length === 0 ? (\n  isLoadingInitial ? (\n    &lt;span style={{ color: \"var(--text-muted)\" }}&gt;Loading...&lt;/span&gt;\n  ) : (\n    &lt;span style={{ color: \"var(--text-muted)\" }}&gt;{placeholder}&lt;/span&gt;\n  )\n) : multi ? (\n</code></pre> <p>Step 4: Verify the fix</p> <ol> <li>Navigate to a page with pre-selected filters (use URL params or saved preset)</li> <li>Observe \"Loading...\" appears briefly instead of placeholder flicker</li> <li>Names appear after loading completes</li> </ol> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx\ngit commit -m \"fix(SearchableSelect): show loading state during initial name fetch\n\nInstead of showing the placeholder briefly before selected item names load,\nnow shows 'Loading...' text. This eliminates the flicker effect when\nthe component mounts with pre-selected values.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-4-fix-carousel-card-heights","title":"Task 4: Fix Carousel Card Heights","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCarousel.jsx:68</code> (loading skeleton) - Modify: <code>client/src/components/ui/SceneCarousel.jsx:174</code> (main carousel) - Modify: <code>client/src/components/ui/SceneCarousel.jsx:182-186</code> (card wrapper)</p> <p>Problem: Carousel uses flexbox which doesn't enforce equal heights. Cards with missing metadata are shorter than neighbors.</p> <p>Step 1: Update loading skeleton to use CSS Grid</p> <p>Replace line 68:</p> <pre><code>// Before\n&lt;div className=\"flex gap-4 overflow-hidden py-4\"&gt;\n\n// After\n&lt;div className=\"grid grid-flow-col auto-cols-[280px] gap-4 overflow-hidden py-4\"&gt;\n</code></pre> <p>Step 2: Update main carousel container to use CSS Grid</p> <p>Replace line 174:</p> <pre><code>// Before\nclassName=\"flex gap-4 overflow-x-auto scrollbar-hide py-4\"\n\n// After\nclassName=\"grid grid-flow-col auto-cols-[280px] gap-4 overflow-x-auto scrollbar-hide py-4\"\n</code></pre> <p>Step 3: Simplify card wrapper (grid handles sizing)</p> <p>Replace lines 182-186 (the card wrapper div):</p> <pre><code>// Before\n&lt;div\n  key={scene.id}\n  className=\"flex-shrink-0\"\n  style={{ width: \"280px\", minWidth: \"280px\" }}\n&gt;\n\n// After\n&lt;div key={scene.id}&gt;\n</code></pre> <p>Step 4: Update skeleton wrapper too</p> <p>Replace lines 71-73:</p> <pre><code>// Before\n&lt;div\n  key={i}\n  className=\"flex-shrink-0\"\n  style={{ width: \"280px\", minWidth: \"280px\" }}\n&gt;\n\n// After\n&lt;div key={i}&gt;\n</code></pre> <p>Step 5: Verify the fix</p> <ol> <li>Navigate to Home page with carousels</li> <li>Find scenes with varying metadata (some with dates/studios, some without)</li> <li>Verify all cards in the carousel have the same height</li> <li>Card bottoms should align horizontally</li> </ol> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/SceneCarousel.jsx\ngit commit -m \"fix(SceneCarousel): use CSS Grid for consistent card heights\n\nChanged carousel from flexbox to CSS Grid (grid-flow-col). Grid automatically\naligns all items in a row to the same height, fixing the issue where cards\nwith missing metadata were shorter than their neighbors.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-5-add-per-page-free-typing","title":"Task 5: Add Per Page Free-Typing","text":"<p>Files: - Modify: <code>client/src/components/ui/Pagination.jsx:68</code> (remove perPageOptions) - Modify: <code>client/src/components/ui/Pagination.jsx:184-216</code> (replace select with input)</p> <p>Problem: Per Page control is a dropdown with fixed options. Users want to type custom values.</p> <p>Step 1: Add state for input value and validation</p> <p>After line 29 (after the destructured props), add:</p> <pre><code>const [perPageInput, setPerPageInput] = useState(String(perPage));\nconst [perPageError, setPerPageError] = useState(false);\n\n// Sync input when perPage prop changes\nuseEffect(() =&gt; {\n  setPerPageInput(String(perPage));\n  setPerPageError(false);\n}, [perPage]);\n</code></pre> <p>Step 2: Add handler for per page input changes</p> <p>Add after the useEffect:</p> <pre><code>const handlePerPageChange = (value) =&gt; {\n  setPerPageInput(value);\n\n  const num = parseInt(value, 10);\n  if (isNaN(num) || num &lt; 1 || num &gt; 500) {\n    setPerPageError(true);\n    return;\n  }\n\n  setPerPageError(false);\n};\n\nconst handlePerPageSubmit = () =&gt; {\n  const num = parseInt(perPageInput, 10);\n  if (!isNaN(num) &amp;&amp; num &gt;= 1 &amp;&amp; num &lt;= 500 &amp;&amp; num !== perPage) {\n    onPerPageChange(num);\n  } else {\n    // Reset to current value if invalid\n    setPerPageInput(String(perPage));\n    setPerPageError(false);\n  }\n};\n\nconst handlePerPageKeyDown = (e) =&gt; {\n  if (e.key === \"Enter\") {\n    e.target.blur(); // Triggers onBlur which calls handlePerPageSubmit\n  }\n};\n</code></pre> <p>Step 3: Replace per page select with input</p> <p>Replace lines 184-218 (the entire perPageSelector div):</p> <pre><code>{showPerPageSelector &amp;&amp; onPerPageChange &amp;&amp; (\n  &lt;div className=\"flex items-center gap-2\"&gt;\n    &lt;label\n      htmlFor=\"perPage\"\n      className=\"hidden sm:block text-sm whitespace-nowrap\"\n      style={{ color: \"var(--text-muted)\" }}\n    &gt;\n      Per Page:\n    &lt;/label&gt;\n    &lt;div\n      data-tv-pagination-item=\"per-page\"\n      ref={(el) =&gt; paginationNav.setItemRef(5, el)}\n      className={paginationNav.isFocused(5) ? \"keyboard-focus\" : \"\"}\n    &gt;\n      &lt;input\n        id=\"perPage\"\n        type=\"number\"\n        min=\"1\"\n        max=\"500\"\n        value={perPageInput}\n        onChange={(e) =&gt; handlePerPageChange(e.target.value)}\n        onBlur={handlePerPageSubmit}\n        onKeyDown={handlePerPageKeyDown}\n        className=\"w-16 sm:w-20 px-2 sm:px-3 py-1 rounded text-sm font-medium transition-colors text-center\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          color: perPageError ? \"var(--status-error)\" : \"var(--text-primary)\",\n          border: `1px solid ${perPageError ? \"var(--status-error)\" : \"var(--border-color)\"}`,\n          height: \"1.8rem\",\n        }}\n      /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 4: Remove unused perPageOptions constant</p> <p>Delete line 68:</p> <pre><code>// Delete this line\nconst perPageOptions = [12, 24, 36, 48, 60, 72, 84, 96, 108, 120];\n</code></pre> <p>Step 5: Verify the fix</p> <ol> <li>Navigate to Scenes page</li> <li>Type a custom number (e.g., 50) in the Per Page input</li> <li>Press Enter or click away - page should reload with 50 items</li> <li>Try invalid values (0, -5, 999) - should show error styling and reset</li> </ol> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/Pagination.jsx\ngit commit -m \"feat(Pagination): allow free-typing per page value\n\nReplaced the per-page dropdown with a number input that accepts values 1-500.\nUsers can type any value and submit with Enter or blur. Invalid values show\nerror styling and reset to the current value.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#task-6-add-per-page-to-filter-presets","title":"Task 6: Add Per Page to Filter Presets","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterPresets.jsx:47-59</code> (add prop) - Modify: <code>client/src/components/ui/FilterPresets.jsx:117-129</code> (save perPage) - Modify: <code>client/src/components/ui/FilterPresets.jsx:148-167</code> (load perPage)</p> <p>Step 1: Add perPage prop to component</p> <p>Update the component props (around line 47):</p> <pre><code>const FilterPresets = ({\n  artifactType,\n  context,\n  currentFilters,\n  permanentFilters = {},\n  currentSort,\n  currentDirection,\n  currentViewMode = \"grid\",\n  currentZoomLevel = \"medium\",\n  currentGridDensity = \"medium\",\n  currentTableColumns = null,\n  currentPerPage = 24,  // Add this line\n  onLoadPreset,\n}) =&gt; {\n</code></pre> <p>Step 2: Include perPage when saving preset</p> <p>Update the apiPost call in handleSavePreset (around line 117):</p> <pre><code>await apiPost(\"/user/filter-presets\", {\n  artifactType,\n  context: effectiveContext,\n  name: presetName,\n  filters: filtersToSave,\n  sort: currentSort,\n  direction: currentDirection,\n  viewMode: currentViewMode,\n  zoomLevel: currentZoomLevel,\n  gridDensity: currentGridDensity,\n  tableColumns: currentViewMode === \"table\" ? currentTableColumns : null,\n  perPage: currentPerPage,  // Add this line\n  setAsDefault,\n});\n</code></pre> <p>Step 3: Include perPage when loading preset</p> <p>Update the onLoadPreset call in handleLoadPreset (around line 155):</p> <pre><code>onLoadPreset({\n  filters: mergedFilters,\n  sort: preset.sort,\n  direction: preset.direction,\n  viewMode: preset.viewMode || \"grid\",\n  zoomLevel: preset.zoomLevel || \"medium\",\n  gridDensity: preset.gridDensity || \"medium\",\n  tableColumns: preset.tableColumns || null,\n  perPage: preset.perPage || null,  // Add this line (null = don't change)\n});\n</code></pre> <p>Step 4: Update callers to pass currentPerPage and handle perPage in onLoadPreset</p> <p>This requires updating components that use FilterPresets. Search for FilterPresets usage:</p> <pre><code>grep -r \"FilterPresets\" client/src --include=\"*.jsx\" -l\n</code></pre> <p>For each file that uses FilterPresets, add: 1. Pass <code>currentPerPage={perPage}</code> prop 2. Handle <code>perPage</code> in the <code>onLoadPreset</code> callback</p> <p>Example for a typical usage:</p> <pre><code>&lt;FilterPresets\n  artifactType=\"scene\"\n  context={filterContext}\n  currentFilters={filters}\n  permanentFilters={permanentFilters}\n  currentSort={sort}\n  currentDirection={direction}\n  currentViewMode={viewMode}\n  currentZoomLevel={zoomLevel}\n  currentGridDensity={gridDensity}\n  currentTableColumns={tableColumns}\n  currentPerPage={perPage}  // Add this\n  onLoadPreset={(preset) =&gt; {\n    setFilters(preset.filters);\n    setSort(preset.sort);\n    setDirection(preset.direction);\n    setViewMode(preset.viewMode);\n    setZoomLevel(preset.zoomLevel);\n    setGridDensity(preset.gridDensity);\n    setTableColumns(preset.tableColumns);\n    if (preset.perPage) {  // Add this\n      setPerPage(preset.perPage);\n    }\n  }}\n/&gt;\n</code></pre> <p>Step 5: Verify the fix</p> <ol> <li>Navigate to Clips page</li> <li>Set per page to 50, apply some filters</li> <li>Save as preset</li> <li>Change per page to 24</li> <li>Load the preset - per page should change back to 50</li> </ol> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/FilterPresets.jsx\n# Add any other modified files that use FilterPresets\ngit commit -m \"feat(FilterPresets): save and load perPage value\n\nPresets now include the perPage value. When loading a preset, the perPage\nis applied if present (old presets without perPage continue to work).\n\nAddresses user request to remember per-page setting in Wall view presets.\"\n</code></pre>"},{"location":"plans/2026-02-01-ui-ux-improvements/#summary","title":"Summary","text":"Task Files Modified Purpose 1 SearchableSelect.jsx Reset options on entityType change 2 filterCache.js Support composite cache keys 3 SearchableSelect.jsx Add loading state to fix flicker 4 SceneCarousel.jsx Use CSS Grid for equal heights 5 Pagination.jsx Free-typing per page input 6 FilterPresets.jsx + callers Save/load perPage in presets <p>Each task results in one commit. Tasks 1-3 fix the dropdown bugs, Task 4 fixes carousel heights, Tasks 5-6 add the per-page improvements.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/","title":"Multiple Stash Instances - Implementation Plan","text":"<p>Status: Design Complete (v3.5) Created: 2025-11-25 Last Updated: 2026-01-22</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#overview","title":"Overview","text":"<p>This document outlines the implementation plan for supporting multiple Stash server instances in Peek, allowing users to aggregate content from multiple Stash libraries into a unified browsing experience.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#current-state-commit-1-complete","title":"Current State (Commit 1 Complete)","text":"<ul> <li><code>StashInstance</code> model exists in database with UUID primary key</li> <li><code>StashInstanceManager</code> service manages connections</li> <li>Single instance enforcement in place (<code>configs.length &gt; 1</code> throws error)</li> <li>Auto-migration from env vars to database on first startup</li> <li>Setup wizard allows configuring first Stash instance</li> <li>Server Settings shows current instance (read-only)</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#key-challenges","title":"Key Challenges","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#1-entity-id-collisions","title":"1. Entity ID Collisions","text":"<p>Stash uses auto-increment integer IDs per-instance. Scene ID <code>123</code> from Instance A is completely different from Scene ID <code>123</code> from Instance B.</p> <p>Options: - Composite key: Store <code>instanceId</code> + <code>sceneId</code> as separate columns (cleaner, preferred) - Prefixed ID: Concatenate as <code>{instanceId}_{sceneId}</code> string (simpler but messier)</p> <p>Decision: Use separate <code>instanceId</code> column for cleaner database architecture.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#2-entity-deduplication","title":"2. Entity Deduplication","text":"<p>The same performer/studio/tag may exist across multiple Stash instances: - Same performer with different local IDs - StashDB integration provides a common identifier (<code>stash_ids</code> field) - Need strategy to merge or deduplicate entities</p> <p>Considerations: - StashDB IDs can serve as deduplication key - If same StashDB ID exists on multiple instances, which one \"wins\"? - May need a \"primary\" instance concept for conflict resolution - Performers without StashDB IDs cannot be deduplicated automatically</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#3-filtering-across-instances","title":"3. Filtering Across Instances","text":"<p>Current filtering assumes single instance: - Tag filters reference tag IDs - Performer filters reference performer IDs - How do we filter when same logical entity has different IDs per instance?</p> <p>Options: - Filter by StashDB ID where available - Filter by name matching (fuzzy, less reliable) - Keep filters instance-scoped (simpler but less unified)</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#4-affected-entity-types","title":"4. Affected Entity Types","text":"<p>All Stash entities need instance tracking: - Scenes - Performers - Studios - Tags - Galleries - Groups - Images</p> <p>Each needs <code>instanceId</code> added to normalized types and cache storage.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#5-proxy-and-streaming","title":"5. Proxy and Streaming","text":"<p>Must route requests to correct instance: - Image proxy needs to know which instance to fetch from - Video streaming needs to use correct instance's file paths - Already have <code>getBaseUrl(instanceId)</code> and <code>getApiKey(instanceId)</code> methods</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#6-user-data-mapping","title":"6. User Data Mapping","text":"<p>Current user data (ratings, watch history, favorites) uses Stash entity IDs: - <code>WatchHistory.sceneId</code> references a scene - <code>SceneRating.sceneId</code> references a scene - Need composite key or migration strategy</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#phase-1-database-schema-foundation","title":"Phase 1: Database &amp; Schema Foundation","text":"<p>All database changes upfront so subsequent phases have the schema they need.</p> <ol> <li>Create migration: multi-instance-schema</li> <li>Add <code>description</code> field to <code>StashInstance</code></li> <li>Create <code>UserStashInstance</code> join table (user \u2194 instance selection)</li> <li>Add <code>instanceId</code> to <code>WatchHistory</code> (with default for existing data)</li> <li>Add <code>instanceId</code> to all rating tables (SceneRating, PerformerRating, etc.)</li> <li>Add <code>instanceId</code> to <code>PlaylistItem</code> for cross-instance playlists</li> <li>Update unique constraints to include <code>instanceId</code></li> <li>Add <code>instanceId</code> to normalized types (NormalizedScene, NormalizedPerformer, etc.)</li> <li>Update TypeScript interfaces for API responses</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-2-backend-multi-instance-support","title":"Phase 2: Backend Multi-Instance Support","text":"<ol> <li>Remove single-instance enforcement in StashInstanceManager</li> <li>Update StashCacheManager to fetch from all enabled instances and merge</li> <li>Update cache key strategy to use <code>instanceId:entityId</code> composite</li> <li>Add instance CRUD endpoints:</li> <li><code>GET /api/setup/stash-instances</code> - List all (admin)</li> <li><code>POST /api/setup/stash-instance</code> - Create (admin)</li> <li><code>PUT /api/setup/stash-instance/:id</code> - Update (admin)</li> <li><code>DELETE /api/setup/stash-instance/:id</code> - Delete (admin)</li> <li>Add user instance selection endpoints (for #321):</li> <li><code>GET /api/user/stash-instances</code> - Get user's selected instances</li> <li><code>PUT /api/user/stash-instances</code> - Update user's instance selection</li> <li>Trigger cache rebuild after any instance change</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-3-entity-routing-controllers","title":"Phase 3: Entity Routing &amp; Controllers","text":"<ol> <li>Update all controllers to handle composite entity references (<code>instanceId</code> + <code>entityId</code>)</li> <li>Update proxy controller to route image requests to correct instance</li> <li>Update video controller to stream from correct instance</li> <li>Update library controller to filter by user's selected instances</li> <li>Update user data controllers to include <code>instanceId</code> in all operations</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-4-deduplication-system","title":"Phase 4: Deduplication System","text":"<ol> <li>Fetch <code>stash_ids</code> arrays from Stash for performers/studios/tags</li> <li>Implement deduplication logic:</li> <li>Match entities by <code>(endpoint, stash_id)</code> pairs</li> <li>Designate primary instance for conflicts (lowest priority number)</li> <li>Surface conflicts to admin in UI</li> <li>Handle entities without stash_ids (keep separate, no auto-dedupe)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-5-ui-updates","title":"Phase 5: UI Updates","text":"<ol> <li>Update Server Settings &gt; Stash Instances for full CRUD:</li> <li>List all instances with status indicators</li> <li>Add Instance button with connection test</li> <li>Edit instance (name, description, URL, API key)</li> <li>Delete instance with confirmation</li> <li>Enable/disable toggle per instance</li> <li>Reorder by priority (drag-drop or arrows)</li> <li>Admin: View metadata conflicts (deduplicated entities with mismatched data)</li> <li>Show instance badge on entities (optional, admin toggle for debugging)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#database-schema-changes","title":"Database Schema Changes","text":"<pre><code>// Already exists - ADD description field\nmodel StashInstance {\n  id          String   @id @default(uuid())\n  name        String\n  description String?  // NEW - helps users understand what content is on this instance\n  url         String\n  apiKey      String\n  enabled     Boolean  @default(true)\n  priority    Int      @default(0)\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  // Relations\n  userSelections UserStashInstance[]\n}\n\n// NEW - tracks which instances each user wants to see content from\n// Users select instances during first-login setup (#321) or in User Preferences\nmodel UserStashInstance {\n  id         Int           @id @default(autoincrement())\n  userId     Int\n  instanceId String\n  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  instance   StashInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)\n  createdAt  DateTime      @default(now())\n\n  @@unique([userId, instanceId])\n}\n\n// Needs update - add instanceId to composite unique\nmodel WatchHistory {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\nmodel SceneRating {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\n// Similar changes for PerformerRating, StudioRating, etc.\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#user-instance-selection-behavior","title":"User Instance Selection Behavior","text":"<ul> <li>No rebuild needed when user changes instance selection</li> <li>Server cache stores ALL instances' content (fetched during startup/sync)</li> <li>User filtering happens at query time based on <code>UserStashInstance</code> records</li> <li>If user has no <code>UserStashInstance</code> records, they see content from ALL enabled instances (default behavior)</li> <li>Admins manage which instances exist; users choose which ones they want to see</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#normalized-type-changes","title":"Normalized Type Changes","text":"<pre><code>interface NormalizedScene {\n  id: string;\n  instanceId: string;  // NEW - which Stash instance this came from\n  // ... existing fields\n}\n\ninterface NormalizedPerformer {\n  id: string;\n  instanceId: string;  // NEW\n  stashDbId?: string;  // NEW - for deduplication\n  // ... existing fields\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#api-response-changes","title":"API Response Changes","text":"<p>Entities returned from API will include <code>instanceId</code>:</p> <pre><code>{\n  \"id\": \"12345\",\n  \"instanceId\": \"8dcbd5b1-73c1-4d1c-b3ce-0924c336e59f\",\n  \"title\": \"Scene Title\",\n  ...\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#design-decisions-resolved-2026-01-20","title":"Design Decisions (Resolved 2026-01-20)","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#1-deduplication-strategy","title":"1. Deduplication Strategy","text":"<p>Decision: Automatic with manual override capability.</p> <p>How it works: - Stash stores <code>stash_ids</code> as an array of <code>{endpoint, stash_id, updated_at}</code> per entity - Each entry identifies the stash-box URL and the ID within that stash-box - An entity can have multiple stash_ids from different stash-boxes</p> <p>Auto-deduplication rule: - If any <code>(endpoint, stash_id)</code> pair matches across instances \u2192 same entity - Different stash-box endpoints with different IDs \u2192 no automatic deduplication - Admin can manually link/merge entities that can't be auto-matched</p> <p>Example: <pre><code>Instance A performer: [{endpoint: \"stashdb.org\", stash_id: \"abc-123\"}]\nInstance B performer: [{endpoint: \"stashdb.org\", stash_id: \"abc-123\"}]\n\u2192 Match! Same performer, auto-dedupe.\n\nInstance A performer: [{endpoint: \"stashdb.org\", stash_id: \"abc-123\"}]\nInstance B performer: [{endpoint: \"private-box.local\", stash_id: \"xyz-789\"}]\n\u2192 No match. Could be same person, but no proof. Admin can manually link.\n</code></pre></p>"},{"location":"plans/MULTI_INSTANCE_STASH/#2-conflicting-metadata-handling","title":"2. Conflicting Metadata Handling","text":"<p>Decision: No automatic resolution in Peek. Surface conflicts, resolve in Stash.</p> <p>How it works: - When deduplicated entities have differing metadata, pick one deterministically (e.g., lowest instance priority number) - Surface conflicts to admin in UI (show which entities have mismatched data) - Admin resolves the conflict in Stash at the source - Next sync picks up the corrected data</p> <p>Rationale: Peek is a viewer, not a metadata management tool. Stash is the source of truth.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#3-performance-cache-strategy","title":"3. Performance / Cache Strategy","text":"<p>Decision: Admin-configurable sync interval with staggered refresh.</p> <p>How it works: - Admin can configure sync interval (default: hourly) - Instances refresh in staggered fashion, not all at once - Parallel fetching during sync for each instance - Per-instance cache invalidation when needed</p> <p>Details: Implementation detail to refine during development.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#4-instance-filtering-in-ui","title":"4. Instance Filtering in UI","text":"<p>Decision: Unified view only (no per-instance filtering).</p> <p>How it works: - Users select which instances to use during first-login setup (v3.3 feature) - After setup, users see a merged library from their selected instances - No filter option to show \"only Instance A\" in browse UI</p> <p>Future: Could add as advanced/power-user feature if requested.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#5-playlist-scope","title":"5. Playlist Scope","text":"<p>Decision: Global playlists (cross-instance).</p> <p>How it works: - Playlists can contain scenes from any instance - Playlist items store <code>(instanceId, sceneId)</code> composite reference - Fits the unified library experience</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-1-single-stash-instance-only","title":"Alternative 1: Single Stash Instance Only","text":"<p>Keep the current single-instance design. Users with multiple Stash servers would need to consolidate into one Stash instance.</p> <p>Pros: Simpler, no ID collision issues Cons: Limits use cases, some users have legitimate multi-instance setups</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-2-instance-scoped-everything","title":"Alternative 2: Instance-Scoped Everything","text":"<p>Keep instances completely separate - user switches between instances like switching accounts.</p> <p>Pros: No collision issues, simpler implementation Cons: No unified library view, poor UX for users who want to see everything together</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-3-external-aggregation","title":"Alternative 3: External Aggregation","text":"<p>Recommend users use Stash's built-in library merging features instead.</p> <p>Pros: No Peek changes needed Cons: May not exist, shifts burden to user</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#estimated-effort","title":"Estimated Effort","text":"<ul> <li>Phase 1: 1-2 days</li> <li>Phase 2: 2-3 days</li> <li>Phase 3: 2-3 days</li> <li>Phase 4: 1-2 days</li> </ul> <p>Total: ~1 week of focused development</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#dependencies","title":"Dependencies","text":"<ul> <li>v3.3 First-Login Setup Wizard (#321) - User instance selection happens here</li> <li>Testing with multiple actual Stash instances</li> <li>Understanding of stash-box <code>stash_ids</code> structure (researched - see Design Decisions)</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#references","title":"References","text":"<ul> <li>Stash GraphQL Schema</li> <li>StashDB Integration Docs</li> <li>Commit 1: <code>291b428</code> - Single instance database storage</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#integration-with-321-user-instance-selection","title":"Integration with #321 (User Instance Selection)","text":"<p>This feature provides the backend; #321 provides the UI for user instance selection.</p> <p>What this feature provides: - <code>UserStashInstance</code> table storing user \u2194 instance associations - <code>GET /api/user/stash-instances</code> - Get current user's selected instances - <code>PUT /api/user/stash-instances</code> - Update user's instance selection - Query-time filtering based on user's selections</p> <p>What #321 will implement: - First-login setup wizard step: \"Select which Stash instances to see content from\" - User Preferences page: Instance selection management - UI calls the endpoints above</p> <p>Behavior: - New users with no <code>UserStashInstance</code> records see ALL enabled instances (sensible default) - Users can opt out of specific instances via setup wizard or preferences - Changing selection takes effect immediately (no rebuild, just query-time filtering) - If an instance is disabled by admin, it's hidden from all users regardless of selection</p>"},{"location":"plans/REELS_IMPLEMENTATION/","title":"TikTok/Reels Implementation Analysis","text":""},{"location":"plans/REELS_IMPLEMENTATION/#overview","title":"Overview","text":"<p>This document analyzes what it would take to implement a TikTok/Reels-like experience in Peek, based on user requests referencing Stash TV and StashReels.</p> <p>Important: This would be a separate page/view, not replacing any existing functionality.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#what-users-want","title":"What Users Want","text":"<p>Based on StashReels and Stash TV implementations:</p>"},{"location":"plans/REELS_IMPLEMENTATION/#core-experience","title":"Core Experience","text":"<ul> <li>Vertical swipe/scroll through videos</li> <li>Auto-play when video comes into view</li> <li>Tap to pause/play</li> <li>Minimal, non-intrusive UI</li> <li>Filter-based playlists (use saved Stash filters)</li> <li>Infinite scrolling to load more content</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#key-features","title":"Key Features","text":"<ul> <li>Mute/unmute toggle</li> <li>Quality selector</li> <li>Fullscreen mode</li> <li>O-counter button</li> <li>Rating stars</li> <li>Video scrubbing with thumbnails</li> <li>Performer/tag links</li> <li>Scene info overlay (hideable)</li> <li>Landscape rotation support</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#technical-architecture","title":"Technical Architecture","text":""},{"location":"plans/REELS_IMPLEMENTATION/#route-page-structure","title":"Route &amp; Page Structure","text":"<pre><code>/reels (new page)\n  - Query params: ?filter=xyz&amp;index=123\n  - Separate from scene browse/grid view\n  - Can deep-link to specific position\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#navigation-integration","title":"Navigation Integration","text":"<pre><code>Current Navigation:\n- Home\n- Scenes (grid view)\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n\nWith Reels Added:\n- Home\n- Scenes (grid view) \u2190 unchanged\n- Reels \u2190 NEW PAGE\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#core-components","title":"Core Components","text":"<p>ReelsPage Component: - Main container with vertical scroll - Manages playlist state (current filter, scenes) - Handles pagination/infinite scroll - Filter selection UI</p> <p>ReelItem Component: - Simplified video player for each scene - Auto-play when in viewport (Intersection Observer) - Pause when scrolled away - Minimal overlay controls - Scene metadata display</p> <p>ReelsControls Component: - Floating UI for global controls - Filter/playlist selector - Settings panel - Exit button</p>"},{"location":"plans/REELS_IMPLEMENTATION/#critical-technical-challenges","title":"Critical Technical Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#1-memory-management-most-important","title":"1. Memory Management (MOST IMPORTANT)","text":"<p>Video.js players consume significant RAM. Cannot have 50 players initialized at once.</p> <p>Solution: Only render 3-5 video elements at a time - Current video (playing) - Next video (pre-buffering) - Previous video (for smooth back-scroll) - Dispose players that scroll out of range</p> <p>StashReels Approach:</p> <p>\"Loads only 11 scenes at once\u2014current scene plus five before and after\u2014to optimize browser memory\"</p> <p>Recommended Strategy:</p> <pre><code>Viewport:\n  [Video -2] \u2190 disposed, removed from DOM\n  [Video -1] \u2190 rendered but paused, player initialized\n  [Video  0] \u2190 CURRENT, playing, HLS session active\n  [Video +1] \u2190 rendered, pre-buffering, HLS starting\n  [Video +2] \u2190 rendered element, no player yet\n  [Video +3] \u2190 disposed, removed from DOM\n</code></pre> <p>Rules: - Only 3-4 Video.js players initialized - Only 1-2 active transcoding sessions - Dispose players &gt;2 positions away - Use Intersection Observer threshold for triggering</p>"},{"location":"plans/REELS_IMPLEMENTATION/#2-transcoding-session-management","title":"2. Transcoding Session Management","text":"<p>Each video creates HLS transcoding session. Can't have 20+ FFmpeg processes running.</p> <p>Solution: - Cleanup sessions immediately on scroll away - Pre-start transcoding for next video - Limit to 2-3 active sessions max - Extend <code>TranscodingManager</code> with session priority system</p>"},{"location":"plans/REELS_IMPLEMENTATION/#3-auto-play-restrictions","title":"3. Auto-Play Restrictions","text":"<p>Mobile browsers block autoplay without user interaction. iOS Safari is particularly restrictive.</p> <p>Solution: - First video requires user tap - After that, can auto-play with muted default - Unmute button shows when needed - Fallback UI: \"Tap to play\" message</p>"},{"location":"plans/REELS_IMPLEMENTATION/#4-scroll-performance","title":"4. Scroll Performance","text":"<p>Need smooth 60fps scrolling with videos.</p> <p>Solution: - CSS scroll-snap-type - Intersection Observer (not scroll events) - GPU-accelerated transforms - Virtual scrolling if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-advantages","title":"Implementation Advantages","text":""},{"location":"plans/REELS_IMPLEMENTATION/#what-peek-already-has","title":"What Peek Already Has \u2705","text":"<ul> <li>Video.js integration - Can reuse player setup</li> <li>HLS transcoding system - TranscodingManager ready</li> <li>Quality selection - Already implemented</li> <li>O-counter + rating - Existing buttons/tracking</li> <li>Watch history - Track viewed reels</li> <li>Scene metadata - Performers, tags, descriptions</li> <li>Theme system - Dark/light modes work</li> <li>Auth system - User preferences</li> <li>Mobile responsive - Touch-friendly UI</li> <li>Saved filters from Stash - Can fetch via GraphQL</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#whats-new-need-to-build","title":"What's New (Need to Build) \ud83c\udd95","text":"<ul> <li>Vertical scroll container - With snap points</li> <li>Intersection Observer logic - Trigger play/pause</li> <li>Player lifecycle management - Create/dispose on scroll</li> <li>Gesture handling - Swipe up/down, double-tap</li> <li>Prefetch strategy - Pre-buffer next video</li> <li>Memory monitoring - Track and cleanup aggressively</li> <li>Playlist management - Filter selection, pagination</li> <li>Minimal UI overlay - Different from full player</li> <li>Infinite scroll pagination - Load more scenes</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-effort-estimate","title":"Implementation Effort Estimate","text":""},{"location":"plans/REELS_IMPLEMENTATION/#phase-1-mvp-5-7-days","title":"Phase 1: MVP (5-7 days)","text":"<ul> <li>Basic vertical scroll with 3 videos</li> <li>Simple auto-play/pause on scroll</li> <li>Minimal controls (mute, close, O-counter)</li> <li>Single filter (e.g., \"Recently Added\")</li> <li>Desktop + mobile basic support</li> </ul> <p>Deliverable: Can swipe through videos with basic playback</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-2-full-features-5-7-days","title":"Phase 2: Full Features (5-7 days)","text":"<ul> <li>Filter selection modal</li> <li>Infinite scroll pagination</li> <li>Full controls (quality, scrubber, fullscreen)</li> <li>Rating integration</li> <li>Scene info overlay</li> <li>Memory optimization</li> <li>Prefetch next video</li> </ul> <p>Deliverable: Feature-complete reels experience</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-3-polish-3-5-days","title":"Phase 3: Polish (3-5 days)","text":"<ul> <li>Mobile gesture improvements (double-tap, swipe velocity)</li> <li>Keyboard shortcuts (arrow keys, space)</li> <li>Performance tuning (virtual scrolling if needed)</li> <li>iOS Safari fixes (autoplay, fullscreen)</li> <li>User preferences (default filter, default quality, mute state)</li> <li>Analytics/tracking</li> <li>Error states (network issues, empty playlists)</li> </ul> <p>Deliverable: Production-ready, polished experience</p> <p>Total Estimate: 13-19 days</p>"},{"location":"plans/REELS_IMPLEMENTATION/#key-technical-decisions","title":"Key Technical Decisions","text":""},{"location":"plans/REELS_IMPLEMENTATION/#scroll-implementation","title":"Scroll Implementation","text":"<p>Option A: Native CSS Scroll Snap (Recommended) <pre><code>.reels-container {\n  scroll-snap-type: y mandatory;\n  overflow-y: scroll;\n}\n\n.reel-item {\n  scroll-snap-align: start;\n  height: 100vh;\n}\n</code></pre></p> <p>Pros: Native, smooth, performant Cons: Less control over snap behavior</p> <p>Option B: Custom Scroll Logic Use wheel/touch events with programmatic scrolling</p> <p>Pros: Full control Cons: Complex, hard to get right, performance issues</p> <p>Recommendation: Start with Option A, fall back to B if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#video-player-approach","title":"Video Player Approach","text":"<p>Option A: Reuse existing <code>VideoPlayer</code> component - Pros: Less code duplication - Cons: Component is complex, has unused features for reels</p> <p>Option B: Create simplified <code>ReelVideoPlayer</code> - Pros: Optimized for reels, cleaner, lighter - Cons: Some code duplication</p> <p>Recommendation: Option B - Create <code>ReelVideoPlayer</code> that shares core Video.js setup but removes unnecessary UI (playlist controls, chapter markers, etc.)</p>"},{"location":"plans/REELS_IMPLEMENTATION/#state-management","title":"State Management","text":"<p>Relatively simple state: <pre><code>{\n  filter: currentFilterId,\n  scenes: [...scene IDs...],\n  currentIndex: 123,\n  hasMore: true,\n  loading: false,\n  muted: true,\n  quality: \"720p\"\n}\n</code></pre></p> <p>Recommendation: React Context or simple useState, no need for Redux/Zustand yet</p>"},{"location":"plans/REELS_IMPLEMENTATION/#transcoding-quality","title":"Transcoding Quality","text":"<p>Users on mobile may want lower quality for data usage.</p> <p>Options: 1. Default to 480p for reels 2. Remember user's last quality selection 3. Auto-select based on connection speed 4. Allow per-reel quality override</p> <p>Recommendation: Start with user's last selected quality, add auto-select later if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#risks-challenges","title":"Risks &amp; Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#high-risk","title":"High Risk","text":"<ol> <li>Memory leaks - Video.js players not properly disposed</li> <li>Transcoding overload - Too many FFmpeg sessions crash server</li> <li>iOS autoplay - Safari blocks autoplay, breaks experience</li> <li>Janky scroll - Videos lag during scroll</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#medium-risk","title":"Medium Risk","text":"<ol> <li>Network handling - Slow connections, failed loads</li> <li>Empty states - No scenes match filter</li> <li>Battery drain - Continuous video playback on mobile</li> <li>User getting \"lost\" - Infinite scroll, no clear endpoint</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Extensive memory profiling during development</li> <li>TranscodingManager session limits</li> <li>Fallback UI for autoplay failures (\"Tap to play\")</li> <li>Virtual scrolling if performance issues</li> <li>\"You've reached the end\" message after X videos</li> <li>Exit button always visible</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#user-experience-considerations","title":"User Experience Considerations","text":""},{"location":"plans/REELS_IMPLEMENTATION/#must-haves","title":"Must-Haves","text":"<ul> <li>\u26a1 Fast response - Video plays within 500ms of scroll</li> <li>\ud83c\udfaf Clear controls - Obvious how to mute, exit, etc.</li> <li>\ud83d\udcf1 Touch-friendly - Large tap targets, intuitive gestures</li> <li>\ud83d\udd01 Smooth transitions - No blank frames between videos</li> <li>\ud83d\udeaa Easy exit - Back button, close button work intuitively</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#nice-to-haves","title":"Nice-to-Haves","text":"<ul> <li>\u2328\ufe0f Keyboard shortcuts - Space (pause), arrows (next/prev)</li> <li>\ud83d\uddb1\ufe0f Mouse wheel - Desktop users can scroll with wheel</li> <li>\ud83d\udcca Progress indicator - \"Video 5 of 47\" or similar</li> <li>\ud83d\udd16 Remember position - Resume where you left off</li> <li>\ud83c\udfa8 Visual polish - Transitions, animations</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#integration-with-existing-features","title":"Integration with Existing Features","text":""},{"location":"plans/REELS_IMPLEMENTATION/#reuse-existing-components","title":"Reuse Existing Components","text":"<ul> <li><code>SceneStats</code> component (O-counter, rating)</li> <li><code>SceneMetadata</code> component (performers, tags)</li> <li><code>libraryApi</code> service (fetch scenes)</li> <li><code>watchHistoryApi</code> (track views)</li> <li><code>TranscodingManager</code> (HLS sessions)</li> <li>Quality selector UI</li> <li>Auth/theme contexts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#new-components","title":"New Components","text":"<ul> <li><code>ReelsPage.jsx</code> - Main page container</li> <li><code>ReelVideoPlayer.jsx</code> - Simplified player based on <code>VideoPlayer</code></li> <li><code>ReelItem.jsx</code> - Individual reel in scroll container</li> <li><code>ReelsControls.jsx</code> - Floating control UI</li> <li><code>useReelsPlayer.js</code> - Player lifecycle hook</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#modifications-needed","title":"Modifications Needed","text":"<ul> <li>Extend <code>TranscodingManager</code> with session priority (reels vs regular playback)</li> <li>Add reels-specific watch tracking (mark as viewed after X seconds)</li> <li>Add user preferences for reels (default filter, mute state, quality)</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#benefits-of-being-a-separate-page","title":"Benefits of Being a Separate Page","text":""},{"location":"plans/REELS_IMPLEMENTATION/#zero-risk-to-existing-features","title":"Zero Risk to Existing Features","text":"<ul> <li>All current pages (Scenes, Scene Detail, Playlists, etc.) remain untouched</li> <li>If reels page has bugs, doesn't affect main browsing</li> <li>Can be feature-flagged or hidden behind settings if needed</li> <li>Easy to disable if issues arise</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#simpler-implementation","title":"Simpler Implementation","text":"<ul> <li>Don't need to refactor existing components</li> <li>Can use completely different layout/structure</li> <li>Can ignore desktop optimizations if mobile-focused</li> <li>Different routing, different state management</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#gradual-rollout","title":"Gradual Rollout","text":"<ul> <li>Can release as \"beta\" feature</li> <li>Add nav link only when ready</li> <li>Can gather feedback without disrupting existing workflows</li> <li>Easy to A/B test</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#resource-isolation","title":"Resource Isolation","text":"<ul> <li>Reels page uses its own Video.js players (separate from scene detail)</li> <li>Can set different transcoding limits for reels vs regular playback</li> <li>Memory cleanup when navigating away (unmount entire page)</li> <li>No shared state conflicts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#mobile-first-design","title":"Mobile-First Design","text":"<ul> <li>Can optimize entirely for mobile without breaking desktop scene browsing</li> <li>Different UI paradigms (vertical vs grid) don't conflict</li> <li>Touch gestures won't interfere with click interactions elsewhere</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#rollback-safety","title":"Rollback Safety","text":"<p>If reels page has critical bugs: <pre><code>// In navigation or route config\nconst REELS_ENABLED = import.meta.env.VITE_ENABLE_REELS === 'true';\n\n// Or user setting\nif (user.preferences.showReels) {\n  // Show reels nav link\n}\n</code></pre></p> <p>Can disable without affecting anything else.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#recommended-implementation-path","title":"Recommended Implementation Path","text":""},{"location":"plans/REELS_IMPLEMENTATION/#option-a-mvp-first-recommended","title":"Option A: MVP First (Recommended)","text":"<ol> <li>Validate Demand - Confirm multiple users requesting this</li> <li>Build MVP (3-5 days):</li> <li>Single hardcoded filter (\"Recently Added\")</li> <li>No infinite scroll (just load 20 videos)</li> <li>Basic controls only</li> <li>Desktop-first (mobile later)</li> <li>User Testing - Get feedback before full build</li> <li>Iterate - Build out full features based on feedback</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#option-b-full-build","title":"Option B: Full Build","text":"<p>Skip MVP, build complete feature over 2-3 weeks. Higher risk but faster time-to-complete if MVP would be approved anyway.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#success-criteria","title":"Success Criteria","text":"<p>Technical: - Memory usage stays under 500MB even after 50+ videos viewed - Max 2-3 concurrent transcoding sessions - Smooth 60fps scroll on mobile devices - Video starts within 500ms of scroll</p> <p>User Experience: - 80%+ of users can navigate without instructions - &lt;5% bounce rate on reels page - Average session length &gt;5 minutes - Positive feedback in Discord/GitHub</p>"},{"location":"plans/REELS_IMPLEMENTATION/#conclusion","title":"Conclusion","text":"<p>Arguments For: - \ud83d\udc4d High user engagement (TikTok proves the UX works) - \ud83d\udc4d Differentiates Peek from Stash - \ud83d\udc4d Mobile-first feature (Peek's strength) - \ud83d\udc4d Peek has good infrastructure already (video player, transcoding) - \ud83d\udc4d Can be isolated page (low risk to existing features)</p> <p>Arguments Against: - \ud83d\udc4e Significant effort (2-3 weeks full-time) - \ud83d\udc4e Performance risks (memory, transcoding load) - \ud83d\udc4e Ongoing maintenance (iOS Safari bugs, etc.) - \ud83d\udc4e StashReels already exists for Stash users - \ud83d\udc4e May encourage mindless consumption</p> <p>Recommendation: If you have 2-3 weeks of development time and users are actively requesting this, it's worth building. Start with a minimal MVP to validate the approach, then iterate based on feedback.</p> <p>The key to success will be: 1. Aggressive memory management - Only 3-5 players max 2. Transcoding limits - Max 2 concurrent sessions 3. Mobile testing early - iOS Safari will be the pain point 4. Performance profiling - Measure memory/CPU continuously</p> <p>Last Updated: 2025-10-30 Status: Analysis complete, awaiting decision to proceed</p>"},{"location":"reference/api-reference/","title":"API Reference","text":"<p>Auto-generated from TypeScript source files. Last updated: 2026-01-04</p>"},{"location":"reference/api-reference/#contents","title":"Contents","text":"<ul> <li>Auth</li> <li>Setup</li> <li>Sync</li> <li>Exclusions</li> <li>User</li> <li>Playlists</li> <li>Carousels</li> <li>Watch History</li> <li>Image View History</li> <li>Ratings</li> <li>Custom Themes</li> <li>Library</li> </ul>"},{"location":"reference/api-reference/#auth","title":"Auth","text":"<p>Authentication endpoints for login, logout, and session management.</p>"},{"location":"reference/api-reference/#setup","title":"Setup","text":"<p>Setup wizard endpoints for initial configuration.</p>"},{"location":"reference/api-reference/#get-apisetupstatus","title":"GET /api/setup/status","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface GetSetupStatusResponse {\n  setupComplete: boolean;\n  hasUsers: boolean;\n  hasStashInstance: boolean;\n  userCount: number;\n  stashInstanceCount: number;\n}\n</code></pre> <p>Controller: <code>getSetupStatus</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#post-apisetupcreate-admin","title":"POST /api/setup/create-admin","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface CreateFirstAdminRequest {\n  username: string;\n  password: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateFirstAdminResponse {\n  success: true;\n  user: {\n  id: number;\n  username: string;\n  role: string;\n  createdAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>createFirstAdmin</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#post-apisetuptest-stash-connection","title":"POST /api/setup/test-stash-connection","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface TestStashConnectionRequest {\n  url: string;\n  apiKey: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface TestStashConnectionResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n  details?: string;\n}\n</code></pre> <p>Controller: <code>testStashConnection</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#post-apisetupcreate-stash-instance","title":"POST /api/setup/create-stash-instance","text":"<p>Authentication: None</p> <p>Request Body:</p> <pre><code>interface CreateFirstStashInstanceRequest {\n  name?: string;\n  url: string;\n  apiKey: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateFirstStashInstanceResponse {\n  success: true;\n  instance: {\n  id: string;\n  name: string;\n  url: string;\n  enabled: boolean;\n  createdAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>createFirstStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#post-apisetupreset","title":"POST /api/setup/reset","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface ResetSetupResponse {\n  success: true;\n  message: string;\n  deleted: {\n  users: number;\n  stashInstances: number;\n};\n}\n</code></pre> <p>Controller: <code>resetSetup</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#get-apisetupstash-instance","title":"GET /api/setup/stash-instance","text":"<p>Authentication: None</p> <p>Response:</p> <pre><code>interface GetStashInstanceResponse {\n  instance: {\n  id: string;\n  name: string;\n  url: string;\n  enabled: boolean;\n  priority: number;\n  createdAt: Date;\n  updatedAt: Date;\n} | null;\n  instanceCount: number;\n}\n</code></pre> <p>Controller: <code>getStashInstance</code> in <code>../controllers/setup.ts</code></p>"},{"location":"reference/api-reference/#sync","title":"Sync","text":"<p>Cache synchronization endpoints for refreshing Stash data.</p>"},{"location":"reference/api-reference/#exclusions","title":"Exclusions","text":"<p>Content exclusion management endpoints.</p>"},{"location":"reference/api-reference/#user","title":"User","text":"<p>User settings and preference endpoints.</p>"},{"location":"reference/api-reference/#get-apiusersettings","title":"GET /api/user/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiusersettings","title":"PUT /api/user/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#post-apiuserchange-password","title":"POST /api/user/change-password","text":"<p>Authentication: Required</p> <p>Controller: <code>changePassword</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuserfilter-presets","title":"GET /api/user/filter-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>getFilterPresets</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#post-apiuserfilter-presets","title":"POST /api/user/filter-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>saveFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#delete-apiuserfilter-presetsartifacttypepresetid","title":"DELETE /api/user/filter-presets/:artifactType/:presetId","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuserdefault-presets","title":"GET /api/user/default-presets","text":"<p>Authentication: Required</p> <p>Controller: <code>getDefaultFilterPresets</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiuserdefault-preset","title":"PUT /api/user/default-preset","text":"<p>Authentication: Required</p> <p>Controller: <code>setDefaultFilterPreset</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuserall","title":"GET /api/user/all","text":"<p>Authentication: Required</p> <p>Controller: <code>getAllUsers</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#post-apiusercreate","title":"POST /api/user/create","text":"<p>Authentication: Required</p> <p>Controller: <code>createUser</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#delete-apiuseruserid","title":"DELETE /api/user/:userId","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteUser</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiuseruseridrole","title":"PUT /api/user/:userId/role","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserRole</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiuseruseridsettings","title":"PUT /api/user/:userId/settings","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserSettings</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#post-apiuseruseridsync-from-stash","title":"POST /api/user/:userId/sync-from-stash","text":"<p>Authentication: Required</p> <p>Controller: <code>syncFromStash</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuseruseridrestrictions","title":"GET /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>getUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiuseruseridrestrictions","title":"PUT /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>updateUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#delete-apiuseruseridrestrictions","title":"DELETE /api/user/:userId/restrictions","text":"<p>Authentication: Required</p> <p>Controller: <code>deleteUserRestrictions</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#post-apiuserhidden-entities","title":"POST /api/user/hidden-entities","text":"<p>Authentication: Required</p> <p>Controller: <code>hideEntity</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#delete-apiuserhidden-entitiesall","title":"DELETE /api/user/hidden-entities/all","text":"<p>Authentication: Required</p> <p>Controller: <code>unhideAllEntities</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#delete-apiuserhidden-entitiesentitytypeentityid","title":"DELETE /api/user/hidden-entities/:entityType/:entityId","text":"<p>Authentication: Required</p> <p>Controller: <code>unhideEntity</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuserhidden-entities","title":"GET /api/user/hidden-entities","text":"<p>Authentication: Required</p> <p>Controller: <code>getHiddenEntities</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#get-apiuserhidden-entitiesids","title":"GET /api/user/hidden-entities/ids","text":"<p>Authentication: Required</p> <p>Controller: <code>getHiddenEntityIds</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#put-apiuserhide-confirmation","title":"PUT /api/user/hide-confirmation","text":"<p>Authentication: Required</p> <p>Controller: <code>updateHideConfirmation</code> in <code>../controllers/user.ts</code></p>"},{"location":"reference/api-reference/#playlists","title":"Playlists","text":"<p>Playlist management endpoints for creating and organizing scene collections.</p>"},{"location":"reference/api-reference/#get-apiplaylists","title":"GET /api/playlists/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserPlaylistsResponse {\n  playlists: PlaylistData[];\n}\n</code></pre> <p>Controller: <code>getUserPlaylists</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#get-apiplaylistsid","title":"GET /api/playlists/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetPlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>getPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#post-apiplaylists","title":"POST /api/playlists/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreatePlaylistRequest {\n  name: string;\n  description?: string;\n  isPublic?: boolean;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreatePlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>createPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#put-apiplaylistsid","title":"PUT /api/playlists/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdatePlaylistRequest {\n  name?: string;\n  description?: string;\n  isPublic?: boolean;\n  shuffle?: boolean;\n  repeat?: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdatePlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdatePlaylistResponse {\n  playlist: PlaylistData;\n}\n</code></pre> <p>Controller: <code>updatePlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#delete-apiplaylistsid","title":"DELETE /api/playlists/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeletePlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeletePlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>deletePlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#post-apiplaylistsiditems","title":"POST /api/playlists/:id/items","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface AddSceneToPlaylistRequest {\n  sceneId: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface AddSceneToPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface AddSceneToPlaylistResponse {\n  item: {\n  id: number;\n  playlistId: number;\n  sceneId: string;\n  position: number;\n  addedAt: Date;\n};\n}\n</code></pre> <p>Controller: <code>addSceneToPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#delete-apiplaylistsiditemssceneid","title":"DELETE /api/playlists/:id/items/:sceneId","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface RemoveSceneFromPlaylistParams {\n  id: string;\n  sceneId: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface RemoveSceneFromPlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>removeSceneFromPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#put-apiplaylistsidreorder","title":"PUT /api/playlists/:id/reorder","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface ReorderPlaylistRequest {\n  items: Array&lt;{\n  sceneId: string;\n  position: number;\n}&gt;;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface ReorderPlaylistParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface ReorderPlaylistResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>reorderPlaylist</code> in <code>../controllers/playlist.ts</code></p>"},{"location":"reference/api-reference/#carousels","title":"Carousels","text":"<p>Custom carousel configuration endpoints.</p>"},{"location":"reference/api-reference/#get-apicarousels","title":"GET /api/carousels/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserCarouselsResponse {\n  carousels: CarouselData[];\n}\n</code></pre> <p>Controller: <code>getUserCarousels</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#post-apicarouselspreview","title":"POST /api/carousels/preview","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface PreviewCarouselRequest {\n  rules: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface PreviewCarouselResponse {\n  scenes: NormalizedScene[];\n}\n</code></pre> <p>Controller: <code>previewCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#get-apicarouselsid","title":"GET /api/carousels/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>getCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#get-apicarouselsidexecute","title":"GET /api/carousels/:id/execute","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface ExecuteCarouselByIdParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface ExecuteCarouselByIdResponse {\n  carousel: {\n  id: string;\n  title: string;\n  icon: string;\n};\n  scenes: NormalizedScene[];\n}\n</code></pre> <p>Controller: <code>executeCarouselById</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#post-apicarousels","title":"POST /api/carousels/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreateCarouselRequest {\n  title: string;\n  icon?: string;\n  rules: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>createCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#put-apicarouselsid","title":"PUT /api/carousels/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdateCarouselRequest {\n  title?: string;\n  icon?: string;\n  rules?: PeekSceneFilter;\n  sort?: string;\n  direction?: string;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdateCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdateCarouselResponse {\n  carousel: CarouselData;\n}\n</code></pre> <p>Controller: <code>updateCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#delete-apicarouselsid","title":"DELETE /api/carousels/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeleteCarouselParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeleteCarouselResponse {\n  success: true;\n  message: string;\n}\n</code></pre> <p>Controller: <code>deleteCarousel</code> in <code>../controllers/carousel.ts</code></p>"},{"location":"reference/api-reference/#watch-history","title":"Watch History","text":"<p>Watch history tracking endpoints.</p>"},{"location":"reference/api-reference/#post-apiwatch-historyping","title":"POST /api/watch-history/ping","text":"<p>Authentication: Required</p> <p>Controller: <code>pingWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#post-apiwatch-historysave-activity","title":"POST /api/watch-history/save-activity","text":"<p>Authentication: Required</p> <p>Controller: <code>saveActivity</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#post-apiwatch-historyincrement-play-count","title":"POST /api/watch-history/increment-play-count","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementPlayCount</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#post-apiwatch-historyincrement-o","title":"POST /api/watch-history/increment-o","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementOCounter</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#get-apiwatch-history","title":"GET /api/watch-history/","text":"<p>Authentication: Required</p> <p>Controller: <code>getAllWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#delete-apiwatch-history","title":"DELETE /api/watch-history/","text":"<p>Authentication: Required</p> <p>Controller: <code>clearAllWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#get-apiwatch-historysceneid","title":"GET /api/watch-history/:sceneId","text":"<p>Authentication: Required</p> <p>Controller: <code>getWatchHistory</code> in <code>../controllers/watchHistory.ts</code></p>"},{"location":"reference/api-reference/#image-view-history","title":"Image View History","text":"<p>Image view history tracking endpoints.</p>"},{"location":"reference/api-reference/#post-apiimage-view-historyincrement-o","title":"POST /api/image-view-history/increment-o","text":"<p>Authentication: Required</p> <p>Controller: <code>incrementImageOCounter</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"reference/api-reference/#post-apiimage-view-historyview","title":"POST /api/image-view-history/view","text":"<p>Authentication: Required</p> <p>Controller: <code>recordImageView</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"reference/api-reference/#get-apiimage-view-historyimageid","title":"GET /api/image-view-history/:imageId","text":"<p>Authentication: Required</p> <p>Controller: <code>getImageViewHistory</code> in <code>../controllers/imageViewHistory.ts</code></p>"},{"location":"reference/api-reference/#ratings","title":"Ratings","text":"<p>Rating and favorite management endpoints.</p>"},{"location":"reference/api-reference/#put-apiratingsscenesceneid","title":"PUT /api/ratings/scene/:sceneId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateSceneRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingsperformerperformerid","title":"PUT /api/ratings/performer/:performerId","text":"<p>Authentication: Required</p> <p>Controller: <code>updatePerformerRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingsstudiostudioid","title":"PUT /api/ratings/studio/:studioId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateStudioRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingstagtagid","title":"PUT /api/ratings/tag/:tagId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateTagRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingsgallerygalleryid","title":"PUT /api/ratings/gallery/:galleryId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateGalleryRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingsgroupgroupid","title":"PUT /api/ratings/group/:groupId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateGroupRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#put-apiratingsimageimageid","title":"PUT /api/ratings/image/:imageId","text":"<p>Authentication: Required</p> <p>Controller: <code>updateImageRating</code> in <code>../controllers/ratings.ts</code></p>"},{"location":"reference/api-reference/#custom-themes","title":"Custom Themes","text":"<p>Custom theme management endpoints.</p>"},{"location":"reference/api-reference/#get-apithemescustom","title":"GET /api/themes/custom/","text":"<p>Authentication: Required</p> <p>Response:</p> <pre><code>interface GetUserCustomThemesResponse {\n  themes: CustomThemeData[];\n}\n</code></pre> <p>Controller: <code>getUserCustomThemes</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#get-apithemescustomid","title":"GET /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface GetCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface GetCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>getCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#post-apithemescustom","title":"POST /api/themes/custom/","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface CreateCustomThemeRequest {\n  name: string;\n  config: ThemeConfig;\n}\n</code></pre> <p>Response:</p> <pre><code>interface CreateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>createCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#put-apithemescustomid","title":"PUT /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>Request Body:</p> <pre><code>interface UpdateCustomThemeRequest {\n  name?: string;\n  config?: ThemeConfig;\n}\n</code></pre> <p>URL Parameters:</p> <pre><code>interface UpdateCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface UpdateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>updateCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#delete-apithemescustomid","title":"DELETE /api/themes/custom/:id","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DeleteCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DeleteCustomThemeResponse {\n  success: true;\n}\n</code></pre> <p>Controller: <code>deleteCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#post-apithemescustomidduplicate","title":"POST /api/themes/custom/:id/duplicate","text":"<p>Authentication: Required</p> <p>URL Parameters:</p> <pre><code>interface DuplicateCustomThemeParams {\n  id: string;\n}\n</code></pre> <p>Response:</p> <pre><code>interface DuplicateCustomThemeResponse {\n  theme: CustomThemeData &amp; {\n  userId: number\n};\n}\n</code></pre> <p>Controller: <code>duplicateCustomTheme</code> in <code>../controllers/customTheme.ts</code></p>"},{"location":"reference/api-reference/#library","title":"Library","text":"<p>Library browsing endpoints for scenes, performers, studios, tags, groups, galleries, and images.</p>"},{"location":"reference/api-reference/#post-apilibrarygalleries","title":"POST /api/library/galleries","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleries</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarygalleriesminimal","title":"POST /api/library/galleries/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleriesMinimal</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"reference/api-reference/#get-apilibrarygalleriesid","title":"GET /api/library/galleries/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>findGalleryById</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"reference/api-reference/#get-apilibrarygalleriesgalleryidimages","title":"GET /api/library/galleries/:galleryId/images","text":"<p>Authentication: Required</p> <p>Controller: <code>getGalleryImages</code> in <code>../../controllers/library/galleries.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarygroups","title":"POST /api/library/groups","text":"<p>Authentication: Required</p> <p>Controller: <code>findGroups</code> in <code>../../controllers/library/groups.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarygroupsminimal","title":"POST /api/library/groups/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findGroupsMinimal</code> in <code>../../controllers/library/groups.ts</code></p>"},{"location":"reference/api-reference/#post-apilibraryimages","title":"POST /api/library/images","text":"<p>Authentication: Required</p> <p>Controller: <code>findImages</code> in <code>../../controllers/library/images.ts</code></p>"},{"location":"reference/api-reference/#get-apilibraryimagesid","title":"GET /api/library/images/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>findImageById</code> in <code>../../controllers/library/images.ts</code></p>"},{"location":"reference/api-reference/#post-apilibraryperformers","title":"POST /api/library/performers","text":"<p>Authentication: Required</p> <p>Controller: <code>findPerformers</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"reference/api-reference/#post-apilibraryperformersminimal","title":"POST /api/library/performers/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findPerformersMinimal</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"reference/api-reference/#put-apilibraryperformersid","title":"PUT /api/library/performers/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updatePerformer</code> in <code>../../controllers/library/performers.ts</code></p>"},{"location":"reference/api-reference/#post-apilibraryscenes","title":"POST /api/library/scenes","text":"<p>Authentication: Required</p> <p>Controller: <code>findScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"reference/api-reference/#get-apilibraryscenesidsimilar","title":"GET /api/library/scenes/:id/similar","text":"<p>Authentication: Required</p> <p>Controller: <code>findSimilarScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"reference/api-reference/#get-apilibraryscenesrecommended","title":"GET /api/library/scenes/recommended","text":"<p>Authentication: Required</p> <p>Controller: <code>getRecommendedScenes</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"reference/api-reference/#put-apilibraryscenesid","title":"PUT /api/library/scenes/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateScene</code> in <code>../../controllers/library/scenes.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarystudios","title":"POST /api/library/studios","text":"<p>Authentication: Required</p> <p>Controller: <code>findStudios</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarystudiosminimal","title":"POST /api/library/studios/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findStudiosMinimal</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"reference/api-reference/#put-apilibrarystudiosid","title":"PUT /api/library/studios/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateStudio</code> in <code>../../controllers/library/studios.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarytags","title":"POST /api/library/tags","text":"<p>Authentication: Required</p> <p>Controller: <code>findTags</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"reference/api-reference/#post-apilibrarytagsminimal","title":"POST /api/library/tags/minimal","text":"<p>Authentication: Required</p> <p>Controller: <code>findTagsMinimal</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"reference/api-reference/#put-apilibrarytagsid","title":"PUT /api/library/tags/:id","text":"<p>Authentication: Required</p> <p>Controller: <code>updateTag</code> in <code>../../controllers/library/tags.ts</code></p>"},{"location":"reference/docker-basics/","title":"Docker Basics","text":"<p>New to Docker? This 5-minute guide covers everything you need to know to run Peek (or any Docker app).</p>"},{"location":"reference/docker-basics/#what-is-docker","title":"What is Docker?","text":"<p>Think of Docker as a shipping container for software. Just like a shipping container can hold anything and be moved anywhere, a Docker container packages an app with everything it needs to run - code, settings, databases - into one portable unit.</p> <p>Why use it?</p> <ul> <li>No installation headaches - The app comes pre-configured</li> <li>No dependency conflicts - Each container is isolated</li> <li>Easy updates - Pull a new version, restart, done</li> <li>Works everywhere - Same container runs on Linux, Mac, Windows</li> </ul>"},{"location":"reference/docker-basics/#key-concepts-the-scary-parts-explained","title":"Key Concepts (The Scary Parts Explained)","text":""},{"location":"reference/docker-basics/#images-vs-containers","title":"Images vs Containers","text":"<ul> <li>Image = A blueprint/recipe (like a cake recipe)</li> <li>Container = A running instance of that image (like an actual cake)</li> </ul> <p>You download an image once, then create containers from it. You can have multiple containers from the same image.</p>"},{"location":"reference/docker-basics/#the-three-things-that-connect-your-container-to-the-outside-world","title":"The Three Things That Connect Your Container to the Outside World","text":"<p>When you run a Docker container, it's isolated by default - like a sealed box. These three options poke holes in that box:</p>"},{"location":"reference/docker-basics/#1-ports-p","title":"1. Ports (<code>-p</code>)","text":"<p>Containers have their own network. Ports connect the container's internal network to your computer.</p> <pre><code>-p 6969:80\n    \u2502    \u2502\n    \u2502    \u2514\u2500\u2500 Container's internal port (where the app listens)\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Your computer's port (what you type in browser)\n</code></pre> <p>Example: <code>-p 6969:80</code> means \"when I go to <code>localhost:6969</code>, forward that to port 80 inside the container\"</p> <p>Common mistake: The app inside always uses its internal port. You only change the left number if port 6969 is already used on your computer.</p>"},{"location":"reference/docker-basics/#2-volumes-v","title":"2. Volumes (<code>-v</code>)","text":"<p>Containers are temporary - when you delete one, everything inside is lost. Volumes are persistent storage that survives container deletion.</p> <pre><code>-v peek-data:/app/data\n      \u2502          \u2502\n      \u2502          \u2514\u2500\u2500 Path inside the container\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Name of the volume (or path on your computer)\n</code></pre> <p>Two types:</p> <ul> <li>Named volumes (<code>peek-data:/app/data</code>) - Docker manages the storage location. Simple and recommended.</li> <li>Bind mounts (<code>/home/user/peek:/app/data</code>) - You specify exactly where on your computer. Useful when you need direct access to files.</li> </ul> <p>Why it matters: Your database, settings, and playlists live in volumes. Delete the container, update it, whatever - your data stays safe.</p>"},{"location":"reference/docker-basics/#3-environment-variables-e","title":"3. Environment Variables (<code>-e</code>)","text":"<p>Configuration values passed into the container. Like filling in blanks on a form.</p> <pre><code>-e JWT_SECRET=\"abc123\"\n      \u2502           \u2502\n      \u2502           \u2514\u2500\u2500 The value\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 The variable name\n</code></pre> <p>Common examples:</p> <ul> <li><code>JWT_SECRET</code> - A password for encrypting user sessions</li> <li><code>TZ=America/New_York</code> - Timezone setting</li> <li><code>PUID=1000</code> - User ID for file permissions</li> </ul>"},{"location":"reference/docker-basics/#essential-commands","title":"Essential Commands","text":""},{"location":"reference/docker-basics/#getting-images","title":"Getting Images","text":"<pre><code># Download an image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Download a specific version\ndocker pull carrotwaxr/peek-stash-browser:3.1.0\n\n# Download beta/development version (if available)\ndocker pull carrotwaxr/peek-stash-browser:beta\n</code></pre> <p>Tags explained:</p> <ul> <li><code>:latest</code> - Most recent stable release (default if you don't specify)</li> <li><code>:3.1.0</code> - Specific version number (good for stability)</li> <li><code>:beta</code> - Pre-release testing version (may have bugs)</li> </ul>"},{"location":"reference/docker-basics/#running-containers","title":"Running Containers","text":"<pre><code># Basic run\ndocker run -d --name peek carrotwaxr/peek-stash-browser:latest\n\n# Full example with all options (see Windows note below)\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"your-secret-here\" \\\n  --restart unless-stopped \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Flag meanings:</p> Flag What it does <code>-d</code> Run in background (detached) <code>--name peek</code> Give the container a friendly name <code>-p 6969:80</code> Map port 6969 on your machine to port 80 in container <code>-v peek-data:/app/data</code> Persist data in a volume <code>-e KEY=value</code> Set environment variable <code>--restart unless-stopped</code> Auto-restart if it crashes or computer reboots <p>Windows users: See Platform-Specific Notes for multi-line command syntax.</p>"},{"location":"reference/docker-basics/#managing-running-containers","title":"Managing Running Containers","text":"<pre><code># See what's running\ndocker ps\n\n# See all containers (including stopped)\ndocker ps -a\n\n# Stop a container\ndocker stop peek-stash-browser\n\n# Start a stopped container\ndocker start peek-stash-browser\n\n# Restart a container\ndocker restart peek-stash-browser\n\n# Remove a container (must be stopped first)\ndocker rm peek-stash-browser\n\n# Force remove a running container\ndocker rm -f peek-stash-browser\n</code></pre>"},{"location":"reference/docker-basics/#viewing-logs","title":"Viewing Logs","text":"<pre><code># See all logs\ndocker logs peek-stash-browser\n\n# Follow logs in real-time (Ctrl+C to exit)\ndocker logs -f peek-stash-browser\n\n# See last 50 lines\ndocker logs --tail 50 peek-stash-browser\n</code></pre>"},{"location":"reference/docker-basics/#running-commands-inside-a-container","title":"Running Commands Inside a Container","text":"<p>Sometimes you need to poke around inside a container:</p> <pre><code># Open a shell inside the container\ndocker exec -it peek-stash-browser /bin/sh\n\n# Run a single command\ndocker exec peek-stash-browser ls /app/data\n\n# Check what's using disk space\ndocker exec peek-stash-browser du -sh /app/data/*\n</code></pre> <p>Flags:</p> <ul> <li><code>-i</code> = Interactive (keep stdin open)</li> <li><code>-t</code> = Allocate a terminal</li> </ul> <p>Type <code>exit</code> to leave the shell.</p>"},{"location":"reference/docker-basics/#updating-a-container","title":"Updating a Container","text":"<p>Docker doesn't have an \"update\" command. The process is:</p> <ol> <li>Pull the new image</li> <li>Stop and remove the old container</li> <li>Create a new container with the same settings</li> </ol> <pre><code># 1. Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# 2. Stop and remove old container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# 3. Run new container (same command as original install)\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"your-secret-here\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Your data is safe because it's in the volume, not the container.</p> <p>Windows users: See Platform-Specific Notes for multi-line command syntax.</p>"},{"location":"reference/docker-basics/#cleanup","title":"Cleanup","text":"<pre><code># Remove unused images (reclaim disk space)\ndocker image prune\n\n# Remove all stopped containers\ndocker container prune\n\n# Nuclear option: remove everything unused\ndocker system prune\n</code></pre>"},{"location":"reference/docker-basics/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"reference/docker-basics/#windows","title":"Windows","text":"<p>Docker Desktop for Windows runs Linux containers inside a lightweight VM. This works well but has some quirks:</p> <p>Performance: Files stored on Windows (<code>C:\\...</code>) are slower than named volumes. Stick with named volumes like <code>-v peek-data:/app/data</code> for best results.</p> <p>Path format:</p> <pre><code># Windows paths in PowerShell\n-v C:\\Users\\You\\peek-data:/app/data\n\n# Or use forward slashes\n-v C:/Users/You/peek-data:/app/data\n</code></pre> <p>Multi-line commands: PowerShell uses backtick (<code>`</code>) instead of backslash (<code>\\</code>) to continue commands on the next line:</p> <pre><code>docker run -d `\n  --name peek `\n  -p 6969:80 `\n  carrotwaxr/peek-stash-browser:latest\n</code></pre>"},{"location":"reference/docker-basics/#macos","title":"macOS","text":"<p>Similar to Windows - Docker runs in a VM. Named volumes are faster than bind mounts to your Mac filesystem.</p>"},{"location":"reference/docker-basics/#linux","title":"Linux","text":"<p>Docker runs natively - best performance. Bind mounts work great.</p> <p>Permission tip: If you get permission errors with bind mounts, you may need to set <code>PUID</code> and <code>PGID</code> environment variables to match your user ID:</p> <pre><code># Find your IDs\nid\n\n# Use them in docker run\n-e PUID=1000 -e PGID=1000\n</code></pre>"},{"location":"reference/docker-basics/#quick-reference-card","title":"Quick Reference Card","text":"Task Command Download image <code>docker pull image:tag</code> Run container <code>docker run -d --name name image</code> List running <code>docker ps</code> Stop <code>docker stop name</code> Start <code>docker start name</code> Remove <code>docker rm name</code> View logs <code>docker logs name</code> Follow logs <code>docker logs -f name</code> Shell access <code>docker exec -it name /bin/sh</code> Update Pull \u2192 Stop \u2192 Remove \u2192 Run"},{"location":"reference/entity-relationships/","title":"Entity Relationships","text":"<p>This document describes the data model relationships between Peek's cached entities. Understanding these relationships is essential for working with content filtering, queries, and the sync system.</p>"},{"location":"reference/entity-relationships/#entity-types","title":"Entity Types","text":"<p>Peek mirrors Stash's entity model, caching entities locally in SQLite. This enables:</p> <ul> <li>Performant queries \u2014 No network round-trips to Stash for library browsing</li> <li>Per-user features \u2014 Content restrictions, hidden items, ratings, favorites, watch history</li> <li>Offline resilience \u2014 Library remains accessible if Stash is temporarily unavailable</li> </ul> Entity Stash Source Peek Cache Table Notes Scene Yes <code>StashScene</code> Primary content type Performer Yes <code>StashPerformer</code> Studio Yes <code>StashStudio</code> Has parent/child hierarchy Tag Yes <code>StashTag</code> Has parent/child DAG Group Yes <code>StashGroup</code> Has parent/child hierarchy (containing_groups/sub_groups) Gallery Yes <code>StashGallery</code> Contains Images Image Yes <code>StashImage</code> Playlist Peek-only <code>Playlist</code> User-created scene collections SceneMarker Yes Not cached Clips from Scenes (future feature)"},{"location":"reference/entity-relationships/#scene-relationships","title":"Scene Relationships","text":"Related Entity Cardinality Junction Table Notes Studio Many-to-One \u2014 <code>StashScene.studioId</code> Performer Many-to-Many <code>ScenePerformer</code> Tag Many-to-Many <code>SceneTag</code> Group Many-to-Many <code>SceneGroup</code> Includes <code>sceneIndex</code> for ordering Gallery Many-to-Many <code>SceneGallery</code>"},{"location":"reference/entity-relationships/#performer-relationships","title":"Performer Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>ScenePerformer</code> Inverse of Scene\u2192Performer Tag Many-to-Many <code>PerformerTag</code> Image Many-to-Many <code>ImagePerformer</code> Gallery Many-to-Many <code>GalleryPerformer</code> Group \u2014 \u2014 Computed by Stash (performers appearing in group's scenes)"},{"location":"reference/entity-relationships/#studio-relationships","title":"Studio Relationships","text":"Related Entity Cardinality Junction Table Notes Scene One-to-Many \u2014 Inverse of Scene\u2192Studio Tag Many-to-Many <code>StudioTag</code> Image One-to-Many \u2014 <code>StashImage.studioId</code> Gallery One-to-Many \u2014 <code>StashGallery.studioId</code> Parent Studio Many-to-One \u2014 <code>StashStudio.parentId</code> Child Studios One-to-Many \u2014 Inverse of parentId Group \u2014 \u2014 Computed by Stash (groups with this studio)"},{"location":"reference/entity-relationships/#tag-relationships","title":"Tag Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneTag</code> Inverse of Scene\u2192Tag Performer Many-to-Many <code>PerformerTag</code> Inverse of Performer\u2192Tag Studio Many-to-Many <code>StudioTag</code> Inverse of Studio\u2192Tag Group Many-to-Many <code>GroupTag</code> Inverse of Group\u2192Tag Gallery Many-to-Many <code>GalleryTag</code> Inverse of Gallery\u2192Tag Image Many-to-Many <code>ImageTag</code> Inverse of Image\u2192Tag Parent Tags Many-to-Many \u2014 <code>StashTag.parentIds</code> (JSON array) Child Tags Many-to-Many \u2014 Inverse, resolved at runtime <p>Tag Hierarchies</p> <p>Tag hierarchies form a DAG (directed acyclic graph), not a tree. Tags can have multiple parents.</p>"},{"location":"reference/entity-relationships/#group-relationships","title":"Group Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneGroup</code> Includes <code>sceneIndex</code> for ordering Tag Many-to-Many <code>GroupTag</code> Studio Many-to-One \u2014 <code>StashGroup.studioId</code> Containing Groups Many-to-Many \u2014 Via Stash <code>containing_groups</code> Sub Groups Many-to-Many \u2014 Via Stash <code>sub_groups</code>"},{"location":"reference/entity-relationships/#gallery-relationships","title":"Gallery Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneGallery</code> Inverse of Scene\u2192Gallery Performer Many-to-Many <code>GalleryPerformer</code> Tag Many-to-Many <code>GalleryTag</code> Studio Many-to-One \u2014 <code>StashGallery.studioId</code> Image One-to-Many <code>ImageGallery</code>"},{"location":"reference/entity-relationships/#image-relationships","title":"Image Relationships","text":"Related Entity Cardinality Junction Table Notes Gallery Many-to-Many <code>ImageGallery</code> Performer Many-to-Many <code>ImagePerformer</code> Tag Many-to-Many <code>ImageTag</code> Studio Many-to-One \u2014 <code>StashImage.studioId</code>"},{"location":"reference/entity-relationships/#playlist-relationships-peek-only","title":"Playlist Relationships (Peek-only)","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>PlaylistItem</code> Includes <code>position</code> for ordering User Many-to-One \u2014 <code>Playlist.userId</code>"},{"location":"reference/entity-relationships/#metadata-inheritance","title":"Metadata Inheritance","text":"<p>Peek pre-computes inherited metadata during sync to enable efficient filtering and consistent behavior.</p>"},{"location":"reference/entity-relationships/#scene-tag-inheritance","title":"Scene Tag Inheritance","text":"<p>Scenes inherit tags from their associated performers, studio, and groups. This enables tag-based filtering to work transparently across all related entities.</p> <p>Inheritance sources:</p> Source Description Performer Tags Tags on any performer in the scene Studio Tags Tags on the scene's studio Group Tags Tags on any group the scene belongs to <p>Key rules:</p> <ul> <li>No duplication: Tags already directly on the scene are not added to inherited tags</li> <li>Deduplicated: Same tag from multiple sources (e.g., two performers) appears once</li> <li>Stored separately: Inherited tags stored in <code>inheritedTagIds</code> field, not mixed with direct tags</li> <li>When computed: After every sync (full, incremental, or smart)</li> </ul> <p>Query behavior:</p> <p>When you filter scenes by tag, Peek searches both direct tags AND inherited tags. This means:</p> <ul> <li>Filtering by a performer's tag shows scenes with that performer</li> <li>Filtering by a studio's tag shows scenes from that studio</li> <li>Content restrictions on tags apply to inherited tags too</li> </ul> <p>Example: If performer \"Jane\" has tag \"Comedy\", all scenes with Jane will match a \"Comedy\" tag filter, even if the scene itself isn't tagged \"Comedy\".</p>"},{"location":"reference/entity-relationships/#image-gallery-inheritance","title":"Image Gallery Inheritance","text":"<p>Images inherit metadata from their parent gallery when the image's own field is empty. This ensures images in a gallery share consistent metadata without manual duplication.</p> <p>Inherited fields:</p> Field Inheritance Rule Performers Inherit if image has no performers Tags Inherit if image has no tags Studio Inherit if image has no studio Date Inherit if image has no date Photographer Inherit if image has no photographer Details Inherit if image has no details <p>Key rules:</p> <ul> <li>Never overwrites: Only copies when image field is NULL/empty</li> <li>All-or-nothing for relationships: Performers and tags only inherit if image has NONE</li> <li>Multi-gallery handling: If image is in multiple galleries, uses first gallery (by ID)</li> <li>When computed: After every sync that touches images or galleries</li> </ul> <p>Note</p> <p>Image <code>title</code> is NOT inherited \u2014 each image keeps its own name.</p> <p>Example: A gallery has studio \"Acme\" and tags \"Nature\", \"Landscape\". An image in that gallery with no metadata will inherit all three. An image with its own studio but no tags will keep its studio and inherit the tags.</p>"},{"location":"reference/entity-relationships/#stash-graphql-schema-reference","title":"Stash GraphQL Schema Reference","text":"<p>Key entity types from Stash for reference:</p> <ul> <li>Scene: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>groups[]</code>, <code>galleries[]</code>, <code>files[]</code> (contains <code>duration</code>)</li> <li>Performer: <code>id</code>, <code>name</code>, <code>tags[]</code>, <code>scene_count</code>, <code>image_count</code>, <code>gallery_count</code>, <code>group_count</code></li> <li>Studio: <code>id</code>, <code>name</code>, <code>parent_studio</code>, <code>child_studios[]</code>, <code>tags[]</code>, <code>groups[]</code></li> <li>Tag: <code>id</code>, <code>name</code>, <code>parents[]</code>, <code>children[]</code>, various <code>*_count</code> fields</li> <li>Group: <code>id</code>, <code>name</code>, <code>studio</code>, <code>tags[]</code>, <code>containing_groups[]</code>, <code>sub_groups[]</code>, <code>scenes[]</code></li> <li>Gallery: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>scenes[]</code>, <code>image_count</code>, <code>photographer</code>, <code>details</code></li> <li>Image: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>galleries[]</code>, <code>photographer</code>, <code>details</code></li> <li>SceneMarker: <code>id</code>, <code>scene</code>, <code>primary_tag</code>, <code>tags[]</code>, <code>seconds</code>, <code>end_seconds</code></li> </ul> <p>See also: Technical Overview for architecture details, Sync Architecture for sync details</p>"},{"location":"user-guide/browse-and-display/","title":"Browse and Display Options","text":"<p>Peek offers multiple ways to browse your library with customizable view modes and card display settings.</p>"},{"location":"user-guide/browse-and-display/#view-modes","title":"View Modes","text":"<p>Switch between view modes using the toolbar buttons on any browse page.</p>"},{"location":"user-guide/browse-and-display/#grid-view","title":"Grid View","text":"<p>The default card-based layout showing thumbnails with metadata.</p> <ul> <li>Standard card grid with consistent sizing</li> <li>Shows title, studio, date, and rating information</li> <li>Hover for sprite preview (scenes)</li> <li>Three density levels: Small, Medium, Large</li> <li>Available for all entity types</li> </ul>"},{"location":"user-guide/browse-and-display/#wall-view","title":"Wall View","text":"<p>A justified gallery layout that preserves aspect ratios.</p> <ul> <li>Images and videos fill rows naturally without letterboxing</li> <li>All visible previews can play simultaneously</li> <li>Three zoom levels: Small, Medium, Large</li> <li>Available for: Scenes, Galleries, Images, Performers, Studios, Groups</li> </ul> <p>Wall playback modes (Settings \u2192 Display):</p> Mode Behavior Autoplay Videos play when visible, hover controls volume Hover Static thumbnail until hover, then plays Static Thumbnails only, no video playback"},{"location":"user-guide/browse-and-display/#table-view","title":"Table View","text":"<p>A high-density tabular layout for scanning metadata across many items.</p> <ul> <li>Compact rows with sortable columns</li> <li>Click column headers to sort</li> <li>Customizable columns per entity type</li> <li>Available for all entity types</li> </ul> <p>Managing columns:</p> <ol> <li>Click Columns button in toolbar</li> <li>Check/uncheck columns to show/hide</li> <li>Use arrows to reorder columns</li> <li>Or right-click any column header \u2192 Hide column</li> </ol>"},{"location":"user-guide/browse-and-display/#timeline-view","title":"Timeline View","text":"<p>Browse content chronologically, organized by date.</p> <ul> <li>Content grouped by year, month, or day</li> <li>Expandable date sections with item counts</li> <li>Visual timeline with thumbnails</li> <li>Three density levels: Small, Medium, Large</li> <li>Available for: Scenes, Galleries, Images</li> </ul> <p>Navigation:</p> <ul> <li>Click date header to expand/collapse</li> <li>Click thumbnail to open detail page</li> <li>Use density controls to adjust items per row</li> </ul>"},{"location":"user-guide/browse-and-display/#folder-view","title":"Folder View","text":"<p>Navigate content through your tag hierarchy as folders.</p> <ul> <li>Tags displayed as folders based on parent/child relationships</li> <li>Breadcrumb navigation shows your current path</li> <li>Item count badges on each folder</li> <li>Click into nested tags like browsing directories</li> <li>Three density levels: Small, Medium, Large</li> <li>Available for: Scenes, Galleries, Images</li> </ul> <p>Navigation:</p> <ul> <li>Click folder to navigate into that tag</li> <li>Use breadcrumbs to navigate back up</li> <li>Root level shows top-level parent tags</li> <li>Content displays when you reach a leaf tag or click to view items</li> </ul>"},{"location":"user-guide/browse-and-display/#tag-hierarchy-view","title":"Tag Hierarchy View","text":"<p>A tree view showing parent/child tag relationships (Tags page only).</p> <ul> <li>Expandable nodes reveal child tags</li> <li>Visual indentation shows hierarchy depth</li> <li>Search filters the tree while showing ancestors</li> <li>Expand All / Collapse All buttons for quick navigation</li> </ul> <p>Navigation:</p> <ul> <li>Single click: Expand/collapse node</li> <li>Double-click: Open tag detail page</li> <li>Arrow keys: Navigate the tree</li> <li>Enter: Open selected tag</li> </ul>"},{"location":"user-guide/browse-and-display/#density-controls","title":"Density Controls","text":"<p>Adjust how many items appear per row using the S/M/L buttons in the toolbar.</p>"},{"location":"user-guide/browse-and-display/#grid-density","title":"Grid Density","text":"<p>In Grid View, density controls the number of columns:</p> Level Columns (Desktop) Description Small 4-6 More items, smaller cards Medium 3-5 Balanced view (default) Large 2-3 Fewer items, larger cards"},{"location":"user-guide/browse-and-display/#wall-zoom","title":"Wall Zoom","text":"<p>In Wall View, zoom controls row height:</p> Level Row Height Items per Row (1920px) Small 150px 6-8 items Medium 220px 4-5 items (default) Large 320px 2-3 items"},{"location":"user-guide/browse-and-display/#card-display-settings","title":"Card Display Settings","text":"<p>Customize what information appears on cards and detail pages.</p>"},{"location":"user-guide/browse-and-display/#accessing-settings","title":"Accessing Settings","text":"<p>Full settings: Settings \u2192 Customization \u2192 Card Display</p> <p>Quick access: Click the \u2699\ufe0f icon in the search toolbar for current entity type settings.</p>"},{"location":"user-guide/browse-and-display/#available-options","title":"Available Options","text":"<p>Settings vary by entity type. Common options include:</p> Setting Description Show studio Display studio name on cards Show date Display date on cards Show rating Display star rating badge Show favorite Display favorite button Show O-counter Display O-counter badge Show description Display description text Show relationships Display performer/tag indicators <p>Scene-specific:</p> <ul> <li>Show studio code (abbreviated studio name)</li> <li>Show description on detail page</li> </ul> <p>Tag-specific:</p> <ul> <li>Description and relationship indicators only</li> </ul>"},{"location":"user-guide/browse-and-display/#per-entity-defaults","title":"Per-Entity Defaults","text":"<p>Each entity type (Scene, Performer, Studio, etc.) has independent settings. Configure each type separately in the Card Display settings accordion.</p>"},{"location":"user-guide/browse-and-display/#filter-presets","title":"Filter Presets","text":"<p>Save your current view configuration for quick access later.</p>"},{"location":"user-guide/browse-and-display/#what-gets-saved","title":"What Gets Saved","text":"<ul> <li>All active filters</li> <li>Sort field and direction</li> <li>View mode (Grid/Wall/Table/Hierarchy)</li> <li>Grid density (for Grid view)</li> <li>Zoom level (for Wall view)</li> <li>Table column configuration</li> </ul>"},{"location":"user-guide/browse-and-display/#creating-a-preset","title":"Creating a Preset","text":"<ol> <li>Configure your filters and view settings</li> <li>Click Presets \u2192 Save current as preset</li> <li>Enter a name</li> <li>Optionally set as default for this page</li> </ol>"},{"location":"user-guide/browse-and-display/#using-presets","title":"Using Presets","text":"<ul> <li>Click Presets to see saved presets</li> <li>Click a preset name to apply it</li> <li>Star icon indicates the default preset</li> <li>Presets are per-entity-type (Scene presets, Performer presets, etc.)</li> </ul>"},{"location":"user-guide/browse-and-display/#url-persistence","title":"URL Persistence","text":"<p>Your browse state is reflected in the URL, making it easy to bookmark or share specific views.</p> <p>URL parameters include:</p> <ul> <li><code>view</code> - grid, wall, table, or hierarchy</li> <li><code>grid_density</code> - small, medium, or large (grid view)</li> <li><code>zoom</code> - small, medium, or large (wall view)</li> <li><code>sort</code> and <code>dir</code> - current sort settings</li> <li>Filter parameters - active filters</li> </ul> <p>Sharing a URL shares your exact view configuration.</p>"},{"location":"user-guide/browse-and-display/#tips","title":"Tips","text":""},{"location":"user-guide/browse-and-display/#for-large-libraries","title":"For Large Libraries","text":"<ul> <li>Use Table View to quickly scan metadata across hundreds of items</li> <li>Use Wall View with Small zoom for visual overview</li> <li>Create Filter Presets for common browsing patterns</li> </ul>"},{"location":"user-guide/browse-and-display/#for-tag-organization","title":"For Tag Organization","text":"<ul> <li>Use Hierarchy View to understand tag relationships</li> <li>Expand parent tags to find related child tags</li> <li>Search within hierarchy to find specific tags</li> </ul>"},{"location":"user-guide/browse-and-display/#for-performance","title":"For Performance","text":"<ul> <li>Static wall playback mode uses less bandwidth</li> <li>Table view loads faster than Grid or Wall for large result sets</li> <li>Pagination keeps memory usage reasonable</li> </ul>"},{"location":"user-guide/browse-and-display/#related","title":"Related","text":"<ul> <li>Keyboard Navigation \u2014 Keyboard shortcuts for all view modes</li> <li>Custom Carousels \u2014 Create homepage carousels with saved filters</li> <li>Images \u2014 Image-specific browsing features</li> </ul>"},{"location":"user-guide/content-restrictions/","title":"Content Restrictions","text":"<p>Content Restrictions allow admins to control what content each user can access. Unlike Hidden Items (which users control themselves), Content Restrictions are admin-only and cannot be bypassed by users.</p>"},{"location":"user-guide/content-restrictions/#overview","title":"Overview","text":"Feature Who Controls Who Sees Content Restrictions Admins only Affects specific users Hidden Items Each user Only that user <p>Key behaviors:</p> <ul> <li>Admins bypass all Content Restrictions (they always see everything)</li> <li>Restrictions cascade throughout the UI\u2014restricted items don't appear anywhere</li> <li>Users cannot see or modify their own restrictions</li> </ul>"},{"location":"user-guide/content-restrictions/#restriction-types","title":"Restriction Types","text":"<p>You can restrict content by four entity types:</p> Type Best For Notes Collections (Groups) Primary filtering Most reliable\u2014static, manually curated Tags Content categories May change if using Stash plugins that auto-tag Studios Production company limits Useful for brand-specific access Galleries Image gallery access Restricts gallery and its images <p>Recommended Approach</p> <p>Use Collections (Groups) as your primary restriction mechanism. Create groups in Stash to organize content by access level, then restrict users to appropriate groups in Peek.</p>"},{"location":"user-guide/content-restrictions/#restriction-modes","title":"Restriction Modes","text":"<p>Each entity type can have one of three modes:</p>"},{"location":"user-guide/content-restrictions/#none-default","title":"None (Default)","text":"<p>No restrictions for this entity type. User sees all content.</p>"},{"location":"user-guide/content-restrictions/#exclude-mode","title":"Exclude Mode","text":"<p>Hide specific items. Everything else is visible.</p> <p>Example: Exclude the tag \"Documentary\"</p> <ul> <li>User won't see scenes tagged \"Documentary\"</li> <li>User won't see performers who only appear in \"Documentary\" scenes</li> <li>\"Documentary\" won't appear in tag filters or lists</li> </ul>"},{"location":"user-guide/content-restrictions/#include-mode","title":"Include Mode","text":"<p>Show ONLY specific items. Everything else is hidden.</p> <p>Example: Include only the collection \"Family Friendly\"</p> <ul> <li>User only sees scenes in \"Family Friendly\" group</li> <li>All other content is completely hidden</li> <li>This is the most restrictive mode</li> </ul> <p>Include Mode is Restrictive</p> <p>Include mode hides ALL content not in the specified list. Use carefully\u2014combine multiple entity types thoughtfully.</p>"},{"location":"user-guide/content-restrictions/#setting-up-restrictions","title":"Setting Up Restrictions","text":"<p>Requirements: Admin role</p>"},{"location":"user-guide/content-restrictions/#step-1-plan-your-approach","title":"Step 1: Plan Your Approach","text":"<p>Before setting restrictions, decide:</p> <ol> <li>What content should this user see? (or not see)</li> <li>Which entity type is most appropriate? (Groups are recommended)</li> <li>Should you use Include or Exclude?</li> </ol>"},{"location":"user-guide/content-restrictions/#step-2-organize-in-stash","title":"Step 2: Organize in Stash","text":"<p>Create appropriate groups/tags in Stash:</p> <ul> <li>For Include mode: Create groups containing allowed content</li> <li>For Exclude mode: Ensure restricted content has identifying tags/groups</li> </ul>"},{"location":"user-guide/content-restrictions/#step-3-configure-in-peek","title":"Step 3: Configure in Peek","text":"<ol> <li>Go to Settings \u2192 User Management</li> <li>Find the target user</li> <li>Click Content Restrictions</li> <li>For each entity type you want to restrict:</li> <li>Select the mode (Exclude or Include)</li> <li>Search and select specific items</li> <li>Enable Restrict Empty if desired (see below)</li> <li>Click Save</li> </ol>"},{"location":"user-guide/content-restrictions/#restrict-empty-option","title":"Restrict Empty Option","text":"<p>When enabled, hides content that has no metadata for that entity type:</p> Entity Type Restrict Empty Hides Tags Scenes with no tags Groups Scenes not in any group Studios Scenes with no studio Galleries Scenes not linked to galleries <p>This prevents unorganized content from appearing.</p>"},{"location":"user-guide/content-restrictions/#how-cascading-works","title":"How Cascading Works","text":"<p>Restrictions cascade to related content:</p>"},{"location":"user-guide/content-restrictions/#tag-restrictions","title":"Tag Restrictions","text":"<p>Restricting a tag hides:</p> <ul> <li>Scenes with that tag (direct or inherited)</li> <li>Performers primarily associated with restricted content</li> <li>Studios primarily associated with restricted content</li> <li>The tag itself in all filter dropdowns and lists</li> </ul>"},{"location":"user-guide/content-restrictions/#studio-restrictions","title":"Studio Restrictions","text":"<p>Restricting a studio hides:</p> <ul> <li>All scenes from that studio</li> <li>The studio in filter dropdowns</li> <li>Studio info on performer pages</li> </ul>"},{"location":"user-guide/content-restrictions/#group-restrictions","title":"Group Restrictions","text":"<p>Restricting a group hides:</p> <ul> <li>Scenes in that group</li> <li>The group in browse views</li> <li>Group info on scene detail pages</li> </ul>"},{"location":"user-guide/content-restrictions/#gallery-restrictions","title":"Gallery Restrictions","text":"<p>Restricting a gallery hides:</p> <ul> <li>The gallery itself</li> <li>Images in that gallery</li> <li>Gallery links on scene pages</li> </ul>"},{"location":"user-guide/content-restrictions/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/content-restrictions/#age-based-access","title":"Age-Based Access","text":"<p>Create groups in Stash for different age ratings:</p> <pre><code>- \"All Ages\" group\n- \"Teen\" group\n- \"Adult\" group\n</code></pre> <p>Then use Include mode: Kids see only \"All Ages\", teens see \"All Ages\" + \"Teen\", etc.</p>"},{"location":"user-guide/content-restrictions/#category-based-access","title":"Category-Based Access","text":"<p>Use tags to categorize content, then Exclude unwanted categories:</p> <ul> <li>Tag content in Stash by category</li> <li>Exclude specific tags per user</li> </ul>"},{"location":"user-guide/content-restrictions/#studio-based-access","title":"Studio-Based Access","text":"<p>Restrict by production company:</p> <ul> <li>Include only specific studios for limited access</li> <li>Exclude studios for blocking specific sources</li> </ul>"},{"location":"user-guide/content-restrictions/#combining-restrictions","title":"Combining Restrictions","text":"<p>You can set restrictions on multiple entity types. They combine as follows:</p> <ol> <li>Include rules intersect (must match ALL includes)</li> <li>Exclude rules union (must not match ANY excludes)</li> </ol> <p>Example:</p> <ul> <li>Include: Groups = \"Approved Content\"</li> <li>Exclude: Tags = \"Violence\"</li> </ul> <p>Result: User sees content from \"Approved Content\" that isn't tagged \"Violence\"</p>"},{"location":"user-guide/content-restrictions/#verifying-restrictions","title":"Verifying Restrictions","text":"<p>After setting restrictions:</p> <ol> <li>Create a test account with the same restrictions</li> <li>Log in as that user (or use incognito)</li> <li>Browse the library to verify expected content appears</li> <li>Check filters to ensure restricted items don't appear in dropdowns</li> <li>View detail pages to confirm cascading works</li> </ol>"},{"location":"user-guide/content-restrictions/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/content-restrictions/#user-sees-restricted-content","title":"User sees restricted content","text":"<ul> <li>Verify the restriction is saved (refresh User Management)</li> <li>Check if user is an admin (admins bypass restrictions)</li> <li>Ensure sync has completed after making changes in Stash</li> </ul>"},{"location":"user-guide/content-restrictions/#too-much-content-is-hidden","title":"Too much content is hidden","text":"<ul> <li>Review Include mode restrictions\u2014they're very restrictive</li> <li>Check for overlapping Exclude rules</li> <li>Verify Restrict Empty settings</li> </ul>"},{"location":"user-guide/content-restrictions/#restrictions-dont-cascade","title":"Restrictions don't cascade","text":"<ul> <li>Wait for sync to complete after Stash changes</li> <li>Trigger manual sync if needed</li> <li>Check that related entities have proper associations in Stash</li> </ul>"},{"location":"user-guide/content-restrictions/#related-features","title":"Related Features","text":"<ul> <li>Hidden Items \u2014 User-controlled hiding of individual items</li> <li>User Management \u2014 Full user administration guide</li> <li>FAQ \u2014 Common questions including sync behavior</li> </ul>"},{"location":"user-guide/custom-carousels/","title":"Custom Carousels","text":"<p>Create personalized homepage carousels using a visual query builder. Custom carousels let you define filter rules to automatically curate collections of scenes based on performers, tags, ratings, and more.</p>"},{"location":"user-guide/custom-carousels/#creating-a-custom-carousel","title":"Creating a Custom Carousel","text":"<ol> <li>Navigate to Settings \u2192 Homepage Carousels</li> <li>Click Create Carousel</li> <li>Configure your carousel:</li> <li>Title: Give your carousel a descriptive name</li> <li>Icon: Choose from a selection of icons</li> <li>Filter Rules: Add one or more rules to define which scenes appear</li> <li> <p>Sort: Choose how scenes are ordered (Random, Recently Added, etc.)</p> </li> <li> <p>Click Preview to see matching scenes</p> </li> <li>Click Save once you're satisfied with the preview</li> </ol>"},{"location":"user-guide/custom-carousels/#filter-rules","title":"Filter Rules","text":"<p>Each rule consists of a filter type, comparison operator, and value. All rules must match (AND logic) for a scene to appear in the carousel.</p>"},{"location":"user-guide/custom-carousels/#available-filters","title":"Available Filters","text":"Filter Description Performers Scenes featuring specific performers Tags Scenes with specific tags Studio Scenes from a specific studio Collections Scenes in specific groups/collections Rating Scenes within a rating range (0-100) Duration Scene length in minutes Resolution Video quality (480p, 720p, 1080p, etc.) Play Count Number of times you've watched O Count Your O count for the scene Favorite Scenes Only your favorited scenes Favorite Performers Scenes with your favorite performers Favorite Studios Scenes from your favorite studios Favorite Tags Scenes with your favorite tags Created Date When the scene was added Scene Date The scene's release date Last Played Date When you last watched Performer Age Performer age at time of scene Performer Count Number of performers in scene Bitrate Video bitrate in Mbps Title Contains Text search in scene title Details Contains Text search in scene description"},{"location":"user-guide/custom-carousels/#comparison-operators","title":"Comparison Operators","text":"<p>Different filter types support different operators:</p> <ul> <li>Entity filters (Performers, Tags, etc.): includes any of, includes all of, excludes</li> <li>Numeric filters (Rating, Duration, etc.): between, greater than, less than</li> <li>Boolean filters (Favorites): is true / is false</li> <li>Text filters: contains</li> </ul>"},{"location":"user-guide/custom-carousels/#managing-carousels","title":"Managing Carousels","text":""},{"location":"user-guide/custom-carousels/#reordering","title":"Reordering","text":"<p>Use the up/down arrow buttons next to each carousel to change the display order on your homepage.</p>"},{"location":"user-guide/custom-carousels/#visibility","title":"Visibility","text":"<p>Click the eye icon to show/hide individual carousels. Hidden carousels remain saved but won't appear on the homepage.</p>"},{"location":"user-guide/custom-carousels/#editing","title":"Editing","text":"<p>Click the pencil icon on any custom carousel to modify its rules, title, or icon.</p>"},{"location":"user-guide/custom-carousels/#deleting","title":"Deleting","text":"<p>Click the trash icon to delete a custom carousel. This action cannot be undone.</p>"},{"location":"user-guide/custom-carousels/#limits","title":"Limits","text":"<ul> <li>Maximum of 15 custom carousels per user</li> <li>Each carousel displays up to 12 scenes</li> <li>All filter rules use AND logic (scenes must match all rules)</li> </ul>"},{"location":"user-guide/custom-carousels/#tips","title":"Tips","text":"<ul> <li>Start simple: Begin with one or two rules and add more as needed</li> <li>Use Preview: Always preview before saving to ensure your rules work as expected</li> <li>Random sort: Great for variety - shows different scenes each time you visit</li> <li>Combine with favorites: Create carousels for \"Highly rated scenes with favorite performers\"</li> <li>Content restrictions: Custom carousels respect your hidden items and content restrictions</li> </ul>"},{"location":"user-guide/custom-carousels/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/custom-carousels/#carousel-shows-no-scenes-found","title":"Carousel shows \"No scenes found\"","text":"<ul> <li>Your filter rules may be too restrictive</li> <li>Try relaxing some rules or using different operators</li> <li>Check that you have scenes matching your criteria</li> </ul>"},{"location":"user-guide/custom-carousels/#carousel-not-appearing-on-homepage","title":"Carousel not appearing on homepage","text":"<ul> <li>Make sure the carousel is enabled (eye icon should be visible, not crossed out)</li> <li>Try refreshing the page</li> <li>Check Settings \u2192 Homepage Carousels to verify it's toggled on</li> </ul>"},{"location":"user-guide/downloads/","title":"Downloads","text":"<p>Download scenes, images, and entire playlists for offline viewing. Downloads require permission from an admin.</p>"},{"location":"user-guide/downloads/#requirements","title":"Requirements","text":"<p>To use the download feature, you must have the appropriate permissions:</p> Permission What You Can Download Can Download Files Individual scenes and images Can Download Playlists Playlist zip archives <p>Permission Setup</p> <p>Admins grant download permissions through User Groups or individual user permissions.</p>"},{"location":"user-guide/downloads/#downloading-scenes","title":"Downloading Scenes","text":""},{"location":"user-guide/downloads/#from-scene-detail-page","title":"From Scene Detail Page","text":"<ol> <li>Open any scene to view its detail page</li> <li>Click the Download button in the action bar</li> <li>The download starts immediately</li> </ol> <p>Scene downloads stream directly from your Stash server\u2014there's no waiting for file preparation.</p>"},{"location":"user-guide/downloads/#whats-downloaded","title":"What's Downloaded","text":"<ul> <li>The original video file in its native format</li> <li>Filename based on the scene title</li> </ul>"},{"location":"user-guide/downloads/#downloading-images","title":"Downloading Images","text":""},{"location":"user-guide/downloads/#from-image-lightbox","title":"From Image Lightbox","text":"<ol> <li>Open any image in the lightbox viewer</li> <li>Click the Download button</li> <li>The image downloads immediately</li> </ol> <p>Image downloads also stream directly from Stash.</p>"},{"location":"user-guide/downloads/#downloading-playlists","title":"Downloading Playlists","text":"<p>Playlist downloads create a zip archive containing all scenes in the playlist, plus helpful metadata files.</p>"},{"location":"user-guide/downloads/#starting-a-playlist-download","title":"Starting a Playlist Download","text":"<ol> <li>Open a playlist</li> <li>Click the Download button</li> <li>A progress indicator shows the zip creation status</li> <li>When complete, the download starts automatically</li> </ol> <p>Processing Time</p> <p>Playlist downloads require server-side processing to create the zip file. Large playlists may take several minutes.</p>"},{"location":"user-guide/downloads/#whats-included","title":"What's Included","text":"<p>Each playlist zip contains:</p> File Description Scene videos All video files in original quality playlist.m3u M3U playlist file for media players {scene}.nfo Kodi-compatible metadata for each scene"},{"location":"user-guide/downloads/#m3u-playlist","title":"M3U Playlist","text":"<p>The included <code>playlist.m3u</code> file lets you play scenes in order using any media player that supports M3U format (VLC, Plex, Kodi, etc.).</p>"},{"location":"user-guide/downloads/#nfo-metadata","title":"NFO Metadata","text":"<p>Each scene includes a <code>.nfo</code> file with Kodi-compatible metadata:</p> <ul> <li>Title and description</li> <li>Performers</li> <li>Studio</li> <li>Tags</li> <li>Runtime</li> <li>Date added</li> </ul> <p>These files allow Kodi and similar media managers to display proper metadata for your downloaded scenes.</p>"},{"location":"user-guide/downloads/#size-limits","title":"Size Limits","text":"<p>Playlist downloads have a maximum size limit (default: 10 GB). If a playlist exceeds this limit:</p> <ol> <li>You'll see an error message showing the playlist size</li> <li>Consider splitting large playlists into smaller ones</li> <li>Or ask an admin to increase the limit</li> </ol>"},{"location":"user-guide/downloads/#download-history","title":"Download History","text":"<p>View all your downloads in one place.</p>"},{"location":"user-guide/downloads/#accessing-download-history","title":"Accessing Download History","text":"<ul> <li>Click your username in the header \u2192 Downloads</li> <li>Or navigate directly to <code>/downloads</code></li> </ul>"},{"location":"user-guide/downloads/#download-status","title":"Download Status","text":"Status Description Pending Download queued, waiting to start Processing Playlist zip being created (shows progress %) Completed Ready to download Failed Something went wrong"},{"location":"user-guide/downloads/#managing-downloads","title":"Managing Downloads","text":"<p>From the Downloads page, you can:</p> Action Description Download Download a completed file Retry Retry a failed playlist download Delete Remove a download from your history"},{"location":"user-guide/downloads/#download-expiration","title":"Download Expiration","text":"<p>Completed playlist downloads are available for 24 hours, then automatically cleaned up to save server space. Individual scene and image downloads don't expire\u2014you can re-download them anytime.</p>"},{"location":"user-guide/downloads/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/downloads/#you-do-not-have-permission-to-download","title":"\"You do not have permission to download\"","text":"<p>Your account doesn't have download permissions. Ask an admin to: 1. Add you to a group with download permissions, or 2. Enable download permissions on your account directly</p>"},{"location":"user-guide/downloads/#playlist-exceeds-maximum-download-size","title":"\"Playlist exceeds maximum download size\"","text":"<p>The playlist is too large. Options: - Split the playlist into smaller playlists - Download individual scenes instead - Ask an admin to increase the size limit</p>"},{"location":"user-guide/downloads/#download-stuck-on-processing","title":"Download stuck on \"Processing\"","text":"<p>Playlist zip creation can take time for large playlists. If it seems stuck: 1. Check the Downloads page for the current progress percentage 2. For very large playlists, processing may take 10+ minutes 3. If progress doesn't change for extended periods, try:    - Refreshing the page    - Deleting and retrying the download</p>"},{"location":"user-guide/downloads/#downloaded-file-wont-play","title":"Downloaded file won't play","text":"<ul> <li>Verify your media player supports the video codec</li> <li>Try VLC media player (supports most formats)</li> <li>Check that the download completed fully (not corrupted)</li> </ul>"},{"location":"user-guide/downloads/#nfo-files-not-recognized","title":"NFO files not recognized","text":"<ul> <li>Ensure your media manager is configured for NFO metadata</li> <li>In Kodi, enable \"Local information only\" for the media source</li> <li>File must be in the same folder as the video with matching name</li> </ul>"},{"location":"user-guide/downloads/#next-steps","title":"Next Steps","text":"<ul> <li>Playlists \u2014 Create and manage playlists</li> <li>User Management \u2014 Understand permissions and groups</li> <li>Troubleshooting \u2014 Fix common issues</li> </ul>"},{"location":"user-guide/external-player/","title":"External Player","text":"<p>Peek allows you to open scenes in external media players like VLC for enhanced playback features such as hardware acceleration, subtitle support, and advanced playback controls.</p>"},{"location":"user-guide/external-player/#platform-compatibility","title":"Platform Compatibility","text":"Platform Status Notes Android \u2705 Works Opens app chooser for any installed video player iOS \u2705 Works Opens directly in VLC (requires VLC for iOS) Windows (Edge/Chrome) \u2705 Works Requires protocol handler setup (see below) Windows (Firefox) \u26a0\ufe0f Limited May not work due to Firefox's protocol handling macOS \ud83d\udd2c Untested Should work with protocol handler Linux \ud83d\udd2c Untested Should work with protocol handler <p>Help Us Test</p> <p>We need community feedback on platform compatibility. If you test on a platform not marked as \"Works\", please report your results on GitHub so we can update this documentation.</p>"},{"location":"user-guide/external-player/#using-the-external-player-button","title":"Using the External Player Button","text":"<p>On the scene page, you'll find an external player button (external link icon) next to the \"View in Stash\" button. The behavior differs by platform:</p>"},{"location":"user-guide/external-player/#mobile-devices","title":"Mobile Devices","text":"<ul> <li>Android: Tapping the button opens a dialog to choose any installed video player app (VLC, MX Player, etc.)</li> <li>iOS: Tapping the button opens the scene directly in VLC (requires VLC for iOS to be installed)</li> </ul>"},{"location":"user-guide/external-player/#desktop-windowsmaclinux","title":"Desktop (Windows/Mac/Linux)","text":"<p>The button becomes a combo button with two parts:</p> <ol> <li>Main button (external link icon): Opens the scene in VLC</li> <li>Dropdown arrow: Click to reveal additional options:</li> <li>Copy Stream URL: Copies the direct stream URL to your clipboard</li> </ol>"},{"location":"user-guide/external-player/#setting-up-vlc-protocol-handler-desktop","title":"Setting Up VLC Protocol Handler (Desktop)","text":"<p>For the \"Open in VLC\" button to work on desktop, you need to install a protocol handler that registers the <code>vlc://</code> URL scheme with your operating system.</p> <p>Why is this needed? VLC doesn't natively understand <code>vlc://</code> URLs. The protocol handler intercepts these URLs, strips the <code>vlc://</code> prefix, and passes the actual video URL to VLC.</p>"},{"location":"user-guide/external-player/#windows-setup-recommended-method","title":"Windows Setup (Recommended Method)","text":"<p>The most reliable method for Windows is using a registry file with a PowerShell script. This approach handles URL encoding issues that browsers introduce.</p>"},{"location":"user-guide/external-player/#step-1-create-the-registry-file","title":"Step 1: Create the Registry File","text":"<ol> <li>Open Notepad</li> <li>Paste the following content:</li> </ol> <pre><code>Windows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\vlc]\n@=\"URL:VLC Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\vlc\\DefaultIcon]\n@=\"C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe,0\"\n\n[HKEY_CLASSES_ROOT\\vlc\\shell]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open\\command]\n@=\"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -WindowStyle Hidden -Command \\\"&amp; {$url='%1' -replace '^vlc://' -replace '^http//', 'http://' -replace '^https//', 'https://'; Start-Process -FilePath 'C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe' -ArgumentList $url}\\\"\"\n</code></pre> <ol> <li>Save as <code>vlc-protocol.reg</code> (make sure to select \"All Files\" as the file type)</li> </ol> <p>Adjust VLC Path if Needed</p> <p>If VLC is installed in a different location (e.g., <code>C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe</code>), update both paths in the registry file accordingly.</p>"},{"location":"user-guide/external-player/#step-2-install-the-registry-entries","title":"Step 2: Install the Registry Entries","text":"<ol> <li>Double-click the <code>vlc-protocol.reg</code> file</li> <li>Click \"Yes\" when prompted by User Account Control</li> <li>Click \"Yes\" when asked to confirm adding to the registry</li> <li>You should see \"The keys and values contained in [path] have been successfully added to the registry\"</li> </ol>"},{"location":"user-guide/external-player/#step-3-test-it","title":"Step 3: Test It","text":"<ol> <li>Open Peek in Edge or Chrome</li> <li>Navigate to a scene</li> <li>Click the external player button</li> <li>When prompted, allow the browser to open the VLC handler</li> <li>VLC should open and start playing the video</li> </ol>"},{"location":"user-guide/external-player/#how-the-powershell-script-works","title":"How the PowerShell Script Works","text":"<p>The PowerShell command in the registry performs these transformations:</p> <ol> <li>Removes the <code>vlc://</code> prefix from the URL</li> <li>Fixes <code>http//</code> \u2192 <code>http://</code> (browsers strip the colon for security)</li> <li>Fixes <code>https//</code> \u2192 <code>https://</code></li> <li>Launches VLC with the corrected URL</li> </ol>"},{"location":"user-guide/external-player/#alternative-third-party-protocol-handlers","title":"Alternative: Third-Party Protocol Handlers","text":"<p>These tools may also work, though results vary:</p> <ul> <li>player-protocol - Supports VLC and PotPlayer</li> <li>vlc-protocol - VLC-specific handler</li> </ul>"},{"location":"user-guide/external-player/#macos-setup","title":"macOS Setup","text":"<p>macOS users can try:</p> <ol> <li>Install a protocol handler like player-protocol</li> <li>Or use the \"Copy Stream URL\" fallback method</li> </ol> <p>macOS Testers Needed</p> <p>If you've successfully set up VLC protocol handling on macOS, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#linux-setup","title":"Linux Setup","text":"<p>Linux users can register protocol handlers via <code>xdg-mime</code> or desktop files. A typical approach:</p> <ol> <li>Create a <code>.desktop</code> file for handling <code>x-scheme-handler/vlc</code></li> <li>Register it with <code>xdg-mime default vlc-handler.desktop x-scheme-handler/vlc</code></li> </ol> <p>Linux Testers Needed</p> <p>If you've successfully set up VLC protocol handling on Linux, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#copying-the-stream-url-fallback-method","title":"Copying the Stream URL (Fallback Method)","text":"<p>If you don't want to set up a protocol handler, or it's not working on your platform, you can use the \"Copy Stream URL\" option:</p> <ol> <li>Click the dropdown arrow on the external player button</li> <li>Select \"Copy Stream URL\"</li> <li>Open VLC manually</li> <li>Go to Media \u2192 Open Network Stream (Ctrl+N on Windows/Linux, Cmd+N on macOS)</li> <li>Paste the URL and click Play</li> </ol> <p>This method works on all platforms without any additional setup.</p>"},{"location":"user-guide/external-player/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/external-player/#open-in-vlc-doesnt-work-windows","title":"\"Open in VLC\" doesn't work (Windows)","text":"<ol> <li>Check browser: Try Edge or Chrome instead of Firefox</li> <li>Verify registry: Open <code>regedit</code> and check that <code>HKEY_CLASSES_ROOT\\vlc</code> exists</li> <li>Check VLC path: Ensure the path in the registry matches your VLC installation</li> <li>Use fallback: Copy the stream URL and open it manually in VLC</li> </ol>"},{"location":"user-guide/external-player/#firefox-doesnt-open-vlc-windows","title":"Firefox doesn't open VLC (Windows)","text":"<p>Firefox handles custom protocols differently from Edge/Chrome and may not respect Windows registry protocol handlers. Known workarounds:</p> <ul> <li>Use Edge or Chrome for the \"Open in VLC\" feature</li> <li>Use the \"Copy Stream URL\" fallback method</li> <li>Set <code>network.protocol-handler.expose.vlc</code> to <code>false</code> in <code>about:config</code> (results may vary)</li> </ul> <p>Known Issue</p> <p>Firefox on Windows currently doesn't reliably support the <code>vlc://</code> protocol even with the registry handler installed. We're tracking this issue and welcome any solutions from the community.</p>"},{"location":"user-guide/external-player/#video-wont-play-in-vlc","title":"Video won't play in VLC","text":"<ul> <li>Ensure VLC is up to date (version 3.0 or later recommended)</li> <li>The stream URL goes through Peek's proxy, which should handle authentication automatically</li> <li>Try the \"Copy Stream URL\" method to verify the URL works</li> </ul>"},{"location":"user-guide/external-player/#android-no-app-found-to-handle-the-link","title":"Android: No app found to handle the link","text":"<ul> <li>Install a video player app (VLC, MX Player, etc.)</li> <li>The Android intent system should show a list of compatible apps</li> </ul>"},{"location":"user-guide/external-player/#ios-link-doesnt-open-vlc","title":"iOS: Link doesn't open VLC","text":"<ul> <li>Ensure VLC for iOS is installed from the App Store</li> <li>The <code>vlc-x-callback://</code> scheme is only supported by VLC</li> <li>Other iOS video players are not currently supported</li> </ul>"},{"location":"user-guide/external-player/#technical-details","title":"Technical Details","text":""},{"location":"user-guide/external-player/#url-formats-by-platform","title":"URL Formats by Platform","text":"Platform URL Format Example Android Intent URI <code>intent://host#Intent;action=android.intent.action.VIEW;scheme=https;type=video/mp4;...</code> iOS VLC x-callback <code>vlc-x-callback://x-callback-url/stream?url=...</code> Desktop VLC protocol <code>vlc://https://peek.example.com/api/scene/123/proxy-stream/stream</code>"},{"location":"user-guide/external-player/#stream-url","title":"Stream URL","text":"<p>The stream URL points to Peek's proxy endpoint, not directly to Stash. This ensures:</p> <ul> <li>API keys are not exposed in URLs</li> <li>Authentication is handled by Peek</li> <li>The URL format is: <code>{peek-url}/api/scene/{sceneId}/proxy-stream/stream</code></li> </ul>"},{"location":"user-guide/external-player/#contributing","title":"Contributing","text":"<p>If you've found a solution for a platform or browser that's not working, please:</p> <ol> <li>Open an issue with your platform details</li> <li>Describe the steps you took to get it working</li> <li>We'll update this documentation to help other users</li> </ol>"},{"location":"user-guide/hidden-items/","title":"Hidden Items","text":"<p>Hide specific content from your personal view without affecting other users.</p>"},{"location":"user-guide/hidden-items/#overview","title":"Overview","text":"<p>Hidden Items let you personally hide content you don't want to see. Unlike Content Restrictions (admin-controlled), Hidden Items are entirely user-controlled.</p> Feature Who Controls Scope Hidden Items You Only your view Content Restrictions Admins Per-user access control"},{"location":"user-guide/hidden-items/#how-to-hide-items","title":"How to Hide Items","text":""},{"location":"user-guide/hidden-items/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Click the three-dot menu (\u22ee) on any scene card</li> <li>Select \"Hide Scene\"</li> <li>Confirm in the dialog (or check \"Don't ask again\" to skip future confirmations)</li> </ol>"},{"location":"user-guide/hidden-items/#from-entity-cards","title":"From Entity Cards","text":"<p>The same three-dot menu is available on: - Performer cards - Studio cards - Tag cards - Group/Collection cards - Gallery cards</p>"},{"location":"user-guide/hidden-items/#bulk-actions-scenes","title":"Bulk Actions (Scenes)","text":"<ol> <li>Enable multi-select mode by clicking the checkbox icon</li> <li>Select multiple scenes</li> <li>Click \"Hide Selected\" in the bulk action bar</li> </ol>"},{"location":"user-guide/hidden-items/#managing-hidden-items","title":"Managing Hidden Items","text":""},{"location":"user-guide/hidden-items/#viewing-hidden-items","title":"Viewing Hidden Items","text":"<ol> <li>Go to My Settings</li> <li>Scroll to the \"Hidden Items\" section</li> <li>Click View Hidden Items</li> </ol>"},{"location":"user-guide/hidden-items/#restoring-hidden-items","title":"Restoring Hidden Items","text":"<p>From the Hidden Items page: - Click Restore on individual items to unhide them - Click Restore All to restore all hidden items at once - Use the tabs to filter by entity type (Scenes, Performers, Studios, etc.)</p>"},{"location":"user-guide/hidden-items/#dont-ask-again","title":"Don't Ask Again","text":"<p>If you frequently hide items and want to skip the confirmation dialog: 1. Check \"Don't ask me again\" when hiding an item, OR 2. Go to My Settings &gt; Hidden Items section 3. Check \"Don't ask for confirmation when hiding items\"</p> <p>You can toggle this setting on/off at any time.</p>"},{"location":"user-guide/hidden-items/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/hidden-items/#for-regular-users","title":"For Regular Users","text":"<ul> <li>Hidden items are filtered from all views (search, carousels, recommendations)</li> <li>Hidden items persist across sessions and page refreshes</li> <li>Other users are not affected by your hidden items</li> </ul>"},{"location":"user-guide/hidden-items/#for-admin-users","title":"For Admin Users","text":"<ul> <li>Admins can hide content for themselves just like regular users</li> <li>Content Restrictions (INCLUDE/EXCLUDE rules) are bypassed for admins</li> <li>Hidden Items filtering is ALWAYS applied, even for admins</li> <li>This allows admins to maintain full admin access while personalizing their own view</li> </ul>"},{"location":"user-guide/hidden-items/#cascading-behavior","title":"Cascading Behavior","text":"<p>When you hide an entity: - Hiding a Scene: Only that scene is hidden - Hiding a Performer: That performer and scenes where they appear may be affected - Hiding a Studio: That studio and scenes from it may be affected - Hiding a Tag: That tag and related content may be affected</p> <p>Note: The exact cascading behavior depends on your Content Restrictions settings and whether hidden entities are the only content associated with related items.</p>"},{"location":"user-guide/hidden-items/#faq","title":"FAQ","text":""},{"location":"user-guide/hidden-items/#can-i-accidentally-hide-something-important","title":"Can I accidentally hide something important?","text":"<p>You can always restore hidden items from My Settings &gt; View Hidden Items. The Restore All button makes it easy to undo bulk actions.</p>"},{"location":"user-guide/hidden-items/#do-hidden-items-count-toward-my-stats","title":"Do hidden items count toward my stats?","text":"<p>Hidden items are excluded from most views but may still appear in certain statistics or reports.</p>"},{"location":"user-guide/hidden-items/#can-admins-see-what-ive-hidden","title":"Can admins see what I've hidden?","text":"<p>Admins can see that you have hidden items (via database access) but the hidden items feature is designed for personal use. Each user's hidden items are private to them.</p>"},{"location":"user-guide/hidden-items/#what-happens-if-content-ive-hidden-is-updated-in-stash","title":"What happens if content I've hidden is updated in Stash?","text":"<p>Hidden items remain hidden even if the underlying content is modified in Stash. The hiding is based on entity ID, not content characteristics.</p>"},{"location":"user-guide/hidden-items/#related","title":"Related","text":"<ul> <li>Content Restrictions \u2014 Admin-controlled access restrictions</li> <li>User Management \u2014 Full user administration guide</li> </ul>"},{"location":"user-guide/images/","title":"Images","text":"<p>Browse, filter, and view images from your Stash library with a full-featured lightbox viewer.</p>"},{"location":"user-guide/images/#browsing-images","title":"Browsing Images","text":""},{"location":"user-guide/images/#the-images-page","title":"The Images Page","text":"<p>Access the Images page from the main navigation menu. Here you can:</p> <ul> <li>Browse all images in your library with thumbnail cards</li> <li>Search by title, code, or other text fields</li> <li>Filter by performer, studio, tag, or gallery</li> <li>Sort by date, rating, random, and more</li> <li>Paginate through large collections</li> </ul>"},{"location":"user-guide/images/#image-cards","title":"Image Cards","text":"<p>Each image card displays:</p> <ul> <li>Thumbnail preview</li> <li>Title (if set)</li> <li>Rating stars (your Peek rating)</li> <li>O counter indicator</li> <li>Favorite heart icon</li> </ul> <p>Hover actions:</p> <ul> <li>Click the star to rate the image</li> <li>Click the heart to favorite/unfavorite</li> <li>Click the O button to increment the O counter</li> </ul>"},{"location":"user-guide/images/#the-lightbox-viewer","title":"The Lightbox Viewer","text":"<p>Click any image to open it in the full-screen lightbox viewer.</p>"},{"location":"user-guide/images/#navigation","title":"Navigation","text":"<p>Keyboard:</p> Key Action \u2190 / \u2192 Previous / Next image Escape Close lightbox F Toggle fullscreen I Toggle info drawer Space Play/pause slideshow <p>Touch/Mouse:</p> <ul> <li>Swipe left/right to navigate between images</li> <li>Click arrows on screen edges</li> <li>Tap to show/hide controls</li> </ul>"},{"location":"user-guide/images/#slideshow-mode","title":"Slideshow Mode","text":"<p>Start an automatic slideshow:</p> <ol> <li>Open an image in the lightbox</li> <li>Click the Play button or press Space</li> <li>Images advance automatically every 5 seconds</li> <li>Click Pause or press Space to stop</li> </ol> <p>Slideshow Timer</p> <p>Click the clock icon to adjust slideshow duration (2, 3, 5, 10, or 15 seconds).</p>"},{"location":"user-guide/images/#rating-favorites","title":"Rating &amp; Favorites","text":"<p>Rate images directly in the lightbox:</p> <ul> <li>R key: Enter rating mode, then:<ul> <li>1-5: Set rating (1=20%, 2=40%, 3=60%, 4=80%, 5=100%)</li> <li>0: Clear rating</li> </ul> </li> <li>F key: Toggle favorite</li> </ul> <p>Your ratings and favorites are saved to Peek (separate from Stash ratings).</p>"},{"location":"user-guide/images/#o-counter","title":"O Counter","text":"<p>Track special moments:</p> <ul> <li>Press O or click the O button to increment</li> <li>Counter syncs with Stash if enabled in settings</li> <li>View your O history in the info drawer</li> </ul>"},{"location":"user-guide/images/#info-drawer","title":"Info Drawer","text":"<p>Press I or click the info button to see image metadata:</p> <ul> <li>Title and code</li> <li>Date and photographer</li> <li>Studio information</li> <li>Performers and tags</li> <li>File details (resolution, size)</li> <li>Gallery associations</li> </ul> <p>The drawer slides in from the right and can stay open while navigating.</p>"},{"location":"user-guide/images/#fullscreen-mode","title":"Fullscreen Mode","text":"<p>Press F or click the expand button to enter fullscreen mode. Press Escape or F again to exit.</p>"},{"location":"user-guide/images/#filtering-images","title":"Filtering Images","text":""},{"location":"user-guide/images/#by-performer","title":"By Performer","text":"<ol> <li>Click Filters in the search controls</li> <li>Select Performers</li> <li>Choose one or more performers</li> <li>Images featuring those performers will display</li> </ol>"},{"location":"user-guide/images/#by-gallery","title":"By Gallery","text":"<p>Filter to see images from specific galleries:</p> <ol> <li>Click Filters</li> <li>Select Galleries</li> <li>Choose the gallery</li> <li>Only images from that gallery appear</li> </ol>"},{"location":"user-guide/images/#by-tag","title":"By Tag","text":"<ol> <li>Click Filters</li> <li>Select Tags</li> <li>Choose one or more tags</li> <li>Matching images display</li> </ol> <p>Inherited Tags</p> <p>Images can inherit tags from their parent gallery, performers, and studio.</p>"},{"location":"user-guide/images/#combined-filters","title":"Combined Filters","text":"<p>Combine multiple filters for precise results:</p> <ul> <li>Performer: \"Jane Doe\" + Tag: \"Outdoor\" = Jane's outdoor images</li> </ul>"},{"location":"user-guide/images/#gallery-image-viewing","title":"Gallery Image Viewing","text":"<p>When viewing a gallery detail page, click any image to open it in the lightbox with special features:</p>"},{"location":"user-guide/images/#cross-page-navigation","title":"Cross-Page Navigation","text":"<p>Navigate seamlessly across gallery pages:</p> <ol> <li>Open the lightbox on an image</li> <li>Navigate to the last image on the current page</li> <li>Press \u2192 to automatically load the next page</li> <li>Continue browsing without closing the lightbox</li> </ol>"},{"location":"user-guide/images/#inherited-metadata","title":"Inherited Metadata","text":"<p>Images in galleries inherit metadata from the parent:</p> <ul> <li>Gallery's studio</li> <li>Gallery's performers</li> <li>Gallery's tags</li> <li>Photographer information</li> </ul> <p>This inherited data appears in the info drawer.</p>"},{"location":"user-guide/images/#view-tracking","title":"View Tracking","text":"<p>Peek automatically tracks which images you view:</p> <ul> <li>View count: Incremented after viewing for 3+ seconds</li> <li>View history: Timestamps of each view</li> <li>Last viewed: When you last saw the image</li> </ul> <p>View this data in the info drawer or on performer/studio detail pages.</p>"},{"location":"user-guide/images/#tips-tricks","title":"Tips &amp; Tricks","text":""},{"location":"user-guide/images/#quick-rating","title":"Quick Rating","text":"<p>Use number keys while in the lightbox for rapid rating:</p> <ul> <li>View image \u2192 Press 4 \u2192 Instantly 4-star rated \u2192 \u2192 \u2192 Next image</li> </ul>"},{"location":"user-guide/images/#random-browse","title":"Random Browse","text":"<p>Set sort to Random for discovery mode. The random seed is consistent within your session, so pagination works correctly.</p>"},{"location":"user-guide/images/#touch-devices","title":"Touch Devices","text":"<p>The lightbox is fully touch-optimized:</p> <ul> <li>Swipe left/right to navigate</li> <li>Tap center to show/hide controls</li> <li>Pinch to zoom (coming soon)</li> </ul>"},{"location":"user-guide/images/#keyboard-only-navigation","title":"Keyboard-Only Navigation","text":"<p>For TV mode or keyboard-only use:</p> <ol> <li>Use Tab to navigate image cards</li> <li>Press Enter to open lightbox</li> <li>Use arrow keys to browse</li> <li>Press Escape to close</li> </ol>"},{"location":"user-guide/images/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/images/#images-not-loading","title":"Images not loading","text":"<ul> <li>Check your Stash connection in Server Settings</li> <li>Verify path mappings are configured correctly</li> <li>Ensure Stash has generated thumbnails</li> </ul>"},{"location":"user-guide/images/#lightbox-not-opening","title":"Lightbox not opening","text":"<ul> <li>Make sure JavaScript is enabled</li> <li>Try refreshing the page</li> <li>Check browser console for errors</li> </ul>"},{"location":"user-guide/images/#slow-loading","title":"Slow loading","text":"<ul> <li>Large libraries may take time to load</li> <li>Use filters to narrow results</li> <li>Check your network connection to Stash</li> </ul>"},{"location":"user-guide/images/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Track your viewing across scenes and images</li> <li>Keyboard Navigation - Complete keyboard shortcuts</li> <li>Hidden Items - Hide images you don't want to see</li> </ul>"},{"location":"user-guide/keyboard-navigation/","title":"Keyboard Navigation &amp; TV Mode","text":"<p>Peek supports keyboard navigation for remotes, wireless keyboards, or couch browsing.</p> <p>TV Mode Status</p> <p>TV Mode is a work-in-progress. Grid navigation works on most pages (Scenes, Performers, Studios, Tags), but some features and pages don't have full TV navigation yet. Best experience is currently with a wireless keyboard.</p>"},{"location":"user-guide/keyboard-navigation/#why-keyboard-navigation","title":"Why Keyboard Navigation?","text":"<ul> <li>TV Mode - Navigate Peek with a remote (partial support)</li> <li>Accessibility - Full keyboard support for users who prefer or require it</li> <li>Efficiency - Navigate faster without reaching for the mouse</li> <li>Couch Browsing - Control everything from your couch with a wireless keyboard</li> </ul>"},{"location":"user-guide/keyboard-navigation/#global-navigation","title":"Global Navigation","text":""},{"location":"user-guide/keyboard-navigation/#primary-navigation-keys","title":"Primary Navigation Keys","text":"Key Action <code>Tab</code> Move to next focusable element <code>Shift+Tab</code> Move to previous focusable element <code>Enter</code> Activate/click the focused element <code>Space</code> Activate buttons (also play/pause in video player) <code>Escape</code> Go back or close modals"},{"location":"user-guide/keyboard-navigation/#arrow-key-navigation","title":"Arrow Key Navigation","text":"<p>Arrow keys navigate through grid layouts and lists:</p> Key Action <code>\u2191</code> Move focus up (in grids and lists) <code>\u2193</code> Move focus down (in grids and lists) <code>\u2190</code> Move focus left (in grids) <code>\u2192</code> Move focus right (in grids) <p>Grid Navigation: - Scene grids automatically respond to arrow keys - Focus moves intelligently between rows and columns - Works on Scenes, Performers, Studios, Tags pages</p> <p>List Navigation: - Arrow up/down navigates vertical lists - Works in playlists, search results, settings</p>"},{"location":"user-guide/keyboard-navigation/#scene-browsing","title":"Scene Browsing","text":""},{"location":"user-guide/keyboard-navigation/#scene-grid-navigation","title":"Scene Grid Navigation","text":"<p>Navigating scene cards:</p> <ol> <li>Use <code>Tab</code> or arrow keys to focus a scene card</li> <li>Press <code>Enter</code> to open the scene detail page</li> <li>Press <code>Escape</code> to go back to the grid</li> </ol> <p>Quick actions on scene cards:</p> Key Action <code>Enter</code> Open scene detail page <code>P</code> Play scene immediately (when focused) <code>+</code> Add to playlist (opens playlist selector) <code>F</code> Toggle favorite (when supported)"},{"location":"user-guide/keyboard-navigation/#scene-detail-page","title":"Scene Detail Page","text":"<p>While viewing scene details:</p> Key Action <code>Space</code> or <code>Enter</code> Play video <code>Escape</code> Return to previous page <code>Tab</code> Navigate between action buttons"},{"location":"user-guide/keyboard-navigation/#video-player-controls","title":"Video Player Controls","text":""},{"location":"user-guide/keyboard-navigation/#playback-controls","title":"Playback Controls","text":"Key Action <code>Space</code> or <code>K</code> Play/Pause <code>\u2190</code> Seek backward 5 seconds <code>\u2192</code> Seek forward 5 seconds <code>J</code> Seek backward 10 seconds <code>L</code> Seek forward 10 seconds <code>Home</code> Jump to beginning <code>End</code> Jump to end <code>0-9</code> Jump to 0%-90% of video <p>Examples: - Press <code>5</code> to jump to 50% of the video - Press <code>0</code> to jump to the start - Press <code>9</code> to jump to 90%</p>"},{"location":"user-guide/keyboard-navigation/#volume-controls","title":"Volume Controls","text":"Key Action <code>\u2191</code> Increase volume <code>\u2193</code> Decrease volume <code>M</code> Mute/unmute"},{"location":"user-guide/keyboard-navigation/#display-controls","title":"Display Controls","text":"Key Action <code>F</code> Toggle fullscreen <code>Escape</code> Exit fullscreen <code>T</code> Toggle theater mode (when available)"},{"location":"user-guide/keyboard-navigation/#playlist-playback","title":"Playlist Playback","text":"<p>While playing a playlist:</p> Key Action <code>N</code> or <code>Shift+\u2192</code> Next scene in playlist <code>P</code> or <code>Shift+\u2190</code> Previous scene in playlist <code>S</code> Toggle shuffle <code>R</code> Cycle repeat mode (Off \u2192 All \u2192 One) <code>Escape</code> Exit playlist playback"},{"location":"user-guide/keyboard-navigation/#search-filtering","title":"Search &amp; Filtering","text":""},{"location":"user-guide/keyboard-navigation/#search-box","title":"Search Box","text":"Key Action <code>/</code> or <code>Ctrl+F</code> Focus search box (from anywhere) <code>Escape</code> Clear search and exit search box <code>Enter</code> Submit search / apply filters <code>\u2193</code> Move to search results (from search box)"},{"location":"user-guide/keyboard-navigation/#filter-controls","title":"Filter Controls","text":"<p>While using filters:</p> Key Action <code>Tab</code> Move between filter options <code>Space</code> Toggle checkbox filters <code>Enter</code> Apply filters <code>Escape</code> Close filter panel"},{"location":"user-guide/keyboard-navigation/#playlists","title":"Playlists","text":""},{"location":"user-guide/keyboard-navigation/#playlist-management","title":"Playlist Management","text":"Key Action <code>N</code> Create new playlist (when on Playlists page) <code>Enter</code> Open focused playlist <code>Delete</code> Delete focused playlist (with confirmation)"},{"location":"user-guide/keyboard-navigation/#editing-playlists","title":"Editing Playlists","text":"<p>In edit mode:</p> Key Action <code>Tab</code> Navigate between scenes <code>Delete</code> Remove focused scene from playlist <code>Escape</code> Exit edit mode <code>Enter</code> Save changes <p>Reordering scenes: - Use mouse drag-and-drop for reordering - Keyboard reordering not currently supported</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode","title":"TV Mode","text":"<p>Work in Progress</p> <p>TV Mode is being actively developed. Grid navigation works on most browse pages, but full remote-only navigation isn't complete yet.</p>"},{"location":"user-guide/keyboard-navigation/#what-is-tv-mode","title":"What is TV Mode?","text":"<p>TV Mode enables enhanced keyboard/remote navigation:</p> <ul> <li>Large Focus Indicators - Easy to see what's selected from across the room</li> <li>Remote-Friendly Navigation - Arrow keys and Enter for grid navigation</li> <li>Auto-Scroll - Page scrolls to keep focused element visible</li> </ul> <p>Current limitations:</p> <ul> <li>Some pages (Settings, modals) still require mouse or Tab navigation</li> <li>Search/filter controls need Tab to navigate</li> <li>Best paired with a wireless keyboard for full functionality</li> </ul>"},{"location":"user-guide/keyboard-navigation/#using-peek-on-tv","title":"Using Peek on TV","text":"<p>Recommended setup:</p> <ol> <li>Connect a computer to your TV (HDMI)</li> <li>Access Peek via web browser on that computer</li> <li>Use a wireless keyboard (e.g., Logitech K400) - recommended for best experience</li> <li>Enable TV Mode from the user menu</li> <li>Use arrow keys to navigate grids, Enter to select</li> </ol> <p>Alternative remotes (limited support):</p> <ul> <li>Android TV remote apps</li> <li>Smart TV keyboards</li> <li>Game controllers (via browser support)</li> </ul>"},{"location":"user-guide/keyboard-navigation/#tv-mode-tips","title":"TV Mode Tips","text":"<ol> <li>Use fullscreen browser mode (F11) for immersive experience</li> <li>Enable auto-hide cursor in your OS settings</li> <li>Increase font size in browser settings (Ctrl +)</li> <li>Use dark theme for better viewing in dark rooms</li> <li>Keep a mouse nearby for features not yet TV-navigable</li> </ol>"},{"location":"user-guide/keyboard-navigation/#settings-navigation","title":"Settings Navigation","text":""},{"location":"user-guide/keyboard-navigation/#navigating-settings-pages","title":"Navigating Settings Pages","text":"Key Action <code>Tab</code> Move between settings sections <code>Enter</code> Open/edit focused setting <code>Space</code> Toggle switches and checkboxes <code>Escape</code> Cancel without saving"},{"location":"user-guide/keyboard-navigation/#saving-settings","title":"Saving Settings","text":"Key Action <code>Enter</code> Save changes (when focused on Save button) <code>Escape</code> Cancel changes"},{"location":"user-guide/keyboard-navigation/#modal-dialogs","title":"Modal Dialogs","text":""},{"location":"user-guide/keyboard-navigation/#dialog-controls","title":"Dialog Controls","text":"Key Action <code>Enter</code> Confirm action (OK, Save, Submit) <code>Escape</code> Cancel and close dialog <code>Tab</code> Navigate between dialog buttons <p>Examples: - Delete confirmation dialogs - Playlist selector - Add to playlist modal - Login form</p>"},{"location":"user-guide/keyboard-navigation/#accessibility-features","title":"Accessibility Features","text":""},{"location":"user-guide/keyboard-navigation/#focus-indicators","title":"Focus Indicators","text":"<p>Peek shows clear visual focus indicators:</p> <ul> <li>Blue outline around focused elements</li> <li>Highlighted cards when focused in grids</li> <li>Button highlights when focused</li> <li>Scale effect on focused scene cards</li> </ul>"},{"location":"user-guide/keyboard-navigation/#screen-reader-support","title":"Screen Reader Support","text":"<p>Basic screen reader support:</p> <ul> <li>Alt text on images</li> <li>ARIA labels on buttons and controls</li> <li>Semantic HTML for proper navigation</li> <li>Keyboard-accessible everything</li> </ul> <p>Screen Reader Support</p> <p>Screen reader support is improving but may not be perfect. Please report accessibility issues on GitHub.</p>"},{"location":"user-guide/keyboard-navigation/#customizing-keyboard-shortcuts","title":"Customizing Keyboard Shortcuts","text":"<p>Currently not customizable. Keyboard shortcuts are built-in and cannot be changed.</p> <p>Future enhancement: Custom keyboard shortcuts may be added in a future update.</p>"},{"location":"user-guide/keyboard-navigation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/keyboard-navigation/#keyboard-navigation-not-working","title":"Keyboard navigation not working","text":"<p>Solution: - Click anywhere in the browser window to focus it - Try pressing <code>Tab</code> to activate focus mode - Check if a modal or dialog is open (press <code>Escape</code>) - Disable browser extensions that may interfere - Try a different browser</p>"},{"location":"user-guide/keyboard-navigation/#focus-indicator-not-visible","title":"Focus indicator not visible","text":"<p>Solution: - Your browser theme may be hiding focus outlines - Try a different theme in Peek (Settings \u2192 My Settings) - Check browser zoom level (Ctrl + 0 to reset) - Report as a bug if it persists</p>"},{"location":"user-guide/keyboard-navigation/#arrow-keys-scroll-page-instead-of-navigating","title":"Arrow keys scroll page instead of navigating","text":"<p>Solution: - Click on the scene grid to focus it first - Use <code>Tab</code> to focus an element, then arrow keys work - Some areas use <code>Tab</code> navigation only</p>"},{"location":"user-guide/keyboard-navigation/#video-player-shortcuts-not-working","title":"Video player shortcuts not working","text":"<p>Solution: - Make sure video player is focused (click on it) - Some shortcuts only work during playback - Check if another app is intercepting keys - Try clicking the video before using shortcuts</p>"},{"location":"user-guide/keyboard-navigation/#tips-for-power-users","title":"Tips for Power Users","text":""},{"location":"user-guide/keyboard-navigation/#speed-navigation","title":"Speed Navigation","text":"<ol> <li>Use <code>/</code> to search instantly from any page</li> <li>Use number keys (0-9) to scrub through videos quickly</li> <li>Press <code>Escape</code> repeatedly to navigate back multiple levels</li> <li>Use <code>Tab + Enter</code> combo for rapid clicking</li> </ol>"},{"location":"user-guide/keyboard-navigation/#couch-potato-mode","title":"Couch Potato Mode","text":"<p>Perfect setup for couch browsing:</p> <ol> <li>Open Peek in fullscreen (F11)</li> <li>Create a \"Favorites\" playlist</li> <li>Start playlist playback</li> <li>Use only these keys:</li> <li><code>Space</code> - Play/Pause</li> <li><code>N</code> - Next video</li> <li><code>P</code> - Previous video</li> <li><code>\u2191/\u2193</code> - Volume</li> <li><code>F</code> - Fullscreen on/off</li> </ol>"},{"location":"user-guide/keyboard-navigation/#workflow-optimization","title":"Workflow Optimization","text":"<p>Browse and queue efficiently:</p> <ol> <li>Navigate scene grid with arrow keys</li> <li>Press <code>+</code> on scenes you want to watch</li> <li>Add all to \"Watch Later\" playlist</li> <li>Open playlist and press Play</li> <li>Lean back and enjoy</li> </ol>"},{"location":"user-guide/keyboard-navigation/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Playlists - Create and manage custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"},{"location":"user-guide/merge-detection/","title":"Merge Detection &amp; Data Recovery","text":"<p>When scenes are merged in Stash, Peek automatically detects this and preserves your user activity data like watch history, ratings, and favorites.</p>"},{"location":"user-guide/merge-detection/#how-scene-merging-works-in-stash","title":"How Scene Merging Works in Stash","text":"<p>In Stash, you can merge duplicate scenes together. This is useful when:</p> <ul> <li>You download a higher resolution version of a scene you already had</li> <li>You discover duplicates after adding new content</li> <li>You have alternate versions (director's cut, different endings)</li> </ul> <p>When merging in Stash, the source scene is completely deleted - all its file fingerprints are transferred to the destination scene, but the source scene ID no longer exists.</p>"},{"location":"user-guide/merge-detection/#the-problem-peek-solves","title":"The Problem Peek Solves","text":"<p>Without merge detection, when Peek syncs with Stash:</p> <ol> <li>Peek sees the source scene is missing from Stash</li> <li>Peek soft-deletes the source scene</li> <li>Your watch history, ratings, and favorites become \"orphaned\"</li> <li>When you view the merged (destination) scene, your activity data is missing</li> </ol> <p>With merge detection, Peek automatically transfers your activity to the surviving scene.</p>"},{"location":"user-guide/merge-detection/#automatic-merge-detection","title":"Automatic Merge Detection","text":""},{"location":"user-guide/merge-detection/#how-it-works","title":"How It Works","text":"<p>Peek uses PHASH (perceptual hash) fingerprints to detect merges:</p> <ol> <li>When a scene is about to be soft-deleted during sync, Peek checks its PHASH</li> <li>If another scene has the same PHASH, it's likely a merge target</li> <li>Peek automatically transfers all user activity data to the target scene</li> <li>The source scene is then soft-deleted as normal</li> </ol>"},{"location":"user-guide/merge-detection/#what-gets-transferred","title":"What Gets Transferred","text":"<p>For each user with activity on the merged scene:</p> Data Type Transfer Logic Play count Added together Play duration Added together O count Added together Resume time Target scene's value kept (if any) Last played Most recent timestamp kept Rating Target scene's rating kept (if set) Favorite OR logic - if either was favorited, result is favorited <p>Automatic and Seamless</p> <p>You don't need to do anything - merge detection happens automatically during normal syncs.</p>"},{"location":"user-guide/merge-detection/#admin-recovery-tool","title":"Admin Recovery Tool","text":"<p>For scenes that were merged before this feature was implemented, or where automatic detection couldn't find a match, admins can manually recover orphaned data.</p>"},{"location":"user-guide/merge-detection/#accessing-the-tool","title":"Accessing the Tool","text":"<ol> <li>Go to Settings (gear icon)</li> <li>Click the Server tab</li> <li>Select Merge Recovery</li> </ol>"},{"location":"user-guide/merge-detection/#understanding-the-interface","title":"Understanding the Interface","text":"<p>The Merge Recovery tab shows:</p> <ul> <li>Total orphaned scenes with user activity</li> <li>For each orphan:<ul> <li>Scene title and when it was deleted</li> <li>PHASH value (if available)</li> <li>Activity summary: total plays, ratings, favorites</li> <li>Potential PHASH matches</li> </ul> </li> </ul>"},{"location":"user-guide/merge-detection/#recovering-orphaned-data","title":"Recovering Orphaned Data","text":"<p>For a single scene:</p> <ol> <li>Click on an orphaned scene to expand it</li> <li>Review the potential matches (sorted by likelihood)</li> <li>Either:<ul> <li>Click Transfer next to a match to transfer activity to that scene</li> <li>Enter a scene ID manually if you know the correct target</li> </ul> </li> <li>The activity data is transferred and an audit record is created</li> </ol> <p>For all scenes at once:</p> <ol> <li>Click Auto-Reconcile All</li> <li>Peek transfers activity for all orphans with exact PHASH matches</li> <li>Orphans without matches are skipped (handle manually later)</li> </ol>"},{"location":"user-guide/merge-detection/#discarding-orphaned-data","title":"Discarding Orphaned Data","text":"<p>If an orphaned scene's data is no longer relevant (e.g., you deleted the scene intentionally):</p> <ol> <li>Expand the orphan</li> <li>Click Discard Activity</li> <li>Confirm the action</li> </ol> <p>Permanent Action</p> <p>Discarding orphaned data permanently deletes the watch history and ratings. This cannot be undone.</p>"},{"location":"user-guide/merge-detection/#limitations","title":"Limitations","text":""},{"location":"user-guide/merge-detection/#when-automatic-detection-fails","title":"When Automatic Detection Fails","text":"<p>PHASH-based detection may not work when:</p> <ul> <li>Scene had no PHASH - Fingerprinting wasn't run in Stash before the scene was synced to Peek</li> <li>Scene was deleted before PHASH sync - Peek didn't have the PHASH stored</li> <li>Scene was split, not merged - Different operation, same result in Peek</li> </ul> <p>In these cases, use the admin recovery tool to manually reconcile.</p>"},{"location":"user-guide/merge-detection/#phash-not-available","title":"PHASH Not Available","text":"<p>If a scene shows \"No PHASH\" in the recovery tool:</p> <ol> <li>The scene was synced before fingerprint syncing was implemented</li> <li>You can manually enter the target scene ID if you know it</li> <li>Future syncs will include PHASH data for new scenes</li> </ol>"},{"location":"user-guide/merge-detection/#audit-trail","title":"Audit Trail","text":"<p>Every merge reconciliation (automatic or manual) creates an audit record containing:</p> <ul> <li>Source and target scene IDs</li> <li>Which PHASH matched them (if automatic)</li> <li>All transferred data values</li> <li>When the reconciliation happened</li> <li>Who performed it (system for automatic, admin username for manual)</li> </ul> <p>This ensures full traceability of data transfers.</p>"},{"location":"user-guide/merge-detection/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/merge-detection/#before-merging-in-stash","title":"Before Merging in Stash","text":"<ol> <li>Run a full sync in Peek first to ensure PHASHes are stored</li> <li>Merge scenes in Stash as normal</li> <li>Run another sync - merge detection happens automatically</li> </ol>"},{"location":"user-guide/merge-detection/#checking-results","title":"Checking Results","text":"<p>After a sync where merges occurred:</p> <ol> <li>Check the sync log for \"Detected merge\" messages</li> <li>Verify your watch history appears on the destination scene</li> <li>If something is missing, check the admin recovery tool</li> </ol>"},{"location":"user-guide/merge-detection/#for-admins","title":"For Admins","text":"<ul> <li>Periodically check the Merge Recovery tab for orphaned scenes</li> <li>Use Auto-Reconcile All to quickly process exact matches</li> <li>Manually review and reconcile scenes without PHASH matches</li> </ul>"},{"location":"user-guide/merge-detection/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/merge-detection/#activity-not-transferred","title":"Activity Not Transferred","text":"<p>Possible causes:</p> <ul> <li>PHASH wasn't available at sync time</li> <li>Multiple potential matches exist (check admin tool)</li> <li>Scene was deleted, not merged</li> </ul> <p>Solution: Use the admin recovery tool to manually reconcile.</p>"},{"location":"user-guide/merge-detection/#wrong-scene-got-the-activity","title":"Wrong Scene Got the Activity","text":"<p>If activity was transferred to the wrong scene:</p> <ol> <li>Currently, there's no automatic undo</li> <li>Contact your admin to manually adjust records if needed</li> <li>Future enhancement: undo capability using audit records</li> </ol>"},{"location":"user-guide/merge-detection/#orphaned-scenes-keep-appearing","title":"Orphaned Scenes Keep Appearing","text":"<p>If the same scenes keep showing as orphaned:</p> <ul> <li>They may have been deleted in Stash (not merged)</li> <li>Check if they should be discarded rather than reconciled</li> <li>If they're legitimately orphaned, use the recovery tool</li> </ul>"},{"location":"user-guide/merge-detection/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Learn more about watch history tracking</li> <li>User Management - Admin features and user management</li> </ul>"},{"location":"user-guide/personalization/","title":"Personalization","text":"<p>Customize Peek's navigation and layout to match how you browse your library.</p>"},{"location":"user-guide/personalization/#landing-page-preference","title":"Landing Page Preference","text":"<p>Choose which page to land on after logging in, instead of always starting at Home.</p>"},{"location":"user-guide/personalization/#setting-your-landing-page","title":"Setting Your Landing Page","text":"<ol> <li>Go to Settings \u2192 Navigation</li> <li>Under Landing Page After Login, select your preferred page</li> <li>Click Save</li> </ol>"},{"location":"user-guide/personalization/#available-landing-pages","title":"Available Landing Pages","text":"Page Description Home Homepage with carousels (default) Scenes Scene browse page Performers Performer browse page Studios Studio browse page Tags Tag browse page Collections Collections/groups page Galleries Gallery browse page Images Image browse page Playlists Your playlists Recommended AI-recommended scenes Watch History Your viewing history User Stats Your statistics dashboard"},{"location":"user-guide/personalization/#random-mode","title":"Random Mode","text":"<p>For variety, enable Random one of selected pages to land on a different page each login:</p> <ol> <li>Toggle on Random one of selected pages</li> <li>Select 2 or more pages (checkboxes appear)</li> <li>Click Save</li> </ol> <p>Each time you log in, Peek randomly picks one of your selected pages.</p>"},{"location":"user-guide/personalization/#peek-logo-navigation","title":"Peek Logo Navigation","text":"<p>Clicking the Peek logo in the navigation bar also respects your landing page preference:</p> <ul> <li>If you've set a specific page, clicking the logo takes you there</li> <li>In random mode, each click picks a different page from your selection</li> <li>This works in all layouts: mobile top bar, expanded sidebar, and collapsed sidebar</li> </ul>"},{"location":"user-guide/personalization/#when-preferences-apply","title":"When Preferences Apply","text":"<p>Your landing page preference applies when:</p> <ul> <li>Logging in from a fresh browser or after session expiry</li> <li>Clicking the Peek logo from any page</li> </ul> <p>Your preference does not apply when:</p> <ul> <li>Redirected to login: If you were browsing <code>/performers</code> and your session expired, you'll return to <code>/performers</code> after login (not your preference)</li> <li>Existing tab: If you have a long-running tab open, Peek remembers your last URL and returns you there after re-authentication</li> </ul> <p>Testing your preference</p> <p>After changing your landing page setting, open a new browser tab to test. Existing tabs remember your last location.</p>"},{"location":"user-guide/personalization/#navigation-menu-customization","title":"Navigation Menu Customization","text":"<p>Reorder or hide items in the main navigation sidebar to prioritize the pages you use most.</p>"},{"location":"user-guide/personalization/#customizing-the-menu","title":"Customizing the Menu","text":"<ol> <li>Go to Settings \u2192 Navigation</li> <li>Under Navigation Menu, you'll see all available menu items</li> <li>Use the drag handles (\u22ee\u22ee) to reorder items</li> <li>Toggle the eye icon to show/hide items</li> <li>Click Save to apply changes</li> </ol>"},{"location":"user-guide/personalization/#available-navigation-items","title":"Available Navigation Items","text":"<ul> <li>Scenes</li> <li>Recommended</li> <li>Performers</li> <li>Studios</li> <li>Tags</li> <li>Collections</li> <li>Galleries</li> <li>Images</li> <li>Playlists</li> </ul>"},{"location":"user-guide/personalization/#tips","title":"Tips","text":"<ul> <li>Hide rarely-used items to declutter the sidebar</li> <li>Put your most-used pages at the top for faster access</li> <li>Hidden items are still accessible via direct URL</li> <li>Changes take effect immediately after saving (page reloads)</li> </ul>"},{"location":"user-guide/personalization/#homepage-carousels","title":"Homepage Carousels","text":"<p>The homepage displays carousels of content. You can customize which carousels appear and their order.</p>"},{"location":"user-guide/personalization/#managing-carousels","title":"Managing Carousels","text":"<ol> <li>Go to Settings \u2192 Navigation</li> <li>Under Homepage Carousels, you'll see all available carousels</li> <li>Use arrows to reorder carousels</li> <li>Toggle visibility with the eye icon</li> <li>Changes save automatically</li> </ol>"},{"location":"user-guide/personalization/#default-carousels","title":"Default Carousels","text":"Carousel Content Continue Watching Scenes you've started but not finished Recently Watched Your recent viewing history Recommended AI-generated suggestions Favorites Your favorited scenes Recently Added Newest scenes in your library"},{"location":"user-guide/personalization/#custom-carousels","title":"Custom Carousels","text":"<p>Create your own carousels with custom filter rules. See Custom Carousels for details on the carousel builder.</p>"},{"location":"user-guide/personalization/#related","title":"Related","text":"<ul> <li>Custom Carousels \u2014 Create personalized homepage carousels</li> <li>Browse and Display \u2014 View modes and card display options</li> <li>User Management \u2014 Account settings and preferences</li> </ul>"},{"location":"user-guide/playlists/","title":"Playlists","text":"<p>Create and manage custom playlists to organize your favorite scenes.</p>"},{"location":"user-guide/playlists/#creating-a-playlist","title":"Creating a Playlist","text":"<ol> <li>Click Playlists in the navigation menu</li> <li>Click the Create Playlist button</li> <li>Enter a name for your playlist</li> <li>Optionally add a description</li> <li>Click Create</li> </ol> <p>Your new playlist is now ready to use!</p>"},{"location":"user-guide/playlists/#adding-scenes-to-playlists","title":"Adding Scenes to Playlists","text":"<p>There are two ways to add scenes to your playlists:</p>"},{"location":"user-guide/playlists/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Find a scene you want to add (on any page with scene cards)</li> <li>Click the + (plus) icon on the scene card</li> <li>Select the playlist you want to add it to</li> <li>The scene is added instantly!</li> </ol>"},{"location":"user-guide/playlists/#from-scene-detail-page","title":"From Scene Detail Page","text":"<ol> <li>Click on a scene to open its detail page</li> <li>Click the Add to Playlist button</li> <li>Select the playlist you want to add it to</li> <li>Done!</li> </ol> <p>Multiple Playlists</p> <p>You can add the same scene to multiple playlists. Great for organizing scenes by different themes or moods!</p>"},{"location":"user-guide/playlists/#managing-your-playlists","title":"Managing Your Playlists","text":""},{"location":"user-guide/playlists/#viewing-playlist-contents","title":"Viewing Playlist Contents","text":"<ol> <li>Click Playlists in the navigation</li> <li>Click on any playlist to see its scenes</li> <li>Scroll through to see all scenes in the playlist</li> </ol>"},{"location":"user-guide/playlists/#editing-playlist-details","title":"Editing Playlist Details","text":"<ol> <li>Open a playlist</li> <li>Click the Edit button (pencil icon)</li> <li>Change the name or description</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#reordering-scenes","title":"Reordering Scenes","text":"<p>Want to change the playback order?</p> <ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Drag and drop scenes to reorder them</li> <li>Click Save when done</li> </ol> <p>The playlist will play scenes in the order you've arranged them.</p>"},{"location":"user-guide/playlists/#removing-scenes","title":"Removing Scenes","text":"<ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Click the \u00d7 (remove) icon on any scene</li> <li>Confirm removal</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#deleting-a-playlist","title":"Deleting a Playlist","text":"<p>Permanent Action</p> <p>Deleting a playlist cannot be undone. The scenes themselves are not deleted, just the playlist.</p> <ol> <li>Open the playlist you want to delete</li> <li>Click the Delete button (trash icon)</li> <li>Confirm deletion</li> <li>The playlist is permanently removed</li> </ol>"},{"location":"user-guide/playlists/#playing-playlists","title":"Playing Playlists","text":""},{"location":"user-guide/playlists/#basic-playback","title":"Basic Playback","text":"<ol> <li>Open a playlist</li> <li>Click the Play button</li> <li>Playback starts with the first scene</li> <li>When a scene ends, the next scene plays automatically</li> </ol>"},{"location":"user-guide/playlists/#shuffle-mode","title":"Shuffle Mode","text":"<p>Randomize the playback order:</p> <ol> <li>Open a playlist</li> <li>Click the Shuffle button (shuffle icon)</li> <li>Playlist will play scenes in random order</li> <li>Click Shuffle again to turn it off</li> </ol> <p>Shuffle Tip</p> <p>Shuffle is perfect for long playlists when you want variety!</p>"},{"location":"user-guide/playlists/#repeat-modes","title":"Repeat Modes","text":"<p>Choose how playback repeats:</p> <p>Repeat Off (default) - Playlist plays once and stops</p> <p>Repeat All - When playlist ends, it starts over from the beginning - Continues until you stop it</p> <p>Repeat One - Current scene repeats continuously - Great for favorite scenes!</p> <p>To change repeat mode: 1. Open a playlist 2. Click the Repeat button 3. Click again to cycle through modes: Off \u2192 All \u2192 One \u2192 Off</p>"},{"location":"user-guide/playlists/#navigation-during-playback","title":"Navigation During Playback","text":"<p>While watching a playlist:</p> <ul> <li>Next Scene: Click the next button or press N</li> <li>Previous Scene: Click the previous button or press P</li> <li>Exit Playlist: Click the back button to return to browsing</li> </ul>"},{"location":"user-guide/playlists/#playlist-tips-tricks","title":"Playlist Tips &amp; Tricks","text":""},{"location":"user-guide/playlists/#organization-ideas","title":"Organization Ideas","text":"<ul> <li>By Performer: Create playlists for your favorite performers</li> <li>By Studio: Group scenes from specific studios</li> <li>By Theme: Organize by categories or tags</li> <li>Watch Later: Save scenes you want to watch later</li> <li>Best Of: Curate your absolute favorites</li> <li>Mood-Based: Create playlists for different moods or occasions</li> </ul>"},{"location":"user-guide/playlists/#quick-access","title":"Quick Access","text":"<p>Your playlists are always accessible from: - The Playlists page (shows all playlists) - Any scene's Add to Playlist menu - The + icon on scene cards</p>"},{"location":"user-guide/playlists/#playlist-size","title":"Playlist Size","text":"<p>There's no limit to how many: - Playlists you can create - Scenes you can add to a playlist - Playlists a single scene can be in</p>"},{"location":"user-guide/playlists/#downloading-playlists","title":"Downloading Playlists","text":"<p>You can download entire playlists as zip archives for offline viewing. The zip includes all video files plus an M3U playlist and Kodi-compatible NFO metadata files.</p> <p>To download a playlist: 1. Open a playlist 2. Click the Download button 3. Wait for the zip to be created (progress shown) 4. Download starts automatically when ready</p> <p>Permission Required</p> <p>Downloading playlists requires the \"Can Download Playlists\" permission. See Downloads for details.</p>"},{"location":"user-guide/playlists/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/playlists/#scene-wont-add-to-playlist","title":"Scene won't add to playlist","text":"<ul> <li>Make sure you're logged in</li> <li>Check that the playlist still exists</li> <li>Try refreshing the page</li> </ul>"},{"location":"user-guide/playlists/#playlist-wont-play","title":"Playlist won't play","text":"<ul> <li>Verify the playlist has scenes in it</li> <li>Check that you can play individual scenes</li> <li>Make sure your path mappings are configured correctly</li> </ul>"},{"location":"user-guide/playlists/#changes-arent-saving","title":"Changes aren't saving","text":"<ul> <li>Make sure to click Save after editing</li> <li>Check your internet connection</li> <li>Try refreshing and making changes again</li> </ul>"},{"location":"user-guide/playlists/#next-steps","title":"Next Steps","text":"<ul> <li>Downloads - Download playlists, scenes, and images for offline viewing</li> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Troubleshooting - Fix common issues</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/recommendations/","title":"Recommendations","text":"<p>Get personalized scene suggestions based on your favorites and ratings.</p>"},{"location":"user-guide/recommendations/#how-it-works","title":"How It Works","text":"<p>Peek learns your preferences from your activity:</p> <ul> <li>Favorited performers - Scenes featuring performers you've favorited</li> <li>Highly-rated performers - Scenes with performers you've rated 4+ stars</li> <li>Favorited studios - Scenes from studios you've favorited</li> <li>Highly-rated studios - Scenes from studios you've rated 4+ stars</li> <li>Favorited tags - Scenes with tags you've favorited</li> <li>Highly-rated tags - Scenes with tags you've rated 4+ stars</li> <li>Scene ratings - Similar scenes to ones you've rated highly</li> </ul> <p>The more you rate and favorite, the better your recommendations become!</p>"},{"location":"user-guide/recommendations/#accessing-recommendations","title":"Accessing Recommendations","text":""},{"location":"user-guide/recommendations/#recommended-page","title":"Recommended Page","text":"<p>Click Recommended in the navigation menu to see a full page of personalized suggestions.</p> <p>The page shows:</p> <ul> <li>Scenes matching your preferences</li> <li>Pagination for browsing more results</li> <li>Your current activity stats</li> </ul>"},{"location":"user-guide/recommendations/#recommended-sidebar","title":"Recommended Sidebar","text":"<p>When viewing a scene, the sidebar shows related recommendations:</p> <ul> <li>Similar performers</li> <li>Same studio</li> <li>Matching tags</li> </ul>"},{"location":"user-guide/recommendations/#building-your-profile","title":"Building Your Profile","text":""},{"location":"user-guide/recommendations/#getting-started","title":"Getting Started","text":"<p>If you're new to Peek, you'll see a message explaining how to get recommendations:</p> <ol> <li>Favorite performers you enjoy</li> <li>Rate scenes you watch (especially 4+ stars)</li> <li>Favorite studios that consistently produce content you like</li> <li>Favorite tags for your preferred categories</li> </ol>"},{"location":"user-guide/recommendations/#activity-indicators","title":"Activity Indicators","text":"<p>The Recommended page shows your current activity:</p> <pre><code>Your current activity:\n\u2022 5 favorited performers, 3 highly-rated\n\u2022 2 favorited studios, 1 highly-rated\n\u2022 8 favorited tags, 4 highly-rated\n\u2022 15 favorited scenes, 42 rated scenes\n</code></pre> <p>This helps you understand what's driving your recommendations.</p>"},{"location":"user-guide/recommendations/#tips-for-better-recommendations","title":"Tips for Better Recommendations","text":""},{"location":"user-guide/recommendations/#rate-generously","title":"Rate Generously","text":"<p>Rate scenes you watch, even if just quickly:</p> <ul> <li>4+ stars = Scenes similar to this will be recommended</li> <li>Below 7.0 = Won't negatively affect recommendations, but won't boost similar content</li> </ul>"},{"location":"user-guide/recommendations/#favorite-strategically","title":"Favorite Strategically","text":"<p>Favorites have strong weight in recommendations:</p> <ul> <li>Favorite your top performers (not just ones you like)</li> <li>Favorite studios whose content you consistently enjoy</li> <li>Favorite tags for categories you always want to see</li> </ul>"},{"location":"user-guide/recommendations/#explore-hidden-gems","title":"Explore Hidden Gems","text":"<p>Recommendations can surface scenes you might have missed:</p> <ul> <li>Older content from favorite performers</li> <li>Other scenes from studios you've rated highly</li> <li>Scenes with multiple matching tags</li> </ul>"},{"location":"user-guide/recommendations/#how-recommendations-are-scored","title":"How Recommendations Are Scored","text":"<p>Scenes are scored based on multiple factors:</p> Factor Weight Favorited performer in scene High Highly-rated performer in scene Medium-High Favorited studio Medium Highly-rated studio Medium Favorited tags (each) Low-Medium Highly-rated tags (each) Low <p>Scenes matching multiple criteria score higher and appear first.</p>"},{"location":"user-guide/recommendations/#excluding-scenes","title":"Excluding Scenes","text":"<p>Already seen a recommendation? Don't want to see it again?</p> <ol> <li>Click the Hide button on the scene card</li> <li>The scene won't appear in recommendations again</li> <li>Hidden scenes can be restored from Settings &gt; Hidden Items</li> </ol>"},{"location":"user-guide/recommendations/#recommendations-vs-random","title":"Recommendations vs. Random","text":"Feature Recommendations Random Sort Personalized Yes No Based on ratings Yes No Surfaces old content Yes Yes Repeatable Yes (same preferences = same results) No (different each session) <p>Use Recommendations when you want curated content. Use Random when you want to discover without preferences.</p>"},{"location":"user-guide/recommendations/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/recommendations/#no-recommendations-yet","title":"\"No Recommendations Yet\"","text":"<p>This appears when you haven't rated or favorited enough content:</p> <ol> <li>Browse scenes and rate some 4+ stars</li> <li>Favorite a few performers you enjoy</li> <li>Return to Recommendations</li> </ol>"},{"location":"user-guide/recommendations/#recommendations-seem-repetitive","title":"Recommendations seem repetitive","text":"<p>If you're seeing the same scenes:</p> <ol> <li>Hide scenes you've already watched</li> <li>Rate more scenes to expand your profile</li> <li>Favorite more diverse performers/tags</li> </ol>"},{"location":"user-guide/recommendations/#recommendations-dont-match-my-taste","title":"Recommendations don't match my taste","text":"<p>Your recommendation profile might need tuning:</p> <ol> <li>Review your favorites (Settings &gt; remove any accidental favorites)</li> <li>Rate more scenes to give the algorithm more data</li> <li>Remember: ratings 4+ stars strongly influence results</li> </ol>"},{"location":"user-guide/recommendations/#next-steps","title":"Next Steps","text":"<ul> <li>Custom Carousels - Create your own homepage carousels</li> <li>Watch History - Track what you've watched</li> <li>Playlists - Manually curate scene collections</li> </ul>"},{"location":"user-guide/user-management/","title":"User Management","text":"<p>Peek supports multiple users with separate preferences, watch history, and content access. Admins can create accounts, set content restrictions, manage user groups, and control permissions.</p>"},{"location":"user-guide/user-management/#user-roles","title":"User Roles","text":"<p>Peek has two user roles:</p> Role Description Admin Full access including user management, server settings, and bypasses all content restrictions User Standard access with personal preferences, playlists, and watch history <p>Admin Content Access</p> <p>Admins always see all content, regardless of any restrictions. This allows admins to manage and organize content that may be restricted for other users.</p>"},{"location":"user-guide/user-management/#creating-users","title":"Creating Users","text":"<p>Requirements: Admin role</p> <ol> <li>Go to Settings \u2192 User Management tab</li> <li>Click + Create User</li> <li>Enter:</li> <li>Username (must be unique)</li> <li>Password (minimum 8 characters, must include at least one letter and one number)</li> <li>Role (User or Admin)</li> <li>Click Create</li> </ol> <p>The new user can now log in with these credentials.</p>"},{"location":"user-guide/user-management/#managing-users","title":"Managing Users","text":"<p>Requirements: Admin role</p> <p>Click on any user row in the User Management table to open the User Edit Modal, which provides a comprehensive view of user settings:</p>"},{"location":"user-guide/user-management/#user-edit-modal-sections","title":"User Edit Modal Sections","text":"Section Description Account Change username, password, and role Groups Manage group memberships for permission inheritance Permissions View and override individual permissions Content Restrictions Set what content the user can see"},{"location":"user-guide/user-management/#quick-actions","title":"Quick Actions","text":"<p>From the user table, you can also:</p> Action Description Sync from Stash Import ratings and favorites from Stash for this user Delete Remove the user account <p>Cannot Delete Self</p> <p>Admins cannot delete their own account. Another admin must perform this action.</p>"},{"location":"user-guide/user-management/#user-groups","title":"User Groups","text":"<p>User groups allow you to manage permissions for multiple users at once. Users inherit permissions from all groups they belong to.</p>"},{"location":"user-guide/user-management/#how-groups-work","title":"How Groups Work","text":"<ul> <li>Each group defines default permissions (sharing, downloading files, downloading playlists)</li> <li>Users can belong to multiple groups</li> <li>Permissions use \"most permissive wins\" logic\u2014if any group grants a permission, the user has it</li> <li>Individual user overrides can further customize permissions</li> </ul>"},{"location":"user-guide/user-management/#managing-groups","title":"Managing Groups","text":"<p>Requirements: Admin role</p> <ol> <li>Go to Settings \u2192 Groups tab</li> <li>Click + Create Group to add a new group</li> <li>Enter:</li> <li>Name (must be unique)</li> <li>Description (optional)</li> <li>Default Permissions (toggle which permissions group members should have)</li> <li>Click Create</li> </ol>"},{"location":"user-guide/user-management/#group-permissions","title":"Group Permissions","text":"Permission Description Can Share Allow users to share content links (future feature) Can Download Files Allow downloading individual scenes and images Can Download Playlists Allow downloading playlist zip archives"},{"location":"user-guide/user-management/#adding-users-to-groups","title":"Adding Users to Groups","text":"<ol> <li>Click on a user in the User Management table</li> <li>Go to the Groups section</li> <li>Check the groups you want the user to belong to</li> <li>Click Save</li> </ol>"},{"location":"user-guide/user-management/#permission-resolution","title":"Permission Resolution","text":"<p>When determining a user's effective permissions:</p> <ol> <li>Start with all permissions disabled</li> <li>For each group the user belongs to, if the group grants a permission, enable it</li> <li>Apply any user-level overrides (explicit allow or deny)</li> </ol> <p>Permission Inheritance</p> <p>The Groups section in the User Edit Modal shows which permissions are inherited from groups vs. overridden at the user level.</p>"},{"location":"user-guide/user-management/#permissions","title":"Permissions","text":"<p>Permissions control what actions users can perform beyond viewing content.</p>"},{"location":"user-guide/user-management/#available-permissions","title":"Available Permissions","text":"Permission Description Can Share Share content links with others Can Download Files Download individual scenes and images Can Download Playlists Download playlist zip archives"},{"location":"user-guide/user-management/#setting-permissions","title":"Setting Permissions","text":"<ol> <li>Click on a user in the User Management table</li> <li>Go to the Permissions section</li> <li>For each permission, choose:</li> <li>Inherit \u2014 Use the value from group memberships</li> <li>Allow \u2014 Explicitly grant this permission</li> <li>Deny \u2014 Explicitly deny this permission</li> <li>Click Save</li> </ol> <p>Override Priority</p> <p>User-level overrides always take precedence over group permissions. An explicit \"Deny\" will block a permission even if a group grants it.</p>"},{"location":"user-guide/user-management/#content-restrictions","title":"Content Restrictions","text":"<p>Admins can restrict what content users see. Restrictions cascade throughout the UI\u2014restricted items won't appear in lists, cards, dropdowns, or detail pages.</p>"},{"location":"user-guide/user-management/#restriction-types","title":"Restriction Types","text":"Type Best For Collections (Groups) Most reliable\u2014static, manually curated sets Tags Content categories (may change if using Stash plugins) Studios Limiting by production company Galleries Restricting specific gallery content <p>Recommended Approach</p> <p>Use Collections (Groups) as your primary restriction mechanism. Create groups in Stash for content categories, then restrict users to specific groups in Peek.</p>"},{"location":"user-guide/user-management/#restriction-modes","title":"Restriction Modes","text":"Mode Behavior None No restrictions (default) Exclude Hide selected items and all associated content Include Show ONLY selected items\u2014user sees nothing else"},{"location":"user-guide/user-management/#setting-restrictions","title":"Setting Restrictions","text":"<ol> <li>Click on a user in the User Management table</li> <li>Go to the Content Restrictions section</li> <li>For each entity type (Collections, Tags, Studios, Galleries):</li> <li>Select a mode (None, Exclude, or Include)</li> <li>Choose specific items to include or exclude</li> <li>Optionally enable Restrict Empty to hide content with no metadata for that type</li> <li>Click Save</li> </ol>"},{"location":"user-guide/user-management/#how-restrictions-work","title":"How Restrictions Work","text":"<p>Exclude mode example: - Exclude the tag \"Documentary\" - User won't see any scenes, performers, or studios tagged \"Documentary\"</p> <p>Include mode example: - Include only the collection \"Favorites\" - User only sees scenes in the \"Favorites\" group\u2014nothing else</p> <p>Cascading behavior: - Restricted tags don't appear in filter dropdowns - Restricted studios don't appear on performer detail pages - Scene counts exclude restricted content</p>"},{"location":"user-guide/user-management/#user-settings","title":"User Settings","text":""},{"location":"user-guide/user-management/#what-users-can-configure","title":"What Users Can Configure","text":"<p>Each user can customize their own experience:</p> Setting Options Video Quality Auto, 1080p, 720p, 480p, 360p Playback Mode Direct, Transcode, Auto Preview Quality Sprite, WebP, MP4 Theme Light, Dark, Deep Purple, The Hub, Custom Home Carousels Enable/disable and reorder Navigation Customize menu items Wall Playback Autoplay, Hover, Static"},{"location":"user-guide/user-management/#accessing-settings","title":"Accessing Settings","text":"<ul> <li>Click your username in the header \u2192 Settings</li> <li>Or navigate directly to the Settings page</li> </ul>"},{"location":"user-guide/user-management/#syncing-with-stash","title":"Syncing with Stash","text":""},{"location":"user-guide/user-management/#sync-from-stash-import","title":"Sync from Stash (Import)","text":"<p>Imports a user's ratings and favorites from Stash into Peek. Useful when: - A new user already has data in Stash - Recovering from a Peek database reset</p> <p>To sync: 1. Go to User Management 2. Click Sync from Stash for the user 3. Select what to import (ratings, favorites, O-counter) 4. Click Start Sync</p>"},{"location":"user-guide/user-management/#sync-to-stash-export","title":"Sync to Stash (Export)","text":"<p>When enabled, user activity syncs back to Stash:</p> Data Sync Behavior O-Counter Aggregates across users (increments add up) Ratings Overwrites (last user to rate wins) Favorites Individual per user <p>Multi-User Considerations</p> <p>If multiple users rate the same scene, the last rating wins in Stash. O-counters aggregate, so they'll be higher in Stash than for any individual user.</p> <p>To enable/disable: 1. Go to User Management 2. Find the user in the table 3. Toggle the Sync to Stash column</p>"},{"location":"user-guide/user-management/#hidden-items","title":"Hidden Items","text":"<p>Users can hide individual items they don't want to see. Unlike admin restrictions, users can unhide items themselves.</p>"},{"location":"user-guide/user-management/#hiding-content","title":"Hiding Content","text":"<ul> <li>On any card, click the \u22ee menu \u2192 Hide</li> <li>Or on detail pages, use the Hide action</li> </ul>"},{"location":"user-guide/user-management/#managing-hidden-items","title":"Managing Hidden Items","text":"<ol> <li>Go to Settings \u2192 Hidden Items tab</li> <li>View all hidden items by type</li> <li>Click Unhide to restore visibility</li> </ol> <p>See Hidden Items for details.</p>"},{"location":"user-guide/user-management/#user-menu","title":"User Menu","text":"<p>The user menu (top-right corner) provides quick access to:</p> <ul> <li>Watch History \u2014 Resume where you left off</li> <li>My Stats \u2014 Personal viewing statistics</li> <li>Downloads \u2014 View and manage your download history</li> <li>TV Mode \u2014 Toggle enhanced keyboard navigation</li> <li>Sign Out \u2014 Log out of your account</li> </ul>"},{"location":"user-guide/user-management/#proxy-authentication-sso","title":"Proxy Authentication (SSO)","text":"<p>Peek supports single sign-on via reverse proxy authentication. When configured:</p> <ul> <li>Users are automatically logged in based on proxy headers</li> <li>Usernames must match exactly between proxy and Peek</li> <li>See Configuration - Proxy Authentication for setup</li> </ul>"},{"location":"user-guide/user-management/#security","title":"Security","text":""},{"location":"user-guide/user-management/#password-requirements","title":"Password Requirements","text":"<p>Passwords must meet these requirements:</p> <ul> <li>Minimum 8 characters</li> <li>At least one letter (a-z or A-Z)</li> <li>At least one number (0-9)</li> </ul>"},{"location":"user-guide/user-management/#account-lockout","title":"Account Lockout","text":"<p>To protect against brute-force attacks:</p> <ul> <li>After 5 failed login attempts, the account is locked for 15 minutes</li> <li>The lockout applies per username</li> <li>Admins cannot manually unlock accounts\u2014wait for the lockout to expire</li> </ul>"},{"location":"user-guide/user-management/#rate-limiting","title":"Rate Limiting","text":"<p>Authentication endpoints are rate-limited:</p> <ul> <li>10 requests per 15 minutes per IP address</li> <li>Applies to login, password reset, and registration endpoints</li> <li>Helps prevent automated attacks</li> </ul>"},{"location":"user-guide/user-management/#recovery-keys","title":"Recovery Keys","text":"<p>Each user has a recovery key that can be used to reset their password if forgotten.</p> <p>Viewing your recovery key: 1. Go to Settings \u2192 Account tab 2. Your recovery key is displayed in the Security section 3. Copy and store it in a safe place (password manager recommended)</p> <p>Using a recovery key: 1. On the login page, click Forgot Password 2. Enter your username 3. Enter your recovery key 4. Set a new password</p> <p>Keep Your Recovery Key Safe</p> <p>Recovery keys are the only way to reset a forgotten password without admin intervention. Store yours securely\u2014if you lose both your password and recovery key, an admin must reset your password.</p>"},{"location":"user-guide/user-management/#admin-password-reset","title":"Admin Password Reset","text":"<p>Admins can reset any user's password:</p> <ol> <li>Click on the user in User Management</li> <li>In the Account section, enter a new password</li> <li>Click Save</li> </ol> <p>The user should change their password after logging in.</p>"},{"location":"user-guide/user-management/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Passwords are hashed with bcrypt (never stored in plain text)</li> <li>Sessions expire after 24 hours of activity</li> <li>Inactive sessions expire after 4 hours</li> <li>Change the default admin password immediately after setup</li> <li>Store recovery keys in a password manager</li> <li>Use unique passwords for each user account</li> </ul>"},{"location":"user-guide/user-management/#next-steps","title":"Next Steps","text":"<ul> <li>Downloads \u2014 Download scenes, images, and playlists</li> <li>Hidden Items \u2014 Manage your personal hidden content</li> <li>Watch History \u2014 Track and resume playback</li> <li>Configuration \u2014 Server-level settings</li> </ul>"},{"location":"user-guide/watch-history/","title":"Watch History &amp; Resume Playback","text":"<p>Peek automatically tracks your viewing progress and lets you resume playback exactly where you left off.</p>"},{"location":"user-guide/watch-history/#how-watch-history-works","title":"How Watch History Works","text":""},{"location":"user-guide/watch-history/#automatic-tracking","title":"Automatic Tracking","text":"<p>Peek tracks your progress automatically while you watch:</p> <ul> <li>Progress is saved every few seconds during playback</li> <li>No manual action needed - just watch normally</li> <li>Per-user tracking - each user has their own watch history</li> <li>Syncs across devices - resume on any device where you're logged in</li> </ul>"},{"location":"user-guide/watch-history/#what-gets-tracked","title":"What Gets Tracked","text":"<p>For each scene you watch, Peek remembers:</p> <ul> <li>Current position - Exact timestamp where you stopped</li> <li>Total progress - Percentage watched (e.g., 65% complete)</li> <li>Last watched date - When you last viewed this scene</li> <li>Watch count - How many times you've watched it</li> </ul>"},{"location":"user-guide/watch-history/#resume-playback","title":"Resume Playback","text":""},{"location":"user-guide/watch-history/#automatic-resume","title":"Automatic Resume","text":"<p>When you click Play on a scene you've partially watched:</p> <ol> <li>Video player opens</li> <li>You see a \"Resume from [timestamp]\" notification</li> <li>Player automatically jumps to where you left off</li> <li>Click \"Start from beginning\" if you prefer to restart</li> </ol> <p>Quick Resume</p> <p>The resume prompt appears for 5 seconds. If you do nothing, playback continues from your last position automatically!</p>"},{"location":"user-guide/watch-history/#from-scene-cards","title":"From Scene Cards","text":"<p>Scene cards show your progress visually:</p> <ul> <li>Progress bar at the bottom of the thumbnail</li> <li>Percentage indicator (e.g., \"65% watched\")</li> <li>Blue progress bar fills from left to right as you watch</li> </ul> <p>To resume from a scene card: 1. Find the scene (look for the progress bar) 2. Click Play 3. Playback resumes automatically</p>"},{"location":"user-guide/watch-history/#continue-watching","title":"Continue Watching","text":""},{"location":"user-guide/watch-history/#quick-access-to-in-progress-scenes","title":"Quick Access to In-Progress Scenes","text":"<p>The Continue Watching section shows all partially-watched scenes:</p> <p>Location: Home page (top section)</p> <p>What appears here: - Scenes you've started but not finished - Sorted by most recently watched - Shows progress percentage - Limited to your last 20 in-progress scenes</p> <p>To resume: 1. Go to Home page 2. Find the scene in Continue Watching 3. Click Play 4. Resumes from where you stopped</p> <p>Fast Resume</p> <p>Continue Watching is the fastest way to pick up where you left off!</p>"},{"location":"user-guide/watch-history/#when-scenes-disappear-from-continue-watching","title":"When Scenes Disappear from Continue Watching","text":"<p>A scene is removed from Continue Watching when: - You watch to completion (95%+ watched counts as complete) - You manually clear watch history for that scene - It falls outside your last 20 in-progress scenes</p>"},{"location":"user-guide/watch-history/#managing-watch-history","title":"Managing Watch History","text":""},{"location":"user-guide/watch-history/#viewing-your-history","title":"Viewing Your History","text":"<p>Full watch history coming in future update. Currently:</p> <ul> <li>View in-progress scenes via Continue Watching on home page</li> <li>See progress bars on scene cards throughout the app</li> <li>Check scene detail page for watch progress</li> </ul>"},{"location":"user-guide/watch-history/#marking-as-watched","title":"Marking as Watched","text":"<p>To mark a scene as fully watched without watching it:</p> <ol> <li>Open the scene detail page</li> <li>Seek to the end of the video (last 5%)</li> <li>Let it play for a few seconds</li> <li>Scene is marked as watched</li> </ol> <p>Or manually skip to 95%+ completion to trigger \"watched\" status.</p>"},{"location":"user-guide/watch-history/#clearing-watch-history","title":"Clearing Watch History","text":"<p>For a single scene:</p> <ol> <li>Open the scene detail page</li> <li>Click the \u22ee (three dots) menu</li> <li>Select \"Clear watch history\"</li> <li>Progress is reset to 0%</li> </ol> <p>For all scenes:</p> <ol> <li>Go to Settings \u2192 My Settings</li> <li>Scroll to Watch History section</li> <li>Click \"Clear all watch history\"</li> <li>Confirm the action</li> <li>All progress is reset</li> </ol> <p>Cannot Be Undone</p> <p>Clearing watch history is permanent. You cannot restore cleared progress.</p>"},{"location":"user-guide/watch-history/#privacy-data","title":"Privacy &amp; Data","text":""},{"location":"user-guide/watch-history/#whats-stored","title":"What's Stored","text":"<p>Watch history is stored in Peek's database:</p> <ul> <li>User ID - Associated with your account</li> <li>Scene ID - Which scene you watched</li> <li>Progress position - Timestamp (in seconds)</li> <li>Last watched date - When you last viewed it</li> <li>Watch count - Total number of views</li> </ul>"},{"location":"user-guide/watch-history/#whats-not-stored","title":"What's NOT Stored","text":"<ul> <li>No video file access logs - Peek doesn't log file system access</li> <li>No sharing with Stash - Watch history stays in Peek only</li> <li>No external tracking - History never leaves your Peek instance</li> </ul>"},{"location":"user-guide/watch-history/#privacy-controls","title":"Privacy Controls","text":"<ul> <li>Per-user isolation - You only see your own history</li> <li>Admin cannot see - Even admins can't view other users' watch history</li> <li>Clear anytime - You control your history data</li> </ul>"},{"location":"user-guide/watch-history/#watch-history-tips","title":"Watch History Tips","text":""},{"location":"user-guide/watch-history/#efficient-binge-watching","title":"Efficient Binge Watching","text":"<ol> <li>Start watching scenes you want to explore</li> <li>Switch between different scenes freely</li> <li>Return to Continue Watching to resume any of them</li> <li>No need to finish in one sitting</li> </ol>"},{"location":"user-guide/watch-history/#organize-with-playlists","title":"Organize with Playlists","text":"<p>Combine watch history with playlists:</p> <ol> <li>Create a \"To Watch\" playlist</li> <li>Add scenes you plan to watch later</li> <li>Watch them at your own pace</li> <li>Progress tracked automatically</li> <li>Resume from Continue Watching or the playlist</li> </ol>"},{"location":"user-guide/watch-history/#track-rewatches","title":"Track Rewatches","text":"<p>Want to rewatch a favorite scene?</p> <ol> <li>Click Play on an already-watched scene</li> <li>Choose \"Start from beginning\" when prompted</li> <li>Watch count increments</li> <li>New progress tracked</li> </ol>"},{"location":"user-guide/watch-history/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/watch-history/#resume-not-working","title":"Resume not working","text":"<p>Solution: - Make sure you're logged in (watch history is per-user) - Check that you watched for at least 10 seconds (minimum tracking threshold) - Verify you're using the same user account - Try refreshing the page</p>"},{"location":"user-guide/watch-history/#progress-bar-not-showing","title":"Progress bar not showing","text":"<p>Solution: - Progress may not appear if you only watched a few seconds - Progress bars require at least 5% completion to display - Try playing the video for longer - Clear browser cache if progress seems stuck</p>"},{"location":"user-guide/watch-history/#continue-watching-is-empty","title":"Continue Watching is empty","text":"<p>Possible reasons: - You haven't started watching any scenes yet - All your in-progress scenes are completed - You cleared your watch history - You're using a different user account</p>"},{"location":"user-guide/watch-history/#progress-resets-unexpectedly","title":"Progress resets unexpectedly","text":"<p>Solution: - Check if someone else cleared watch history (admin action) - Verify you're logged in (anonymous users don't save history) - Check browser console for errors (F12 \u2192 Console) - Report as a bug if it persists</p>"},{"location":"user-guide/watch-history/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>While watching a video:</p> Key Action <code>\u2190</code> Seek backward 5s <code>\u2192</code> Seek forward 5s <code>J</code> Seek backward 10s <code>L</code> Seek forward 10s <code>Space</code> Play/Pause <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>See the Keyboard Navigation Guide for complete shortcuts.</p>"},{"location":"user-guide/watch-history/#next-steps","title":"Next Steps","text":"<ul> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Organize scenes into custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"}]}