{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Peek Stash Browser","text":"<p>A modern web application for browsing and streaming your Stash media library with adaptive video streaming, playlists, and watch history tracking.</p> <ul> <li> Quick Start</li> </ul> <p>Get up and running in minutes with Docker or unRAID</p> <p> Installation</p> <ul> <li> Configuration</li> </ul> <p>Set up Peek to connect with your Stash server</p> <p> Setup Guide</p> <ul> <li> Troubleshooting</li> </ul> <p>Common issues and solutions</p> <p> Get Help</p>"},{"location":"#what-is-peek","title":"What is Peek?","text":"<p>Peek is a web-based browser for your Stash library, offering a sleek modern interface optimized for video streaming and playback.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Video Streaming - Proxied through Stash with quality selection (Direct, 1080p, 720p, 480p, 360p)</li> <li>Watch History Tracking - Automatic progress tracking and resume playback (Learn more)</li> <li>Playlist Management - Create, organize, and play custom playlists (Learn more)</li> <li>Modern Interface - Responsive React UI with theme support</li> <li>Full Keyboard Navigation - Complete TV remote and keyboard control support (Learn more)</li> <li>Mobile Ready - Optimized for all devices</li> <li>Scalable Library - SQLite-based storage supports 100k+ scenes</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"DockerunRAID <pre><code>docker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/stash/media:/app/media:ro \\\n  -v /path/to/peek/data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Open Community Applications</li> <li>Search for \"Peek Stash Browser\"</li> <li>Click Install and configure</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"#first-login","title":"First Login","text":"<p>On first access, you'll be guided through a setup wizard:</p> <ol> <li>Welcome - Introduction to Peek</li> <li>Create Admin - Set your admin username and password</li> <li>Connect to Stash - Enter your Stash URL and API key</li> <li>Complete - Setup finished!</li> </ol>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Stash server with GraphQL API enabled</li> <li>Docker (or unRAID)</li> <li>Network access between Peek and Stash</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Peek uses a single-container architecture:</p> <ul> <li>Frontend: React 19 app served by nginx</li> <li>Backend: Node.js/Express API server (proxied through nginx)</li> <li>Database: SQLite (embedded, no separate container)</li> <li>Streaming: Proxied through Stash (no local transcoding)</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: GitHub Issues</li> <li>Stash Community: Discord - #third-party-integrations channel</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Built with Stash, React, Express, FFmpeg, and other amazing open source projects.</p>"},{"location":"design/cache-scalability-brainstorm/","title":"Cache Scalability Brainstorm","text":"<p>Issues: #135, #160 Branch: <code>feature/cache-scalability-investigation</code> Date: 2025-12-08</p>"},{"location":"design/cache-scalability-brainstorm/#problem-statement","title":"Problem Statement","text":"<p>Peek's cache initialization fails on large Stash libraries: - Issue #135: 24k scenes - GraphQL 422 error on groups fetch with <code>per_page: -1</code> - Issue #160: 104k scenes - Node.js <code>ERR_STRING_TOO_LONG</code> (~512MB string limit exceeded)</p> <p>Both issues stem from the same root cause: unbounded GraphQL queries that don't scale.</p>"},{"location":"design/cache-scalability-brainstorm/#current-architecture","title":"Current Architecture","text":""},{"location":"design/cache-scalability-brainstorm/#data-flow","title":"Data Flow","text":"<pre><code>Stash Server (source of truth)\n    \u2502\n    \u25bc per_page: -1 (fetch ALL)\nStashCacheManager (in-memory Maps)\n    \u2502\n    \u251c\u2500\u2500\u25ba FilteredEntityCacheService (per-user filtered views)\n    \u2502\n    \u2514\u2500\u2500\u25ba 18+ files (controllers, services, middleware)\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#why-the-cache-exists","title":"Why the Cache Exists","text":"<ol> <li>Performance: Avoid repeated GraphQL queries for browsing/filtering</li> <li>URL Transformation: Rewrite Stash URLs to Peek proxy URLs (hide API keys)</li> <li>User Restrictions: Cascade filtering (hidden performers \u2192 hidden scenes)</li> <li>Aggregations: \"Most watched performer\", \"Top tags by play count\"</li> <li>Multi-user Support: Different users see different filtered content</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#current-memory-estimates","title":"Current Memory Estimates","text":"<ul> <li>~3KB per scene (with nested performers, tags, studio, files, paths)</li> <li>~1KB per performer/tag/studio</li> <li>100k scenes \u2248 300MB just for scenes</li> <li>Total with galleries, groups, etc. \u2248 400-500MB for large libraries</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#the-scaling-wall","title":"The Scaling Wall","text":"Scenes Approximate JSON Size Status 10,000 ~30MB Works fine 25,000 ~75MB Works, slow startup 50,000 ~150MB Edge case, may fail 100,000 ~300MB Hits string limit, fails"},{"location":"design/cache-scalability-brainstorm/#questions-for-discussion","title":"Questions for Discussion","text":""},{"location":"design/cache-scalability-brainstorm/#q1-what-filtering-patterns-does-peek-actually-need","title":"Q1: What filtering patterns does Peek actually need?","text":"<p>Current usage patterns I observed: - Carousel: Random scenes, filtered by user restrictions - Browse: Paginated lists with sorting - Search: Text search across titles/performers - Stats: Aggregations like \"top performers by watch time\"</p> <p>Question: Are there filtering patterns that require all data in memory? Or could most be satisfied with paginated queries to Stash?</p>"},{"location":"design/cache-scalability-brainstorm/#q2-whats-the-acceptable-trade-off-between-memory-and-features","title":"Q2: What's the acceptable trade-off between memory and features?","text":"<p>Options range from: - Current: Everything in memory (fast, feature-rich, doesn't scale) - Hybrid: Metadata in memory, paginated queries for large result sets - Pass-through: Cache only IDs, query Stash for everything (slow, scales infinitely)</p> <p>Question: Which features would you sacrifice for scalability? Or is there a budget for more complex caching?</p>"},{"location":"design/cache-scalability-brainstorm/#q3-should-peek-own-its-own-entity-database","title":"Q3: Should Peek own its own entity database?","text":"<p>Currently Peek stores: - User data (watch history, ratings, favorites) - Path mappings, settings</p> <p>It does NOT store Stash entities (scenes, performers, etc.) - only caches them.</p> <p>Question: Would you consider syncing Stash entities to SQLite? This enables: - Pagination at the database level - SQL filtering/sorting - Survives restarts without re-fetching - Incremental updates via Stash webhooks</p> <p>Trade-off: Adds complexity, data duplication, sync challenges</p>"},{"location":"design/cache-scalability-brainstorm/#q4-whats-the-deployment-model-priority","title":"Q4: What's the deployment model priority?","text":"<p>Current: Docker-only (FFmpeg dependency)</p> <p>Future goal mentioned: Native binaries for Windows/Unix</p> <p>Question: Does the caching solution need to support both? SQLite works everywhere. Redis would complicate native deployment.</p>"},{"location":"design/cache-scalability-brainstorm/#solution-space","title":"Solution Space","text":""},{"location":"design/cache-scalability-brainstorm/#approach-a-paginated-fetching-minimal-change","title":"Approach A: Paginated Fetching (Minimal Change)","text":"<p>Idea: Keep current architecture, but fetch in pages to avoid string limit.</p> <pre><code>async function fetchAllScenes(): Promise&lt;Scene[]&gt; {\n  const PAGE_SIZE = 5000;\n  const allScenes: Scene[] = [];\n  let page = 1;\n\n  while (true) {\n    const result = await stash.findScenesCompact({\n      filter: { page, per_page: PAGE_SIZE }\n    });\n    allScenes.push(...result.findScenes.scenes);\n    if (allScenes.length &gt;= result.findScenes.count) break;\n    page++;\n  }\n  return allScenes;\n}\n</code></pre> <p>Pros: - Minimal code changes - Fixes the immediate crash - No architecture change</p> <p>Cons: - Still loads everything into memory - Memory still grows linearly with library size - 104k scenes still needs ~300MB RAM for scenes alone</p> <p>Verdict: Quick fix, not a real solution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-b-sqlite-entity-cache-full-sync","title":"Approach B: SQLite Entity Cache (Full Sync)","text":"<p>Idea: Sync Stash entities to local SQLite database. Query database instead of in-memory Maps.</p> <pre><code>Stash Server\n    \u2502\n    \u25bc Paginated sync\nSQLite Database (scenes, performers, studios, tags, galleries, groups)\n    \u2502\n    \u25bc Prisma queries\nControllers/Services\n</code></pre> <p>Schema additions: <pre><code>model CachedScene {\n  id          String @id\n  title       String?\n  date        String?\n  studioId    String?\n  rating100   Int?\n  duration    Int?\n  // ... minimal fields for filtering/sorting\n  rawData     String // JSON blob for full data\n  lastSynced  DateTime\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n}\n</code></pre></p> <p>Sync Strategy: - Initial: Paginated full sync (5000 at a time) - Refresh: Incremental via <code>updated_at &gt; lastSync</code> filter - Stash webhooks: Real-time updates (optional enhancement)</p> <p>Query Strategy: - Browse: SQL pagination with sorting - Filter: SQL WHERE clauses - Full data: Fetch <code>rawData</code> JSON and deserialize</p> <p>Pros: - Unlimited scalability (SQLite handles millions of rows) - Fast SQL queries with indexes - Survives restarts - Incremental sync possible - Works for native binaries</p> <p>Cons: - Significant refactor - Data duplication (Stash + Peek) - Sync complexity (what if entities deleted in Stash?) - Need to handle schema evolution</p>"},{"location":"design/cache-scalability-brainstorm/#approach-c-hybrid-cache-metadata-in-memory-full-data-lazy-loaded","title":"Approach C: Hybrid Cache (Metadata in Memory, Full Data Lazy-Loaded)","text":"<p>Idea: Store minimal metadata in memory, fetch full data on-demand.</p> <pre><code>interface SceneMetadata {\n  id: string;\n  title: string;\n  date: string;\n  studioId: string;\n  performerIds: string[];\n  tagIds: string[];\n  rating100: number;\n  // No nested objects, no files, no paths\n}\n\n// In-memory: ~500 bytes per scene instead of ~3KB\nconst sceneMetadata = new Map&lt;string, SceneMetadata&gt;();\n\n// On-demand fetch for full data\nasync function getFullScene(id: string): Promise&lt;NormalizedScene&gt; {\n  const meta = sceneMetadata.get(id);\n  if (!meta) return null;\n\n  // Fetch full data from Stash (or a local cache)\n  const full = await stash.findScenes({ ids: [id] });\n  return transformScene(full.findScenes.scenes[0]);\n}\n</code></pre> <p>Pros: - 80% memory reduction - Most filtering works on metadata - Preserves current architecture patterns</p> <p>Cons: - Increases latency for full scene views - Complex to implement correctly - Still linear memory growth (just slower)</p>"},{"location":"design/cache-scalability-brainstorm/#approach-d-pass-through-to-stash-no-cache","title":"Approach D: Pass-through to Stash (No Cache)","text":"<p>Idea: Remove the cache entirely. Proxy all queries to Stash.</p> <p>Pros: - Simplest architecture - No sync issues - Stash handles all scalability</p> <p>Cons: - Loses user restrictions (can't filter without seeing all data) - Every request hits Stash (slower) - Can't aggregate stats across scenes - URL transformation happens on every request</p> <p>Verdict: Not viable - loses too many features</p>"},{"location":"design/cache-scalability-brainstorm/#approach-e-external-cache-redismemcached","title":"Approach E: External Cache (Redis/Memcached)","text":"<p>Idea: Use Redis for distributed caching.</p> <p>Pros: - Battle-tested scalability - Shared across instances - LRU eviction built-in</p> <p>Cons: - New dependency (complicates native deployment) - Overkill for single-user instances - Still need to handle large data serialization</p> <p>Verdict: Only makes sense for multi-node deployment, not the typical use case</p>"},{"location":"design/cache-scalability-brainstorm/#what-large-enterprise-apps-do","title":"What Large Enterprise Apps Do","text":""},{"location":"design/cache-scalability-brainstorm/#pattern-1-database-as-cache","title":"Pattern 1: Database as Cache","text":"<ul> <li>Example: Elasticsearch for search, PostgreSQL for source of truth</li> <li>Relevance: SQLite could serve as Peek's \"search index\"</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-2-materialized-views","title":"Pattern 2: Materialized Views","text":"<ul> <li>Example: Pre-computed aggregations stored separately</li> <li>Relevance: Peek's FilteredEntityCacheService is already doing this per-user</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-3-incremental-sync","title":"Pattern 3: Incremental Sync","text":"<ul> <li>Example: CDC (Change Data Capture), webhooks</li> <li>Relevance: Stash has a GraphQL subscription API for real-time updates</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-4-tiered-caching","title":"Pattern 4: Tiered Caching","text":"<ul> <li>Example: L1 (in-memory, small, hot), L2 (disk, large, warm), L3 (remote, cold)</li> <li>Relevance: Memory \u2192 SQLite \u2192 Stash API</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#pattern-5-pagination-cursor-based-navigation","title":"Pattern 5: Pagination + Cursor-based Navigation","text":"<ul> <li>Example: GraphQL connections with <code>after</code> cursor</li> <li>Relevance: Stash supports this, Peek could adopt it</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#recommendation-questions","title":"Recommendation Questions","text":"<p>Before I recommend a specific approach, I need clarity on:</p> <ol> <li>Scope of refactor acceptable?</li> <li> <p>Quick fix (paginated fetch) vs. medium (hybrid) vs. large (SQLite sync)</p> </li> <li> <p>Feature preservation priority?</p> </li> <li>User restrictions cascade filtering</li> <li>Cross-scene aggregations (stats)</li> <li> <p>Fast browsing/search</p> </li> <li> <p>Stash API capabilities?</p> </li> <li>Does Stash support filtering by <code>updated_at</code>? (for incremental sync)</li> <li> <p>Does Stash have webhook support? (for real-time sync)</p> </li> <li> <p>Testing strategy?</p> </li> <li>Do we have access to a 100k+ scene library for testing?</li> <li>Can we simulate with synthetic data?</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#decision-sqlite-entity-cache","title":"Decision: SQLite Entity Cache","text":"<p>After discussion, we've decided on Approach B: SQLite Entity Cache for the following reasons:</p>"},{"location":"design/cache-scalability-brainstorm/#why-sqlite","title":"Why SQLite?","text":"<ol> <li> <p>The pagination + filtering problem: If we paginate from Stash then apply user restrictions, we get fewer results than requested (e.g., request 50, restrictions remove 10, return 40). This breaks pagination. We need the full dataset locally.</p> </li> <li> <p>Memory doesn't scale: Current in-memory approach fails at ~50-100k scenes due to Node.js string limits and memory pressure.</p> </li> <li> <p>Minimal duplication: ~50-100MB for 100k scenes (vs 500MB+ in Stash). We store only what Peek needs.</p> </li> <li> <p>Offline resilience: Peek can serve browse requests even if Stash is temporarily unavailable.</p> </li> <li> <p>Native binary compatible: SQLite works everywhere - no Redis/external dependencies.</p> </li> </ol>"},{"location":"design/cache-scalability-brainstorm/#sync-strategy","title":"Sync Strategy","text":"<p>Sync Triggers: | Trigger | Type | When | |---------|------|------| | Startup | Full/Incremental | Peek server starts (full if first run) | | Scan complete | Incremental | Stash finishes scan (via WebSocket subscription) | | Polling | Incremental | Every N minutes (configurable, default 60, range 5-120) | | Manual | Full/Incremental | Admin triggers via UI | | Plugin webhook | Incremental | Optional - if Stash plugin installed |</p> <p>Sync Types: - Incremental: Query entities where <code>updated_at &gt; lastSyncTime</code>, upsert changes - Full: Paginated fetch of everything, used on first run or recovery</p> <p>Optional Real-Time Enhancement: A simple Stash plugin can POST to Peek on entity changes, enabling near real-time sync. This is optional - polling works without it, plugin makes it faster.</p>"},{"location":"design/cache-scalability-brainstorm/#entity-handling","title":"Entity Handling","text":"<ul> <li>Soft delete: Mark entities as deleted rather than hard-deleting</li> <li>Preserves Peek-specific data (watch history, ratings) if entity is re-added</li> <li>Allows user to see \"X scenes were removed from Stash\"</li> <li>Orphan detection: Periodic check for entities in Peek but not in Stash</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#key-features-to-preserve","title":"Key Features to Preserve","text":"<ul> <li>\u2705 User restrictions (cascade filtering)</li> <li>\u2705 Stats/aggregations (computed from local DB)</li> <li>\u2705 Fast browsing (SQL pagination with indexes)</li> <li>\u26a0\ufe0f Offline resilience (partial - can browse cached data)</li> </ul>"},{"location":"design/cache-scalability-brainstorm/#next-steps","title":"Next Steps","text":"<ol> <li>Design the SQLite schema for cached entities</li> <li>Create migration strategy from in-memory to SQLite</li> <li>Implement incremental sync logic</li> <li>Add scanCompleteSubscribe WebSocket listener</li> <li>Update all 18+ dependent files to query SQLite instead of Maps</li> <li>Test with synthetic 100k+ scene dataset</li> </ol>"},{"location":"design/cache-scalability-brainstorm/#appendix-memory-calculation-details","title":"Appendix: Memory Calculation Details","text":""},{"location":"design/cache-scalability-brainstorm/#current-scene-object-size","title":"Current Scene Object Size","text":"<pre><code>{\n  id: \"12345\",                    // 5 bytes\n  title: \"Example Scene Title\",   // ~30 bytes\n  date: \"2024-01-15\",            // 10 bytes\n  // ... base fields ~500 bytes\n\n  performers: [                   // ~200 bytes each\n    { id, name, image_path, gender, tags: [...] }\n  ],\n  tags: [                         // ~50 bytes each\n    { id, name, image_path, favorite }\n  ],\n  studio: { id, name, tags: [...] },  // ~150 bytes\n  files: [{                       // ~300 bytes each\n    path, basename, duration, video_codec, audio_codec, ...\n  }],\n  paths: {                        // ~400 bytes\n    preview, screenshot, sprite, vtt, webp, caption\n  },\n  sceneStreams: [...]            // ~150 bytes\n}\n\n// Total: ~2-4KB per scene depending on performers/tags\n</code></pre>"},{"location":"design/cache-scalability-brainstorm/#memory-projection-table","title":"Memory Projection Table","text":"Scenes Minimal (500B) Current (~3KB) With Galleries 10,000 5 MB 30 MB 40 MB 50,000 25 MB 150 MB 200 MB 100,000 50 MB 300 MB 400 MB 250,000 125 MB 750 MB 1 GB"},{"location":"design/cache-scalability-plan/","title":"SQLite Entity Cache Implementation Plan","text":"<p>Issue: #135, #160 - Cache fails on large libraries (24k-104k scenes) Design Docs: cache-scalability-brainstorm.md, sqlite-cache-schema.md Branch: <code>feature/cache-scalability-investigation</code></p>"},{"location":"design/cache-scalability-plan/#overview","title":"Overview","text":"<p>Replace the in-memory <code>StashCacheManager</code> with a SQLite-backed entity cache that: - Syncs Stash entities to local database using paginated fetches - Queries via Prisma instead of in-memory Maps - Supports incremental sync via <code>updated_at</code> timestamps - Scales to 100k+ scenes without memory issues</p>"},{"location":"design/cache-scalability-plan/#phase-1-database-schema","title":"Phase 1: Database Schema","text":""},{"location":"design/cache-scalability-plan/#task-11-add-cached-entity-tables-to-prisma-schema","title":"Task 1.1: Add Cached Entity Tables to Prisma Schema","text":"<p>File: <code>server/prisma/schema.prisma</code></p> <p>Add the following models after existing models:</p> <pre><code>// ============================================================================\n// CACHED STASH ENTITIES\n// These tables store synced data from Stash for scalable querying\n// ============================================================================\n\nmodel CachedScene {\n  id              String    @id                    // Stash scene ID\n  stashInstanceId String?                          // Which Stash server\n\n  // Indexed fields for filtering/sorting\n  title           String?\n  code            String?\n  date            String?                          // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                             // seconds (from file)\n  organized       Boolean   @default(false)\n\n  // Full entity data as JSON (performers, tags, files, paths, streams, etc.)\n  data            String                           // JSON blob\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?                        // Soft delete\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n\nmodel CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneTag[]\n  images          ImageTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGroup {\n  id              String    @id\n  stashInstanceId String?\n\n  name            String\n  date            String?\n  studioId        String?\n  rating100       Int?\n  duration        Int?\n  sceneCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedGallery {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  imageCount      Int       @default(0)\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes          SceneGallery[]\n  images          ImageGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\nmodel CachedImage {\n  id              String    @id\n  stashInstanceId String?\n\n  title           String?\n  date            String?\n  studioId        String?\n  rating100       Int?\n  oCounter        Int       @default(0)\n  organized       Boolean   @default(false)\n  width           Int?\n  height          Int?\n  fileSize        Int?\n\n  data            String\n\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  performers      ImagePerformer[]\n  tags            ImageTag[]\n  galleries       ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n\n// Junction tables for efficient many-to-many queries\n\nmodel ScenePerformer {\n  sceneId         String\n  performerId     String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])\n}\n\nmodel SceneTag {\n  sceneId         String\n  tagId           String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])\n}\n\nmodel SceneGroup {\n  sceneId         String\n  groupId         String\n  sceneIndex      Int?\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group           CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId         String\n  galleryId       String\n  scene           CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n\nmodel ImagePerformer {\n  imageId         String\n  performerId     String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId         String\n  tagId           String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId         String\n  galleryId       String\n  image           CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery         CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n\n// Sync state tracking per entity type\nmodel SyncState {\n  id                    Int       @id @default(autoincrement())\n  stashInstanceId       String?\n  entityType            String                     // 'scene', 'performer', etc.\n\n  lastFullSync          DateTime?\n  lastIncrementalSync   DateTime?\n  lastSyncCount         Int       @default(0)\n  lastSyncDurationMs    Int?\n  lastError             String?\n  totalEntities         Int       @default(0)\n\n  @@unique([stashInstanceId, entityType])\n}\n\n// Sync settings (admin configurable)\nmodel SyncSettings {\n  id                    Int       @id @default(1)  // Singleton\n  syncIntervalMinutes   Int       @default(60)     // Default 60 min (current behavior)\n  enableScanSubscription Boolean  @default(true)   // Subscribe to scanCompleteSubscribe\n  enablePluginWebhook   Boolean   @default(false)  // Accept webhook from Stash plugin\n\n  updatedAt             DateTime  @updatedAt\n}\n</code></pre> <p>Verification: Run <code>npx prisma validate</code> to ensure schema is valid.</p>"},{"location":"design/cache-scalability-plan/#task-12-create-prisma-migration","title":"Task 1.2: Create Prisma Migration","text":"<p>Commands: <pre><code>cd server\nnpx prisma migrate dev --name add_cached_entities\n</code></pre></p> <p>This creates the migration file and applies it to the development database.</p> <p>Verification: Check that <code>server/prisma/migrations/*_add_cached_entities/migration.sql</code> exists.</p>"},{"location":"design/cache-scalability-plan/#task-13-add-fts5-full-text-search-via-raw-sql-migration","title":"Task 1.3: Add FTS5 Full-Text Search via Raw SQL Migration","text":"<p>File: Create <code>server/prisma/migrations/YYYYMMDDHHMMSS_add_fts5_search/migration.sql</code> manually</p> <pre><code>-- Create FTS5 virtual tables for full-text search\n-- Note: These are created via raw SQL because Prisma doesn't support virtual tables\n\nCREATE VIRTUAL TABLE IF NOT EXISTS scene_fts USING fts5(\n  id UNINDEXED,\n  title,\n  details,\n  code\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS performer_fts USING fts5(\n  id UNINDEXED,\n  name,\n  aliases\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS studio_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\nCREATE VIRTUAL TABLE IF NOT EXISTS tag_fts USING fts5(\n  id UNINDEXED,\n  name\n);\n\n-- Triggers to keep FTS in sync with main tables\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\n  INSERT INTO scene_fts(id, title, details, code)\n  VALUES (new.id, new.title, json_extract(new.data, '$.details'), new.code);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  DELETE FROM scene_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_insert AFTER INSERT ON CachedPerformer BEGIN\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_update AFTER UPDATE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\n  INSERT INTO performer_fts(id, name, aliases)\n  VALUES (new.id, new.name, json_extract(new.data, '$.aliases'));\nEND;\n\nCREATE TRIGGER IF NOT EXISTS performer_fts_delete AFTER DELETE ON CachedPerformer BEGIN\n  DELETE FROM performer_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_insert AFTER INSERT ON CachedStudio BEGIN\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_update AFTER UPDATE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\n  INSERT INTO studio_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS studio_fts_delete AFTER DELETE ON CachedStudio BEGIN\n  DELETE FROM studio_fts WHERE id = old.id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_insert AFTER INSERT ON CachedTag BEGIN\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_update AFTER UPDATE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\n  INSERT INTO tag_fts(id, name) VALUES (new.id, new.name);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS tag_fts_delete AFTER DELETE ON CachedTag BEGIN\n  DELETE FROM tag_fts WHERE id = old.id;\nEND;\n</code></pre> <p>Verification: Run <code>npx prisma migrate deploy</code> and verify FTS tables exist in database.</p>"},{"location":"design/cache-scalability-plan/#phase-2-sync-service","title":"Phase 2: Sync Service","text":""},{"location":"design/cache-scalability-plan/#task-21-create-stashsyncservice","title":"Task 2.1: Create StashSyncService","text":"<p>File: <code>server/services/StashSyncService.ts</code></p> <p>This service handles all sync operations between Stash and the local SQLite cache.</p> <p>Key responsibilities: 1. Full sync: Paginated fetch of all entities (5000 per batch) 2. Incremental sync: Fetch only entities where <code>updated_at &gt; lastSyncTime</code> 3. Deletion detection: Mark entities as deleted if not in Stash response 4. Junction table management: Keep scene\u2194performer, scene\u2194tag, etc. in sync 5. Progress reporting: Emit events for UI progress display</p> <p>Implementation outline:</p> <pre><code>// server/services/StashSyncService.ts\n\nimport { PrismaClient } from '@prisma/client';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { transformScene, transformPerformer, /* etc */ } from '../utils/pathMapping.js';\nimport { logger } from '../utils/logger.js';\nimport { EventEmitter } from 'events';\n\ninterface SyncProgress {\n  entityType: string;\n  phase: 'fetching' | 'processing' | 'complete' | 'error';\n  current: number;\n  total: number;\n  message?: string;\n}\n\nclass StashSyncService extends EventEmitter {\n  private prisma: PrismaClient;\n  private syncInProgress = false;\n  private readonly PAGE_SIZE = 5000;\n\n  constructor(prisma: PrismaClient) {\n    super();\n    this.prisma = prisma;\n  }\n\n  /**\n   * Full sync - fetches all entities from Stash\n   * Used on first run or when incremental sync fails\n   */\n  async fullSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      throw new Error('Sync already in progress');\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      // Sync each entity type in order (dependencies first)\n      await this.syncStudios(stashInstanceId, true);\n      await this.syncTags(stashInstanceId, true);\n      await this.syncPerformers(stashInstanceId, true);\n      await this.syncGroups(stashInstanceId, true);\n      await this.syncGalleries(stashInstanceId, true);\n      await this.syncScenes(stashInstanceId, true);\n      await this.syncImages(stashInstanceId, true);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'full', Date.now() - startTime);\n\n      logger.info('Full sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Incremental sync - fetches only changed entities\n   */\n  async incrementalSync(stashInstanceId?: string): Promise&lt;void&gt; {\n    if (this.syncInProgress) {\n      logger.warn('Sync already in progress, skipping');\n      return;\n    }\n\n    this.syncInProgress = true;\n    const startTime = Date.now();\n\n    try {\n      const lastSync = await this.getLastSyncTime(stashInstanceId);\n\n      if (!lastSync) {\n        logger.info('No previous sync found, performing full sync');\n        await this.fullSync(stashInstanceId);\n        return;\n      }\n\n      // Sync each entity type (only changed)\n      await this.syncStudios(stashInstanceId, false, lastSync);\n      await this.syncTags(stashInstanceId, false, lastSync);\n      await this.syncPerformers(stashInstanceId, false, lastSync);\n      await this.syncGroups(stashInstanceId, false, lastSync);\n      await this.syncGalleries(stashInstanceId, false, lastSync);\n      await this.syncScenes(stashInstanceId, false, lastSync);\n      await this.syncImages(stashInstanceId, false, lastSync);\n\n      // Update sync state\n      await this.updateSyncState(stashInstanceId, 'incremental', Date.now() - startTime);\n\n      logger.info('Incremental sync completed', { durationMs: Date.now() - startTime });\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Sync scenes with pagination\n   */\n  private async syncScenes(\n    stashInstanceId: string | undefined,\n    isFullSync: boolean,\n    lastSyncTime?: Date\n  ): Promise&lt;void&gt; {\n    const stash = stashInstanceManager.getDefault();\n    let page = 1;\n    let totalSynced = 0;\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'fetching',\n      current: 0,\n      total: 0,\n    } as SyncProgress);\n\n    while (true) {\n      // Build filter for incremental sync\n      const filter = lastSyncTime ? {\n        updated_at: { modifier: 'GREATER_THAN', value: lastSyncTime.toISOString() }\n      } : undefined;\n\n      const result = await stash.findScenesCompact({\n        filter: { page, per_page: this.PAGE_SIZE },\n        scene_filter: filter,\n      });\n\n      const scenes = result.findScenes.scenes;\n      const total = result.findScenes.count;\n\n      if (scenes.length === 0) break;\n\n      // Process batch\n      await this.processScenessBatch(scenes, stashInstanceId);\n\n      totalSynced += scenes.length;\n      this.emit('progress', {\n        entityType: 'scene',\n        phase: 'processing',\n        current: totalSynced,\n        total,\n      } as SyncProgress);\n\n      if (totalSynced &gt;= total) break;\n      page++;\n    }\n\n    this.emit('progress', {\n      entityType: 'scene',\n      phase: 'complete',\n      current: totalSynced,\n      total: totalSynced,\n    } as SyncProgress);\n  }\n\n  /**\n   * Process a batch of scenes - upsert to database\n   */\n  private async processScenessBatch(scenes: any[], stashInstanceId?: string): Promise&lt;void&gt; {\n    for (const scene of scenes) {\n      const transformed = transformScene(scene);\n      const duration = scene.files?.[0]?.duration || null;\n\n      // Upsert scene\n      await this.prisma.cachedScene.upsert({\n        where: { id: scene.id },\n        update: {\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n          syncedAt: new Date(),\n          deletedAt: null, // Clear soft delete if re-synced\n        },\n        create: {\n          id: scene.id,\n          stashInstanceId,\n          title: scene.title,\n          code: scene.code,\n          date: scene.date,\n          studioId: scene.studio?.id || null,\n          rating100: scene.rating100,\n          duration,\n          organized: scene.organized || false,\n          data: JSON.stringify(transformed),\n          stashCreatedAt: scene.created_at ? new Date(scene.created_at) : null,\n          stashUpdatedAt: scene.updated_at ? new Date(scene.updated_at) : null,\n        },\n      });\n\n      // Sync junction tables\n      await this.syncScenePerformers(scene.id, scene.performers || []);\n      await this.syncSceneTags(scene.id, scene.tags || []);\n      await this.syncSceneGroups(scene.id, scene.groups || []);\n      await this.syncSceneGalleries(scene.id, scene.galleries || []);\n    }\n  }\n\n  // Similar methods for other entity types...\n  // syncPerformers, syncStudios, syncTags, syncGroups, syncGalleries, syncImages\n\n  /**\n   * Sync scene\u2194performer junction table\n   */\n  private async syncScenePerformers(sceneId: string, performers: any[]): Promise&lt;void&gt; {\n    // Delete existing relationships\n    await this.prisma.scenePerformer.deleteMany({ where: { sceneId } });\n\n    // Insert new relationships\n    if (performers.length &gt; 0) {\n      await this.prisma.scenePerformer.createMany({\n        data: performers.map(p =&gt; ({ sceneId, performerId: p.id })),\n        skipDuplicates: true,\n      });\n    }\n  }\n\n  // Helper methods...\n}\n\nexport const stashSyncService = new StashSyncService(prisma);\n</code></pre> <p>Verification: Write unit tests for sync logic. Test with mock data.</p>"},{"location":"design/cache-scalability-plan/#task-22-create-sync-scheduler","title":"Task 2.2: Create Sync Scheduler","text":"<p>File: <code>server/services/SyncScheduler.ts</code></p> <p>Handles automatic sync triggers: - Startup sync - Polling interval (configurable, default 60 min) - Stash scan completion (WebSocket subscription) - Manual trigger</p> <p>Implementation outline:</p> <pre><code>// server/services/SyncScheduler.ts\n\nimport { stashSyncService } from './StashSyncService.js';\nimport { stashInstanceManager } from './StashInstanceManager.js';\nimport { logger } from '../utils/logger.js';\nimport prisma from '../prisma/singleton.js';\n\nclass SyncScheduler {\n  private intervalId: NodeJS.Timeout | null = null;\n  private wsConnection: WebSocket | null = null;\n\n  async start(): Promise&lt;void&gt; {\n    // Load settings\n    const settings = await prisma.syncSettings.findFirst() || {\n      syncIntervalMinutes: 60,\n      enableScanSubscription: true,\n    };\n\n    // Start polling interval\n    this.startPollingInterval(settings.syncIntervalMinutes);\n\n    // Start WebSocket subscription for scan events\n    if (settings.enableScanSubscription) {\n      this.startScanSubscription();\n    }\n\n    // Perform initial sync\n    await this.performStartupSync();\n  }\n\n  private startPollingInterval(intervalMinutes: number): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n\n    const intervalMs = intervalMinutes * 60 * 1000;\n\n    this.intervalId = setInterval(async () =&gt; {\n      logger.info('Scheduled sync triggered');\n      try {\n        await stashSyncService.incrementalSync();\n      } catch (error) {\n        logger.error('Scheduled sync failed', { error });\n      }\n    }, intervalMs);\n\n    logger.info(`Sync scheduler started (interval: ${intervalMinutes} min)`);\n  }\n\n  private startScanSubscription(): void {\n    // Connect to Stash GraphQL WebSocket for scanCompleteSubscribe\n    // Implementation depends on graphql-ws or similar library\n    // When scan completes, trigger incrementalSync()\n  }\n\n  private async performStartupSync(): Promise&lt;void&gt; {\n    const syncState = await prisma.syncState.findFirst({\n      where: { entityType: 'scene' },\n    });\n\n    if (!syncState?.lastFullSync) {\n      logger.info('No previous sync found, performing full sync on startup');\n      await stashSyncService.fullSync();\n    } else {\n      logger.info('Performing incremental sync on startup');\n      await stashSyncService.incrementalSync();\n    }\n  }\n\n  stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    if (this.wsConnection) {\n      this.wsConnection.close();\n      this.wsConnection = null;\n    }\n  }\n}\n\nexport const syncScheduler = new SyncScheduler();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-23-add-webhook-endpoint-for-optional-stash-plugin","title":"Task 2.3: Add Webhook Endpoint for Optional Stash Plugin","text":"<p>File: <code>server/routes/sync.ts</code></p> <pre><code>// POST /api/sync/notify - Webhook from Stash plugin\nrouter.post('/notify', requireAdmin, async (req, res) =&gt; {\n  const { entity, id, action } = req.body;\n\n  // Validate request\n  if (!entity || !id || !action) {\n    return res.status(400).json({ error: 'Missing required fields' });\n  }\n\n  // Queue single entity sync\n  await stashSyncService.syncSingleEntity(entity, id, action);\n\n  res.json({ ok: true });\n});\n\n// POST /api/sync/trigger - Manual sync trigger\nrouter.post('/trigger', requireAdmin, async (req, res) =&gt; {\n  const { type = 'incremental' } = req.body;\n\n  if (type === 'full') {\n    await stashSyncService.fullSync();\n  } else {\n    await stashSyncService.incrementalSync();\n  }\n\n  res.json({ ok: true });\n});\n\n// GET /api/sync/status - Get sync status\nrouter.get('/status', requireAuth, async (req, res) =&gt; {\n  const states = await prisma.syncState.findMany();\n  const settings = await prisma.syncSettings.findFirst();\n\n  res.json({ states, settings });\n});\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-3-query-service","title":"Phase 3: Query Service","text":""},{"location":"design/cache-scalability-plan/#task-31-create-cachedentityqueryservice","title":"Task 3.1: Create CachedEntityQueryService","text":"<p>File: <code>server/services/CachedEntityQueryService.ts</code></p> <p>This service replaces direct <code>stashCacheManager</code> calls with Prisma queries.</p> <p>Key methods:</p> <pre><code>class CachedEntityQueryService {\n  /**\n   * Get all scenes with filtering, sorting, pagination\n   */\n  async getScenes(options: {\n    userId: number;\n    filters?: SceneFilters;\n    sort?: string;\n    direction?: 'asc' | 'desc';\n    limit?: number;\n    offset?: number;\n  }): Promise&lt;{ scenes: NormalizedScene[]; total: number }&gt; {\n    // Build Prisma where clause from filters\n    // Apply user restrictions (hidden entities, content restrictions)\n    // Execute query with pagination\n    // Parse JSON data field\n    // Merge with user ratings/watch history\n    // Return results\n  }\n\n  /**\n   * Get single scene by ID\n   */\n  async getScene(id: string, userId: number): Promise&lt;NormalizedScene | null&gt; {\n    const cached = await prisma.cachedScene.findFirst({\n      where: { id, deletedAt: null },\n    });\n\n    if (!cached) return null;\n\n    const data = JSON.parse(cached.data);\n    // Merge with user data\n    return this.mergeSceneWithUserData(data, userId);\n  }\n\n  /**\n   * Full-text search across scenes\n   */\n  async searchScenes(query: string, userId: number, limit = 50): Promise&lt;NormalizedScene[]&gt; {\n    // Use FTS5 for search\n    const results = await prisma.$queryRaw`\n      SELECT s.id, s.data\n      FROM scene_fts\n      INNER JOIN CachedScene s ON scene_fts.id = s.id\n      WHERE scene_fts MATCH ${query}\n        AND s.deletedAt IS NULL\n      ORDER BY rank\n      LIMIT ${limit}\n    `;\n\n    // Filter by user restrictions\n    // Merge with user data\n    return results;\n  }\n\n  // Similar methods for performers, studios, tags, groups, galleries, images\n}\n\nexport const cachedEntityQueryService = new CachedEntityQueryService();\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-32-create-query-builders-for-complex-filters","title":"Task 3.2: Create Query Builders for Complex Filters","text":"<p>File: <code>server/utils/queryBuilders.ts</code></p> <p>Helper functions to build Prisma <code>where</code> clauses from UI filter objects:</p> <pre><code>/**\n * Build Prisma where clause for scene filters\n */\nexport function buildSceneWhereClause(\n  filters: PeekSceneFilter,\n  userId: number,\n  hiddenEntityIds: { scenes: string[]; performers: string[]; studios: string[]; tags: string[] }\n): Prisma.CachedSceneWhereInput {\n  const where: Prisma.CachedSceneWhereInput = {\n    deletedAt: null,\n    id: { notIn: hiddenEntityIds.scenes },\n  };\n\n  // Studio filter\n  if (filters.studioIds?.length) {\n    where.studioId = { in: filters.studioIds };\n  }\n\n  // Hidden studios\n  if (hiddenEntityIds.studios.length) {\n    where.studioId = {\n      ...where.studioId,\n      notIn: hiddenEntityIds.studios,\n    };\n  }\n\n  // Date range\n  if (filters.dateFrom || filters.dateTo) {\n    where.date = {};\n    if (filters.dateFrom) where.date.gte = filters.dateFrom;\n    if (filters.dateTo) where.date.lte = filters.dateTo;\n  }\n\n  // Rating filter\n  if (filters.minRating !== undefined) {\n    where.rating100 = { gte: filters.minRating };\n  }\n\n  // Performer filter (requires subquery)\n  if (filters.performerIds?.length) {\n    where.performers = {\n      some: { performerId: { in: filters.performerIds } },\n    };\n  }\n\n  // Tag filter\n  if (filters.tagIds?.length) {\n    where.tags = {\n      some: { tagId: { in: filters.tagIds } },\n    };\n  }\n\n  // Exclude hidden performers (cascade)\n  if (hiddenEntityIds.performers.length) {\n    where.performers = {\n      ...where.performers,\n      none: { performerId: { in: hiddenEntityIds.performers } },\n    };\n  }\n\n  return where;\n}\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-4-controller-migration","title":"Phase 4: Controller Migration","text":""},{"location":"design/cache-scalability-plan/#task-41-update-scene-controllers","title":"Task 4.1: Update Scene Controllers","text":"<p>Files to modify: - <code>server/controllers/library/scenes.ts</code> - <code>server/controllers/carousel.ts</code></p> <p>Replace <code>stashCacheManager.getAllScenes()</code> with <code>cachedEntityQueryService.getScenes()</code>.</p> <p>Before: <pre><code>const allScenes = stashCacheManager.getAllScenes();\nlet filtered = allScenes.filter(/* ... */);\nfiltered.sort(/* ... */);\nconst paginated = filtered.slice(offset, offset + limit);\n</code></pre></p> <p>After: <pre><code>const { scenes, total } = await cachedEntityQueryService.getScenes({\n  userId,\n  filters,\n  sort,\n  direction,\n  limit,\n  offset,\n});\n</code></pre></p>"},{"location":"design/cache-scalability-plan/#task-42-update-performer-controllers","title":"Task 4.2: Update Performer Controllers","text":"<p>File: <code>server/controllers/library/performers.ts</code></p> <p>Same pattern as scenes. Replace in-memory filtering with database queries.</p>"},{"location":"design/cache-scalability-plan/#task-43-update-studio-controllers","title":"Task 4.3: Update Studio Controllers","text":"<p>File: <code>server/controllers/library/studios.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-44-update-tag-controllers","title":"Task 4.4: Update Tag Controllers","text":"<p>File: <code>server/controllers/library/tags.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-45-update-group-controllers","title":"Task 4.5: Update Group Controllers","text":"<p>File: <code>server/controllers/library/groups.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-46-update-gallery-controllers","title":"Task 4.6: Update Gallery Controllers","text":"<p>File: <code>server/controllers/library/galleries.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-47-update-image-controllers","title":"Task 4.7: Update Image Controllers","text":"<p>File: <code>server/controllers/library/images.ts</code></p>"},{"location":"design/cache-scalability-plan/#task-48-update-stats-controller","title":"Task 4.8: Update Stats Controller","text":"<p>File: <code>server/controllers/stats.ts</code></p> <p>Aggregations like \"top performers\" use SQL GROUP BY instead of in-memory loops.</p>"},{"location":"design/cache-scalability-plan/#task-49-update-user-services","title":"Task 4.9: Update User Services","text":"<p>Files: - <code>server/services/UserHiddenEntityService.ts</code> - <code>server/services/UserStatsService.ts</code></p> <p>These now query SQLite instead of in-memory cache.</p>"},{"location":"design/cache-scalability-plan/#task-410-update-auth-middleware","title":"Task 4.10: Update Auth Middleware","text":"<p>File: <code>server/middleware/auth.ts</code></p> <p>Replace <code>requireCacheReady()</code> with sync status check:</p> <pre><code>export const requireSyncComplete = async (req, res, next) =&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: { entityType: 'scene' },\n  });\n\n  if (!syncState?.lastFullSync &amp;&amp; !syncState?.lastIncrementalSync) {\n    return res.status(503).json({\n      error: 'Initial sync in progress',\n      message: 'Please wait for sync to complete',\n    });\n  }\n\n  next();\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#phase-5-cleanup","title":"Phase 5: Cleanup","text":""},{"location":"design/cache-scalability-plan/#task-51-remove-stashcachemanager","title":"Task 5.1: Remove StashCacheManager","text":"<p>Delete file: <code>server/services/StashCacheManager.ts</code></p> <p>Remove imports from all 17 files that currently import it.</p>"},{"location":"design/cache-scalability-plan/#task-52-remove-filteredentitycacheservice","title":"Task 5.2: Remove FilteredEntityCacheService","text":"<p>Delete file: <code>server/services/FilteredEntityCacheService.ts</code></p> <p>SQLite queries with user filtering replace this entirely.</p>"},{"location":"design/cache-scalability-plan/#task-53-update-cache-initializer","title":"Task 5.3: Update Cache Initializer","text":"<p>File: <code>server/initializers/cache.ts</code></p> <p>Replace with sync initialization:</p> <pre><code>export const initializeSync = async () =&gt; {\n  logger.info('Starting sync scheduler...');\n  await syncScheduler.start();\n  logger.info('Sync scheduler started');\n};\n</code></pre>"},{"location":"design/cache-scalability-plan/#task-54-update-server-entry-point","title":"Task 5.4: Update Server Entry Point","text":"<p>File: <code>server/index.ts</code></p> <p>Replace cache initialization with sync initialization.</p>"},{"location":"design/cache-scalability-plan/#phase-6-testing-validation","title":"Phase 6: Testing &amp; Validation","text":""},{"location":"design/cache-scalability-plan/#task-61-create-synthetic-test-data-generator","title":"Task 6.1: Create Synthetic Test Data Generator","text":"<p>File: <code>server/scripts/generateTestData.ts</code></p> <p>Generate 100k+ fake scenes for testing scalability.</p>"},{"location":"design/cache-scalability-plan/#task-62-write-integration-tests","title":"Task 6.2: Write Integration Tests","text":"<ul> <li>Test full sync with large dataset</li> <li>Test incremental sync</li> <li>Test query performance</li> <li>Test FTS search</li> <li>Test user restrictions</li> </ul>"},{"location":"design/cache-scalability-plan/#task-63-performance-benchmarks","title":"Task 6.3: Performance Benchmarks","text":"<p>Compare: - Memory usage (before vs after) - Startup time - Query response times - Sync duration for various library sizes</p>"},{"location":"design/cache-scalability-plan/#phase-7-ui-updates","title":"Phase 7: UI Updates","text":""},{"location":"design/cache-scalability-plan/#task-71-add-sync-status-to-server-settings","title":"Task 7.1: Add Sync Status to Server Settings","text":"<p>Show: - Last sync time per entity type - Total entities synced - Sync progress (when running) - Error messages</p>"},{"location":"design/cache-scalability-plan/#task-72-add-sync-interval-setting","title":"Task 7.2: Add Sync Interval Setting","text":"<p>Allow admin to configure polling interval (5-120 minutes).</p>"},{"location":"design/cache-scalability-plan/#task-73-add-manual-sync-buttons","title":"Task 7.3: Add Manual Sync Buttons","text":"<ul> <li>\"Incremental Sync\" - sync changes only</li> <li>\"Full Sync\" - re-sync everything</li> </ul>"},{"location":"design/cache-scalability-plan/#verification-checklist","title":"Verification Checklist","text":"<p>After implementation, verify:</p> <ul> <li> Fresh install works (full sync on first run)</li> <li> Existing install migrates cleanly</li> <li> 100k scene library loads without errors</li> <li> Memory usage stays under 200MB</li> <li> Scene browsing responds in &lt;100ms</li> <li> Search works with FTS5</li> <li> User restrictions apply correctly</li> <li> Stats/aggregations work</li> <li> Incremental sync detects changes</li> <li> Soft delete works (removed scenes hidden but recoverable)</li> <li> All 17 dependent files updated</li> <li> No references to old StashCacheManager</li> </ul>"},{"location":"design/cache-scalability-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Keep old StashCacheManager code on a branch 2. Add feature flag to switch between old/new 3. Can revert by setting flag and redeploying</p>"},{"location":"design/cache-scalability-plan/#estimated-scope","title":"Estimated Scope","text":"Phase Tasks Complexity Phase 1: Schema 3 Medium Phase 2: Sync Service 3 High Phase 3: Query Service 2 Medium Phase 4: Controller Migration 10 Medium (repetitive) Phase 5: Cleanup 4 Low Phase 6: Testing 3 Medium Phase 7: UI 3 Low Total 28 tasks <p>This is a significant refactor but follows a clear progression: schema \u2192 sync \u2192 query \u2192 migrate \u2192 cleanup \u2192 test \u2192 UI.</p>"},{"location":"design/json-blob-elimination-plan/","title":"JSON Blob Elimination Plan","text":"<p>Date: 2025-12-09 Status: Planning Branch: <code>feature/cache-scalability-investigation</code> Related: sqlite-cache-schema.md, cache-scalability-plan.md</p>"},{"location":"design/json-blob-elimination-plan/#problem-statement","title":"Problem Statement","text":"<p>The current SQLite cache implementation stores entity data in a JSON blob column (<code>data</code>), which causes severe performance issues:</p> <ol> <li>Sync Performance: ~100 scenes/minute = 3.6 hours for 22k scenes</li> <li>JSON Serialization: Every upsert requires <code>JSON.stringify()</code> of large objects</li> <li>Junction Tables: 4 DELETE + 4 INSERT operations per scene (performers, tags, groups, galleries)</li> <li>Query Overhead: Every read requires <code>JSON.parse()</code> to access data</li> </ol> <p>The JSON blob approach was chosen for simplicity but doesn't scale. We need a proper normalized schema.</p>"},{"location":"design/json-blob-elimination-plan/#additional-problem-sync-state-logic","title":"Additional Problem: Sync State Logic","text":"<p>The current startup sync logic only checks for scene sync state:</p> <pre><code>// SyncScheduler.ts - performStartupSync()\nconst syncState = await prisma.syncState.findFirst({\n  where: { entityType: \"scene\" },\n});\n\nconst hasCompletedSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\nif (!hasCompletedSync) {\n  // Full sync triggered even though Studios, Tags, Performers etc may be complete\n  await stashSyncService.fullSync();\n}\n</code></pre> <p>Issues: 1. Only checks scene sync state - ignores other entity types 2. If scene sync fails/never completes, full sync is triggered every restart 3. Already-synced entities (Studios, Tags, Performers) are re-synced unnecessarily 4. Full sync doesn't use per-entity incremental logic</p> <p>Required Fix: Each entity type should independently check its own sync state and skip if nothing changed since last sync.</p>"},{"location":"design/json-blob-elimination-plan/#solution-eliminate-json-blob","title":"Solution: Eliminate JSON Blob","text":"<p>Store all consumed fields as individual database columns. Transform URLs at read time instead of storing transformed values.</p>"},{"location":"design/json-blob-elimination-plan/#key-insight-url-transformation","title":"Key Insight: URL Transformation","text":"<p>Currently, <code>transformScene()</code> converts Stash URLs to proxy URLs at sync time and stores them in the JSON blob. This is wasteful because:</p> <ol> <li>URLs contain the Stash host which may change</li> <li>We're storing redundant data (full nested objects)</li> <li>Transformation is a simple prefix replacement that can happen at read time</li> </ol> <p>New approach: Store only Stash entity IDs. Transform URLs when constructing the response.</p>"},{"location":"design/json-blob-elimination-plan/#phase-1-schema-redesign","title":"Phase 1: Schema Redesign","text":""},{"location":"design/json-blob-elimination-plan/#cachedscene-expanded-columns","title":"CachedScene - Expanded Columns","text":"<p>Replace JSON blob with explicit columns for all consumed fields:</p> <pre><code>model CachedScene {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields (already indexed) ===\n  title           String?\n  code            String?\n  date            String?                   // YYYY-MM-DD\n  studioId        String?\n  rating100       Int?\n  duration        Int?                      // seconds (from primary file)\n  organized       Boolean   @default(false)\n\n  // === New fields from JSON blob ===\n  details         String?                   // Scene description (used in search)\n\n  // Primary file metadata\n  filePath        String?                   // Primary file path\n  fileBitRate     Int?                      // bits/second\n  fileFrameRate   Float?                    // fps\n  fileWidth       Int?                      // pixels\n  fileHeight      Int?                      // pixels\n  fileVideoCodec  String?                   // e.g., \"h264\", \"hevc\"\n  fileAudioCodec  String?                   // e.g., \"aac\", \"ac3\"\n  fileSize        BigInt?                   // bytes (can be &gt; 4GB)\n\n  // Stash paths (raw, transformed at read time)\n  pathScreenshot  String?                   // Screenshot URL path\n  pathPreview     String?                   // Preview video path\n  pathSprite      String?                   // Sprite sheet path\n  pathVtt         String?                   // VTT chapter path\n  pathChaptersVtt String?                   // Chapters VTT path\n  pathStream      String?                   // Primary stream path\n  pathCaption     String?                   // Caption path\n\n  // Scene streams (JSON array - small, rarely changes)\n  streams         String?                   // JSON: [{url, mime_type, label}]\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Junction table relations\n  performers      ScenePerformer[]\n  tags            SceneTag[]\n  groups          SceneGroup[]\n  galleries       SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([stashUpdatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedperformer-expanded-columns","title":"CachedPerformer - Expanded Columns","text":"<pre><code>model CachedPerformer {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  disambiguation  String?\n  gender          String?\n  birthdate       String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields from JSON blob ===\n  aliasList       String?                   // JSON array of aliases\n  imagePath       String?                   // Raw image URL path\n  details         String?                   // Biography\n\n  // Additional performer metadata\n  country         String?\n  ethnicity       String?\n  hairColor       String?\n  eyeColor        String?\n  height          Int?                      // cm\n  weight          Int?                      // kg\n  measurements    String?                   // e.g., \"34D-24-34\"\n  tattoos         String?\n  piercings       String?\n  careerLength    String?\n  deathDate       String?\n  url             String?                   // Homepage\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          ScenePerformer[]\n  images          ImagePerformer[]\n  tags            PerformerTag[]            // NEW: performers can have tags\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedstudio-expanded-columns","title":"CachedStudio - Expanded Columns","text":"<pre><code>model CachedStudio {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  parentId        String?\n  favorite        Boolean   @default(false)\n  rating100       Int?\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n  galleryCount    Int       @default(0)\n\n  // === New fields ===\n  details         String?                   // Studio description\n  imagePath       String?                   // Raw logo URL path\n  url             String?                   // Studio website\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  tags            StudioTag[]               // NEW: studios can have tags\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#cachedtag-expanded-columns","title":"CachedTag - Expanded Columns","text":"<pre><code>model CachedTag {\n  id              String    @id\n  stashInstanceId String?\n\n  // === Core fields ===\n  name            String\n  favorite        Boolean   @default(false)\n  sceneCount      Int       @default(0)\n  imageCount      Int       @default(0)\n\n  // === New fields ===\n  description     String?                   // Tag description\n  imagePath       String?                   // Tag image URL path\n  parentId        String?                   // Parent tag for hierarchy\n\n  // Sync metadata\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relations\n  scenes          SceneTag[]\n  images          ImageTag[]\n  performers      PerformerTag[]\n  studios         StudioTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([parentId])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#new-junction-tables","title":"New Junction Tables","text":"<pre><code>// Performer tags (for tag filtering that includes performer tags)\nmodel PerformerTag {\n  performerId     String\n  tagId           String\n  performer       CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([performerId, tagId])\n  @@index([tagId])\n}\n\n// Studio tags\nmodel StudioTag {\n  studioId        String\n  tagId           String\n  studio          CachedStudio    @relation(fields: [studioId], references: [id], onDelete: Cascade)\n  tag             CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([studioId, tagId])\n  @@index([tagId])\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-2-sync-optimization","title":"Phase 2: Sync Optimization","text":""},{"location":"design/json-blob-elimination-plan/#strategy-1-batch-upserts-with-raw-sql","title":"Strategy 1: Batch Upserts with Raw SQL","text":"<p>Replace Prisma individual upserts with bulk raw SQL:</p> <pre><code>private async processScenesBatchOptimized(\n  scenes: Scene[],\n  stashInstanceId: string | undefined\n): Promise&lt;void&gt; {\n  // Build batch INSERT...ON CONFLICT statement\n  const values = scenes.map(scene =&gt; {\n    const file = scene.files?.[0];\n    const paths = scene.paths;\n\n    return `(\n      '${scene.id}',\n      ${stashInstanceId ? `'${stashInstanceId}'` : 'NULL'},\n      ${escape(scene.title)},\n      ${escape(scene.code)},\n      ${escape(scene.date)},\n      ${scene.studio?.id ? `'${scene.studio.id}'` : 'NULL'},\n      ${scene.rating100 ?? 'NULL'},\n      ${file?.duration ? Math.round(file.duration) : 'NULL'},\n      ${scene.organized ? 1 : 0},\n      ${escape(scene.details)},\n      ${escape(file?.path)},\n      ${file?.bit_rate ?? 'NULL'},\n      ${file?.frame_rate ?? 'NULL'},\n      ${file?.width ?? 'NULL'},\n      ${file?.height ?? 'NULL'},\n      ${escape(file?.video_codec)},\n      ${escape(file?.audio_codec)},\n      ${file?.size ?? 'NULL'},\n      ${escape(paths?.screenshot)},\n      ${escape(paths?.preview)},\n      ${escape(paths?.sprite)},\n      ${escape(paths?.vtt)},\n      ${escape(paths?.chapters_vtt)},\n      ${escape(paths?.stream)},\n      ${escape(paths?.caption)},\n      ${escape(JSON.stringify(scene.sceneStreams || []))},\n      ${scene.created_at ? `'${scene.created_at}'` : 'NULL'},\n      ${scene.updated_at ? `'${scene.updated_at}'` : 'NULL'},\n      datetime('now'),\n      NULL\n    )`;\n  }).join(',\\n');\n\n  await prisma.$executeRawUnsafe(`\n    INSERT INTO CachedScene (\n      id, stashInstanceId, title, code, date, studioId, rating100, duration,\n      organized, details, filePath, fileBitRate, fileFrameRate, fileWidth,\n      fileHeight, fileVideoCodec, fileAudioCodec, fileSize, pathScreenshot,\n      pathPreview, pathSprite, pathVtt, pathChaptersVtt, pathStream, pathCaption,\n      streams, stashCreatedAt, stashUpdatedAt, syncedAt, deletedAt\n    ) VALUES ${values}\n    ON CONFLICT(id) DO UPDATE SET\n      title = excluded.title,\n      code = excluded.code,\n      date = excluded.date,\n      studioId = excluded.studioId,\n      rating100 = excluded.rating100,\n      duration = excluded.duration,\n      organized = excluded.organized,\n      details = excluded.details,\n      filePath = excluded.filePath,\n      fileBitRate = excluded.fileBitRate,\n      fileFrameRate = excluded.fileFrameRate,\n      fileWidth = excluded.fileWidth,\n      fileHeight = excluded.fileHeight,\n      fileVideoCodec = excluded.fileVideoCodec,\n      fileAudioCodec = excluded.fileAudioCodec,\n      fileSize = excluded.fileSize,\n      pathScreenshot = excluded.pathScreenshot,\n      pathPreview = excluded.pathPreview,\n      pathSprite = excluded.pathSprite,\n      pathVtt = excluded.pathVtt,\n      pathChaptersVtt = excluded.pathChaptersVtt,\n      pathStream = excluded.pathStream,\n      pathCaption = excluded.pathCaption,\n      streams = excluded.streams,\n      stashCreatedAt = excluded.stashCreatedAt,\n      stashUpdatedAt = excluded.stashUpdatedAt,\n      syncedAt = excluded.syncedAt,\n      deletedAt = NULL\n  `);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#strategy-2-batch-junction-table-operations","title":"Strategy 2: Batch Junction Table Operations","text":"<p>Instead of per-scene DELETE + INSERT, batch by page:</p> <pre><code>private async syncSceneJunctionTablesOptimized(\n  scenes: Scene[]\n): Promise&lt;void&gt; {\n  const sceneIds = scenes.map(s =&gt; s.id);\n\n  // Single DELETE per junction table for entire batch\n  await Promise.all([\n    prisma.$executeRawUnsafe(\n      `DELETE FROM ScenePerformer WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneTag WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGroup WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n    prisma.$executeRawUnsafe(\n      `DELETE FROM SceneGallery WHERE sceneId IN (${sceneIds.map(id =&gt; `'${id}'`).join(',')})`\n    ),\n  ]);\n\n  // Collect all junction records\n  const performerRecords: string[] = [];\n  const tagRecords: string[] = [];\n  const groupRecords: string[] = [];\n  const galleryRecords: string[] = [];\n\n  for (const scene of scenes) {\n    for (const p of scene.performers || []) {\n      performerRecords.push(`('${scene.id}', '${p.id}')`);\n    }\n    for (const t of scene.tags || []) {\n      tagRecords.push(`('${scene.id}', '${t.id}')`);\n    }\n    for (const g of scene.groups || []) {\n      const index = g.scene_index ?? 'NULL';\n      groupRecords.push(`('${scene.id}', '${g.id}', ${index})`);\n    }\n    for (const g of scene.galleries || []) {\n      galleryRecords.push(`('${scene.id}', '${g.id}')`);\n    }\n  }\n\n  // Single INSERT per junction table\n  const inserts = [];\n\n  if (performerRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO ScenePerformer (sceneId, performerId) VALUES ${performerRecords.join(',')}`\n    ));\n  }\n  if (tagRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneTag (sceneId, tagId) VALUES ${tagRecords.join(',')}`\n    ));\n  }\n  if (groupRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGroup (sceneId, groupId, sceneIndex) VALUES ${groupRecords.join(',')}`\n    ));\n  }\n  if (galleryRecords.length &gt; 0) {\n    inserts.push(prisma.$executeRawUnsafe(\n      `INSERT OR IGNORE INTO SceneGallery (sceneId, galleryId) VALUES ${galleryRecords.join(',')}`\n    ));\n  }\n\n  await Promise.all(inserts);\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#expected-performance-improvement","title":"Expected Performance Improvement","text":"Operation Before After Improvement Scene upsert 1 Prisma call/scene 1 SQL/batch 100x fewer calls JSON.stringify Every scene None Eliminated Junction deletes 4 calls/scene 4 calls/batch 100x fewer calls Junction inserts 4 calls/scene 4 calls/batch 100x fewer calls Total per batch ~500 DB calls ~9 DB calls 55x reduction <p>With 100 scenes per batch: - Before: 500+ Prisma operations - After: 9 raw SQL operations</p> <p>Projected sync time for 22k scenes: ~4-6 minutes instead of 3.6 hours</p>"},{"location":"design/json-blob-elimination-plan/#phase-25-fix-sync-state-logic-priority","title":"Phase 2.5: Fix Sync State Logic (PRIORITY)","text":"<p>This should be implemented before the JSON blob elimination to prevent unnecessary re-syncing.</p>"},{"location":"design/json-blob-elimination-plan/#problem","title":"Problem","text":"<p>Current <code>performStartupSync()</code> only checks scene sync state: - If scenes never completed, ALL entity types are re-synced from scratch - Studios, Tags, Performers that already synced are re-fetched needlessly</p>"},{"location":"design/json-blob-elimination-plan/#solution-smart-per-entity-sync","title":"Solution: Smart Per-Entity Sync","text":"<p>Each entity type should: 1. Check its own SyncState record 2. Query Stash for count of entities updated since last sync 3. Skip if nothing changed (count = 0) 4. Only fetch changed entities if count &gt; 0</p>"},{"location":"design/json-blob-elimination-plan/#implementation","title":"Implementation","text":"<pre><code>// SyncScheduler.ts\nprivate async performStartupSync(): Promise&lt;void&gt; {\n  // Check sync state for ALL entity types, not just scenes\n  const syncStates = await prisma.syncState.findMany();\n  const syncStateMap = new Map(syncStates.map(s =&gt; [s.entityType, s]));\n\n  // If ANY entity type has a completed sync, use incremental for all\n  const hasAnySync = syncStates.some(s =&gt; s.lastFullSync || s.lastIncrementalSync);\n\n  if (!hasAnySync) {\n    logger.info(\"No previous sync found for any entity, performing full sync\");\n    await stashSyncService.fullSync();\n    return;\n  }\n\n  // Smart incremental sync - checks each entity independently\n  logger.info(\"Performing smart incremental sync on startup\");\n  await stashSyncService.smartIncrementalSync();\n}\n\n// StashSyncService.ts\nasync smartIncrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n  const results: SyncResult[] = [];\n\n  // Each entity type checks independently\n  for (const entityType of ['studio', 'tag', 'performer', 'group', 'gallery', 'scene', 'image']) {\n    const syncState = await this.getSyncState(stashInstanceId, entityType);\n    const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n    if (!lastSync) {\n      // Never synced this entity type - do full sync for just this type\n      logger.info(`No sync state for ${entityType}, performing full sync`);\n      const result = await this.syncEntityType(entityType, stashInstanceId, true);\n      results.push(result);\n    } else {\n      // Check if anything changed since last sync\n      const changeCount = await this.getChangeCount(entityType, lastSync);\n\n      if (changeCount === 0) {\n        logger.info(`${entityType}: No changes since ${lastSync.toISOString()}, skipping`);\n        results.push({\n          entityType,\n          synced: 0,\n          deleted: 0,\n          durationMs: 0,\n        });\n      } else {\n        logger.info(`${entityType}: ${changeCount} changes since ${lastSync.toISOString()}`);\n        const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n        results.push(result);\n      }\n    }\n  }\n\n  return results;\n}\n\nprivate async getChangeCount(entityType: string, since: Date): Promise&lt;number&gt; {\n  const stash = stashInstanceManager.getDefault();\n  const filter = {\n    updated_at: { modifier: \"GREATER_THAN\", value: since.toISOString() }\n  };\n\n  switch (entityType) {\n    case 'scene':\n      const sceneResult = await stash.findScenesCompact({\n        filter: { page: 1, per_page: 0 }, // Only get count, no data\n        scene_filter: filter,\n      });\n      return sceneResult.findScenes.count;\n\n    case 'performer':\n      const performerResult = await stash.findPerformersCompact({\n        filter: { page: 1, per_page: 0 },\n        performer_filter: filter,\n      });\n      return performerResult.findPerformers.count;\n\n    // Similar for other entity types...\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#benefits","title":"Benefits","text":"<ol> <li>Restart resilience: If scene sync fails, other entities don't re-sync</li> <li>Fast startup: Entities with no changes skip API calls entirely</li> <li>Incremental always: Even \"full sync\" uses per-entity incremental when possible</li> <li>Progress visibility: Each entity type reports its own status</li> </ol>"},{"location":"design/json-blob-elimination-plan/#test-scenario","title":"Test Scenario","text":"<p>After implementing: 1. Run full sync to completion (or partial - doesn't matter) 2. Restart server 3. Expected: \"Studios: No changes since X, skipping\" for already-synced types 4. Only entities that never completed or have changes get synced</p>"},{"location":"design/json-blob-elimination-plan/#phase-3-query-layer-updates","title":"Phase 3: Query Layer Updates","text":""},{"location":"design/json-blob-elimination-plan/#cachedentityqueryservice-changes","title":"CachedEntityQueryService Changes","text":"<p>Replace JSON parsing with direct column access and URL transformation:</p> <pre><code>class CachedEntityQueryService {\n  private transformSceneUrls(scene: CachedScene): NormalizedScene {\n    const baseUrl = this.getStashProxyBaseUrl();\n\n    return {\n      id: scene.id,\n      title: scene.title,\n      code: scene.code,\n      date: scene.date,\n      details: scene.details,\n      rating100: scene.rating100,\n      organized: scene.organized,\n\n      // File metadata\n      files: scene.filePath ? [{\n        path: scene.filePath,\n        duration: scene.duration,\n        bit_rate: scene.fileBitRate,\n        frame_rate: scene.fileFrameRate,\n        width: scene.fileWidth,\n        height: scene.fileHeight,\n        video_codec: scene.fileVideoCodec,\n        audio_codec: scene.fileAudioCodec,\n        size: scene.fileSize,\n      }] : [],\n\n      // Transformed URLs\n      paths: {\n        screenshot: this.transformUrl(scene.pathScreenshot),\n        preview: this.transformUrl(scene.pathPreview),\n        sprite: this.transformUrl(scene.pathSprite),\n        vtt: this.transformUrl(scene.pathVtt),\n        chapters_vtt: this.transformUrl(scene.pathChaptersVtt),\n        stream: this.transformUrl(scene.pathStream),\n        caption: this.transformUrl(scene.pathCaption),\n      },\n\n      // Parse streams JSON (small, rarely changes)\n      sceneStreams: scene.streams\n        ? JSON.parse(scene.streams).map(s =&gt; ({\n            ...s,\n            url: this.transformUrl(s.url),\n          }))\n        : [],\n\n      // Nested entities loaded separately\n      studio: null,      // Loaded via JOIN or separate query\n      performers: [],    // Loaded via junction table\n      tags: [],          // Loaded via junction table\n      groups: [],        // Loaded via junction table\n      galleries: [],     // Loaded via junction table\n\n      // Timestamps\n      created_at: scene.stashCreatedAt?.toISOString(),\n      updated_at: scene.stashUpdatedAt?.toISOString(),\n    };\n  }\n\n  private transformUrl(path: string | null): string | null {\n    if (!path) return null;\n    // Replace Stash host with proxy prefix\n    return `/api/proxy/stash${path}`;\n  }\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#loading-nested-entities","title":"Loading Nested Entities","text":"<p>For detail views that need performers/tags, use efficient batch loading:</p> <pre><code>async getSceneWithRelations(id: string): Promise&lt;NormalizedScene | null&gt; {\n  const scene = await prisma.cachedScene.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: {\n        include: { performer: true }\n      },\n      tags: {\n        include: { tag: true }\n      },\n      groups: {\n        include: { group: true }\n      },\n      galleries: {\n        include: { gallery: true }\n      },\n    },\n  });\n\n  if (!scene) return null;\n\n  const transformed = this.transformSceneUrls(scene);\n\n  // Add nested entities\n  transformed.performers = scene.performers.map(sp =&gt;\n    this.transformPerformerUrls(sp.performer)\n  );\n  transformed.tags = scene.tags.map(st =&gt;\n    this.transformTagUrls(st.tag)\n  );\n  transformed.groups = scene.groups.map(sg =&gt; ({\n    ...this.transformGroupUrls(sg.group),\n    scene_index: sg.sceneIndex,\n  }));\n  transformed.studio = scene.studioId\n    ? await this.getStudio(scene.studioId)\n    : null;\n\n  return transformed;\n}\n</code></pre>"},{"location":"design/json-blob-elimination-plan/#phase-4-migration-path","title":"Phase 4: Migration Path","text":""},{"location":"design/json-blob-elimination-plan/#step-1-add-new-columns-non-breaking","title":"Step 1: Add New Columns (Non-Breaking)","text":"<p>Add new columns to existing schema without removing <code>data</code> column yet.</p>"},{"location":"design/json-blob-elimination-plan/#step-2-dual-write-during-sync","title":"Step 2: Dual-Write During Sync","text":"<p>Update sync to write both JSON blob AND individual columns. This allows rollback.</p>"},{"location":"design/json-blob-elimination-plan/#step-3-update-query-service","title":"Step 3: Update Query Service","text":"<p>Switch CachedEntityQueryService to read from columns instead of JSON.</p>"},{"location":"design/json-blob-elimination-plan/#step-4-remove-json-blob","title":"Step 4: Remove JSON Blob","text":"<p>After validation, remove <code>data</code> column from schema.</p>"},{"location":"design/json-blob-elimination-plan/#step-5-optimize-sync","title":"Step 5: Optimize Sync","text":"<p>Remove JSON.stringify, implement batch operations.</p>"},{"location":"design/json-blob-elimination-plan/#testing-plan","title":"Testing Plan","text":"<ol> <li>Sync Performance Test: Time full sync with 22k scenes</li> <li> <p>Target: &lt; 10 minutes (vs current 3.6 hours)</p> </li> <li> <p>Query Performance Test: Measure browse page response time</p> </li> <li> <p>Target: &lt; 100ms for paginated results</p> </li> <li> <p>Memory Test: Monitor memory during sync</p> </li> <li> <p>Target: &lt; 500MB peak usage</p> </li> <li> <p>Data Integrity Test: Compare output before/after migration</p> </li> <li>All scenes should have same field values</li> </ol>"},{"location":"design/json-blob-elimination-plan/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise: 1. Re-enable JSON blob writing 2. Switch query service back to JSON parsing 3. Performance will degrade but functionality preserved</p>"},{"location":"design/json-blob-elimination-plan/#files-to-modify","title":"Files to Modify","text":""},{"location":"design/json-blob-elimination-plan/#schema","title":"Schema","text":"<ul> <li><code>server/prisma/schema.prisma</code> - Add new columns</li> </ul>"},{"location":"design/json-blob-elimination-plan/#sync-service","title":"Sync Service","text":"<ul> <li><code>server/services/StashSyncService.ts</code> - Batch operations, remove JSON</li> </ul>"},{"location":"design/json-blob-elimination-plan/#query-service","title":"Query Service","text":"<ul> <li><code>server/services/CachedEntityQueryService.ts</code> - Direct column access</li> </ul>"},{"location":"design/json-blob-elimination-plan/#transformation","title":"Transformation","text":"<ul> <li><code>server/utils/pathMapping.ts</code> - Move URL transformation to query time</li> </ul>"},{"location":"design/json-blob-elimination-plan/#types","title":"Types","text":"<ul> <li><code>server/types/index.ts</code> - Update NormalizedScene type if needed</li> </ul>"},{"location":"design/json-blob-elimination-plan/#summary","title":"Summary","text":"<p>Root Cause: JSON blob storage creates O(n) serialization overhead and prevents SQL query optimization.</p> <p>Solution: 1. Store all fields as individual columns 2. Transform URLs at read time (not sync time) 3. Use batch SQL operations for sync 4. Reduce DB operations from ~500/batch to ~9/batch</p> <p>Expected Result: Sync time reduced from 3.6 hours to ~5 minutes for 22k scenes.</p>"},{"location":"design/sqlite-cache-schema/","title":"SQLite Entity Cache Schema Design","text":"<p>Related: cache-scalability-brainstorm.md Date: 2025-12-08</p>"},{"location":"design/sqlite-cache-schema/#design-goals","title":"Design Goals","text":"<ol> <li>Scalability: Support 100k+ scenes without memory issues</li> <li>Query Performance: Fast filtering, sorting, pagination via SQL indexes</li> <li>Minimal Storage: Store only what Peek needs for filtering/display</li> <li>Relationships: Maintain scene\u2194performer, scene\u2194tag, etc. for filtering</li> <li>Sync Tracking: Track what's synced, detect deletions, enable incremental updates</li> </ol>"},{"location":"design/sqlite-cache-schema/#schema-design-decisions","title":"Schema Design Decisions","text":""},{"location":"design/sqlite-cache-schema/#decision-1-normalized-vs-denormalized","title":"Decision 1: Normalized vs Denormalized","text":"<p>Option A: Fully Normalized (separate tables with junction tables) <pre><code>CachedScene, CachedPerformer, ScenePerformer (junction), etc.\n</code></pre> - Pros: Clean relationships, no data duplication - Cons: Complex JOINs for every query, harder to paginate</p> <p>Option B: Denormalized with JSON (store relationships as JSON) <pre><code>CachedScene { performerIds: \"[1,2,3]\", tagIds: \"[4,5,6]\" }\n</code></pre> - Pros: Simple queries, fast reads - Cons: Can't filter by \"scenes with performer X\" efficiently</p> <p>Option C: Hybrid (normalized + JSON for full data) <pre><code>CachedScene { studioId, performerIds JSON, tagIds JSON, fullData JSON }\n+ Junction tables for efficient filtering\n</code></pre> - Pros: Best of both - efficient filtering AND full data access - Cons: More storage, need to keep junction tables in sync</p> <p>Decision: Option C (Hybrid) - We need both efficient filtering AND full entity data.</p>"},{"location":"design/sqlite-cache-schema/#decision-2-what-to-index","title":"Decision 2: What to Index","text":"<p>For scene filtering, we need to support: - Filter by studio, performers, tags, groups - Sort by date, rating, title, created_at, play_count, random - Text search on title - Date range queries</p> <p>Indexes needed: - <code>studioId</code> - Filter by studio - <code>date</code> - Sort/filter by scene date - <code>createdAt</code> - Sort by when added to Stash - <code>rating100</code> - Sort by rating - <code>title</code> - Text search (use SQLite FTS5 for full-text search) - Junction table indexes for performer/tag/group filtering</p>"},{"location":"design/sqlite-cache-schema/#decision-3-soft-delete-strategy","title":"Decision 3: Soft Delete Strategy","text":"<p>When an entity is deleted from Stash: 1. Mark <code>deletedAt</code> timestamp in Peek 2. Don't show in browse results 3. Keep for 30 days (allows Peek data recovery if re-added) 4. Periodic cleanup job removes old deleted entities</p>"},{"location":"design/sqlite-cache-schema/#proposed-schema","title":"Proposed Schema","text":""},{"location":"design/sqlite-cache-schema/#core-entity-tables","title":"Core Entity Tables","text":"<pre><code>// Cached scene from Stash\n// Contains indexed fields for filtering + JSON blob for full data\nmodel CachedScene {\n  id            String    @id                    // Stash scene ID\n  stashInstanceId String?                        // Which Stash server (for multi-instance)\n\n  // === Indexed fields for filtering/sorting ===\n  title         String?\n  date          String?                          // YYYY-MM-DD format\n  studioId      String?\n  rating100     Int?\n  duration      Int?                             // seconds\n  organized     Boolean   @default(false)\n  oCounter      Int       @default(0)\n  playCount     Int       @default(0)\n\n  // === Full entity data (JSON) ===\n  // Contains: performers, tags, files, paths, streams, etc.\n  // Transformed with proxy URLs at sync time\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?                      // created_at from Stash\n  stashUpdatedAt  DateTime?                      // updated_at from Stash\n  syncedAt        DateTime  @default(now())      // When Peek last synced this entity\n  deletedAt       DateTime?                      // Soft delete timestamp\n\n  // Relationships (for efficient filtering)\n  performers    ScenePerformer[]\n  tags          SceneTag[]\n  groups        SceneGroup[]\n  galleries     SceneGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([stashCreatedAt])\n  @@index([rating100])\n  @@index([duration])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])                      // For incremental sync\n}\n\nmodel CachedPerformer {\n  id            String    @id                    // Stash performer ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  gender        String?\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        ScenePerformer[]\n\n  @@index([name])\n  @@index([gender])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedStudio {\n  id            String    @id                    // Stash studio ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  parentId      String?                          // Parent studio ID\n  favorite      Boolean   @default(false)\n  rating100     Int?\n  sceneCount    Int       @default(0)\n  imageCount    Int       @default(0)\n  galleryCount  Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        CachedScene[]                    // Direct relation (not junction)\n\n  @@index([name])\n  @@index([parentId])\n  @@index([favorite])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedTag {\n  id            String    @id                    // Stash tag ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  favorite      Boolean   @default(false)\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneTag[]\n\n  @@index([name])\n  @@index([favorite])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGroup {\n  id            String    @id                    // Stash group ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  name          String\n  date          String?\n  studioId      String?\n  rating100     Int?\n  duration      Int?\n  sceneCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGroup[]\n\n  @@index([name])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([sceneCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel CachedGallery {\n  id            String    @id                    // Stash gallery ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  imageCount    Int       @default(0)\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  scenes        SceneGallery[]\n\n  @@index([title])\n  @@index([date])\n  @@index([studioId])\n  @@index([rating100])\n  @@index([imageCount])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#junction-tables-for-efficient-many-to-many-filtering","title":"Junction Tables (for efficient many-to-many filtering)","text":"<pre><code>model ScenePerformer {\n  sceneId       String\n  performerId   String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, performerId])\n  @@index([performerId])                         // For \"scenes with performer X\" queries\n}\n\nmodel SceneTag {\n  sceneId       String\n  tagId         String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, tagId])\n  @@index([tagId])                               // For \"scenes with tag X\" queries\n}\n\nmodel SceneGroup {\n  sceneId       String\n  groupId       String\n  sceneIndex    Int?                             // Position in group\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  group         CachedGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, groupId])\n  @@index([groupId])\n}\n\nmodel SceneGallery {\n  sceneId       String\n  galleryId     String\n\n  scene         CachedScene     @relation(fields: [sceneId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([sceneId, galleryId])\n  @@index([galleryId])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#sync-metadata-table","title":"Sync Metadata Table","text":"<pre><code>// Tracks sync state per entity type\nmodel SyncState {\n  id              Int       @id @default(autoincrement())\n  stashInstanceId String?\n  entityType      String                         // 'scene', 'performer', etc.\n\n  lastFullSync    DateTime?                      // Last complete sync\n  lastIncrementalSync DateTime?                  // Last incremental sync\n  lastSyncCount   Int       @default(0)          // Entities synced in last run\n  lastSyncDuration Int?                          // Milliseconds\n  lastError       String?                        // Error message if last sync failed\n\n  @@unique([stashInstanceId, entityType])\n}\n</code></pre>"},{"location":"design/sqlite-cache-schema/#query-patterns","title":"Query Patterns","text":""},{"location":"design/sqlite-cache-schema/#pattern-1-paginated-scene-browse","title":"Pattern 1: Paginated Scene Browse","text":"<pre><code>-- Get page 2 of scenes (50 per page), sorted by date DESC\n-- With user restrictions applied (exclude hidden, apply tag restrictions)\n\nSELECT s.id, s.data\nFROM CachedScene s\nWHERE s.deletedAt IS NULL\n  AND s.id NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'scene')\n  AND s.studioId NOT IN (SELECT entityId FROM UserHiddenEntity WHERE userId = ? AND entityType = 'studio')\n  -- User restriction: only scenes with tag \"Favorite\"\n  AND EXISTS (SELECT 1 FROM SceneTag st WHERE st.sceneId = s.id AND st.tagId IN (?))\nORDER BY s.date DESC\nLIMIT 50 OFFSET 50;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-2-filter-by-performer","title":"Pattern 2: Filter by Performer","text":"<pre><code>-- Get all scenes featuring performer \"123\"\nSELECT s.id, s.data\nFROM CachedScene s\nINNER JOIN ScenePerformer sp ON sp.sceneId = s.id\nWHERE sp.performerId = '123'\n  AND s.deletedAt IS NULL\nORDER BY s.date DESC;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#pattern-3-aggregation-top-performers-by-play-count","title":"Pattern 3: Aggregation (Top Performers by Play Count)","text":"<pre><code>-- Top 10 performers by user's play count\nSELECT p.id, p.name, SUM(ups.playCount) as totalPlays\nFROM CachedPerformer p\nINNER JOIN UserPerformerStats ups ON ups.performerId = p.id\nWHERE ups.userId = ?\n  AND p.deletedAt IS NULL\nGROUP BY p.id\nORDER BY totalPlays DESC\nLIMIT 10;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#storage-estimates","title":"Storage Estimates","text":"Entity Count JSON Size Indexed Fields Total Scene 100,000 ~2KB ~200B ~220MB Performer 10,000 ~500B ~100B ~6MB Studio 1,000 ~300B ~50B ~350KB Tag 10,000 ~200B ~50B ~2.5MB Group 5,000 ~400B ~100B ~2.5MB Gallery 20,000 ~400B ~100B ~10MB Total ~240MB <p>Junction tables add ~10-20% overhead for relationships.</p> <p>Total estimated storage for 100k scene library: ~300MB</p>"},{"location":"design/sqlite-cache-schema/#migration-strategy","title":"Migration Strategy","text":""},{"location":"design/sqlite-cache-schema/#phase-1-add-schema-non-breaking","title":"Phase 1: Add Schema (Non-Breaking)","text":"<ol> <li>Add new Cached* tables via Prisma migration</li> <li>Keep existing StashCacheManager working</li> <li>Add new StashSyncService that populates SQLite</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-2-parallel-operation","title":"Phase 2: Parallel Operation","text":"<ol> <li>Both in-memory cache and SQLite populated</li> <li>Add feature flag to switch query source</li> <li>Test performance and correctness</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-3-switch-to-sqlite","title":"Phase 3: Switch to SQLite","text":"<ol> <li>Update all 18+ dependent files to use SQLite queries</li> <li>Remove in-memory cache</li> <li>Delete StashCacheManager</li> </ol>"},{"location":"design/sqlite-cache-schema/#phase-4-cleanup","title":"Phase 4: Cleanup","text":"<ol> <li>Remove FilteredEntityCacheService (SQLite replaces it)</li> <li>Clean up old code paths</li> <li>Performance tuning</li> </ol>"},{"location":"design/sqlite-cache-schema/#resolved-questions","title":"Resolved Questions","text":"<ol> <li>Full-text search: \u2705 Use SQLite FTS5 for title/name search (see FTS5 section below)</li> <li>Performer tags: TBD - defer until needed</li> <li>Image caching: \u2705 Yes, cache Images as separate entity (see CachedImage below)</li> <li>Multi-instance: TBD - current design supports it via stashInstanceId</li> </ol>"},{"location":"design/sqlite-cache-schema/#fts5-full-text-search","title":"FTS5 Full-Text Search","text":"<p>SQLite FTS5 provides fast, sophisticated text search with: - Word stemming (searching \"running\" matches \"run\") - Relevance ranking - Prefix matching (\"test*\" matches \"testing\") - Boolean operators (AND, OR, NOT)</p>"},{"location":"design/sqlite-cache-schema/#fts5-virtual-tables","title":"FTS5 Virtual Tables","text":"<pre><code>-- Create FTS5 virtual table for scene search\nCREATE VIRTUAL TABLE scene_fts USING fts5(\n  id,\n  title,\n  details,\n  content='CachedScene',\n  content_rowid='rowid'\n);\n\n-- Create FTS5 virtual table for performer search\nCREATE VIRTUAL TABLE performer_fts USING fts5(\n  id,\n  name,\n  aliases,\n  content='CachedPerformer',\n  content_rowid='rowid'\n);\n\n-- Triggers to keep FTS index in sync\nCREATE TRIGGER scene_fts_insert AFTER INSERT ON CachedScene BEGIN\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_delete AFTER DELETE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\nEND;\n\nCREATE TRIGGER scene_fts_update AFTER UPDATE ON CachedScene BEGIN\n  INSERT INTO scene_fts(scene_fts, rowid, id, title, details)\n  VALUES ('delete', old.rowid, old.id, old.title, json_extract(old.data, '$.details'));\n  INSERT INTO scene_fts(rowid, id, title, details)\n  VALUES (new.rowid, new.id, new.title, json_extract(new.data, '$.details'));\nEND;\n</code></pre>"},{"location":"design/sqlite-cache-schema/#fts5-query-example","title":"FTS5 Query Example","text":"<pre><code>-- Search for scenes matching \"blonde teacher\"\nSELECT s.id, s.data, rank\nFROM scene_fts\nINNER JOIN CachedScene s ON scene_fts.id = s.id\nWHERE scene_fts MATCH 'blonde teacher'\n  AND s.deletedAt IS NULL\nORDER BY rank\nLIMIT 50;\n</code></pre> <p>Note: Prisma doesn't support FTS5 virtual tables directly. We'll create these via raw SQL migrations.</p>"},{"location":"design/sqlite-cache-schema/#cachedimage-entity","title":"CachedImage Entity","text":"<pre><code>model CachedImage {\n  id            String    @id                    // Stash image ID\n  stashInstanceId String?\n\n  // === Indexed fields ===\n  title         String?\n  date          String?\n  studioId      String?\n  rating100     Int?\n  oCounter      Int       @default(0)\n  organized     Boolean   @default(false)\n\n  // File info (for display)\n  width         Int?\n  height        Int?\n  fileSize      Int?                             // bytes\n\n  // === Full entity data ===\n  data          String                           // JSON blob\n\n  // === Sync metadata ===\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  // Relationships\n  performers    ImagePerformer[]\n  tags          ImageTag[]\n  galleries     ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([deletedAt])\n  @@index([stashUpdatedAt])\n}\n\nmodel ImagePerformer {\n  imageId       String\n  performerId   String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  performer     CachedPerformer @relation(fields: [performerId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, performerId])\n  @@index([performerId])\n}\n\nmodel ImageTag {\n  imageId       String\n  tagId         String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  tag           CachedTag       @relation(fields: [tagId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, tagId])\n  @@index([tagId])\n}\n\nmodel ImageGallery {\n  imageId       String\n  galleryId     String\n\n  image         CachedImage     @relation(fields: [imageId], references: [id], onDelete: Cascade)\n  gallery       CachedGallery   @relation(fields: [galleryId], references: [id], onDelete: Cascade)\n\n  @@id([imageId, galleryId])\n  @@index([galleryId])\n}\n</code></pre> <p>Note: CachedPerformer and CachedTag need updated to include the new Image relations.</p>"},{"location":"design/sqlite-cache-schema/#next-steps","title":"Next Steps","text":"<ol> <li>Review this schema with stakeholder</li> <li>Create Prisma migration</li> <li>Implement StashSyncService</li> <li>Create SQL query builders for each access pattern</li> <li>Update controllers one by one</li> </ol>"},{"location":"development/regression-testing/","title":"Regression Testing Guide","text":"<p>This guide provides comprehensive regression testing procedures for Peek Stash Browser. Use this checklist before releasing new versions to ensure core functionality remains stable.</p> <p>Report Inaccuracies</p> <p>If you find any errors, outdated information, or inaccurate testing steps in this document, please report them via GitHub Issues with the label <code>documentation</code>. This helps keep the testing guide accurate and useful for everyone.</p>"},{"location":"development/regression-testing/#testing-environment-setup","title":"Testing Environment Setup","text":"<p>Before beginning regression testing:</p> <ol> <li>Test Data: Ensure your Stash library has:</li> <li>Multiple scenes with various file formats (MP4, MKV, etc.)</li> <li>Scenes with different durations (short &lt;5min, medium 5-30min, long &gt;30min)</li> <li>Multiple performers, studios, tags</li> <li>At least one gallery and one group/movie</li> <li>Network Conditions: Test on stable network connection</li> <li>Browsers: Test on at least two browsers (Chrome/Edge and Firefox recommended)</li> <li>Clean State: Clear browser cache and cookies before testing critical flows</li> </ol>"},{"location":"development/regression-testing/#test-execution-guidelines","title":"Test Execution Guidelines","text":"<ul> <li>Mark Pass/Fail: Check off tests as you complete them</li> <li>Document Failures: Note version, browser, and steps to reproduce any failures</li> <li>Severity Levels:</li> <li>Critical: Blocks core functionality (video playback, login, etc.)</li> <li>High: Major feature broken (search, playlists, filtering)</li> <li>Medium: Feature degraded but usable</li> <li>Low: Minor UI/UX issue</li> </ul>"},{"location":"development/regression-testing/#core-feature-tests","title":"Core Feature Tests","text":""},{"location":"development/regression-testing/#1-authentication-user-management","title":"1. Authentication &amp; User Management","text":""},{"location":"development/regression-testing/#11-first-time-setup","title":"1.1 First-Time Setup","text":"<p>Precondition: Fresh installation with no existing database</p> <ul> <li> Setup wizard appears on first access</li> <li> Can configure path mappings successfully</li> <li> Path mappings are validated (invalid paths show error)</li> <li> Default admin user is created</li> <li> After setup, redirects to login page</li> </ul>"},{"location":"development/regression-testing/#12-login-flow","title":"1.2 Login Flow","text":"<ul> <li> Can log in with valid credentials</li> <li> Invalid credentials show error message</li> <li> Session persists after page refresh</li> <li> JWT token expires after 24 hours (requires waiting or manual token expiry)</li> <li> Expired token redirects to login page</li> </ul>"},{"location":"development/regression-testing/#13-user-preferences","title":"1.3 User Preferences","text":"<p>Precondition: Logged in as any user</p> <ul> <li> Settings page loads without errors</li> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Preferences persist after logout/login</li> <li> Preferences apply immediately (theme change, etc.)</li> </ul>"},{"location":"development/regression-testing/#14-user-management-admin-only","title":"1.4 User Management (Admin Only)","text":"<p>Precondition: Logged in as admin user</p> <ul> <li> Can view list of all users</li> <li> Can create new user (Admin or User role)</li> <li> Can delete non-admin users</li> <li> Cannot delete own admin account</li> <li> Can change user passwords</li> <li> Can toggle user roles (Admin \u2194 User)</li> </ul>"},{"location":"development/regression-testing/#2-video-playback","title":"2. Video Playback","text":""},{"location":"development/regression-testing/#21-direct-playback-no-transcoding","title":"2.1 Direct Playback (No Transcoding)","text":"<p>Precondition: Select quality \"Direct\" in video player</p> <ul> <li> Video starts playing within 3 seconds</li> <li> Playback is smooth (no stuttering)</li> <li> Audio syncs with video</li> <li> Can pause and resume</li> <li> Can seek to different timestamps (beginning, middle, end)</li> <li> Volume control works</li> <li> Fullscreen toggle works</li> <li> Player shows correct duration</li> <li> Timeline/scrubber reflects current position</li> </ul>"},{"location":"development/regression-testing/#22-transcoded-playback-hls","title":"2.2 Transcoded Playback (HLS)","text":"<p>Precondition: Select quality \"720p\" or lower in video player</p> <ul> <li> HLS stream starts within 5 seconds</li> <li> Quality selector shows available qualities (360p, 480p, 720p, 1080p)</li> <li> Can switch between qualities mid-playback</li> <li> Playback resumes at same position after quality change</li> <li> Seeking works correctly (forward and backward)</li> <li> Far seeks (&gt;2 minutes ahead) restart transcoding session properly</li> <li> Segments load progressively (check Network tab)</li> <li> No missing segments or 404 errors</li> <li> Transcoding session cleans up after 90 seconds of inactivity</li> </ul> <p>Test Scenarios:</p> <ul> <li> Short video (&lt;5min): Plays from start to finish without errors</li> <li> Long video (&gt;30min): Can seek to middle and end without issues</li> <li> Multiple quality switches: Switch between 360p \u2192 720p \u2192 480p during playback</li> <li> Rapid seeking: Seek multiple times in quick succession (shouldn't crash)</li> </ul>"},{"location":"development/regression-testing/#23-resume-playback","title":"2.3 Resume Playback","text":"<p>Precondition: Previously watched a scene partially (not to completion)</p> <ul> <li> Scene shows resume position indicator (progress bar on thumbnail)</li> <li> Clicking scene shows \"Resume\" and \"Restart\" options</li> <li> \"Resume\" starts playback at last position (within 5 seconds accuracy)</li> <li> \"Restart\" starts playback at 0:00</li> <li> Resume position updates as video plays</li> <li> Watching to completion clears resume position</li> </ul>"},{"location":"development/regression-testing/#24-watch-history-tracking","title":"2.4 Watch History Tracking","text":"<ul> <li> Play count increments after watching</li> <li> Play duration accumulates correctly</li> <li> O-counter increments when marking scenes</li> <li> Last played timestamp updates</li> <li> Watch history appears in \"Recently Watched\" carousel (if implemented)</li> <li> Watch history persists across sessions</li> </ul>"},{"location":"development/regression-testing/#3-scene-search-filtering-and-sorting","title":"3. Scene Search, Filtering, and Sorting","text":""},{"location":"development/regression-testing/#31-search-functionality","title":"3.1 Search Functionality","text":"<p>Location: Scenes page, search bar at top</p> <ul> <li> Typing in search bar shows results in real-time</li> <li> Search matches scene titles</li> <li> Search matches performer names</li> <li> Search matches studio names</li> <li> Search matches tag names</li> <li> Empty search shows all scenes</li> <li> Search results update immediately (&lt;500ms)</li> <li> Clearing search resets to full library</li> </ul>"},{"location":"development/regression-testing/#32-filtering","title":"3.2 Filtering","text":"<p>Location: Scenes page, filter panel (sidebar or modal)</p>"},{"location":"development/regression-testing/#basic-filters","title":"Basic Filters","text":"<ul> <li> Filter by performer (single selection)</li> <li> Filter by multiple performers (AND logic)</li> <li> Filter by studio (single selection)</li> <li> Filter by tag (single selection)</li> <li> Filter by multiple tags (AND/OR logic based on settings)</li> <li> Filter by rating (min/max range)</li> <li> Filter by organized status (Yes/No/All)</li> <li> Filter by O-counter value (min/max range)</li> </ul>"},{"location":"development/regression-testing/#advanced-filters","title":"Advanced Filters","text":"<ul> <li> Filter by duration (min/max range in minutes)</li> <li> Filter by resolution (SD/HD/4K/etc.)</li> <li> Filter by interactive (Yes/No if applicable)</li> <li> Combining multiple filters applies AND logic correctly</li> <li> Clearing filters resets to full library</li> </ul>"},{"location":"development/regression-testing/#filter-presets","title":"Filter Presets","text":"<ul> <li> Can save current filter state as preset</li> <li> Can load saved filter preset</li> <li> Can delete saved filter preset</li> <li> Presets persist across sessions</li> <li> Default presets load on page visit (if configured)</li> </ul>"},{"location":"development/regression-testing/#hidden-items-filter","title":"Hidden Items Filter","text":"<ul> <li> Filter shows \"Show Hidden Items\" toggle</li> <li> Hidden scenes are excluded by default</li> <li> Toggling \"Show Hidden Items\" reveals hidden scenes</li> <li> Hidden scenes display with visual indicator (dimmed, badge, etc.)</li> </ul>"},{"location":"development/regression-testing/#33-sorting","title":"3.3 Sorting","text":"<p>Location: Scenes page, sort dropdown</p> <ul> <li> Sort by Date Added (newest first)</li> <li> Sort by Date Added (oldest first)</li> <li> Sort by Title (A-Z)</li> <li> Sort by Title (Z-A)</li> <li> Sort by Duration (longest first)</li> <li> Sort by Duration (shortest first)</li> <li> Sort by Rating (highest first)</li> <li> Sort by Rating (lowest first)</li> <li> Sort by Play Count (most played first)</li> <li> Sort by Random (different order on each load)</li> <li> Sort order persists when navigating away and back</li> <li> Sort works correctly with active filters</li> </ul>"},{"location":"development/regression-testing/#34-paginationinfinite-scroll","title":"3.4 Pagination/Infinite Scroll","text":"<p>Precondition: Library has &gt;40 scenes (default page size)</p> <ul> <li> Initial page loads first 40 scenes</li> <li> Scrolling to bottom loads next page automatically</li> <li> Loading indicator appears while fetching</li> <li> No duplicate scenes appear</li> <li> Can scroll through entire library without errors</li> <li> Scroll position maintained when navigating back from scene details</li> </ul>"},{"location":"development/regression-testing/#4-scene-grid-and-preview-playback","title":"4. Scene Grid and Preview Playback","text":""},{"location":"development/regression-testing/#41-scene-cards-display","title":"4.1 Scene Cards Display","text":"<ul> <li> Scene thumbnails load correctly</li> <li> Scene titles display correctly</li> <li> Scene metadata visible (duration, rating, date, etc.)</li> <li> Performer names display (truncated if too many)</li> <li> Studio name displays (if applicable)</li> <li> Watch history indicators show (resume bar, play count, O-counter)</li> <li> Cards have hover effects (preview, actions, etc.)</li> </ul>"},{"location":"development/regression-testing/#42-preview-playback-on-hover","title":"4.2 Preview Playback on Hover","text":"<p>Precondition: Preview feature enabled in settings</p> <ul> <li> Hovering over scene card for 2 seconds starts preview</li> <li> Preview plays short clip from scene</li> <li> Preview has no audio (or low volume)</li> <li> Preview loops continuously while hovering</li> <li> Moving mouse away stops preview immediately</li> <li> Preview quality matches user preference (Low/Medium/High)</li> <li> Preview doesn't interfere with clicking/navigation</li> <li> Multiple rapid hovers don't cause errors</li> </ul>"},{"location":"development/regression-testing/#43-scene-card-actions","title":"4.3 Scene Card Actions","text":"<p>Location: Hover over scene card or three-dot menu</p> <ul> <li> Can play scene directly (navigates to player page)</li> <li> Can add scene to playlist (opens playlist selector)</li> <li> Can mark scene as watched</li> <li> Can mark O-counter increment</li> <li> Can rate scene (opens rating modal or inline rating)</li> <li> Can hide scene (requires confirmation, scene disappears)</li> <li> Can view scene details (navigates to details page)</li> <li> Can download original file (triggers download)</li> </ul>"},{"location":"development/regression-testing/#5-playlists","title":"5. Playlists","text":""},{"location":"development/regression-testing/#51-playlist-creation","title":"5.1 Playlist Creation","text":"<p>Location: Playlists page or scene card menu</p> <ul> <li> Can create new playlist with name</li> <li> Can create new playlist with description (optional)</li> <li> Empty playlists are allowed</li> <li> Duplicate playlist names are allowed (or prevented based on requirements)</li> <li> New playlist appears in playlists list immediately</li> </ul>"},{"location":"development/regression-testing/#52-addingremoving-scenes","title":"5.2 Adding/Removing Scenes","text":"<ul> <li> Can add scene to playlist from scene card menu</li> <li> Can add multiple scenes to playlist in batch</li> <li> Can remove scene from playlist (via playlist view)</li> <li> Can reorder scenes in playlist (drag-and-drop or up/down buttons)</li> <li> Playlist item count updates immediately</li> <li> Playlist thumbnail updates to first scene</li> </ul>"},{"location":"development/regression-testing/#53-playlist-playback","title":"5.3 Playlist Playback","text":"<p>Precondition: Playlist has at least 3 scenes</p> <ul> <li> Clicking playlist plays first scene</li> <li> Auto-advances to next scene after current finishes</li> <li> \"Previous\" button goes to previous scene</li> <li> \"Next\" button goes to next scene</li> <li> Playlist progress indicator shows (e.g., \"2 of 5\")</li> <li> Can exit playlist playback and return later (resumes at last scene)</li> <li> Shuffle mode randomizes playback order</li> <li> Repeat mode restarts playlist after last scene</li> <li> Shuffle + Repeat combination works correctly</li> </ul>"},{"location":"development/regression-testing/#54-playlist-management","title":"5.4 Playlist Management","text":"<ul> <li> Can rename playlist</li> <li> Can edit playlist description</li> <li> Can delete playlist (requires confirmation)</li> <li> Deleting playlist doesn't delete scenes</li> <li> Can duplicate playlist</li> <li> Can export playlist as M3U (downloads file with relative paths)</li> <li> Can clear all scenes from playlist</li> </ul>"},{"location":"development/regression-testing/#6-performers-studios-tags-galleries-groups","title":"6. Performers, Studios, Tags, Galleries, Groups","text":""},{"location":"development/regression-testing/#61-performers-page","title":"6.1 Performers Page","text":"<ul> <li> Performers grid loads with thumbnails</li> <li> Can search performers by name</li> <li> Can filter performers by tag (if applicable)</li> <li> Can sort performers (name, scene count, etc.)</li> <li> Clicking performer navigates to performer details</li> <li> Performer details show bio, image, scene count</li> <li> Performer details show list of scenes</li> <li> Can filter scenes on performer page (same filters as main scenes page)</li> <li> Can rate performer (if rating feature exists)</li> <li> Can mark performer as favorite</li> </ul>"},{"location":"development/regression-testing/#62-studios-page","title":"6.2 Studios Page","text":"<ul> <li> Studios grid loads with logos/thumbnails</li> <li> Can search studios by name</li> <li> Can sort studios (name, scene count, etc.)</li> <li> Clicking studio navigates to studio details</li> <li> Studio details show scene count and scene list</li> <li> Can filter scenes on studio page</li> <li> Can rate studio (if rating feature exists)</li> <li> Can mark studio as favorite</li> </ul>"},{"location":"development/regression-testing/#63-tags-page","title":"6.3 Tags Page","text":"<ul> <li> Tags list loads (grid or list view)</li> <li> Can search tags by name</li> <li> Can sort tags (name, scene count, etc.)</li> <li> Clicking tag navigates to tag details or filters scenes</li> <li> Tag details show scene count and scene list</li> <li> Can filter scenes by tag combinations (multiple tags)</li> <li> Can hide/show tag categories (if hierarchical)</li> </ul>"},{"location":"development/regression-testing/#64-galleries-page","title":"6.4 Galleries Page","text":"<ul> <li> Galleries grid loads with cover images</li> <li> Can search galleries by title</li> <li> Can filter galleries by performer/studio/tag</li> <li> Clicking gallery navigates to gallery viewer</li> <li> Gallery viewer shows all images in grid or slideshow</li> <li> Can navigate images with arrow keys or swipe</li> <li> Can zoom images</li> <li> Can download images</li> <li> Can rate gallery (if rating feature exists)</li> </ul>"},{"location":"development/regression-testing/#65-groupsmovies-page","title":"6.5 Groups/Movies Page","text":"<ul> <li> Groups grid loads with cover images</li> <li> Can search groups by name</li> <li> Can filter groups by studio/performer/tag</li> <li> Clicking group navigates to group details</li> <li> Group details show scene list in correct order</li> <li> Can play group as playlist (scenes in order)</li> <li> Can reorder scenes in group (if editing is allowed)</li> </ul>"},{"location":"development/regression-testing/#7-ratings-and-favorites","title":"7. Ratings and Favorites","text":""},{"location":"development/regression-testing/#71-rating-scenes","title":"7.1 Rating Scenes","text":"<ul> <li> Can rate scene from 0-100 (or 0-5 stars)</li> <li> Rating updates immediately on scene card</li> <li> Rating persists across sessions</li> <li> Can change rating multiple times</li> <li> Can clear rating (set to null/unrated)</li> <li> Average rating shown alongside user rating (if Stash has community ratings)</li> </ul>"},{"location":"development/regression-testing/#72-favorite-scenes","title":"7.2 Favorite Scenes","text":"<ul> <li> Can mark scene as favorite (heart icon)</li> <li> Favorite status toggles on/off</li> <li> Favorite indicator visible on scene card</li> <li> Can filter scenes to show only favorites</li> <li> Favorites persist across sessions</li> </ul>"},{"location":"development/regression-testing/#73-rating-other-entities","title":"7.3 Rating Other Entities","text":"<p>Test for Performers, Studios, Tags, Galleries, Groups:</p> <ul> <li> Can rate each entity type</li> <li> Can favorite each entity type</li> <li> Ratings and favorites persist</li> <li> Can filter by rating/favorite status</li> </ul>"},{"location":"development/regression-testing/#8-user-settings-and-preferences","title":"8. User Settings and Preferences","text":""},{"location":"development/regression-testing/#81-general-settings","title":"8.1 General Settings","text":"<p>Location: Settings page \u2192 General Settings section</p> <ul> <li> Can change default video quality (auto, 1080p, 720p, 480p, 360p)</li> <li> Can change playback mode (auto, direct, transcode)</li> <li> Can change theme (multiple built-in themes available)</li> <li> Can change preview quality (sprite, webp, mp4)</li> <li> Can toggle preview autoplay on hover (On/Off)</li> <li> Can change minimum play percent (0-100% slider)</li> <li> Can change default sort order for scenes</li> <li> Can change scenes per page (if configurable)</li> <li> Settings save immediately or on \"Save\" button click</li> <li> Settings apply immediately (no page refresh required for most)</li> </ul>"},{"location":"development/regression-testing/#82-carousel-preferences","title":"8.2 Carousel Preferences","text":"<p>Location: Settings page \u2192 Homepage Carousels section</p> <ul> <li> Can toggle hardcoded carousels on/off (Continue Watching, High Rated, etc.)</li> <li> Can reorder carousels with up/down buttons</li> <li> Changes reflect on home page after save</li> </ul>"},{"location":"development/regression-testing/#83-custom-carousels","title":"8.3 Custom Carousels","text":"<p>Location: Settings page \u2192 Homepage Carousels \u2192 Create Carousel</p> <ul> <li> Can create custom carousel with title and icon</li> <li> Can add filter rules (performers, tags, rating, etc.)</li> <li> Preview shows matching scenes before save</li> <li> Save is disabled until preview succeeds</li> <li> Can edit existing custom carousel</li> <li> Can delete custom carousel</li> <li> Custom carousel appears on homepage</li> <li> Maximum 15 custom carousels enforced</li> <li> Filter options are sorted alphabetically</li> <li> Scene titles use basename fallback when no title</li> </ul>"},{"location":"development/regression-testing/#84-navigation-preferences","title":"8.4 Navigation Preferences","text":"<p>Location: Settings page \u2192 Navigation Settings section</p> <ul> <li> Can toggle sidebar visibility (always visible, collapsible, hidden)</li> <li> Can toggle top bar elements (show/hide search, user menu, etc.)</li> <li> Can configure keyboard shortcuts (if customizable)</li> </ul>"},{"location":"development/regression-testing/#85-filter-presets","title":"8.5 Filter Presets","text":"<p>Location: Settings page \u2192 Filter Presets section</p> <ul> <li> Can view saved filter presets</li> <li> Can edit filter preset name/description</li> <li> Can delete filter preset</li> <li> Can set default filter preset (auto-loads on scenes page)</li> <li> Can export/import filter presets (JSON file)</li> </ul>"},{"location":"development/regression-testing/#86-hidden-items-user-feature","title":"8.6 Hidden Items (User Feature)","text":"<p>Location: Settings page \u2192 link to Hidden Items page</p> <ul> <li> Can hide individual scenes, performers, studios, tags, galleries, groups</li> <li> Hidden items link in Settings navigates to Hidden Items page</li> <li> Hidden Items page shows all hidden entities grouped by type</li> <li> Can unhide items from Hidden Items page</li> <li> \"Show Hidden Items\" toggle on filter panels reveals hidden content</li> <li> Hidden items persist across sessions</li> </ul>"},{"location":"development/regression-testing/#86-content-restrictions-admin-feature","title":"8.6 Content Restrictions (Admin Feature)","text":"<p>Location: User Management page \u2192 Content Restrictions modal (admin only)</p> <p>Note: This is an admin-only feature for managing per-user content restrictions, separate from user-level hidden items.</p> <ul> <li> Admin can access Content Restrictions modal from User Management</li> <li> Can set INCLUDE mode (user sees only specified groups/tags/studios/galleries)</li> <li> Can set EXCLUDE mode (user doesn't see specified groups/tags/studios/galleries)</li> <li> Can select multiple groups, tags, studios, galleries for restriction</li> <li> Restrictions apply only to the selected user</li> <li> Restrictions apply immediately across all pages for that user</li> <li> Restrictions persist across sessions</li> <li> Can clear all restrictions for a user</li> </ul>"},{"location":"development/regression-testing/#9-keyboard-navigation-and-shortcuts","title":"9. Keyboard Navigation and Shortcuts","text":""},{"location":"development/regression-testing/#91-global-shortcuts","title":"9.1 Global Shortcuts","text":"<p>Precondition: Focus on main application (not in text input)</p> <ul> <li> <code>Space</code> or <code>K</code> pauses/plays video (in player)</li> <li> <code>F</code> toggles fullscreen (in player)</li> <li> <code>M</code> toggles mute (in player)</li> <li> <code>Left/Right</code> arrow keys seek video (\u00b15 seconds)</li> <li> <code>Up/Down</code> arrow keys adjust volume (\u00b15%)</li> <li> <code>J/L</code> keys seek video (\u00b110 seconds)</li> <li> <code>Home/End</code> keys jump to start/end of video</li> <li> <code>Shift+&gt;/Shift+&lt;</code> adjust playback speed</li> <li> <code>Shift+N/Shift+P</code> next/previous scene in playlist</li> <li> Media hardware keys (Play/Pause, FastForward, Rewind, TrackNext, TrackPrevious)</li> <li> <code>0-9</code> seek to percentage (1 = 10%, 5 = 50%, etc.)</li> <li> <code>Esc</code> exits fullscreen or closes modals</li> <li> <code>/</code> focuses search bar</li> <li> <code>?</code> opens keyboard shortcuts help modal (if implemented)</li> </ul>"},{"location":"development/regression-testing/#92-scene-grid-navigation","title":"9.2 Scene Grid Navigation","text":"<p>Precondition: Focus on scenes grid (not in search/filter)</p> <ul> <li> Arrow keys navigate between scene cards</li> <li> <code>Enter</code> plays selected scene</li> <li> <code>A</code> adds selected scene to playlist</li> <li> <code>H</code> hides selected scene</li> <li> <code>R</code> opens rating modal for selected scene</li> <li> Tab/Shift+Tab navigates focusable elements</li> </ul>"},{"location":"development/regression-testing/#93-tv-mode-navigation","title":"9.3 TV Mode Navigation","text":"<p>Precondition: TV Mode enabled (if applicable)</p> <ul> <li> D-pad navigation works (arrow keys simulate remote)</li> <li> Enter/Select button activates items</li> <li> Back button exits player or modals</li> <li> Focus indicators are clearly visible</li> <li> No keyboard traps (can always navigate out)</li> </ul>"},{"location":"development/regression-testing/#10-server-settings-and-admin-features","title":"10. Server Settings and Admin Features","text":""},{"location":"development/regression-testing/#101-server-information","title":"10.1 Server Information","text":"<p>Precondition: Logged in as admin</p> <p>Location: Settings page \u2192 Server tab</p> <ul> <li> Server version displayed correctly (matches package.json)</li> <li> Stash server URL displayed</li> <li> Stash server version displayed (fetched from Stash API)</li> <li> Database location displayed</li> <li> Cache directory location displayed</li> <li> Uptime displayed (time since server start)</li> </ul>"},{"location":"development/regression-testing/#102-cache-management","title":"10.2 Cache Management","text":"<p>Location: Settings page \u2192 Server tab \u2192 Cache section</p> <ul> <li> Can view cache status (last refresh time, entity counts)</li> <li> Can manually refresh cache (button triggers refresh)</li> <li> Cache refresh shows progress indicator</li> <li> Cache refresh completes without errors</li> <li> Scene count updates after cache refresh</li> <li> New scenes from Stash appear after cache refresh</li> </ul>"},{"location":"development/regression-testing/#103-path-mappings","title":"10.3 Path Mappings","text":"<p>Location: Settings page \u2192 Server tab \u2192 Path Mappings section</p> <ul> <li> Can view existing path mappings (Stash path \u2192 Peek path)</li> <li> Can add new path mapping</li> <li> Can edit existing path mapping</li> <li> Can delete path mapping (requires confirmation)</li> <li> Invalid paths show validation error</li> <li> Path mappings apply immediately (no restart required)</li> <li> Test path translation feature works (if exists)</li> </ul>"},{"location":"development/regression-testing/#104-update-checker","title":"10.4 Update Checker","text":"<p>Location: Settings page \u2192 Server tab \u2192 Updates section</p> <ul> <li> Current version displayed</li> <li> \"Check for updates\" button queries GitHub API</li> <li> If update available, shows banner with version number and changelog link</li> <li> If no update, shows \"Up to date\" message</li> <li> Clicking changelog link opens GitHub release page in new tab</li> </ul>"},{"location":"development/regression-testing/#11-error-handling-and-edge-cases","title":"11. Error Handling and Edge Cases","text":""},{"location":"development/regression-testing/#111-network-errors","title":"11.1 Network Errors","text":"<p>Test Scenarios:</p> <ul> <li> Stash server offline: App shows error message, doesn't crash</li> <li> Stash server slow: Loading indicators appear, requests timeout gracefully</li> <li> Invalid Stash API key: Setup wizard or settings page shows authentication error</li> <li> Network interruption during playback: Video pauses, shows buffering indicator, resumes when network recovers</li> </ul>"},{"location":"development/regression-testing/#112-invalid-data-handling","title":"11.2 Invalid Data Handling","text":"<p>Test Scenarios:</p> <ul> <li> Scene with missing file: Shows error message instead of playing, doesn't crash app</li> <li> Scene with invalid path mapping: Shows error message, allows user to update path mappings</li> <li> Corrupted video file: FFmpeg fails gracefully, shows error message</li> <li> Scene with no duration: Displays \"Unknown duration\" or defaults to 0, doesn't crash</li> <li> Scene with no title: Displays filename or \"Untitled\" instead of crashing</li> </ul>"},{"location":"development/regression-testing/#113-permission-errors","title":"11.3 Permission Errors","text":"<p>Test Scenarios:</p> <ul> <li> Non-admin tries to access admin features: Redirected or shown \"Access Denied\" message</li> <li> Expired JWT token: Redirected to login page with message \"Session expired\"</li> <li> Invalid JWT token: Redirected to login page, doesn't crash</li> </ul>"},{"location":"development/regression-testing/#114-database-errors","title":"11.4 Database Errors","text":"<p>Test Scenarios (requires simulating DB issues):</p> <ul> <li> Database locked: Shows error message, retries operation</li> <li> Database migration fails: Server logs error, shows setup wizard or maintenance page</li> <li> Database corruption: Server detects and shows recovery instructions</li> </ul>"},{"location":"development/regression-testing/#115-browser-compatibility","title":"11.5 Browser Compatibility","text":"<p>Test on Multiple Browsers:</p> <ul> <li> Chrome/Edge: All features work</li> <li> Firefox: All features work</li> <li> Safari: All features work (if targeting macOS/iOS)</li> <li> Mobile browsers: Responsive layout, touch controls work</li> </ul>"},{"location":"development/regression-testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/regression-testing/#121-load-times","title":"12.1 Load Times","text":"<ul> <li> Initial page load: &lt;3 seconds on broadband connection</li> <li> Scene grid load: &lt;2 seconds for first 40 scenes</li> <li> Video player load: &lt;3 seconds to first frame (direct playback)</li> <li> HLS stream start: &lt;5 seconds to first frame (transcoded playback)</li> <li> Search/filter response: &lt;500ms for typical library (&lt;10,000 scenes)</li> </ul>"},{"location":"development/regression-testing/#122-resource-usage","title":"12.2 Resource Usage","text":"<p>Precondition: Monitor browser DevTools Performance tab</p> <ul> <li> Memory usage: No memory leaks during 30-minute session</li> <li> CPU usage: &lt;20% CPU during idle browsing (not playing video)</li> <li> Network usage: Only necessary requests (no redundant API calls)</li> </ul>"},{"location":"development/regression-testing/#123-concurrent-sessions","title":"12.3 Concurrent Sessions","text":"<p>Test Scenarios:</p> <ul> <li> Multiple browser tabs: Can play different videos in 2+ tabs simultaneously</li> <li> Multiple users: 2+ users can log in and use app concurrently without interference</li> <li> Transcoding sessions: Multiple concurrent HLS streams don't exhaust server resources</li> </ul>"},{"location":"development/regression-testing/#mobile-and-responsive-testing","title":"Mobile and Responsive Testing","text":""},{"location":"development/regression-testing/#131-mobile-layout","title":"13.1 Mobile Layout","text":"<p>Precondition: Test on mobile device or browser DevTools mobile emulation</p> <ul> <li> Scenes grid adapts to narrow viewport (1-2 columns)</li> <li> Navigation menu becomes hamburger or bottom nav</li> <li> Scene cards remain readable and tappable (no tiny text/buttons)</li> <li> Video player controls are touch-friendly (large buttons)</li> <li> Search bar and filters accessible on mobile</li> <li> Settings page scrollable and functional</li> </ul>"},{"location":"development/regression-testing/#132-touch-controls","title":"13.2 Touch Controls","text":"<ul> <li> Tap scene card to play</li> <li> Swipe to scroll scene grid</li> <li> Pinch to zoom images (in galleries)</li> <li> Tap player controls to pause/play/seek</li> <li> Double-tap player to toggle fullscreen</li> <li> Swipe to navigate between scenes in playlist (if applicable)</li> </ul>"},{"location":"development/regression-testing/#post-release-monitoring","title":"Post-Release Monitoring","text":"<p>After deploying a new version to production:</p> <ol> <li>Check server logs: Look for errors or warnings in first 24 hours</li> <li>Monitor user reports: Track GitHub issues for bug reports</li> <li>Check update notifications: Verify users see update banner if applicable</li> <li>Database migrations: Confirm migrations ran successfully on user instances</li> <li>Performance: Monitor server resource usage (CPU, memory, disk) for anomalies</li> </ol>"},{"location":"development/regression-testing/#test-report-template","title":"Test Report Template","text":"<p>After completing regression testing, document results:</p> <pre><code>**Peek Stash Browser - Regression Test Report**\n\n**Version Tested**: 1.X.X\n**Test Date**: YYYY-MM-DD\n**Tester**: [Your Name]\n**Environment**:\n- Docker Version: X.X.X\n- Browser(s): Chrome X.X, Firefox X.X\n- Stash Version: X.X.X\n- Test Library Size: X scenes, Y performers, Z studios\n\n**Test Results Summary**:\n- Total Tests: X\n- Passed: X\n- Failed: X\n- Skipped: X (with reason)\n\n**Critical Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**High Priority Issues Found**:\n1. [Issue description, steps to reproduce, severity]\n2. ...\n\n**Medium/Low Priority Issues**:\n- [Brief list]\n\n**Recommendation**: \u2705 Ready for release / \u26a0\ufe0f Release with known issues / \u274c Do not release\n\n**Additional Notes**:\n[Any observations, performance notes, or suggestions]\n</code></pre>"},{"location":"development/regression-testing/#automation-recommendations","title":"Automation Recommendations","text":"<p>For future improvements, consider automating these tests:</p> <ul> <li>Unit tests: Core utility functions (path mapping, filter logic, etc.)</li> <li>Integration tests: API endpoints with mock data</li> <li>End-to-end tests: Playwright or Cypress for critical user flows (login, playback, search)</li> <li>Visual regression tests: Screenshot comparison for UI changes</li> <li>Performance tests: Lighthouse CI for page load metrics</li> </ul>"},{"location":"development/regression-testing/#updating-this-document","title":"Updating This Document","text":"<p>As new features are added, update this regression testing guide:</p> <ol> <li>Add new test sections for new features (e.g., \"14. Social Features\")</li> <li>Update existing tests if feature behavior changes</li> <li>Archive obsolete tests (mark as \"Deprecated\" if removed)</li> <li>Keep test steps concise and actionable</li> <li>Include preconditions and expected results for clarity</li> </ol> <p>Last Updated: 2025-01-21 (Version 1.6.0)</p>"},{"location":"development/technical-overview/","title":"Peek Technical Overview","text":"<p>This document serves as a reference for entity types, relationships, and content filtering architecture in Peek. It's designed to be consulted when working on features that interact with the data model.</p>"},{"location":"development/technical-overview/#entity-types","title":"Entity Types","text":"<p>Peek mirrors Stash's entity model, caching entities locally in SQLite. This enables: - Performant queries \u2014 No network round-trips to Stash for library browsing - Per-user features \u2014 Content restrictions, hidden items, ratings, favorites, watch history - Offline resilience \u2014 Library remains accessible if Stash is temporarily unavailable</p> Entity Stash Source Peek Cache Table Notes Scene \u2713 <code>StashScene</code> Primary content type Performer \u2713 <code>StashPerformer</code> Studio \u2713 <code>StashStudio</code> Has parent/child hierarchy Tag \u2713 <code>StashTag</code> Has parent/child DAG Group \u2713 <code>StashGroup</code> Has parent/child hierarchy (containing_groups/sub_groups) Gallery \u2713 <code>StashGallery</code> Contains Images Image \u2713 <code>StashImage</code> Playlist Peek-only <code>Playlist</code> User-created scene collections SceneMarker \u2713 Not cached Clips from Scenes (future feature)"},{"location":"development/technical-overview/#entity-relationships","title":"Entity Relationships","text":""},{"location":"development/technical-overview/#scene-relationships","title":"Scene Relationships","text":"Related Entity Cardinality Junction Table Notes Studio Many-to-One \u2014 <code>StashScene.studioId</code> Performer Many-to-Many <code>ScenePerformer</code> Tag Many-to-Many <code>SceneTag</code> Group Many-to-Many <code>SceneGroup</code> Includes <code>sceneIndex</code> for ordering Gallery Many-to-Many <code>SceneGallery</code>"},{"location":"development/technical-overview/#performer-relationships","title":"Performer Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>ScenePerformer</code> Inverse of Scene\u2192Performer Tag Many-to-Many <code>PerformerTag</code> Image Many-to-Many <code>ImagePerformer</code> Gallery Many-to-Many <code>GalleryPerformer</code> Group \u2014 \u2014 Computed by Stash (performers appearing in group's scenes)"},{"location":"development/technical-overview/#studio-relationships","title":"Studio Relationships","text":"Related Entity Cardinality Junction Table Notes Scene One-to-Many \u2014 Inverse of Scene\u2192Studio Tag Many-to-Many <code>StudioTag</code> Image One-to-Many \u2014 <code>StashImage.studioId</code> Gallery One-to-Many \u2014 <code>StashGallery.studioId</code> Parent Studio Many-to-One \u2014 <code>StashStudio.parentId</code> Child Studios One-to-Many \u2014 Inverse of parentId Group \u2014 \u2014 Computed by Stash (groups with this studio)"},{"location":"development/technical-overview/#tag-relationships","title":"Tag Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneTag</code> Inverse of Scene\u2192Tag Performer Many-to-Many <code>PerformerTag</code> Inverse of Performer\u2192Tag Studio Many-to-Many <code>StudioTag</code> Inverse of Studio\u2192Tag Group Many-to-Many <code>GroupTag</code> Inverse of Group\u2192Tag Gallery Many-to-Many <code>GalleryTag</code> Inverse of Gallery\u2192Tag Image Many-to-Many <code>ImageTag</code> Inverse of Image\u2192Tag Parent Tags Many-to-Many \u2014 <code>StashTag.parentIds</code> (JSON array) Child Tags Many-to-Many \u2014 Inverse, resolved at runtime <p>Note: Tag hierarchies form a DAG (directed acyclic graph), not a tree. Tags can have multiple parents.</p>"},{"location":"development/technical-overview/#group-relationships","title":"Group Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneGroup</code> Includes <code>sceneIndex</code> for ordering Tag Many-to-Many <code>GroupTag</code> Studio Many-to-One \u2014 <code>StashGroup.studioId</code> Containing Groups Many-to-Many \u2014 Via Stash <code>containing_groups</code> Sub Groups Many-to-Many \u2014 Via Stash <code>sub_groups</code>"},{"location":"development/technical-overview/#gallery-relationships","title":"Gallery Relationships","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>SceneGallery</code> Inverse of Scene\u2192Gallery Performer Many-to-Many <code>GalleryPerformer</code> Tag Many-to-Many <code>GalleryTag</code> Studio Many-to-One \u2014 <code>StashGallery.studioId</code> Image One-to-Many <code>ImageGallery</code>"},{"location":"development/technical-overview/#image-relationships","title":"Image Relationships","text":"Related Entity Cardinality Junction Table Notes Gallery Many-to-Many <code>ImageGallery</code> Performer Many-to-Many <code>ImagePerformer</code> Tag Many-to-Many <code>ImageTag</code> Studio Many-to-One \u2014 <code>StashImage.studioId</code>"},{"location":"development/technical-overview/#playlist-relationships-peek-only","title":"Playlist Relationships (Peek-only)","text":"Related Entity Cardinality Junction Table Notes Scene Many-to-Many <code>PlaylistItem</code> Includes <code>position</code> for ordering User Many-to-One \u2014 <code>Playlist.userId</code>"},{"location":"development/technical-overview/#pseudo-relationships-inheritance","title":"Pseudo-Relationships (Inheritance)","text":"<p>Some relationships are \"inherited\" for display/search/filtering purposes.</p>"},{"location":"development/technical-overview/#scene-tag-inheritance","title":"Scene Tag Inheritance","text":"<p>When filtering Scenes (e.g., for content restrictions), Tags are collected from multiple sources:</p> Source Description Direct Scene Tags Explicitly assigned to the scene Performer Tags Tags on any Performer in the scene Studio Tags Tags on the scene's Studio Group Tags Tags on any Group the scene belongs to <p>Implementation: <code>UserRestrictionService.getSceneEntityIds()</code> collects tags from all sources.</p> <p>Rationale: If a Tag represents content that should be restricted (e.g., \"explicit\"), that restriction should apply whether the tag is on the scene directly, on a performer in the scene, on the studio, or on a thematic group/series.</p>"},{"location":"development/technical-overview/#image-gallery-inheritance","title":"Image Gallery Inheritance","text":"<p>Images can inherit metadata from their parent Gallery during sync. This denormalization enables simpler queries and consistent filtering.</p> Field Inheritance Behavior Performers Inherit from Gallery if Image has none Tags Inherit from Gallery if Image has none Studio Inherit from Gallery if Image has none Date Inherit from Gallery if Image has none Photographer Inherit from Gallery if Image has none Details Inherit from Gallery if Image has none <p>Note: Image <code>title</code> is NOT inherited \u2014 each image keeps its own name.</p> <p>Status: Not yet implemented. Currently Images only have their directly-assigned metadata.</p>"},{"location":"development/technical-overview/#stash-communication-patterns","title":"Stash Communication Patterns","text":"<p>Peek communicates with Stash in several ways. Understanding these patterns is important for performance and consistency.</p>"},{"location":"development/technical-overview/#expected-patterns","title":"Expected Patterns","text":"Pattern Purpose Examples Sync Fetch entities to cache locally <code>StashSyncService</code> fetching scenes, performers, etc. Write-back Sync user data to Stash Ratings, favorites, watch history, O-counter Media proxy Stream video/captions through Peek <code>video.ts</code> proxying HLS streams Metadata edit User edits entity metadata Scene/performer/studio/tag updates"},{"location":"development/technical-overview/#known-issues-direct-stash-queries","title":"Known Issues: Direct Stash Queries","text":"<p>These locations query Stash directly for UI display, bypassing the cache. This causes bugs and performance issues.</p> Location Issue Impact Fix <code>playlist.ts:76,165</code> Fetches scene data from Stash for playlist display Shows Stash's O-counter/favorite instead of user's Peek values Query from <code>StashScene</code> cache <code>watchHistory.ts:61</code> Fetches scene duration from Stash on every 10-second ping Unnecessary network calls during playback Store duration in cache (available in <code>files[0].duration</code>) <p>Principle: All UI data should come from Peek's cache. Stash should only be queried for sync operations and media streaming.</p>"},{"location":"development/technical-overview/#content-visibility-system","title":"Content Visibility System","text":"<p>Peek has two mechanisms for hiding content from users. Both cascade (hiding a Tag hides all content with that Tag), but they differ in who controls them and whether they can be undone.</p>"},{"location":"development/technical-overview/#restricted-content-admin-controlled","title":"Restricted Content (Admin-Controlled)","text":"<p>Purpose: Admins restrict content that specific users should never see (e.g., age-inappropriate content, legal restrictions).</p> <p>Storage: <code>UserContentRestriction</code> table</p> Column Type Description <code>userId</code> Int Target user <code>entityType</code> String <code>'groups'</code>, <code>'tags'</code>, <code>'studios'</code>, <code>'galleries'</code> <code>mode</code> String <code>'INCLUDE'</code> (whitelist) or <code>'EXCLUDE'</code> (blacklist) <code>entityIds</code> String JSON array of entity IDs <code>restrictEmpty</code> Boolean Also hide items with no entities of this type <p>Key behaviors: - Only admins can set restrictions (via Server Settings) - Users cannot see or modify their restrictions - Users cannot bypass restrictions - Supports both whitelist (INCLUDE) and blacklist (EXCLUDE) modes - Can restrict by: Tags, Groups, Studios, Galleries</p> <p>Cascading: - Tag restriction \u2192 Hides Scenes/Performers/Studios with that Tag (including inherited tags) - Group restriction \u2192 Hides Scenes in that Group - Studio restriction \u2192 Hides Scenes from that Studio - Gallery restriction \u2192 Hides Scenes linked to that Gallery</p>"},{"location":"development/technical-overview/#hidden-content-user-controlled","title":"Hidden Content (User-Controlled)","text":"<p>Purpose: Users hide content they personally don't want to see. They can undo this at any time.</p> <p>Storage: <code>UserHiddenEntity</code> table</p> Column Type Description <code>userId</code> Int User who hid the entity <code>entityType</code> String Any entity type <code>entityId</code> String Stash entity ID <code>hiddenAt</code> DateTime When it was hidden <p>Key behaviors: - Users control their own hidden items - Users can view and unhide items via Settings - Supports all entity types: Scene, Performer, Studio, Tag, Group, Gallery, Image - Admins still see their own hidden items (they can hide content for personal preference)</p> <p>Cascading: - Hidden Performer \u2192 Hides Scenes with that Performer - Hidden Studio \u2192 Hides Scenes from that Studio - Hidden Tag \u2192 Hides Scenes/Performers/Studios with that Tag (including inherited) - Hidden Group \u2192 Hides Scenes in that Group - Hidden Gallery \u2192 Hides Scenes linked to that Gallery, Images in Gallery</p>"},{"location":"development/technical-overview/#processing-order","title":"Processing Order","text":"<p>Content filtering happens in this order: 1. INCLUDE restrictions (intersection) \u2014 must match ALL includes 2. EXCLUDE restrictions (difference) \u2014 must not match ANY excludes 3. Hidden entity filtering (cascade) 4. Empty entity filtering \u2014 remove organizational entities with no visible content</p>"},{"location":"development/technical-overview/#empty-entity-filtering","title":"Empty Entity Filtering","text":"<p>After restrictions/hiding are applied, organizational entities with no remaining content are removed. Order matters due to dependencies:</p> <ol> <li>Galleries \u2014 Keep if <code>image_count &gt; 0</code></li> <li>Groups \u2014 Keep if has scenes OR has sub-groups with content (tree traversal)</li> <li>Studios \u2014 Keep if appears in visible scenes OR has visible groups/galleries OR has child studios with content</li> <li>Performers \u2014 Keep if appears in visible scenes OR has images OR in visible groups/galleries</li> <li>Tags \u2014 Keep if attached to any visible entity OR has children with content (DAG traversal)</li> </ol> <p>Current limitation: Empty filtering uses scene/image counts from Stash metadata, not restriction-aware counts. A workaround passes <code>visibleScenes</code> to the filter methods.</p>"},{"location":"development/technical-overview/#current-architecture-issues","title":"Current Architecture Issues","text":""},{"location":"development/technical-overview/#problem-in-memory-filtering-doesnt-scale","title":"Problem: In-Memory Filtering Doesn't Scale","text":"<p>The current implementation loads all entities into memory then filters:</p> <pre><code>1. Load ALL scenes from cache\n2. Filter in JavaScript (UserRestrictionService)\n3. Filter empty entities (EmptyEntityFilterService)\n4. Paginate\n</code></pre> <p>This works for small collections but becomes problematic with: - 10k+ scenes - Multiple concurrent users - Complex restriction rules</p>"},{"location":"development/technical-overview/#problem-redundant-computation","title":"Problem: Redundant Computation","text":"<p>Every request recomputes: - Which entities are hidden for this user - Which scenes match restriction rules - Which organizational entities are now empty</p> <p><code>FilteredEntityCacheService</code> helps but is invalidated frequently.</p>"},{"location":"development/technical-overview/#problem-pagination-breaks","title":"Problem: Pagination Breaks","text":"<p>To paginate correctly, we need to know the total count of visible items. Currently: 1. Load ALL items 2. Filter ALL items 3. Get count 4. Return page slice</p> <p>This defeats the purpose of pagination for large collections.</p>"},{"location":"development/technical-overview/#proposed-architecture-pre-computed-exclusions","title":"Proposed Architecture: Pre-Computed Exclusions","text":""},{"location":"development/technical-overview/#core-concept","title":"Core Concept","text":"<p>Instead of filtering at query time, pre-compute and store excluded entity IDs per user. Queries become simple JOINs:</p> <pre><code>-- Get visible scenes for user 5, page 1\nSELECT s.* FROM StashScene s\nLEFT JOIN UserExcludedEntity e\n  ON e.userId = 5\n  AND e.entityType = 'scene'\n  AND e.entityId = s.id\nWHERE e.id IS NULL  -- Not in exclusion list\n  AND s.deletedAt IS NULL\nORDER BY s.stashCreatedAt DESC\nLIMIT 25 OFFSET 0\n</code></pre>"},{"location":"development/technical-overview/#proposed-schema","title":"Proposed Schema","text":"<pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  // Why is this excluded? (for debugging, not query logic)\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  sourceType String?  // If cascade: which entity type caused it\n  sourceId   String?  // If cascade: which entity ID caused it\n\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])      // Primary query index\n  @@index([entityType, entityId])    // For cascade lookups (\"what users exclude this?\")\n}\n\n// Pre-computed visible counts per entity type (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', etc.\n  visibleCount Int      // total entities - excluded entities\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre>"},{"location":"development/technical-overview/#key-design-decisions","title":"Key Design Decisions","text":"<p>1. Single table vs separate tables?</p> <p>Single <code>UserExcludedEntity</code> table is preferred: - Simpler schema - Single JOIN pattern for all queries - <code>reason</code> column distinguishes restriction vs hidden - <code>sourceType</code>/<code>sourceId</code> enable cascade debugging</p> <p>2. How are IDs unique?</p> <p>Stash entity IDs are integers per entity type, NOT globally unique. Scene #1 and Performer #1 can coexist.</p> <p>The composite unique constraint <code>@@unique([userId, entityType, entityId])</code> handles this: - User 5 + scene + \"1\" = one record - User 5 + performer + \"1\" = different record</p> <p>3. Store exclusions vs inclusions?</p> <p>Store exclusions (what to hide): - Most users see most content (exclusions are smaller set) - Simpler query pattern (LEFT JOIN + WHERE NULL) - Easier to reason about</p> <p>4. How to distinguish restricted vs hidden?</p> <p>The <code>reason</code> column: - <code>'restricted'</code> \u2014 Admin set a restriction rule matching this entity - <code>'hidden'</code> \u2014 User explicitly hid this entity - <code>'cascade'</code> \u2014 Hidden due to a related entity being restricted/hidden - <code>'empty'</code> \u2014 Organizational entity with no visible content</p> <p>Users can query their hidden items for the unhide UI: <pre><code>SELECT * FROM UserExcludedEntity\nWHERE userId = ? AND reason = 'hidden'\n</code></pre></p> <p>5. When to recompute?</p> <p>Recompute exclusions when: - Stash sync completes (new/updated entities) - Admin changes restrictions for a user - User hides/unhides an entity - Entity relationships change (rare, usually via Stash)</p> <p>Recomputation is per-user and can be done incrementally for hide/unhide operations.</p>"},{"location":"development/technical-overview/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"development/technical-overview/#target-scale","title":"Target Scale","text":"<p>Some Stash users have 100TB+ collections with millions of images and scenes. The exclusion system must handle: - 1M+ scenes per instance - 1M+ images per instance - Multiple users with different restrictions - Worst case: 50% of content excluded per user</p>"},{"location":"development/technical-overview/#exclusion-table-size-estimates","title":"Exclusion Table Size Estimates","text":"Scenario Exclusion Records Table Size 1M scenes, 10% excluded, 1 user ~100k rows ~10MB 1M scenes, 50% excluded, 5 users ~2.5M rows ~250MB 2M entities, 30% excluded, 10 users ~6M rows ~600MB"},{"location":"development/technical-overview/#performance-characteristics","title":"Performance Characteristics","text":"<p>Query performance (with proper indexes): - Index lookup: O(log n) \u2014 ~20 comparisons for 1M rows - JOIN is efficient because all join columns are indexed - SQLite page cache keeps hot indexes in memory</p> <p>Potential bottlenecks:</p> Concern Mitigation Full recomputation time Never do full recompute except initial setup; use incremental updates COUNT queries Pre-compute visible counts in <code>UserEntityStats</code> table Index memory ~250MB for 5M rows is acceptable for modern servers Cascade complexity Track <code>sourceType</code>/<code>sourceId</code> to enable targeted updates"},{"location":"development/technical-overview/#incremental-update-strategy","title":"Incremental Update Strategy","text":"<p>Hide entity (fast, ~10-100 inserts): 1. Insert exclusion with <code>reason='hidden'</code> 2. Find cascading entities via junction tables 3. Insert cascade exclusions with <code>sourceType</code>/<code>sourceId</code> 4. Decrement <code>visibleCount</code> in <code>UserEntityStats</code></p> <p>Unhide entity (medium, may need partial recompute): 1. Delete exclusion where <code>reason='hidden'</code> AND entity matches 2. Delete cascade exclusions where <code>sourceId</code> matches 3. Re-check if any cascades should remain (other hidden entities may still exclude them) 4. Update <code>visibleCount</code> in <code>UserEntityStats</code></p> <p>Stash sync (diff-based): 1. Compare new entity list with cached list 2. For new entities: check if any restriction rules apply 3. For deleted entities: remove from exclusion table 4. For modified entities: recompute if relationships changed</p>"},{"location":"development/technical-overview/#future-optimization-table-splitting","title":"Future Optimization: Table Splitting","text":"<p>If performance issues arise at 10M+ exclusion rows, consider splitting: - <code>UserExcludedScene</code> \u2014 highest volume - <code>UserExcludedImage</code> \u2014 highest volume - <code>UserExcludedEntity</code> \u2014 for performers, studios, tags, groups, galleries (lower volume)</p> <p>Start with single table; split only if actual performance issues occur.</p>"},{"location":"development/technical-overview/#update-triggers","title":"Update Triggers","text":"<p>Pre-computed exclusions need updating when:</p> Event Scope Action Stash sync (full) All users Diff-based recompute Stash sync (incremental) All users Recompute affected entities only Admin changes restriction One user Recompute that user User hides entity One user Incremental add User unhides entity One user Incremental remove + cascade check"},{"location":"development/technical-overview/#migration-strategy","title":"Migration Strategy","text":"<ol> <li>Keep existing <code>UserContentRestriction</code> and <code>UserHiddenEntity</code> tables as source of truth</li> <li>Add new <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables</li> <li>Implement <code>ExclusionComputationService</code> with incremental update logic</li> <li>Add trigger points for recomputation (sync complete, restriction change, hide/unhide)</li> <li>Migrate query patterns to use exclusion JOINs</li> <li>Add admin endpoints for manual recomputation</li> <li>Remove in-memory filtering code once stable</li> </ol>"},{"location":"development/technical-overview/#api-changes","title":"API Changes","text":"<p>Minimal external API changes needed. Internal query implementation changes.</p> <p>New admin endpoints: <pre><code>POST /api/admin/recompute-exclusions/:userId\nPOST /api/admin/recompute-exclusions/all\nGET  /api/admin/exclusion-stats\n</code></pre></p>"},{"location":"development/technical-overview/#implementation-notes","title":"Implementation Notes","text":""},{"location":"development/technical-overview/#service-files-current","title":"Service Files (Current)","text":"Service Purpose <code>UserRestrictionService.ts</code> Applies INCLUDE/EXCLUDE rules, hidden entity cascade <code>UserHiddenEntityService.ts</code> CRUD for user hidden entities <code>EmptyEntityFilterService.ts</code> Removes empty organizational entities <code>FilteredEntityCacheService.ts</code> Per-user in-memory cache of filtered results <code>StashCacheManager.ts</code> Server-wide entity cache from Stash"},{"location":"development/technical-overview/#service-files-proposed","title":"Service Files (Proposed)","text":"Service Purpose <code>ExclusionComputationService.ts</code> Computes and maintains <code>UserExcludedEntity</code> table <code>ExclusionQueryService.ts</code> Provides query builders with exclusion JOINs"},{"location":"development/technical-overview/#controller-patterns-current","title":"Controller Patterns (Current)","text":"<p>Library controllers follow this pattern: <pre><code>// 1. Get all entities from cache\nlet scenes = stashCacheManager.getAllScenes();\n\n// 2. Apply user restrictions (if not admin)\nif (user.role !== 'ADMIN') {\n  scenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n}\n\n// 3. Apply empty filtering (if not admin)\nif (user.role !== 'ADMIN') {\n  scenes = emptyEntityFilterService.filterEmptyScenes(scenes, ...);\n}\n\n// 4. Apply search/filter/sort\nscenes = applyFilters(scenes, filters);\n\n// 5. Paginate\nconst page = scenes.slice(offset, offset + limit);\n</code></pre></p>"},{"location":"development/technical-overview/#future-pattern-with-pre-computed-exclusions","title":"Future Pattern (With Pre-Computed Exclusions)","text":"<pre><code>// 1. Query with exclusion JOIN \u2014 filtering, pagination, and count in one query\nconst { scenes, total } = await exclusionQueryService.findScenes(userId, {\n  filters,\n  sort,\n  offset,\n  limit,\n});\n\n// Already filtered, already paginated, already counted\n</code></pre>"},{"location":"development/technical-overview/#appendix-stash-graphql-schema-reference","title":"Appendix: Stash GraphQL Schema Reference","text":"<p>Key entity types from Stash for reference:</p> <ul> <li>Scene: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>groups[]</code>, <code>galleries[]</code>, <code>files[]</code> (contains <code>duration</code>)</li> <li>Performer: <code>id</code>, <code>name</code>, <code>tags[]</code>, <code>scene_count</code>, <code>image_count</code>, <code>gallery_count</code>, <code>group_count</code></li> <li>Studio: <code>id</code>, <code>name</code>, <code>parent_studio</code>, <code>child_studios[]</code>, <code>tags[]</code>, <code>groups[]</code></li> <li>Tag: <code>id</code>, <code>name</code>, <code>parents[]</code>, <code>children[]</code>, various <code>*_count</code> fields</li> <li>Group: <code>id</code>, <code>name</code>, <code>studio</code>, <code>tags[]</code>, <code>containing_groups[]</code>, <code>sub_groups[]</code>, <code>scenes[]</code></li> <li>Gallery: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>scenes[]</code>, <code>image_count</code>, <code>photographer</code>, <code>details</code></li> <li>Image: <code>id</code>, <code>title</code>, <code>date</code>, <code>studio</code>, <code>performers[]</code>, <code>tags[]</code>, <code>galleries[]</code>, <code>photographer</code>, <code>details</code></li> <li>SceneMarker: <code>id</code>, <code>scene</code>, <code>primary_tag</code>, <code>tags[]</code>, <code>seconds</code>, <code>end_seconds</code></li> </ul> <p>Document Version: 3.0 Last Updated: 2025-01-02</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Peek Stash Browser is configured through environment variables and the setup wizard. This page documents all available configuration options.</p>"},{"location":"getting-started/configuration/#stash-connection-setup-wizard","title":"Stash Connection (Setup Wizard)","text":"<p>As of v2.0, Stash connection details are configured via the Setup Wizard and stored in the database:</p> <ul> <li>Stash URL: Your Stash GraphQL endpoint (e.g., <code>http://192.168.1.100:9999/graphql</code>)</li> <li>Stash API Key: API key from Stash Settings \u2192 Security</li> </ul> <p>The wizard runs automatically on first access. No environment variables needed for Stash connection!</p> <p>Upgrading from v1.x? Your existing <code>STASH_URL</code> and <code>STASH_API_KEY</code> environment variables will auto-migrate to the database on first start. You can remove them from your container configuration after successful migration.</p>"},{"location":"getting-started/configuration/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>JWT_SECRET</code> JWT signing key Generate with <code>openssl rand -base64 32</code>"},{"location":"getting-started/configuration/#generating-jwt-secret","title":"Generating JWT Secret","text":"<p>Linux/macOS/unRAID: <pre><code>openssl rand -base64 32\n</code></pre></p> <p>Windows PowerShell: <pre><code>$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n[Convert]::ToBase64String($bytes)\n</code></pre></p>"},{"location":"getting-started/configuration/#optional-environment-variables","title":"Optional Environment Variables","text":"<p>These settings have sensible defaults but can be customized:</p> Variable Description Default Notes <code>DATABASE_URL</code> SQLite database file <code>file:/app/data/peek-stash-browser.db</code> Path inside container <code>CONFIG_DIR</code> App data directory <code>/app/data</code> Database + HLS cache <code>TMP_DIR</code> Transcoding temp directory <code>/app/tmp</code> Needs fast I/O <code>NODE_ENV</code> Environment mode <code>production</code> <code>development</code> or <code>production</code> <code>PROXY_AUTH_HEADER</code> Proxy Auth Header Disabled by default"},{"location":"getting-started/configuration/#video-streaming-v20","title":"Video Streaming (v2.0+)","text":"<p>As of v2.0, Peek streams video directly through Stash - no local media access required!</p> <ul> <li>Videos are proxied through the Stash API</li> <li>No media volume mounts needed</li> <li>No path mapping configuration required</li> <li>Simpler container setup</li> </ul> <p>This is a significant simplification from v1.x which required mounting media directories and configuring path mappings.</p>"},{"location":"getting-started/configuration/#security-settings","title":"Security Settings","text":"Variable Description Default When to Use <code>SECURE_COOKIES</code> Enable secure cookie flag <code>false</code> Set to <code>true</code> when using HTTPS reverse proxy <p>Security Best Practices</p> <ul> <li>Set a strong <code>JWT_SECRET</code> during installation (required)</li> <li>Set <code>SECURE_COOKIES=true</code> when using HTTPS</li> <li>Never expose Peek directly to the internet - always use a reverse proxy</li> <li>Admin credentials are created during setup wizard (no default passwords)</li> <li>Stash API key is stored securely in the database (not in environment variables)</li> </ul>"},{"location":"getting-started/configuration/#proxy-authentication","title":"Proxy Authentication","text":"<p>Peek supports delegating authentication to your reverse proxy (e.g., Nginx, Traefik, Caddy, Authelia, Authentik). This is useful when you already have an authentication system in place and want Peek to trust the authenticated user from the proxy.</p>"},{"location":"getting-started/configuration/#how-it-works","title":"How It Works","text":"<ol> <li>Your reverse proxy handles authentication (SSO, OAuth, basic auth, etc.)</li> <li>The proxy adds a header with the authenticated username to all requests</li> <li>Peek reads this header and looks up the corresponding user in its database</li> <li>If no header is present, Peek falls back to standard JWT token authentication</li> </ol>"},{"location":"getting-started/configuration/#configuration_1","title":"Configuration","text":"<p>Set the <code>PROXY_AUTH_HEADER</code> environment variable to the name of the header your proxy uses:</p> <pre><code>PROXY_AUTH_HEADER=X-Peek-Username\n</code></pre> <p>Common header names: - <code>X-Peek-Username</code> (recommended) - <code>X-Forwarded-User</code> (common with Authelia/Traefik) - <code>Remote-User</code> (common with Nginx auth_request) - <code>X-Auth-Request-User</code> (oauth2-proxy)</p>"},{"location":"getting-started/configuration/#security-requirements","title":"Security Requirements","text":"<p>Critical Security Requirements</p> <p>When using proxy authentication, you MUST ensure:</p> <ol> <li>Peek is NOT accessible directly - Only allow access through the reverse proxy</li> <li>The proxy sanitizes the authentication header - The proxy must strip any user-supplied headers with the same name to prevent header injection attacks</li> <li>Network isolation - Peek should only listen on localhost or a private network, not on public interfaces</li> </ol> <p>Failure to follow these requirements will allow anyone to impersonate any user by setting the header in their request.</p>"},{"location":"getting-started/configuration/#example-nginx-with-auth_request","title":"Example: Nginx with auth_request","text":"<pre><code>location / {\n    # Authentication endpoint\n    auth_request /auth;\n\n    # Pass authenticated username to Peek\n    auth_request_set $user $upstream_http_x_auth_user;\n    proxy_set_header Remote-User $user;\n\n    # CRITICAL: Strip any user-provided Remote-User headers\n    proxy_set_header Remote-User \"\";  # Clear first\n    proxy_set_header Remote-User $user;  # Then set from auth\n\n    # Proxy to Peek\n    proxy_pass http://localhost:6969;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n}\n</code></pre> <pre><code># Peek configuration\nPROXY_AUTH_HEADER=Remote-User\n</code></pre>"},{"location":"getting-started/configuration/#example-traefik-with-forwardauth-authelia","title":"Example: Traefik with ForwardAuth (Authelia)","text":"<pre><code># docker-compose.yml\nservices:\n  traefik:\n    labels:\n      - \"traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://auth.example.com\"\n      - \"traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User\"\n\n  peek:\n    environment:\n      - PROXY_AUTH_HEADER=Remote-User\n    labels:\n      - \"traefik.http.routers.peek.middlewares=authelia@docker\"\n</code></pre>"},{"location":"getting-started/configuration/#user-management","title":"User Management","text":"<p>Users must exist in Peek's database for proxy authentication to work:</p> <ol> <li>Create users through Peek's admin panel (Settings \u2192 User Management)</li> <li>The username in Peek must exactly match the username passed by the proxy</li> <li>User roles and permissions are still managed within Peek</li> <li>Passwords are not used when proxy auth is enabled (but must still be set in the database)</li> </ol>"},{"location":"getting-started/configuration/#fallback-behavior","title":"Fallback Behavior","text":"<p>When <code>PROXY_AUTH_HEADER</code> is set but the header is not present in a request, Peek falls back to standard JWT cookie authentication. This allows:</p> <ul> <li>Mixed authentication (some users via proxy, others via direct login)</li> <li>API access using JWT tokens</li> <li>Testing and development without the proxy</li> </ul>"},{"location":"getting-started/configuration/#troubleshooting","title":"Troubleshooting","text":"<p>401 Unauthorized - User not found - Verify the user exists in Peek's database - Check that usernames match exactly (case-sensitive) - Verify the proxy is passing the correct header name</p> <p>Users being logged in as wrong user - CRITICAL: Your proxy is not sanitizing the header properly - Verify the proxy strips user-supplied headers before setting the authenticated value - Check that Peek is not accessible directly (bypass proxy)</p>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#minimal-production-configuration-v20","title":"Minimal Production Configuration (v2.0+)","text":"<pre><code># Required\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Stash connection configured via Setup Wizard (stored in database)\n# All other settings use defaults\n</code></pre>"},{"location":"getting-started/configuration/#complete-production-configuration","title":"Complete Production Configuration","text":"<pre><code># Authentication (Required)\nJWT_SECRET=your_very_long_random_secret_key_here\n\n# Database (Optional - defaults shown)\nDATABASE_URL=file:/app/data/peek-stash-browser.db\nCONFIG_DIR=/app/data\n\n# Security (Optional)\nSECURE_COOKIES=true\n\n# Environment (Optional)\nNODE_ENV=production\n\n# Stash connection configured via Setup Wizard (stored in database)\n</code></pre>"},{"location":"getting-started/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code># Authentication\nJWT_SECRET=dev-secret-change-in-production\n\n# Database (local SQLite file)\nDATABASE_URL=file:./data/peek-db.db\n\n# Development\nNODE_ENV=development\n\n# Stash connection configured via Setup Wizard\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-example","title":"Docker Compose Example","text":"<pre><code>services:\n  peek:\n    image: carrotwaxr/peek-stash-browser:latest\n    container_name: peek-stash-browser\n    ports:\n      - \"6969:80\"\n    volumes:\n      - peek-data:/app/data\n    environment:\n      - JWT_SECRET=${JWT_SECRET}\n      # Optional\n      - NODE_ENV=production\n      - SECURE_COOKIES=false\n    restart: unless-stopped\n\nvolumes:\n  peek-data:\n</code></pre> <p>Stash Connection</p> <p>Stash URL and API key are configured via the Setup Wizard on first access and stored in the database.</p>"},{"location":"getting-started/configuration/#troubleshooting-configuration-issues","title":"Troubleshooting Configuration Issues","text":""},{"location":"getting-started/configuration/#cannot-connect-to-stash","title":"Cannot Connect to Stash","text":"<p>Check:</p> <ul> <li>Stash URL is accessible from the Peek container</li> <li>Stash API key is correct and not expired</li> <li>Stash GraphQL API is enabled</li> </ul> <p>Test connectivity:</p> <pre><code>docker exec peek-stash-browser curl http://your-stash-ip:9999/graphql\n</code></pre> <p>You can update Stash connection details in Settings \u2192 Stash Configuration.</p>"},{"location":"getting-started/configuration/#videos-wont-play","title":"Videos Won't Play","text":"<p>Check:</p> <ul> <li>Stash connection is configured correctly (Settings \u2192 Stash Configuration)</li> <li>Stash server is running and accessible</li> <li>The scene exists in Stash and has a valid video file</li> </ul>"},{"location":"getting-started/configuration/#authentication-issues","title":"Authentication Issues","text":"<p>Check:</p> <ul> <li><code>JWT_SECRET</code> is set</li> <li><code>SECURE_COOKIES</code> matches your HTTP/HTTPS setup</li> <li>Database is writable</li> </ul>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Peek Stash Browser can be deployed in several ways depending on your needs and environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Peek, ensure you have:</p> <ul> <li>Stash Server running with GraphQL API enabled</li> <li>Docker installed (Docker Compose only needed for development)</li> <li>Network access from container to Stash server</li> </ul>"},{"location":"getting-started/installation/#stash-configuration","title":"Stash Configuration","text":"<ol> <li>Enable API in Stash settings</li> <li>Generate API key in Settings \u2192 Security</li> <li>Note GraphQL endpoint (usually <code>http://stash-ip:9999/graphql</code>)</li> <li>Ensure network access from your Docker host to Stash</li> </ol> <p>Note: As of v2.0, Peek streams video directly through Stash - no media volume mounts required!</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#option-1-unraid","title":"Option 1: unRAID","text":""},{"location":"getting-started/installation/#community-applications-recommended","title":"Community Applications (Recommended)","text":"<p>Easiest Installation Method</p> <p>This is the recommended method for unRAID users - everything is pre-configured!</p> <ol> <li>Install from Community Applications:</li> <li>Search for \"Peek Stash Browser\" in unRAID's Community Applications</li> <li>Click install and configure your settings</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> </ol>"},{"location":"getting-started/installation/#manual-template-installation","title":"Manual Template Installation","text":"<p>If Peek isn't available in Community Applications yet, or if you want to install the latest template manually:</p> <p>Step 1: Download the template file</p> <p>Get the template from GitHub:</p> <pre><code>https://raw.githubusercontent.com/carrotwaxr/peek-stash-browser/master/unraid-template.xml\n</code></pre> <p>Step 2: Install the template</p> <p>=== \"USB/Boot Share Exported (Easier)\" 1. Copy <code>unraid-template.xml</code> to your network share at: <code>\\\\your.server.ip.address\\flash\\config\\plugins\\dockerMan\\templates-user</code> 2. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>=== \"USB/Boot Share NOT Exported\" 1. Copy <code>unraid-template.xml</code> to any accessible share (e.g., <code>\\\\your.server.ip.address\\downloads</code>) 2. SSH into your unRAID server 3. Move the template file: <code>bash        cp /mnt/user/downloads/unraid-template.xml /boot/config/plugins/dockerMan/templates-user/</code> 4. The template will be available immediately in Docker tab \u2192 Add Container \u2192 User Templates</p> <p>No Restart Required</p> <p>You do NOT need to restart Docker or unRAID - the template is picked up automatically.</p> <p>Step 3: Configure the container</p> <ol> <li>Go to Docker tab \u2192 Add Container</li> <li>Select \"peek-stash-browser\" from User Templates dropdown</li> <li>Configure required settings:</li> <li>JWT Secret: Generate with <code>openssl rand -hex 32</code> in unRAID terminal</li> <li>App Data Directory: Path for Peek data (e.g., <code>/mnt/user/appdata/peek-stash-browser</code>)</li> <li>Click Apply</li> <li>Access at <code>http://your-unraid-ip:6969</code></li> <li>Complete the Setup Wizard to connect to your Stash server</li> </ol>"},{"location":"getting-started/installation/#option-2-docker-single-container","title":"Option 2: Docker (Single Container)","text":"<p>Recommended for Production</p> <p>Single container includes everything - frontend, backend, and database</p> <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Volume Mounts:</p> <ul> <li><code>peek-data</code> - Database and app data (Docker named volume)</li> </ul> <p>Required Environment Variables:</p> <ul> <li><code>JWT_SECRET</code> - Secret for JWT authentication (recommended to set manually)</li> </ul> <p>Note: Stash URL and API key are configured via the Setup Wizard on first access - no environment variables needed!</p> <p>See Configuration Guide for all environment variables.</p>"},{"location":"getting-started/installation/#windows-examples","title":"Windows Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret (one-time)\n$rng = [System.Security.Cryptography.RandomNumberGenerator]::Create()\n$bytes = New-Object byte[] 32\n$rng.GetBytes($bytes)\n$jwt = [Convert]::ToBase64String($bytes)\n\n# Run Peek\ndocker run -d `\n    --name peek-stash-browser `\n    -p 6969:80 `\n    -v peek-data:/app/data `\n    -e JWT_SECRET=$jwt `\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#linuxmacos-examples","title":"Linux/macOS Examples","text":"<pre><code># Pull the latest image from Docker Hub\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate a secure random JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n    --name peek-stash-browser \\\n    -p 6969:80 \\\n    -v peek-data:/app/data \\\n    -e JWT_SECRET=\"${JWT_SECRET}\" \\\n    carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Managing the container:</p> <pre><code># View logs\ndocker logs peek-stash-browser\n\n# Follow logs in real-time\ndocker logs -f peek-stash-browser\n\n# Stop container\ndocker stop peek-stash-browser\n\n# Start container\ndocker start peek-stash-browser\n\n# Restart container\ndocker restart peek-stash-browser\n\n# Update to new version\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\ndocker pull carrotwaxr/peek-stash-browser:latest\n# Then re-run the docker run command above\n</code></pre> <p>Data persists across updates!</p> <p>Your database and configuration are saved in the <code>peek-data</code> volume and won't be lost when updating.</p>"},{"location":"getting-started/installation/#option-3-docker-compose-development","title":"Option 3: Docker Compose (Development)","text":"<p>For Development Only</p> <p>This method is for development with hot reloading enabled</p> <ol> <li>Clone and setup:</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n</code></pre> <ol> <li>Configure environment (edit <code>.env</code>):</li> </ol> <pre><code>JWT_SECRET=your-dev-secret-here\nDATABASE_URL=file:./data/peek-stash-browser.db\n</code></pre> <ol> <li>Start services:</li> </ol> <pre><code>docker-compose up -d\n</code></pre> <ol> <li>Access the app: Open <code>http://localhost:6969</code></li> </ol>"},{"location":"getting-started/installation/#first-access-setup-wizard","title":"First Access &amp; Setup Wizard","text":"<p>After installation, access Peek in your browser for the first-time setup:</p> <ol> <li>Navigate to <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 4-step setup wizard:</li> <li>Welcome: Introduction to Peek</li> <li>Create Admin: Set your admin username and password</li> <li>Connect to Stash: Enter your Stash URL and API key</li> <li>Complete: Setup finished!</li> <li>Login with your newly created admin credentials</li> </ol>"},{"location":"getting-started/installation/#updating-peek","title":"Updating Peek","text":""},{"location":"getting-started/installation/#check-for-updates","title":"Check for Updates","text":"<p>Peek includes a built-in update checker:</p> <ol> <li>Navigate to Settings \u2192 Server Settings</li> <li>Scroll to the Version Information section</li> <li>Click Check for Updates</li> </ol> <p>The system will query GitHub for new releases and notify you if an update is available.</p>"},{"location":"getting-started/installation/#update-procedure","title":"Update Procedure","text":"<p>To update your Docker container to the latest version:</p> unRAIDLinux/macOSWindows <p>Easiest method: Click Force Update in the Docker tab to pull the latest image and restart.</p> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v peek-data:/app/data \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <pre><code># Stop and remove current container\ndocker stop peek-stash-browser\ndocker rm peek-stash-browser\n\n# Pull latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Restart with same docker run command you used for installation\ndocker run -d `\n  --name peek-stash-browser `\n  -p 6969:80 `\n  -v peek-data:/app/data `\n  -e JWT_SECRET=$jwt `\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <p>Your data persists across updates</p> <p>Database, user settings, Stash configuration, and playlists are stored in the <code>peek-data</code> volume and will not be lost.</p>"},{"location":"getting-started/installation/#version-pinning","title":"Version Pinning","text":"<p>To use a specific version instead of <code>:latest</code>:</p> <pre><code># Pull and use specific version\ndocker pull carrotwaxr/peek-stash-browser:1.0.0\ndocker run ... carrotwaxr/peek-stash-browser:1.0.0\n</code></pre> <p>Available versions: GitHub Releases</p>"},{"location":"getting-started/installation/#port-configuration","title":"Port Configuration","text":"Environment Port Service Description Production <code>6969</code> Complete App nginx serves frontend + proxies API Development <code>6969</code> Frontend UI Vite dev server with hot reloading Development <code>8000</code> Backend API Express server (internal Docker network) <p>Production uses only one port!</p> <p>Production deployment exposes only port <code>6969</code> - nginx handles everything internally</p>"},{"location":"getting-started/installation/#hardware-recommendations","title":"Hardware Recommendations","text":"Component Minimum Recommended CPU 2 cores 4+ cores (for multiple transcoding streams) RAM 2GB 4GB+ Storage SSD for database SSD for database, network storage for media Network 100 Mbps Gigabit (for 4K content)"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configure environment variables</li> <li>Quick Start Guide</li> <li>Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get Peek up and running in 5 minutes!</p>"},{"location":"getting-started/quick-start/#step-1-install-peek","title":"Step 1: Install Peek","text":"Docker (Fastest)unRAIDDocker Compose <pre><code># Pull the latest image\ndocker pull carrotwaxr/peek-stash-browser:latest\n\n# Generate JWT secret\nexport JWT_SECRET=$(openssl rand -base64 32)\n\n# Run Peek\ndocker run -d \\\n  --name peek-stash-browser \\\n  -p 6969:80 \\\n  -v /path/to/media:/app/media:ro \\\n  -v peek-data:/app/data \\\n  -e STASH_URL=\"http://your-stash:9999/graphql\" \\\n  -e STASH_API_KEY=\"your_api_key\" \\\n  -e JWT_SECRET=\"${JWT_SECRET}\" \\\n  carrotwaxr/peek-stash-browser:latest\n</code></pre> <ol> <li>Search \"Peek Stash Browser\" in Community Applications</li> <li>Click Install</li> <li>Configure Stash URL and API key</li> <li>Generate JWT secret: <code>openssl rand -hex 32</code></li> <li>Click Apply</li> </ol> <pre><code>git clone https://github.com/carrotwaxr/peek-stash-browser.git\ncd peek-stash-browser\ncp .env.example .env\n# Edit .env with your settings\ndocker-compose up -d\n</code></pre>"},{"location":"getting-started/quick-start/#step-2-setup-wizard","title":"Step 2: Setup Wizard","text":"<ol> <li>Open browser: <code>http://localhost:6969</code> (or your server IP)</li> <li>Complete the 5-step setup wizard:</li> <li>Welcome - Introduction to Peek</li> <li>Discover Libraries - Auto-discover your Stash library paths</li> <li>Configure Paths - Map Stash paths to Peek container paths</li> <li>Create Admin - Set your admin username and password</li> <li>Complete - Setup finished!</li> </ol> <p>Path Mapping Made Easy</p> <p>The wizard automatically discovers your Stash libraries and helps you configure path mappings correctly!</p>"},{"location":"getting-started/quick-start/#step-3-browse-your-library","title":"Step 3: Browse Your Library","text":"<ul> <li>Scenes: Browse all your video content</li> <li>Performers: View performers and their scenes</li> <li>Studios: Explore by production company</li> <li>Tags: Find content by tags</li> </ul>"},{"location":"getting-started/quick-start/#step-4-watch-videos","title":"Step 4: Watch Videos","text":"<ol> <li>Click any scene to view details</li> <li>Click Play to start video</li> <li>Quality automatically adjusts based on network</li> <li>Use timeline to seek through video</li> </ol>"},{"location":"getting-started/quick-start/#step-5-create-playlists","title":"Step 5: Create Playlists","text":"<p>Organize your favorite scenes into custom playlists:</p> <ol> <li>Click Playlists in the navigation menu</li> <li>Click Create Playlist</li> <li>Enter a name and optional description</li> <li>Click Create</li> </ol> <p>Adding Scenes: - Click the + icon on any scene card - Select your playlist from the menu - Scene is added instantly!</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start playback - Use Shuffle to randomize order - Use Repeat to loop your playlist</p> <p>Learn More</p> <p>See the Complete Playlists Guide for reordering scenes, editing playlists, and more!</p>"},{"location":"getting-started/quick-start/#common-tasks","title":"Common Tasks","text":""},{"location":"getting-started/quick-start/#update-admin-password","title":"Update Admin Password","text":"<ol> <li>Click user icon (top right)</li> <li>Select Settings</li> <li>Enter new password</li> <li>Click Save</li> </ol>"},{"location":"getting-started/quick-start/#create-additional-users","title":"Create Additional Users","text":"<ol> <li>Go to Users (admin only)</li> <li>Click Create User</li> <li>Enter username, email, password</li> <li>Select role (Admin or User)</li> <li>Click Create</li> </ol>"},{"location":"getting-started/quick-start/#configure-theme","title":"Configure Theme","text":"<ol> <li>Click theme toggle icon (moon/sun)</li> <li>Choose Dark or Light mode</li> <li>Theme preference is saved automatically</li> </ol>"},{"location":"getting-started/quick-start/#video-playback-tips","title":"Video Playback Tips","text":"<ul> <li>Direct Play: If browser supports the format, plays directly (no transcoding)</li> <li>Transcoded: HLS streaming with adaptive quality when needed</li> <li>Seeking: Full timeline scrubbing works in both modes</li> <li>Quality: Click quality button to manually select resolution</li> </ul>"},{"location":"getting-started/quick-start/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Space</code> Play/Pause <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>\u2191</code> Volume up <code>\u2193</code> Volume down <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>Full Keyboard Navigation</p> <p>Peek supports complete keyboard navigation including TV mode! See the Keyboard Navigation Guide for all shortcuts.</p>"},{"location":"getting-started/quick-start/#troubleshooting-first-time-issues","title":"Troubleshooting First-Time Issues","text":""},{"location":"getting-started/quick-start/#cant-login","title":"Can't Login","text":"<ul> <li>Check container logs: <code>docker logs peek-stash-browser</code></li> <li>Verify database was created in <code>/app/data</code></li> <li>Ensure <code>JWT_SECRET</code> is set (or auto-generated)</li> </ul>"},{"location":"getting-started/quick-start/#no-scenes-showing","title":"No Scenes Showing","text":"<ul> <li>Check <code>STASH_URL</code> is correct</li> <li>Verify <code>STASH_API_KEY</code> is valid</li> <li>Test Stash connectivity from container:   <pre><code>docker exec peek-stash-browser curl http://your-stash:9999/graphql\n</code></pre></li> </ul>"},{"location":"getting-started/quick-start/#videos-wont-play","title":"Videos Won't Play","text":"<ul> <li>Verify media path is mounted correctly:   <pre><code>docker exec peek-stash-browser ls /app/media\n</code></pre></li> <li>Check path mapping configuration</li> <li>Ensure FFmpeg is installed (included in official image)</li> </ul>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Full Configuration Guide</li> <li>Complete Troubleshooting</li> </ul>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting Guide</li> <li>GitHub Issues</li> <li>Stash Discord - #third-party-integrations channel</li> </ul>"},{"location":"getting-started/upgrading/","title":"Upgrading Peek","text":"<p>This guide covers upgrading Peek to new versions, including database migration procedures and backup strategies.</p>"},{"location":"getting-started/upgrading/#version-300-sqlite-entity-cache","title":"Version 3.0.0 - SQLite Entity Cache","text":"<p>Release Type: Stable</p> <p>Version 3.0.0 introduces a major architectural change: Stash entity data is now stored in SQLite tables instead of being held in memory. This provides:</p> <ul> <li>Scalability: Support for 100k+ scenes without memory exhaustion</li> <li>Performance: Sub-100ms query times with proper indexing</li> <li>Persistence: Library data survives container restarts</li> </ul>"},{"location":"getting-started/upgrading/#whats-changed","title":"What's Changed","text":"Before (v2.1.x) After (v3.0.0) In-memory cache SQLite tables ~3.6 hour sync for 22k scenes ~3 minute sync Memory-limited (~50k scenes max) Disk-limited (tested to 100k+) Data lost on restart Data persists"},{"location":"getting-started/upgrading/#database-changes-summary","title":"Database Changes Summary","text":"<p>The migration adds new tables only - it does NOT modify your existing user data tables:</p> <p>New Tables (23 total): - 7 entity tables: <code>StashScene</code>, <code>StashPerformer</code>, <code>StashStudio</code>, <code>StashTag</code>, <code>StashGroup</code>, <code>StashGallery</code>, <code>StashImage</code> - 14 junction tables for relationships (e.g., <code>ScenePerformer</code>, <code>SceneTag</code>, <code>PerformerTag</code>) - 2 sync management tables: <code>SyncState</code>, <code>SyncSettings</code></p> <p>Preserved Data: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - Scene/performer/studio/tag ratings and favorites - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"getting-started/upgrading/#pre-upgrade-checklist","title":"Pre-Upgrade Checklist","text":"<ol> <li>Back up your database (see Backup Procedure below)</li> <li>Note your current Peek version: Settings &gt; Server Statistics</li> <li>Ensure Docker has sufficient disk space (~500MB for 100k scenes)</li> </ol>"},{"location":"getting-started/upgrading/#backup-procedure","title":"Backup Procedure","text":"<p>Your Peek database is a single SQLite file. Back it up before upgrading:</p>"},{"location":"getting-started/upgrading/#option-1-docker-compose-recommended","title":"Option 1: Docker Compose (Recommended)","text":"<pre><code># Stop Peek to ensure clean backup\ndocker-compose stop peek-server\n\n# Find your data directory (check your docker-compose.yml volumes)\n# Default is ./data or a named volume\n\n# Copy the database file\ncp ./data/peek.db ./data/peek.db.backup-$(date +%Y%m%d)\n\n# Or if using a named volume:\ndocker run --rm -v peek_data:/data -v $(pwd):/backup alpine \\\n  cp /data/peek.db /backup/peek.db.backup-$(date +%Y%m%d)\n\n# Restart Peek\ndocker-compose start peek-server\n</code></pre>"},{"location":"getting-started/upgrading/#option-2-unraid-users","title":"Option 2: unRAID Users","text":"<ol> <li>Navigate to your Peek appdata folder (typically <code>/mnt/user/appdata/peek/</code>)</li> <li>Copy <code>peek.db</code> to a safe location outside the container</li> <li>Also copy <code>peek.db-wal</code> and <code>peek.db-shm</code> if they exist (WAL mode files)</li> </ol>"},{"location":"getting-started/upgrading/#option-3-while-running-less-safe","title":"Option 3: While Running (Less Safe)","text":"<p>SQLite supports hot backups, but stopping the container is safer:</p> <pre><code># If you can't stop the container\ndocker exec peek-server sqlite3 /app/data/peek.db \".backup '/app/data/peek-backup.db'\"\ndocker cp peek-server:/app/data/peek-backup.db ./peek.db.backup\n</code></pre>"},{"location":"getting-started/upgrading/#upgrade-steps","title":"Upgrade Steps","text":""},{"location":"getting-started/upgrading/#step-1-pull-the-new-image","title":"Step 1: Pull the New Image","text":"<pre><code># For docker-compose users\ndocker-compose pull\n\n# For manual docker users\ndocker pull carrotwaxr/peek-stash-browser:3.0.0\n# or for latest\ndocker pull carrotwaxr/peek-stash-browser:latest\n</code></pre>"},{"location":"getting-started/upgrading/#step-2-restart-the-container","title":"Step 2: Restart the Container","text":"<pre><code># Docker Compose\ndocker-compose down\ndocker-compose up -d\n\n# Manual Docker\ndocker stop peek-server\ndocker rm peek-server\ndocker run -d --name peek-server ... carrotwaxr/peek-stash-browser:3.0.0\n</code></pre>"},{"location":"getting-started/upgrading/#step-3-wait-for-migration","title":"Step 3: Wait for Migration","text":"<p>On first startup, Prisma will automatically apply the migration: - Check logs: <code>docker-compose logs -f peek-server</code> - Look for: <code>Applied migration: 20251211000000_stash_entities</code> - Migration typically completes in under 5 seconds</p>"},{"location":"getting-started/upgrading/#step-4-wait-for-initial-sync","title":"Step 4: Wait for Initial Sync","text":"<p>The sync starts automatically on first startup after migration. Watch the logs or the sync progress banner in the UI.</p> <p>Sync times depend on your library size: | Library Size | Expected Time | |--------------|---------------| | 1,000 scenes | ~15 seconds | | 10,000 scenes | ~1-2 minutes | | 50,000 scenes | ~5-8 minutes | | 100,000 scenes | ~15-20 minutes |</p>"},{"location":"getting-started/upgrading/#upgrading-from-300-beta-versions","title":"Upgrading from 3.0.0 Beta Versions","text":"<p>If you're upgrading from any v3.0.0-beta.x version, we recommend running a full sync after upgrading to ensure your database has all the latest fields populated correctly.</p> <p>Why a full sync is recommended: - beta.6 added <code>fileBasename</code> for gallery display - beta.9 added <code>fakeTits</code> for performer filtering</p> <p>How to run a full sync: 1. Go to Settings &gt; Server Settings 2. Click Sync from Stash 3. Select Full Sync (not incremental) 4. Wait for completion</p> <p>This ensures all new fields are populated for existing data.</p>"},{"location":"getting-started/upgrading/#rollback-procedure","title":"Rollback Procedure","text":"<p>If something goes wrong, you can restore your backup:</p> <pre><code># Stop Peek\ndocker-compose stop peek-server\n\n# Restore the backup\ncp ./data/peek.db.backup-YYYYMMDD ./data/peek.db\n\n# Restart with old image\ndocker-compose up -d\n</code></pre> <p>Note: If you need to downgrade the Docker image version, you may need to delete the migration record:</p> <pre><code># Only if downgrading AND experiencing migration errors\ndocker exec peek-server sqlite3 /app/data/peek.db \\\n  \"DELETE FROM _prisma_migrations WHERE migration_name = '20251211000000_stash_entities'\"\n</code></pre>"},{"location":"getting-started/upgrading/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/upgrading/#library-is-empty-after-upgrade","title":"\"Library is empty after upgrade\"","text":"<p>The sync should start automatically on first startup. If your library appears empty after waiting several minutes, check the logs for errors. You can also manually trigger a sync from Settings &gt; Sync.</p>"},{"location":"getting-started/upgrading/#migration-failed","title":"\"Migration failed\"","text":"<p>Check the logs for the specific error: <pre><code>docker-compose logs peek-server | grep -i migration\n</code></pre></p> <p>Common issues: - Disk full: Free up space and restart - Permission denied: Check volume mount permissions - Database locked: Stop other processes accessing the DB</p>"},{"location":"getting-started/upgrading/#sync-is-very-slow","title":"\"Sync is very slow\"","text":"<p>The initial sync after upgrade fetches all data from Stash. Subsequent syncs are incremental and much faster (typically &lt;30 seconds).</p>"},{"location":"getting-started/upgrading/#cant-connect-to-stash","title":"\"Can't connect to Stash\"","text":"<p>Verify your Stash configuration in Settings. The upgrade doesn't change your Stash connection settings.</p>"},{"location":"getting-started/upgrading/#performer-filters-not-working-correctly","title":"\"Performer filters not working correctly\"","text":"<p>If performer filters (like career length, ethnicity, eye color) aren't working as expected, run a full sync to ensure all performer fields are populated.</p>"},{"location":"getting-started/upgrading/#reporting-issues","title":"Reporting Issues","text":"<p>Found a bug? Please report it: - GitHub: github.com/carrotwaxr/peek-stash-browser/issues - Discourse: discourse.stashapp.cc</p> <p>Include: 1. Your Peek version (Settings &gt; Server Statistics) 2. Your Stash version 3. Library size (scene count) 4. Relevant log output 5. Steps to reproduce</p>"},{"location":"getting-started/upgrading/#previous-version-upgrades","title":"Previous Version Upgrades","text":""},{"location":"getting-started/upgrading/#v200-stash-proxy-streaming","title":"v2.0.0 - Stash Proxy Streaming","text":"<p>Version 2.0 removed local transcoding in favor of proxying streams directly through Stash.</p> <p>Key Changes: - Removed FFmpeg transcoding system - Removed path mapping configuration - Added StashInstance table for connection storage</p> <p>Migration: Automatic. No user action required.</p>"},{"location":"getting-started/upgrading/#v1x-to-v2x","title":"v1.x to v2.x","text":"<p>Users upgrading from v1.x will have their schema automatically updated via the schemaCatchup system. All user data is preserved.</p> <p>Migration: Automatic. The system detects legacy databases and applies necessary schema updates before running Prisma migrations.</p>"},{"location":"plans/2024-12-23-3.0-polish-design/","title":"3.0 Polish - Design Document","text":"<p>Three minor issues to address before the 3.0 release.</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-1-long-filename-overflow-on-scene-cards","title":"Issue 1: Long Filename Overflow on Scene Cards","text":"<p>Problem: Filenames like <code>OnlyTarts.25.09.12.Isabella.De.Laa.Big.Wave.In.Her.Pussy.XXX.1080p.MP4-WRB[XC]</code> are unbroken strings that overflow the card boundaries because CSS doesn't know where to break them.</p> <p>Solution: Add <code>word-break: break-all</code> to the title element in <code>CardComponents.jsx</code>. This forces breaks anywhere in long strings, allowing the existing line-clamp and ellipsis to work correctly.</p> <p>File: <code>client/src/components/ui/CardComponents.jsx</code> (CardTitle component, around line 310)</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-2-text-search-fields","title":"Issue 2: Text Search Fields","text":"<p>Problem: Peek's text search doesn't match Stash's behavior. Stash searches more fields.</p> <p>Current state: - Scenes: <code>title</code>, <code>details</code> - Performers: <code>name</code>, <code>details</code> - Studios: <code>name</code>, <code>details</code> - Tags: <code>name</code></p> <p>Stash searches: - Scenes: <code>title</code>, <code>details</code>, <code>filepath</code>, <code>fingerprint</code>, <code>marker titles</code> - Performers: <code>name</code>, <code>aliases</code> - Studios: <code>name</code>, <code>aliases</code> - Tags: <code>name</code>, <code>aliases</code>, <code>sort_name</code></p> <p>Solution: - Scenes: Add <code>filepath</code> to search (requires SQL change in SceneQueryBuilder) - Performers: Add <code>aliases</code> (keep <code>details</code>) - Studios: Add <code>aliases</code> (keep <code>details</code>) - Tags: Add <code>aliases</code></p> <p>Files: - <code>server/services/SceneQueryBuilder.ts</code> - Add filepath to SQL LIKE query - <code>server/controllers/library/performers.ts</code> - Add aliases to filter - <code>server/controllers/library/studios.ts</code> - Add aliases to filter - <code>server/controllers/library/tags.ts</code> - Add aliases to filter</p>"},{"location":"plans/2024-12-23-3.0-polish-design/#issue-3-last-sync-time-not-updated-for-incremental-syncs","title":"Issue 3: Last Sync Time Not Updated for Incremental Syncs","text":"<p>Problem: The Server Settings page shows \"Last synced\" time, but it only reflects full syncs, not incremental/periodic syncs.</p> <p>Root cause: In <code>StashEntityService.getLastRefreshed()</code>: <pre><code>const syncState = await prisma.syncState.findFirst({\n  where: { entityType: \"scene\" },\n  orderBy: { lastFullSync: \"desc\" },  // Only orders by full sync\n});\nreturn syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n</code></pre></p> <p>The query orders by <code>lastFullSync</code> only, so if incremental syncs happen after a full sync, they're not reflected.</p> <p>Solution: Return whichever is more recent between <code>lastFullSync</code> and <code>lastIncrementalSync</code>. Compare both timestamps and return the later one.</p> <p>File: <code>server/services/StashEntityService.ts</code> (around line 1208)</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/","title":"3.0 Polish Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix three minor issues for the Peek 3.0 release: long filename overflow, text search fields (fixes #196), and last sync time display.</p> <p>Architecture: Small, targeted changes to existing components. No new files or major refactoring needed.</p> <p>Tech Stack: React (client), TypeScript/Express (server), SQLite via Prisma (database)</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-1-fix-long-filename-overflow-in-cardtitle","title":"Task 1: Fix Long Filename Overflow in CardTitle","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:308-322</code></p> <p>Step 1: Add word-break to title element</p> <p>In the <code>CardTitle</code> component, add <code>wordBreak: \"break-all\"</code> to the title <code>&lt;h3&gt;</code> style object.</p> <pre><code>const titleElement = (\n  &lt;h3\n    className=\"font-semibold leading-tight text-center\"\n    style={{\n      color: \"var(--text-primary)\",\n      height: titleHeight,\n      display: \"-webkit-box\",\n      WebkitLineClamp: maxTitleLines,\n      WebkitBoxOrient: \"vertical\",\n      overflow: \"hidden\",\n      textOverflow: \"ellipsis\",\n      wordBreak: \"break-all\",  // ADD THIS LINE\n    }}\n  &gt;\n    {title}\n  &lt;/h3&gt;\n);\n</code></pre> <p>Step 2: Verify visually</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code></p> <p>Test by viewing a scene card with a long unbroken filename like \"OnlyTarts.25.09.12.Isabella.De.Laa.Big.Wave.In.Her.Pussy.XXX.1080p.MP4-WRB\". The title should wrap and truncate with ellipsis instead of overflowing.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx\ngit commit -m \"fix: prevent long filename overflow in scene cards\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-2-add-filepath-to-scene-text-search-fixes-196","title":"Task 2: Add Filepath to Scene Text Search (Fixes #196)","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts:1048-1065</code> (first occurrence) - Modify: <code>server/controllers/library/scenes.ts:1105-1122</code> (second occurrence)</p> <p>Step 1: Add filePath to first search filter (lines 1048-1065)</p> <p>Find the scene text search filter around line 1048 and add <code>filePath</code> to the search:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  scenes = scenes.filter((s) =&gt; {\n    const title = s.title || \"\";\n    const details = s.details || \"\";\n    const filePath = s.files?.[0]?.path || \"\";  // ADD THIS LINE\n    const performers = (s.performers || [])\n      .map((p) =&gt; p.name || \"\")\n      .join(\" \");\n    const studio = s.studio?.name || \"\";\n    const tags = (s.tags || []).map((t) =&gt; t.name || \"\").join(\" \");\n\n    return (\n      title.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      filePath.toLowerCase().includes(lowerQuery) ||  // ADD THIS LINE\n      performers.toLowerCase().includes(lowerQuery) ||\n      studio.toLowerCase().includes(lowerQuery) ||\n      tags.toLowerCase().includes(lowerQuery)\n    );\n  });\n}\n</code></pre> <p>Step 2: Add filePath to second search filter (lines 1105-1122)</p> <p>Find the second occurrence around line 1105 and make the same change:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  scenes = scenes.filter((s) =&gt; {\n    const title = s.title || \"\";\n    const details = s.details || \"\";\n    const filePath = s.files?.[0]?.path || \"\";  // ADD THIS LINE\n    const performers = (s.performers || [])\n      .map((p) =&gt; p.name || \"\")\n      .join(\" \");\n    const studio = s.studio?.name || \"\";\n    const tags = (s.tags || []).map((t) =&gt; t.name || \"\").join(\" \");\n\n    return (\n      title.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      filePath.toLowerCase().includes(lowerQuery) ||  // ADD THIS LINE\n      performers.toLowerCase().includes(lowerQuery) ||\n      studio.toLowerCase().includes(lowerQuery) ||\n      tags.toLowerCase().includes(lowerQuery)\n    );\n  });\n}\n</code></pre> <p>Step 3: Run lint to check for errors</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"fix: include filepath in scene text search\n\nCloses #196\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-3-add-aliases-to-tag-text-search","title":"Task 3: Add Aliases to Tag Text Search","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts:284-292</code> (first occurrence) - Modify: <code>server/controllers/library/tags.ts:877-885</code> (second occurrence)</p> <p>Step 1: Add aliases to first search filter (lines 284-292)</p> <p>Find the tag text search filter around line 284 and add <code>aliases</code>:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  tags = tags.filter((t) =&gt; {\n    const name = t.name || \"\";\n    const description = t.description || \"\";\n    const aliases = (t.aliases || []).join(\" \");  // ADD THIS LINE\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      description.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD THIS LINE\n    );\n  });\n}\n</code></pre> <p>Step 2: Add aliases to second search filter (lines 877-885)</p> <p>Find the second occurrence around line 877 and make the same change:</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  tags = tags.filter((t) =&gt; {\n    const name = t.name || \"\";\n    const description = t.description || \"\";\n    const aliases = (t.aliases || []).join(\" \");  // ADD THIS LINE\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      description.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD THIS LINE\n    );\n  });\n}\n</code></pre> <p>Step 3: Run lint to check for errors</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/tags.ts\ngit commit -m \"fix: include aliases in tag text search\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-4-add-aliases-to-studio-text-search","title":"Task 4: Add Aliases to Studio Text Search","text":"<p>Files: - Modify: <code>server/controllers/library/studios.ts:169-178</code> (first occurrence) - Modify: <code>server/controllers/library/studios.ts:528+</code> (second occurrence - findStudiosSimple)</p> <p>Note: Studios have an <code>aliases</code> field in Stash but Peek doesn't currently sync it. Check if the field exists on NormalizedStudio before adding. If not available, skip this task.</p> <p>Step 1: Check if aliases field exists</p> <p>Search for <code>aliases</code> in the studio type or data. If NormalizedStudio doesn't have aliases, this task should be skipped - adding it would require a schema migration and sync changes which is out of scope for this polish release.</p> <p>Step 2: If aliases exists, add to first search filter (lines 169-178)</p> <pre><code>if (searchQuery) {\n  const lowerQuery = searchQuery.toLowerCase();\n  studios = studios.filter((s) =&gt; {\n    const name = s.name || \"\";\n    const details = s.details || \"\";\n    const aliases = (s.aliases || []).join(\" \");  // ADD IF FIELD EXISTS\n    return (\n      name.toLowerCase().includes(lowerQuery) ||\n      details.toLowerCase().includes(lowerQuery) ||\n      aliases.toLowerCase().includes(lowerQuery)  // ADD IF FIELD EXISTS\n    );\n  });\n}\n</code></pre> <p>Step 3: If aliases exists, add to second search filter</p> <p>Apply same change to the second occurrence.</p> <p>Step 4: Run lint and commit (if changes made)</p> <pre><code>git add server/controllers/library/studios.ts\ngit commit -m \"fix: include aliases in studio text search\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-5-fix-last-sync-time-to-show-most-recent-sync","title":"Task 5: Fix Last Sync Time to Show Most Recent Sync","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:1208-1215</code></p> <p>Step 1: Update getLastRefreshed to return most recent sync</p> <p>Replace the current <code>getLastRefreshed()</code> implementation:</p> <pre><code>/**\n * Get last refresh time\n */\nasync getLastRefreshed(): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: { entityType: \"scene\" },\n  });\n\n  if (!syncState) return null;\n\n  const { lastFullSync, lastIncrementalSync } = syncState;\n\n  // Return whichever sync happened more recently\n  if (!lastFullSync) return lastIncrementalSync;\n  if (!lastIncrementalSync) return lastFullSync;\n\n  return lastFullSync &gt; lastIncrementalSync ? lastFullSync : lastIncrementalSync;\n}\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --grep \"getLastRefreshed\"</code></p> <p>If there are existing tests for this function, they may need updating.</p> <p>Step 3: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"fix: show most recent sync time (full or incremental)\"\n</code></pre>"},{"location":"plans/2024-12-23-3.0-polish-plan/#task-6-run-full-test-suite-and-verify","title":"Task 6: Run Full Test Suite and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass</p> <p>Step 2: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Build both client and server</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; cd ../server &amp;&amp; npm run build</code></p> <p>Expected: Both build successfully</p> <p>Step 4: Manual verification</p> <p>Start the app and verify: 1. Long filenames on scene cards wrap and truncate properly 2. Searching for a filename substring returns matching scenes 3. Searching for tag aliases returns matching tags 4. Server Settings page shows the correct last sync time after an incremental sync</p>"},{"location":"plans/2024-12-23-3.0-polish-plan/#summary","title":"Summary","text":"Task Description Files Modified 1 Fix filename overflow <code>client/src/components/ui/CardComponents.jsx</code> 2 Add filepath to scene search (#196) <code>server/controllers/library/scenes.ts</code> 3 Add aliases to tag search <code>server/controllers/library/tags.ts</code> 4 Add aliases to studio search <code>server/controllers/library/studios.ts</code> (if field exists) 5 Fix last sync time display <code>server/services/StashEntityService.ts</code> 6 Verify all changes N/A"},{"location":"plans/2024-12-29-lightbox-enhancements-design/","title":"Lightbox Enhancements Design","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#overview","title":"Overview","text":"<p>Transform Peek's lightbox into a modern, multi-platform image viewer with touch gestures, immersive fullscreen, and accessible metadata.</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#goals","title":"Goals","text":"<ul> <li>Mobile-first touch navigation (swipe to navigate, swipe up for info)</li> <li>True fullscreen mode using Browser Fullscreen API</li> <li>Metadata drawer showing performers, tags, studio, and image details</li> <li>Tap-to-toggle controls for immersive viewing</li> <li>Consistent experience across mobile and desktop</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#user-feedback-sources","title":"User Feedback Sources","text":"<ul> <li>Discourse thread - TikTok-style viewing requests</li> <li>GitHub Issue #193 - Images page (implemented)</li> <li>Discord feedback from honeypotfields:</li> <li>Swipe instead of tap for navigation</li> <li>Hide titlebar/chrome in fullscreen</li> <li>Prevent orientation jump issues</li> <li>Gallery-relevant tags visible without menus</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-1-touch-gesture-navigation","title":"Feature 1: Touch Gesture Navigation","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#gesture-behaviors","title":"Gesture Behaviors","text":"Gesture Action Swipe left Next image Swipe right Previous image Swipe up Open metadata drawer Swipe down Close drawer (if open) or close lightbox Tap Toggle controls visibility"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#thresholds","title":"Thresholds","text":"<ul> <li>Horizontal swipe: 50px minimum, velocity &gt; 0.3</li> <li>Swipe up (drawer): 80px minimum (prevents accidental triggers)</li> <li>Swipe down (close): 100px when drawer closed, 50px when drawer open</li> <li>Diagonal swipes: Use dominant axis (greater delta wins)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Multi-touch ignored (reserved for future pinch-to-zoom)</li> <li>Scroll within drawer: Native scroll; swipe-to-dismiss only at scroll top</li> <li>Drawer open: Swipe down closes drawer first, not lightbox</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#library","title":"Library","text":"<p>Use <code>react-swipeable</code> (~3KB gzipped) for touch handling.</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-2-metadata-drawer","title":"Feature 2: Metadata Drawer","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#layout","title":"Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  (drag handle indicator)           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  [Title]                    [Rating] [O] [\u2764]    \u2502\n\u2502  Studio Name \u2022 Jan 15, 2024 \u2022 3840\u00d72160         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  PERFORMERS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  [avatar] [avatar] [avatar] \u2192 (horizontal scroll)\u2502\n\u2502   Name     Name     Name                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TAGS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  [Tag Chip] [Tag Chip] [Tag Chip] [+3 more]     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  DETAILS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502  Description text if present...                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#styling-consistent-with-existing-patterns","title":"Styling (consistent with existing patterns)","text":"<ul> <li>Container: Bottom sheet, max-height 60vh mobile / 50vh desktop</li> <li>Background: <code>var(--bg-card)</code> with <code>rounded-t-lg</code></li> <li>Section headers: <code>text-sm font-semibold uppercase tracking-wide mb-3 pb-2</code> with <code>border-b-2 border-[var(--accent-primary)]</code></li> <li>Performers: Horizontal scroll, <code>w-[120px]</code> cards, <code>aspect-[2/3]</code> thumbnails, <code>gap-4</code></li> <li>Tags: <code>TagChips</code> component (colored pills, alphabetically sorted)</li> <li>Studio link: <code>hover:underline hover:text-blue-400</code></li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#triggers","title":"Triggers","text":"<ul> <li>Swipe up on image (mobile)</li> <li><code>i</code> hotkey (all platforms)</li> <li>Info button in controls (all platforms)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#dismiss","title":"Dismiss","text":"<ul> <li>Swipe down on drawer</li> <li>Tap outside drawer</li> <li><code>i</code> key (toggle)</li> <li>Escape key</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#interactivity","title":"Interactivity","text":"<ul> <li>Performers, tags, studio are clickable links (navigates to detail page, closes lightbox)</li> <li>Rating, O-counter, favorite are interactive within drawer</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-3-controls-overlay","title":"Feature 3: Controls Overlay","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#layout_1","title":"Layout","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  [\u2715]                            [\u26f6] [i] \u2502  \u2190 Top bar\n\u2502                                         \u2502\n\u2502   \u25c4                               \u25ba     \u2502  \u2190 Side nav (desktop)\n\u2502                                         \u2502\n\u2502                                         \u2502\n\u2502  1 / 24    Title of Image    \u2328 hints   \u2502  \u2190 Bottom bar\n\u2502        [\u25b6 5s \u25bc]  [\u2605 7.2] [\ud83d\udca7 3] [\u2764]    \u2502  \u2190 Controls row\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#visibility-states","title":"Visibility States","text":"Context Default State Behavior Desktop Visible Auto-hide after 3s of no mouse movement Mobile Hidden Tap image to toggle Slideshow Hidden Auto-hide after 2s Interacting Visible Resets auto-hide timer"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-buttons","title":"New Buttons","text":"<ul> <li>Fullscreen [\u26f6]: Top-right, toggles Browser Fullscreen API</li> <li>Info [i]: Top-right, opens metadata drawer</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#button-styling","title":"Button Styling","text":"<ul> <li>Background: <code>rgba(0, 0, 0, 0.5)</code>, <code>hover:bg-opacity-70</code></li> <li>Icons: 24px (<code>w-6 h-6</code>), white with text shadow for contrast</li> <li>Consistent with existing lightbox controls</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#feature-4-fullscreen-mode","title":"Feature 4: Fullscreen Mode","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#behavior","title":"Behavior","text":"<ul> <li>Uses <code>document.documentElement.requestFullscreen()</code> API</li> <li>Toggle via <code>f</code> key or fullscreen button</li> <li>Icon switches between expand/compress states</li> <li>Hides browser chrome entirely (address bar, tabs)</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#escape-key-cascade","title":"Escape Key Cascade","text":"<ol> <li>If drawer open \u2192 close drawer</li> <li>Else if fullscreen \u2192 exit fullscreen</li> <li>Else \u2192 close lightbox</li> </ol>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#fallback","title":"Fallback","text":"<ul> <li>Hide fullscreen button on unsupported browsers</li> <li>Log warning to console</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#platform-notes","title":"Platform Notes","text":"<ul> <li>iOS Safari: Uses <code>webkitRequestFullscreen</code>, different behavior on iPhone vs iPad</li> <li>Test on real devices before release</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#complete-list","title":"Complete List","text":"Key Action \u2190 Previous image \u2192 Next image Space Toggle slideshow Escape Close (cascading: drawer \u2192 fullscreen \u2192 lightbox) <code>i</code> Toggle info drawer <code>f</code> Toggle fullscreen <code>r</code> then <code>1-5</code> Set rating (1-5 stars mapped to 20-100) <code>r</code> then <code>0</code> Clear rating <code>r</code> then <code>f</code> Toggle favorite"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#implementation","title":"Implementation","text":""},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-dependencies","title":"New Dependencies","text":"<pre><code>{\n  \"react-swipeable\": \"^7.0.0\"\n}\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>client/src/components/ui/Lightbox.jsx</code> - Add gestures, new controls, state management</li> <li><code>client/package.json</code> - Add react-swipeable dependency</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#new-files","title":"New Files","text":"File Purpose <code>client/src/components/ui/MetadataDrawer.jsx</code> Bottom sheet component <code>client/src/hooks/useSwipeGestures.js</code> Custom hook wrapping react-swipeable <code>client/src/hooks/useFullscreen.js</code> Fullscreen API hook with state sync"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#component-structure","title":"Component Structure","text":"<pre><code>&lt;Lightbox&gt;\n  &lt;SwipeableContainer&gt;\n    &lt;ControlsOverlay visible={controlsVisible}&gt;\n      &lt;TopBar&gt;\n        &lt;CloseButton /&gt;\n        &lt;FullscreenButton /&gt;\n        &lt;InfoButton /&gt;\n      &lt;/TopBar&gt;\n      &lt;SideNav /&gt;           {/* Desktop only */}\n      &lt;BottomBar&gt;\n        &lt;ImageCounter /&gt;\n        &lt;ImageTitle /&gt;\n        &lt;SlideshowControls /&gt;\n        &lt;RatingBadge /&gt;\n        &lt;OCounterButton /&gt;\n        &lt;FavoriteButton /&gt;\n      &lt;/BottomBar&gt;\n    &lt;/ControlsOverlay&gt;\n    &lt;ImageContainer /&gt;\n  &lt;/SwipeableContainer&gt;\n  &lt;MetadataDrawer\n    open={drawerOpen}\n    image={currentImage}\n    onClose={() =&gt; setDrawerOpen(false)}\n  /&gt;\n&lt;/Lightbox&gt;\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#state-management","title":"State Management","text":"<pre><code>// New state\nconst [controlsVisible, setControlsVisible] = useState(true);\nconst [drawerOpen, setDrawerOpen] = useState(false);\nconst { isFullscreen, toggleFullscreen } = useFullscreen();\n\n// Existing state (preserved)\nconst [currentIndex, setCurrentIndex] = useState(initialIndex);\nconst [isPlaying, setIsPlaying] = useState(autoPlay);\nconst [intervalDuration, setIntervalDuration] = useState(5000);\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#testing-notes","title":"Testing Notes","text":"<ul> <li>Gesture thresholds need real device testing</li> <li>Fullscreen API requires user gesture (cannot auto-trigger)</li> <li>iOS Safari fullscreen behaves differently than Chrome/Firefox</li> <li>Test orientation changes don't cause layout jumps</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-design/#future-enhancements-out-of-scope","title":"Future Enhancements (Out of Scope)","text":"<p>These were discussed but deferred for later consideration:</p> <ul> <li>Pinch-to-zoom: Multi-touch gesture for image zoom/pan</li> <li>Smart sidebar: Desktop-only side panel using pillarbox space for metadata</li> <li>Persistent defaults: User preferences for grid layout, sort order, items per page</li> <li>Tag quick-filters: Tap tag in drawer to filter gallery by that tag</li> </ul>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/","title":"Lightbox Enhancements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add touch gestures, metadata drawer, fullscreen mode, and tap-to-toggle controls to the Lightbox component.</p> <p>Architecture: Extend existing Lightbox.jsx with new hooks for gestures and fullscreen. Create a MetadataDrawer component for the bottom sheet. Use react-swipeable for touch handling.</p> <p>Tech Stack: React 19, react-swipeable, Tailwind CSS, lucide-react icons</p>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-1-add-react-swipeable-dependency","title":"Task 1: Add react-swipeable dependency","text":"<p>Files: - Modify: <code>client/package.json</code></p> <p>Step 1: Install react-swipeable</p> <p>Run: <pre><code>cd client &amp;&amp; npm install react-swipeable\n</code></pre></p> <p>Expected: Package added to dependencies</p> <p>Step 2: Verify installation</p> <p>Run: <pre><code>cd client &amp;&amp; npm ls react-swipeable\n</code></pre></p> <p>Expected: Shows react-swipeable@7.x.x</p> <p>Step 3: Commit</p> <pre><code>git add client/package.json client/package-lock.json\ngit commit -m \"chore: add react-swipeable dependency\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-2-create-usefullscreen-hook","title":"Task 2: Create useFullscreen hook","text":"<p>Files: - Create: <code>client/src/hooks/useFullscreen.js</code></p> <p>Step 1: Write the hook</p> <pre><code>import { useCallback, useEffect, useState } from \"react\";\n\n/**\n * Hook to manage browser fullscreen state\n * @returns {{ isFullscreen: boolean, toggleFullscreen: () =&gt; void, supportsFullscreen: boolean }}\n */\nexport function useFullscreen() {\n  const [isFullscreen, setIsFullscreen] = useState(false);\n\n  const supportsFullscreen = Boolean(\n    document.fullscreenEnabled ||\n      document.webkitFullscreenEnabled ||\n      document.mozFullScreenEnabled ||\n      document.msFullscreenEnabled\n  );\n\n  useEffect(() =&gt; {\n    const handleFullscreenChange = () =&gt; {\n      setIsFullscreen(Boolean(document.fullscreenElement));\n    };\n\n    document.addEventListener(\"fullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"webkitfullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"mozfullscreenchange\", handleFullscreenChange);\n    document.addEventListener(\"MSFullscreenChange\", handleFullscreenChange);\n\n    return () =&gt; {\n      document.removeEventListener(\"fullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"webkitfullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"mozfullscreenchange\", handleFullscreenChange);\n      document.removeEventListener(\"MSFullscreenChange\", handleFullscreenChange);\n    };\n  }, []);\n\n  const toggleFullscreen = useCallback(async () =&gt; {\n    try {\n      if (!document.fullscreenElement) {\n        const elem = document.documentElement;\n        if (elem.requestFullscreen) {\n          await elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) {\n          await elem.webkitRequestFullscreen();\n        } else if (elem.mozRequestFullScreen) {\n          await elem.mozRequestFullScreen();\n        } else if (elem.msRequestFullscreen) {\n          await elem.msRequestFullscreen();\n        }\n      } else {\n        if (document.exitFullscreen) {\n          await document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n          await document.webkitExitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n          await document.mozCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n          await document.msExitFullscreen();\n        }\n      }\n    } catch (err) {\n      console.warn(\"Fullscreen toggle failed:\", err);\n    }\n  }, []);\n\n  return { isFullscreen, toggleFullscreen, supportsFullscreen };\n}\n</code></pre> <p>Step 2: Verify file exists</p> <p>Run: <pre><code>ls -la client/src/hooks/useFullscreen.js\n</code></pre></p> <p>Expected: File exists</p> <p>Step 3: Commit</p> <pre><code>git add client/src/hooks/useFullscreen.js\ngit commit -m \"feat: add useFullscreen hook for browser fullscreen API\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-3-create-metadatadrawer-component","title":"Task 3: Create MetadataDrawer component","text":"<p>Files: - Create: <code>client/src/components/ui/MetadataDrawer.jsx</code></p> <p>Step 1: Write the component</p> <pre><code>import { Link } from \"react-router-dom\";\nimport { X } from \"lucide-react\";\nimport TagChips from \"./TagChips.jsx\";\nimport RatingBadge from \"./RatingBadge.jsx\";\nimport OCounterButton from \"./OCounterButton.jsx\";\nimport FavoriteButton from \"./FavoriteButton.jsx\";\n\n/**\n * Bottom sheet drawer displaying image metadata\n */\nconst MetadataDrawer = ({\n  open,\n  onClose,\n  image,\n  rating,\n  isFavorite,\n  oCounter,\n  onRatingClick,\n  onFavoriteChange,\n  onOCounterChange,\n}) =&gt; {\n  if (!open || !image) return null;\n\n  const studio = image.studio;\n  const performers = image.performers || [];\n  const tags = image.tags || [];\n  const date = image.date\n    ? new Date(image.date).toLocaleDateString()\n    : null;\n  const resolution =\n    image.width &amp;&amp; image.height ? `${image.width}\u00d7${image.height}` : null;\n\n  // Build subtitle parts\n  const subtitleParts = [studio?.name, date, resolution].filter(Boolean);\n  const subtitle = subtitleParts.join(\" \u2022 \");\n\n  return (\n    &lt;&gt;\n      {/* Backdrop */}\n      &lt;div\n        className=\"fixed inset-0 z-50\"\n        onClick={onClose}\n        aria-hidden=\"true\"\n      /&gt;\n\n      {/* Drawer */}\n      &lt;div\n        className=\"fixed bottom-0 left-0 right-0 z-50 rounded-t-lg overflow-hidden\"\n        style={{\n          backgroundColor: \"var(--bg-card)\",\n          maxHeight: \"60vh\",\n        }}\n        onClick={(e) =&gt; e.stopPropagation()}\n      &gt;\n        {/* Drag handle */}\n        &lt;div className=\"flex justify-center py-3\"&gt;\n          &lt;div\n            className=\"w-10 h-1 rounded-full\"\n            style={{ backgroundColor: \"var(--text-muted)\" }}\n          /&gt;\n        &lt;/div&gt;\n\n        {/* Scrollable content */}\n        &lt;div\n          className=\"overflow-y-auto px-4 pb-6\"\n          style={{ maxHeight: \"calc(60vh - 40px)\" }}\n        &gt;\n          {/* Header row: Title + controls */}\n          &lt;div className=\"flex items-start justify-between gap-4 mb-2\"&gt;\n            &lt;h2\n              className=\"text-lg font-semibold line-clamp-2 flex-1\"\n              style={{ color: \"var(--text-primary)\" }}\n            &gt;\n              {image.title || \"Untitled\"}\n            &lt;/h2&gt;\n            &lt;div className=\"flex items-center gap-2 flex-shrink-0\"&gt;\n              &lt;RatingBadge\n                rating={rating}\n                onClick={onRatingClick}\n                size=\"medium\"\n              /&gt;\n              &lt;OCounterButton\n                imageId={image.id}\n                initialCount={oCounter}\n                onChange={onOCounterChange}\n                size=\"medium\"\n                variant=\"card\"\n                interactive={true}\n              /&gt;\n              &lt;FavoriteButton\n                isFavorite={isFavorite}\n                onChange={onFavoriteChange}\n                size=\"medium\"\n                variant=\"card\"\n              /&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n\n          {/* Subtitle: Studio \u2022 Date \u2022 Resolution */}\n          {subtitle &amp;&amp; (\n            &lt;p\n              className=\"text-sm mb-4\"\n              style={{ color: \"var(--text-secondary)\" }}\n            &gt;\n              {studio ? (\n                &lt;Link\n                  to={`/studio/${studio.id}`}\n                  className=\"hover:underline hover:text-blue-400\"\n                  onClick={onClose}\n                &gt;\n                  {studio.name}\n                &lt;/Link&gt;\n              ) : null}\n              {studio &amp;&amp; (date || resolution) ? \" \u2022 \" : null}\n              {date}\n              {date &amp;&amp; resolution ? \" \u2022 \" : null}\n              {resolution}\n            &lt;/p&gt;\n          )}\n\n          {/* Performers section */}\n          {performers.length &gt; 0 &amp;&amp; (\n            &lt;div className=\"mb-4\"&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Performers\n              &lt;/h3&gt;\n              &lt;div\n                className=\"flex gap-4 overflow-x-auto pb-2 scroll-smooth\"\n                style={{ scrollbarWidth: \"thin\" }}\n              &gt;\n                {performers.map((performer) =&gt; (\n                  &lt;Link\n                    key={performer.id}\n                    to={`/performer/${performer.id}`}\n                    className=\"flex flex-col items-center flex-shrink-0 group w-[120px]\"\n                    onClick={onClose}\n                  &gt;\n                    &lt;div\n                      className=\"aspect-[2/3] rounded-lg overflow-hidden mb-2 w-full border-2 border-transparent group-hover:border-[var(--accent-primary)] transition-all\"\n                      style={{ backgroundColor: \"var(--border-color)\" }}\n                    &gt;\n                      {performer.image_path ? (\n                        &lt;img\n                          src={performer.image_path}\n                          alt={performer.name}\n                          className=\"w-full h-full object-cover\"\n                        /&gt;\n                      ) : (\n                        &lt;div className=\"w-full h-full flex items-center justify-center\"&gt;\n                          &lt;span\n                            className=\"text-4xl\"\n                            style={{ color: \"var(--text-secondary)\" }}\n                          &gt;\n                            {performer.gender === \"MALE\" ? \"\u2642\" : \"\u2640\"}\n                          &lt;/span&gt;\n                        &lt;/div&gt;\n                      )}\n                    &lt;/div&gt;\n                    &lt;span\n                      className=\"text-xs font-medium text-center w-full line-clamp-2 group-hover:underline\"\n                      style={{ color: \"var(--text-primary)\" }}\n                    &gt;\n                      {performer.name}\n                    &lt;/span&gt;\n                  &lt;/Link&gt;\n                ))}\n              &lt;/div&gt;\n            &lt;/div&gt;\n          )}\n\n          {/* Tags section */}\n          {tags.length &gt; 0 &amp;&amp; (\n            &lt;div className=\"mb-4\"&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Tags\n              &lt;/h3&gt;\n              &lt;TagChips tags={tags} /&gt;\n            &lt;/div&gt;\n          )}\n\n          {/* Details section (if description exists) */}\n          {image.details &amp;&amp; (\n            &lt;div&gt;\n              &lt;h3\n                className=\"text-sm font-semibold uppercase tracking-wide mb-3 pb-2\"\n                style={{\n                  color: \"var(--text-primary)\",\n                  borderBottom: \"2px solid var(--accent-primary)\",\n                }}\n              &gt;\n                Details\n              &lt;/h3&gt;\n              &lt;p\n                className=\"text-sm leading-relaxed\"\n                style={{ color: \"var(--text-primary)\" }}\n              &gt;\n                {image.details}\n              &lt;/p&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  );\n};\n\nexport default MetadataDrawer;\n</code></pre> <p>Step 2: Verify file exists</p> <p>Run: <pre><code>ls -la client/src/components/ui/MetadataDrawer.jsx\n</code></pre></p> <p>Expected: File exists</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/MetadataDrawer.jsx\ngit commit -m \"feat: add MetadataDrawer component for image metadata display\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-4-add-swipe-gestures-to-lightbox","title":"Task 4: Add swipe gestures to Lightbox","text":"<p>Files: - Modify: <code>client/src/components/ui/Lightbox.jsx</code></p> <p>Step 1: Add imports at top of file</p> <p>Add after existing imports:</p> <pre><code>import { useSwipeable } from \"react-swipeable\";\nimport { Info, Maximize, Minimize } from \"lucide-react\";\nimport { useFullscreen } from \"../../hooks/useFullscreen.js\";\nimport MetadataDrawer from \"./MetadataDrawer.jsx\";\n</code></pre> <p>Step 2: Add new state variables after existing state</p> <p>Add after <code>const [isRatingPopoverOpen, setIsRatingPopoverOpen] = useState(false);</code>:</p> <pre><code>// New state for enhanced features\nconst [controlsVisible, setControlsVisible] = useState(true);\nconst [drawerOpen, setDrawerOpen] = useState(false);\nconst { isFullscreen, toggleFullscreen, supportsFullscreen } = useFullscreen();\nconst controlsTimeoutRef = useRef(null);\n</code></pre> <p>Step 3: Add controls auto-hide logic</p> <p>Add after the controlsTimeoutRef declaration:</p> <pre><code>// Auto-hide controls after inactivity\nconst showControls = useCallback(() =&gt; {\n  setControlsVisible(true);\n  if (controlsTimeoutRef.current) {\n    clearTimeout(controlsTimeoutRef.current);\n  }\n  controlsTimeoutRef.current = setTimeout(() =&gt; {\n    if (!drawerOpen &amp;&amp; !isRatingPopoverOpen) {\n      setControlsVisible(false);\n    }\n  }, 3000);\n}, [drawerOpen, isRatingPopoverOpen]);\n\n// Reset auto-hide on mouse movement (desktop)\nconst handleMouseMove = useCallback(() =&gt; {\n  showControls();\n}, [showControls]);\n\n// Toggle controls on tap (mobile)\nconst handleTap = useCallback(() =&gt; {\n  setControlsVisible((prev) =&gt; !prev);\n}, []);\n</code></pre> <p>Step 4: Add swipe handlers</p> <p>Add after handleTap:</p> <pre><code>// Swipe gesture handlers\nconst swipeHandlers = useSwipeable({\n  onSwipedLeft: () =&gt; goToNext(),\n  onSwipedRight: () =&gt; goToPrevious(),\n  onSwipedUp: () =&gt; setDrawerOpen(true),\n  onSwipedDown: () =&gt; {\n    if (drawerOpen) {\n      setDrawerOpen(false);\n    } else {\n      onClose();\n    }\n  },\n  onTap: handleTap,\n  delta: 50,\n  preventScrollOnSwipe: true,\n  trackMouse: false,\n});\n</code></pre> <p>Step 5: Update keyboard handler for new shortcuts</p> <p>Replace the existing keyboard handler <code>useEffect</code> (lines 206-231) with:</p> <pre><code>// Keyboard controls\nuseEffect(() =&gt; {\n  if (!isOpen) return;\n\n  const handleKeyDown = (e) =&gt; {\n    // Ignore if typing in an input\n    if (e.target.tagName === \"INPUT\" || e.target.tagName === \"TEXTAREA\") return;\n\n    switch (e.key) {\n      case \"Escape\":\n        if (drawerOpen) {\n          setDrawerOpen(false);\n        } else if (isFullscreen) {\n          // Browser handles fullscreen exit, but we track state\n        } else {\n          onClose();\n        }\n        break;\n      case \"ArrowLeft\":\n        goToPrevious();\n        break;\n      case \"ArrowRight\":\n        goToNext();\n        break;\n      case \" \":\n        e.preventDefault();\n        toggleSlideshow();\n        break;\n      case \"i\":\n      case \"I\":\n        setDrawerOpen((prev) =&gt; !prev);\n        break;\n      case \"f\":\n      case \"F\":\n        toggleFullscreen();\n        break;\n      default:\n        break;\n    }\n    showControls();\n  };\n\n  window.addEventListener(\"keydown\", handleKeyDown);\n  return () =&gt; window.removeEventListener(\"keydown\", handleKeyDown);\n}, [isOpen, onClose, goToPrevious, goToNext, toggleSlideshow, drawerOpen, isFullscreen, toggleFullscreen, showControls]);\n</code></pre> <p>Step 6: Clean up timeout on unmount</p> <p>Add after the keyboard useEffect:</p> <pre><code>// Cleanup controls timeout\nuseEffect(() =&gt; {\n  return () =&gt; {\n    if (controlsTimeoutRef.current) {\n      clearTimeout(controlsTimeoutRef.current);\n    }\n  };\n}, []);\n</code></pre> <p>Step 7: Wrap the main container with swipe handlers</p> <p>Replace the opening <code>&lt;div</code> (line 253-258) with:</p> <pre><code>&lt;div\n  {...swipeHandlers}\n  className=\"fixed inset-0 z-50 flex items-center justify-center\"\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.95)\",\n  }}\n  onMouseMove={handleMouseMove}\n  onClick={onClose}\n&gt;\n</code></pre> <p>Step 8: Add controls visibility wrapper and new buttons</p> <p>Replace the close button section (lines 261-271) with:</p> <pre><code>{/* Top controls bar */}\n&lt;div\n  className={`absolute top-4 left-4 right-4 z-50 flex justify-between items-center transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n&gt;\n  {/* Left side - empty for balance */}\n  &lt;div /&gt;\n\n  {/* Right side controls */}\n  &lt;div className=\"flex items-center gap-2\"&gt;\n    {/* Info button */}\n    &lt;button\n      onClick={(e) =&gt; {\n        e.stopPropagation();\n        setDrawerOpen(true);\n      }}\n      className=\"p-2 rounded-full transition-colors\"\n      style={{\n        backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n        color: \"var(--text-primary)\",\n      }}\n      aria-label=\"Show image info\"\n    &gt;\n      &lt;Info size={24} /&gt;\n    &lt;/button&gt;\n\n    {/* Fullscreen button */}\n    {supportsFullscreen &amp;&amp; (\n      &lt;button\n        onClick={(e) =&gt; {\n          e.stopPropagation();\n          toggleFullscreen();\n        }}\n        className=\"p-2 rounded-full transition-colors\"\n        style={{\n          backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n          color: \"var(--text-primary)\",\n        }}\n        aria-label={isFullscreen ? \"Exit fullscreen\" : \"Enter fullscreen\"}\n      &gt;\n        {isFullscreen ? &lt;Minimize size={24} /&gt; : &lt;Maximize size={24} /&gt;}\n      &lt;/button&gt;\n    )}\n\n    {/* Close button */}\n    &lt;button\n      onClick={onClose}\n      className=\"p-2 rounded-full transition-colors\"\n      style={{\n        backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n        color: \"var(--text-primary)\",\n      }}\n      aria-label=\"Close lightbox\"\n    &gt;\n      &lt;X size={24} /&gt;\n    &lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 9: Wrap existing bottom controls with visibility</p> <p>Wrap the image counter (lines 273-282), compact controls (lines 284-403), and keyboard hints (lines 494-505) with the visibility class.</p> <p>For the image counter, change to:</p> <pre><code>{/* Image counter - bottom left */}\n&lt;div\n  className={`absolute bottom-4 left-4 z-50 px-4 py-2 rounded-lg text-lg font-medium transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    color: \"var(--text-primary)\",\n  }}\n&gt;\n  {currentIndex + 1} / {images.length}\n&lt;/div&gt;\n</code></pre> <p>For the compact controls row (slideshow, rating, etc), wrap with:</p> <pre><code>{/* Compact controls - positioned to the right */}\n&lt;div className={`absolute top-16 right-4 z-50 flex items-center gap-3 transition-opacity duration-300 ${\n  controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n}`}&gt;\n</code></pre> <p>For the keyboard hints, change to:</p> <pre><code>{/* Keyboard hints */}\n&lt;div\n  className={`absolute bottom-4 right-4 z-50 px-3 py-2 rounded-lg text-xs transition-opacity duration-300 ${\n    controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n  }`}\n  style={{\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    color: \"var(--text-muted)\",\n  }}\n&gt;\n  &lt;div&gt;\u2190 \u2192 Navigate&lt;/div&gt;\n  &lt;div&gt;Space Slideshow&lt;/div&gt;\n  &lt;div&gt;i Info \u2022 f Fullscreen&lt;/div&gt;\n  &lt;div&gt;Esc Close&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Step 10: Wrap navigation buttons with visibility</p> <p>For both Previous and Next buttons, add the visibility class:</p> <pre><code>{/* Previous button */}\n{images.length &gt; 1 &amp;&amp; (\n  &lt;button\n    onClick={(e) =&gt; {\n      e.stopPropagation();\n      goToPrevious();\n    }}\n    className={`absolute left-4 top-1/2 transform -translate-y-1/2 z-50 p-3 rounded-full transition-all duration-300 ${\n      controlsVisible ? \"opacity-100\" : \"opacity-0 pointer-events-none\"\n    }`}\n    style={{\n      backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n      color: \"var(--text-primary)\",\n    }}\n    aria-label=\"Previous image\"\n  &gt;\n    &lt;ChevronLeft size={32} /&gt;\n  &lt;/button&gt;\n)}\n</code></pre> <p>(Same pattern for Next button)</p> <p>Step 11: Add MetadataDrawer at end of component</p> <p>Before the closing <code>&lt;/div&gt;</code> of the main container, add:</p> <pre><code>{/* Metadata Drawer */}\n&lt;MetadataDrawer\n  open={drawerOpen}\n  onClose={() =&gt; setDrawerOpen(false)}\n  image={currentImage}\n  rating={rating}\n  isFavorite={isFavorite}\n  oCounter={oCounter}\n  onRatingClick={() =&gt; setIsRatingPopoverOpen(true)}\n  onFavoriteChange={handleFavoriteChange}\n  onOCounterChange={handleOCounterChange}\n/&gt;\n</code></pre> <p>Step 12: Verify lint passes</p> <p>Run: <pre><code>cd client &amp;&amp; npm run lint\n</code></pre></p> <p>Expected: No errors</p> <p>Step 13: Commit</p> <pre><code>git add client/src/components/ui/Lightbox.jsx\ngit commit -m \"feat: add swipe gestures, fullscreen, and metadata drawer to Lightbox\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-5-manual-testing-checklist","title":"Task 5: Manual Testing Checklist","text":"<p>Files: None (testing only)</p> <p>Step 1: Start dev server</p> <p>Run: <pre><code>cd client &amp;&amp; npm run dev\n</code></pre></p> <p>Step 2: Test on desktop browser</p> <ul> <li> Open any gallery and click an image to open lightbox</li> <li> Press <code>i</code> key - drawer should open</li> <li> Press <code>i</code> again - drawer should close</li> <li> Press <code>f</code> key - should go fullscreen</li> <li> Press <code>f</code> again - should exit fullscreen</li> <li> Press <code>Escape</code> with drawer open - drawer closes, lightbox stays</li> <li> Press <code>Escape</code> with drawer closed - lightbox closes</li> <li> Click Info button - drawer opens</li> <li> Click Fullscreen button - goes fullscreen</li> <li> Mouse movement resets auto-hide timer</li> <li> After 3s of no mouse movement, controls fade out</li> <li> Click on image toggles controls visibility</li> </ul> <p>Step 3: Test on mobile (or Chrome DevTools mobile emulation)</p> <ul> <li> Swipe left - next image</li> <li> Swipe right - previous image</li> <li> Swipe up - drawer opens</li> <li> Swipe down (drawer open) - drawer closes</li> <li> Swipe down (drawer closed) - lightbox closes</li> <li> Tap image - controls toggle</li> <li> Performers in drawer are horizontally scrollable</li> <li> Tags in drawer display correctly</li> <li> Clicking performer/tag link closes lightbox and navigates</li> </ul> <p>Step 4: Test edge cases</p> <ul> <li> Lightbox with single image - no nav arrows</li> <li> Image without performers - no performers section in drawer</li> <li> Image without tags - no tags section in drawer</li> <li> Image without studio - subtitle shows only date/resolution</li> <li> Rating/favorite/O-counter work in drawer</li> </ul> <p>Step 5: Commit any fixes found during testing</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during lightbox testing\"\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#task-6-final-cleanup-and-pr-preparation","title":"Task 6: Final cleanup and PR preparation","text":"<p>Files: - Modify: <code>docs/plans/2024-12-29-lightbox-enhancements-design.md</code> (add implementation notes)</p> <p>Step 1: Run full lint check</p> <p>Run: <pre><code>cd client &amp;&amp; npm run lint\n</code></pre></p> <p>Expected: No errors</p> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd client &amp;&amp; npm run test:run\n</code></pre></p> <p>Expected: All tests pass</p> <p>Step 3: Build check</p> <p>Run: <pre><code>cd client &amp;&amp; npm run build\n</code></pre></p> <p>Expected: Build succeeds</p> <p>Step 4: Commit any final fixes</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup for lightbox enhancements\"\n</code></pre> <p>Step 5: Push branch</p> <pre><code>git push -u origin feature/lightbox-enhancements-design\n</code></pre>"},{"location":"plans/2024-12-29-lightbox-enhancements-impl/#summary","title":"Summary","text":"Task Description Est. Complexity 1 Add react-swipeable dependency Low 2 Create useFullscreen hook Low 3 Create MetadataDrawer component Medium 4 Add swipe gestures to Lightbox High 5 Manual testing Medium 6 Final cleanup and PR Low <p>Total: 6 tasks with frequent commits for easy rollback if needed.</p>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/","title":"View Tracking &amp; Request Cancellation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix duplicate image view tracking in React Strict Mode and add request cancellation for search pages.</p> <p>Architecture: Two independent fixes: (1) Replace immediate view tracking with 3-second dwell timer in Lightbox; (2) Create <code>useCancellableQuery</code> hook with AbortController support, update API layer to pass signals, refactor 7 search pages to use the hook.</p> <p>Tech Stack: React hooks, AbortController, fetch API</p>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-1-fix-dwell-time-view-tracking-in-lightbox","title":"Task 1: Fix Dwell-Time View Tracking in Lightbox","text":"<p>Files: - Modify: <code>client/src/components/ui/Lightbox.jsx:21</code> (add ref) - Modify: <code>client/src/components/ui/Lightbox.jsx:209-218</code> (replace effect)</p> <p>Step 1: Add viewTimerRef</p> <p>After line 21 (<code>const intervalRef = useRef(null);</code>), add:</p> <pre><code>const viewTimerRef = useRef(null);\n</code></pre> <p>Step 2: Replace the view tracking useEffect</p> <p>Find this effect (around lines 209-218):</p> <pre><code>// Track image view when image changes in lightbox\nuseEffect(() =&gt; {\n  const currentImage = images[currentIndex];\n  if (!currentImage?.id || !isOpen) return;\n\n  // Record the view (fire and forget - don't block UI)\n  imageViewHistoryApi.recordView(currentImage.id).catch((err) =&gt; {\n    console.error(\"Failed to record image view:\", err);\n  });\n}, [currentIndex, images, isOpen]);\n</code></pre> <p>Replace with:</p> <pre><code>// Track image view with 3-second dwell time\n// Only records if user views image for 3+ seconds (filters rapid navigation)\nuseEffect(() =&gt; {\n  const currentImage = images[currentIndex];\n\n  // Clear any existing timer\n  if (viewTimerRef.current) {\n    clearTimeout(viewTimerRef.current);\n    viewTimerRef.current = null;\n  }\n\n  if (!currentImage?.id || !isOpen) return;\n\n  // Start 3-second dwell timer\n  viewTimerRef.current = setTimeout(() =&gt; {\n    imageViewHistoryApi.recordView(currentImage.id).catch((err) =&gt; {\n      console.error(\"Failed to record image view:\", err);\n    });\n    viewTimerRef.current = null;\n  }, 3000);\n\n  // Cleanup on navigation/close\n  return () =&gt; {\n    if (viewTimerRef.current) {\n      clearTimeout(viewTimerRef.current);\n      viewTimerRef.current = null;\n    }\n  };\n}, [currentIndex, images, isOpen]);\n</code></pre> <p>Step 3: Test manually</p> <ul> <li>Open lightbox, navigate quickly through images \u2192 Network tab should show no view API calls</li> <li>Open lightbox, stay on image for 4 seconds \u2192 Network tab should show exactly 1 view call</li> <li>In dev mode (Strict Mode), verify no duplicate calls</li> </ul> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/Lightbox.jsx\ngit commit -m \"fix: use 3-second dwell time for image view tracking\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-2-create-usecancellablequery-hook","title":"Task 2: Create useCancellableQuery Hook","text":"<p>Files: - Create: <code>client/src/hooks/useCancellableQuery.js</code></p> <p>Step 1: Create the hook file</p> <p>Create <code>client/src/hooks/useCancellableQuery.js</code>:</p> <pre><code>import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useAuth } from \"./useAuth.js\";\n\n/**\n * Hook for making cancellable API queries with automatic state management.\n * Aborts previous in-flight requests when a new query is executed.\n *\n * @param {Object} options\n * @param {boolean} options.initialLoading - Initial loading state (default: true)\n * @returns {Object} { data, isLoading, error, execute, setData, initMessage }\n */\nexport function useCancellableQuery({ initialLoading = true } = {}) {\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(initialLoading);\n  const [error, setError] = useState(null);\n  const [initMessage, setInitMessage] = useState(null);\n  const abortControllerRef = useRef(null);\n  const retryTimeoutRef = useRef(null);\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n\n  /**\n   * Execute a query function with automatic cancellation of previous requests.\n   * @param {Function} queryFn - Async function that receives AbortSignal and returns data\n   * @param {Object} options\n   * @param {number} options.retryCount - Current retry count for initializing state (internal use)\n   */\n  const execute = useCallback(\n    async (queryFn, { retryCount = 0 } = {}) =&gt; {\n      // Don't make API calls if not authenticated or still checking auth\n      if (isAuthLoading || !isAuthenticated) {\n        setIsLoading(false);\n        return;\n      }\n\n      // Clear any pending retry\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n\n      // Abort previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      // Create new controller\n      const controller = new AbortController();\n      abortControllerRef.current = controller;\n\n      try {\n        setIsLoading(true);\n        setError(null);\n        setInitMessage(null);\n\n        const result = await queryFn(controller.signal);\n\n        // Only update state if not aborted\n        if (!controller.signal.aborted) {\n          setData(result);\n          setIsLoading(false);\n        }\n      } catch (err) {\n        // Swallow AbortError - request was intentionally cancelled\n        if (err.name === \"AbortError\") {\n          return;\n        }\n\n        // Only update state if not aborted\n        if (!controller.signal.aborted) {\n          // Handle server initializing state with retry\n          if (err.isInitializing &amp;&amp; retryCount &lt; 60) {\n            setInitMessage(\"Server is syncing library, please wait...\");\n            retryTimeoutRef.current = setTimeout(() =&gt; {\n              execute(queryFn, { retryCount: retryCount + 1 });\n            }, 5000);\n            return;\n          }\n\n          setError(err);\n          setIsLoading(false);\n        }\n      }\n    },\n    [isAuthLoading, isAuthenticated]\n  );\n\n  /**\n   * Reset the query state\n   */\n  const reset = useCallback(() =&gt; {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    if (retryTimeoutRef.current) {\n      clearTimeout(retryTimeoutRef.current);\n    }\n    setData(null);\n    setIsLoading(false);\n    setError(null);\n    setInitMessage(null);\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    data,\n    isLoading,\n    error,\n    initMessage,\n    execute,\n    setData,\n    reset,\n  };\n}\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/hooks/useCancellableQuery.js\ngit commit -m \"feat: add useCancellableQuery hook with AbortController support\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-3-add-signal-support-to-api-layer","title":"Task 3: Add Signal Support to API Layer","text":"<p>Files: - Modify: <code>client/src/services/api.js:11-51</code> (apiFetch function) - Modify: <code>client/src/services/api.js:101-103</code> (findScenes) - Modify: <code>client/src/services/api.js:111-113</code> (findPerformers) - Modify: <code>client/src/services/api.js:121-123</code> (findStudios) - Modify: <code>client/src/services/api.js:131-133</code> (findTags) - Modify: <code>client/src/services/api.js:214-216</code> (findGalleries) - Modify: <code>client/src/services/api.js:242-244</code> (findGroups) - Modify: <code>client/src/services/api.js:284-286</code> (findImages)</p> <p>Step 1: Update apiFetch to handle AbortError</p> <p>Find the <code>apiFetch</code> function. After line 22 (<code>const response = await fetch(url, config);</code>), wrap the response handling to catch AbortError early. Update the entire function:</p> <pre><code>async function apiFetch(endpoint, options = {}) {\n  const url = `${API_BASE_URL}${endpoint}`;\n\n  const config = {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n    ...options,\n  };\n\n  let response;\n  try {\n    response = await fetch(url, config);\n  } catch (err) {\n    // Re-throw AbortError so it can be caught by useCancellableQuery\n    if (err.name === \"AbortError\") {\n      throw err;\n    }\n    throw err;\n  }\n\n  if (!response.ok) {\n    // Try to parse error response body\n    let errorData;\n    try {\n      errorData = await response.json();\n    } catch {\n      errorData = { error: `HTTP error! status: ${response.status}` };\n    }\n\n    // Create error with additional metadata\n    const error = new Error(\n      errorData.error ||\n        errorData.message ||\n        `HTTP error! status: ${response.status}`\n    );\n    error.status = response.status;\n    error.data = errorData;\n\n    // Special handling for 503 - server initializing\n    if (response.status === 503 &amp;&amp; errorData.ready === false) {\n      error.isInitializing = true;\n    }\n\n    throw error;\n  }\n\n  return await response.json();\n}\n</code></pre> <p>Step 2: Update libraryApi methods to accept signal</p> <p>Update each find method to accept and pass the signal. Replace each method:</p> <p><code>findScenes</code>: <pre><code>findScenes: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/scenes\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findPerformers</code>: <pre><code>findPerformers: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/performers\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findStudios</code>: <pre><code>findStudios: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/studios\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findTags</code>: <pre><code>findTags: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/tags\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findGalleries</code>: <pre><code>findGalleries: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/galleries\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findGroups</code>: <pre><code>findGroups: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/groups\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p><code>findImages</code>: <pre><code>findImages: (params = {}, signal) =&gt; {\n  return apiFetch(\"/library/images\", {\n    method: \"POST\",\n    body: JSON.stringify(params),\n    signal,\n  });\n},\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add client/src/services/api.js\ngit commit -m \"feat: add AbortController signal support to library API methods\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-4-refactor-imagesjsx-to-use-usecancellablequery","title":"Task 4: Refactor Images.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import for the hook: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove these lines: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute, setData } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire <code>handleQueryChange</code> function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getImages(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getImages to accept signal</p> <p>Change: <pre><code>const getImages = async (query) =&gt; {\n  const response = await libraryApi.findImages(query);\n</code></pre></p> <p>To: <pre><code>const getImages = async (query, signal) =&gt; {\n  const response = await libraryApi.findImages(query, signal);\n</code></pre></p> <p>Step 5: Verify the error conditional still works</p> <p>The existing code <code>if (error &amp;&amp; !initMessage)</code> should still work since <code>initMessage</code> comes from the hook.</p> <p>Step 6: Test manually</p> <ul> <li>Go to Images page, rapidly change filters \u2192 should see cancelled requests in Network tab</li> <li>Ensure images load correctly</li> </ul> <p>Step 7: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"refactor: use useCancellableQuery in Images page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-5-refactor-performersjsx-to-use-usecancellablequery","title":"Task 5: Refactor Performers.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Performers.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getPerformers(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getPerformers to accept signal</p> <p>Change: <pre><code>const getPerformers = async (query) =&gt; {\n  const response = await libraryApi.findPerformers(query);\n</code></pre></p> <p>To: <pre><code>const getPerformers = async (query, signal) =&gt; {\n  const response = await libraryApi.findPerformers(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Performers.jsx\ngit commit -m \"refactor: use useCancellableQuery in Performers page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-6-refactor-studiosjsx-to-use-usecancellablequery","title":"Task 6: Refactor Studios.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Studios.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getStudios(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getStudios to accept signal</p> <p>Change: <pre><code>const getStudios = async (query) =&gt; {\n  const response = await libraryApi.findStudios(query);\n</code></pre></p> <p>To: <pre><code>const getStudios = async (query, signal) =&gt; {\n  const response = await libraryApi.findStudios(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Studios.jsx\ngit commit -m \"refactor: use useCancellableQuery in Studios page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-7-refactor-tagsjsx-to-use-usecancellablequery","title":"Task 7: Refactor Tags.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Tags.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getTags(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getTags to accept signal</p> <p>Change: <pre><code>const getTags = async (query) =&gt; {\n  const response = await libraryApi.findTags(query);\n</code></pre></p> <p>To: <pre><code>const getTags = async (query, signal) =&gt; {\n  const response = await libraryApi.findTags(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Tags.jsx\ngit commit -m \"refactor: use useCancellableQuery in Tags page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-8-refactor-groupsjsx-to-use-usecancellablequery","title":"Task 8: Refactor Groups.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Groups.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getGroups(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getGroups to accept signal</p> <p>Change: <pre><code>const getGroups = async (query) =&gt; {\n  const response = await libraryApi.findGroups(query);\n</code></pre></p> <p>To: <pre><code>const getGroups = async (query, signal) =&gt; {\n  const response = await libraryApi.findGroups(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Groups.jsx\ngit commit -m \"refactor: use useCancellableQuery in Groups page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-9-refactor-galleriesjsx-to-use-usecancellablequery","title":"Task 9: Refactor Galleries.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/pages/Galleries.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useRef, useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback, useRef } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute } = useCancellableQuery();\n</code></pre></p> <p>Step 3: Replace handleQueryChange</p> <p>Remove and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getGalleries(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getGalleries to accept signal</p> <p>Change: <pre><code>const getGalleries = async (query) =&gt; {\n  const response = await libraryApi.findGalleries(query);\n</code></pre></p> <p>To: <pre><code>const getGalleries = async (query, signal) =&gt; {\n  const response = await libraryApi.findGalleries(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Galleries.jsx\ngit commit -m \"refactor: use useCancellableQuery in Galleries page\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-10-refactor-scenesearchjsx-to-use-usecancellablequery","title":"Task 10: Refactor SceneSearch.jsx to Use useCancellableQuery","text":"<p>Files: - Modify: <code>client/src/components/scene-search/SceneSearch.jsx</code></p> <p>Step 1: Update imports</p> <p>Replace: <pre><code>import { useState } from \"react\";\n</code></pre></p> <p>With: <pre><code>import { useCallback } from \"react\";\n</code></pre></p> <p>Add import: <pre><code>import { useCancellableQuery } from \"../../hooks/useCancellableQuery.js\";\n</code></pre></p> <p>Step 2: Replace state declarations</p> <p>Remove: <pre><code>const [lastQuery, setLastQuery] = useState(null);\nconst [isLoading, setIsLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst [data, setData] = useState(null);\nconst [initMessage, setInitMessage] = useState(null);\n</code></pre></p> <p>Replace with: <pre><code>const { data, isLoading, error, initMessage, execute, setData } = useCancellableQuery();\n</code></pre></p> <p>Note: SceneSearch needs <code>setData</code> for <code>handleHideSuccess</code>.</p> <p>Step 3: Replace handleQueryChange</p> <p>Remove the entire function and replace with:</p> <pre><code>const handleQueryChange = useCallback(\n  (newQuery) =&gt; {\n    execute((signal) =&gt; getScenes(newQuery, signal));\n  },\n  [execute]\n);\n</code></pre> <p>Step 4: Update getScenes to accept signal</p> <p>Change: <pre><code>const getScenes = async (query) =&gt; {\n  const response = await libraryApi.findScenes(query);\n</code></pre></p> <p>To: <pre><code>const getScenes = async (query, signal) =&gt; {\n  const response = await libraryApi.findScenes(query, signal);\n</code></pre></p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/scene-search/SceneSearch.jsx\ngit commit -m \"refactor: use useCancellableQuery in SceneSearch\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-11-run-linting-and-fix-any-issues","title":"Task 11: Run Linting and Fix Any Issues","text":"<p>Step 1: Run linting</p> <pre><code>cd client &amp;&amp; npm run lint\n</code></pre> <p>Step 2: Fix any issues</p> <p>Address any linting errors that appear.</p> <p>Step 3: Commit fixes if any</p> <pre><code>git add -A\ngit commit -m \"fix: address linting issues\"\n</code></pre>"},{"location":"plans/2024-12-30-view-tracking-request-cancellation-design/#task-12-manual-testing-verification","title":"Task 12: Manual Testing Verification","text":"<p>Test View Tracking: 1. Open Images page, click an image to open lightbox 2. Navigate quickly through images (arrow keys or buttons) 3. Open Network tab, filter by \"view\" - should see NO requests for quick navigation 4. Stay on one image for 4+ seconds 5. Should see exactly 1 <code>/api/image-view-history/view</code> request 6. Navigate to new image, wait 4+ seconds \u2192 another view request 7. In React dev mode (Strict Mode), verify no duplicate requests</p> <p>Test Request Cancellation: 1. Go to any search page (Images, Performers, etc.) 2. Open Network tab 3. Type in search box rapidly (e.g., \"test\") 4. Should see previous requests cancelled (status \"cancelled\" or greyed out) 5. Only final request should complete 6. Change filters/pagination rapidly \u2192 same cancellation behavior 7. Result should show data from final query, no flicker</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/","title":"Fix Direct Stash Queries","text":"<p>Branch: <code>bugfix/direct-stash-queries</code> Status: Design Complete Complexity: Low-Medium</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#problem-statement","title":"Problem Statement","text":"<p>Two locations in the codebase bypass Peek's cache and query Stash directly for UI data:</p> <ol> <li><code>playlist.ts:76,165</code> \u2014 Fetches full scene data from Stash to display playlist items</li> <li>Bug: Shows Stash's global O-counter and favorite values instead of the user's personal Peek values</li> <li> <p>Performance: Unnecessary network round-trip on every playlist view</p> </li> <li> <p><code>watchHistory.ts:61</code> \u2014 Fetches scene duration from Stash on every 10-second playback ping</p> </li> <li>Performance: Adds latency to every ping during video playback</li> <li>Reliability: Playback tracking fails if Stash is temporarily unreachable</li> </ol> <p>Both issues violate the principle: All UI data should come from Peek's cache.</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#solution-overview","title":"Solution Overview","text":"<p>Both fixes follow the same pattern: replace Stash GraphQL queries with Prisma queries against cached <code>StashScene</code> data.</p> <p>Playlist Fix (<code>playlist.ts</code>): 1. Query <code>StashScene</code> table by IDs instead of <code>stash.findScenes()</code> 2. Merge with user's <code>WatchHistory</code> and <code>SceneRating</code> data for personal O-counter/favorite 3. Apply user restrictions via <code>userRestrictionService.filterScenesForUser()</code> \u2014 restricted scenes are excluded from playlist display 4. Transform paths using existing <code>stashUrlProxy</code> utilities</p> <p>WatchHistory Fix (<code>watchHistory.ts</code>): 1. Query <code>StashScene</code> table for <code>duration</code> field instead of <code>stash.findScenes()</code> 2. The <code>duration</code> column already exists in cache (schema line 433) 3. Fallback: if duration is null/0, continue without percentage calculation (don't fail the ping)</p> <p>Scope boundaries: - We are NOT changing how playlists are created/edited - We are NOT changing the watch history tracking logic itself - We are only changing WHERE the scene data comes from</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#file-servercontrollersplaylistts","title":"File: <code>server/controllers/playlist.ts</code>","text":"<p>Current flow (lines 76 and 165): <pre><code>const scenesResponse = await stash.findScenes({ scene_ids: sceneIds.map(id =&gt; parseInt(id)) });\n</code></pre></p> <p>New flow: <pre><code>// 1. Fetch scenes from cache\nconst scenes = await prisma.stashScene.findMany({\n  where: { id: { in: sceneIds }, deletedAt: null },\n  include: { performers: true, tags: true, groups: true, studio: true }\n});\n\n// 2. Apply user restrictions (filter out hidden/restricted scenes)\nconst visibleScenes = await userRestrictionService.filterScenesForUser(scenes, userId);\n\n// 3. Merge with user's personal data (WatchHistory + SceneRating)\nconst scenesWithUserData = await mergeScenesWithUserData(visibleScenes, userId);\n\n// 4. Transform paths for proxy URLs\nconst transformedScenes = scenesWithUserData.map(s =&gt; transformScene(s));\n</code></pre></p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#file-servercontrollerswatchhistoryts","title":"File: <code>server/controllers/watchHistory.ts</code>","text":"<p>Current flow (line 61): <pre><code>const sceneData = await stash.findScenes({ ids: [sceneId] });\nsceneDuration = sceneData.findScenes.scenes[0]?.files?.[0]?.duration || 0;\n</code></pre></p> <p>New flow: <pre><code>const scene = await prisma.stashScene.findUnique({\n  where: { id: sceneId },\n  select: { duration: true }\n});\nconst sceneDuration = scene?.duration || 0;\n</code></pre></p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Playlist display:</li> <li>Create a playlist with several scenes</li> <li>Verify scenes display with correct screenshots, titles, durations</li> <li>Rate a scene and mark as favorite in Peek</li> <li>Verify playlist shows YOUR rating/favorite, not Stash's global values</li> <li> <p>Increment O-counter on a scene, verify playlist reflects YOUR count</p> </li> <li> <p>Restricted content in playlists:</p> </li> <li>Add a scene to a playlist</li> <li>Have admin restrict that scene (via tag/studio/group restriction)</li> <li>Verify the scene no longer appears in the playlist</li> <li> <p>Unhide/unrestrict, verify it reappears</p> </li> <li> <p>Watch history duration:</p> </li> <li>Play a video, let it ping for 30+ seconds</li> <li>Check server logs \u2014 no Stash GraphQL calls for duration</li> <li> <p>Verify play percentage calculations still work correctly</p> </li> <li> <p>Edge cases:</p> </li> <li>Playlist with scene that was deleted from Stash (should be excluded gracefully)</li> <li>Scene with null/0 duration (ping should continue without failing)</li> </ol> <p>No new automated tests required \u2014 these are simple query pattern changes covered by existing integration tests.</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/controllers/playlist.ts</code> \u2014 Replace Stash queries with Prisma + restriction filtering</li> <li><code>server/controllers/watchHistory.ts</code> \u2014 Replace Stash query with Prisma lookup</li> </ul>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents this as a known issue under \"Stash Communication Patterns\"</li> </ul>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/","title":"Fix Direct Stash Queries - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace direct Stash GraphQL queries with Prisma cache queries in playlist.ts and watchHistory.ts to fix user data display bugs and improve performance.</p> <p>Architecture: Both fixes use the same pattern: query <code>StashScene</code> table via Prisma instead of Stash GraphQL, then apply existing user data merging and restriction filtering.</p> <p>Tech Stack: Prisma, TypeScript, Express</p>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-1-fix-watchhistoryts-duration-lookup","title":"Task 1: Fix watchHistory.ts Duration Lookup","text":"<p>The simpler fix \u2014 replace one Stash query with a Prisma lookup.</p> <p>Files: - Modify: <code>server/controllers/watchHistory.ts:57-69</code></p> <p>Step 1: Replace Stash query with Prisma lookup</p> <p>In <code>server/controllers/watchHistory.ts</code>, find lines 57-69:</p> <pre><code>// Get scene duration from Stash\nconst stash = stashInstanceManager.getDefault();\nlet sceneDuration = 0;\ntry {\n  const sceneData = await stash.findScenes({ ids: [sceneId] });\n  sceneDuration = sceneData.findScenes.scenes[0]?.files?.[0]?.duration || 0;\n} catch (error) {\n  logger.error(\"Failed to fetch scene duration from Stash\", {\n    sceneId,\n    error,\n  });\n  // Continue without duration - won't be able to calculate percentages\n}\n</code></pre> <p>Replace with:</p> <pre><code>// Get scene duration from cache\nlet sceneDuration = 0;\ntry {\n  const scene = await prisma.stashScene.findUnique({\n    where: { id: sceneId },\n    select: { duration: true },\n  });\n  sceneDuration = scene?.duration || 0;\n} catch (error) {\n  logger.error(\"Failed to fetch scene duration from cache\", {\n    sceneId,\n    error,\n  });\n  // Continue without duration - won't be able to calculate percentages\n}\n</code></pre> <p>Step 2: Remove unused import</p> <p>At the top of the file, find line 5:</p> <pre><code>import { stashInstanceManager } from \"../services/StashInstanceManager.js\";\n</code></pre> <p>Remove this line since we no longer use <code>stashInstanceManager</code> in this file.</p> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors related to watchHistory.ts</p> <p>Step 4: Test manually</p> <ol> <li>Start the server: <code>npm run dev</code></li> <li>Play a video in Peek</li> <li>Watch server logs \u2014 should see \"Watch history ping\" logs without any Stash GraphQL errors</li> <li>Check that play percentage calculations still work (resume position updates)</li> </ol> <p>Step 5: Commit</p> <pre><code>git add server/controllers/watchHistory.ts\ngit commit -m \"fix: use cached duration in watchHistory instead of Stash query\n\nReplaces direct Stash GraphQL query with Prisma cache lookup for scene\nduration. Eliminates network call on every 10-second playback ping.\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-2-fix-getplaylist-scene-fetching","title":"Task 2: Fix getPlaylist Scene Fetching","text":"<p>This is the main fix \u2014 replace Stash query with cache query and add restriction filtering.</p> <p>Files: - Modify: <code>server/controllers/playlist.ts:123-221</code> (getPlaylist function)</p> <p>Step 1: Add required imports</p> <p>At the top of <code>server/controllers/playlist.ts</code>, add these imports after the existing ones:</p> <pre><code>import { stashEntityService } from \"../services/StashEntityService.js\";\nimport { userRestrictionService } from \"../services/UserRestrictionService.js\";\n</code></pre> <p>Step 2: Replace getPlaylist implementation</p> <p>Replace the entire <code>getPlaylist</code> function (lines 123-221) with:</p> <pre><code>/**\n * Get single playlist with items and scene details from cache\n */\nexport const getPlaylist = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const playlistId = parseInt(req.params.id);\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    if (isNaN(playlistId)) {\n      return res.status(400).json({ error: \"Invalid playlist ID\" });\n    }\n\n    const playlist = await prisma.playlist.findFirst({\n      where: {\n        id: playlistId,\n        userId, // Only allow accessing own playlists\n      },\n      include: {\n        items: {\n          orderBy: {\n            position: \"asc\",\n          },\n        },\n      },\n    });\n\n    if (!playlist) {\n      return res.status(404).json({ error: \"Playlist not found\" });\n    }\n\n    // Fetch scene details from cache for all items\n    if (playlist.items.length &gt; 0) {\n      const sceneIds = playlist.items.map((item) =&gt; item.sceneId);\n\n      try {\n        // 1. Fetch scenes from cache with relations\n        const scenes = await stashEntityService.getScenesByIdsWithRelations(sceneIds);\n\n        // 2. Apply user restrictions (filter out hidden/restricted scenes)\n        const isAdmin = req.user?.role === \"ADMIN\";\n        const visibleScenes = isAdmin\n          ? scenes\n          : await userRestrictionService.filterScenesForUser(scenes, userId);\n\n        // 3. Reset user-specific fields to defaults before merging Peek user data\n        const scenesWithDefaults = visibleScenes.map((s) =&gt; ({\n          ...s,\n          ...DEFAULT_SCENE_USER_FIELDS,\n        }));\n\n        // 4. Merge with user's personal data (WatchHistory + SceneRating)\n        const { mergeScenesWithUserData } = await import(\"./library/scenes.js\");\n        const scenesWithUserHistory = await mergeScenesWithUserData(\n          scenesWithDefaults,\n          userId\n        );\n\n        // 5. Transform paths for proxy URLs\n        const transformedScenes = scenesWithUserHistory.map((s) =&gt;\n          transformScene(s as unknown as Scene)\n        );\n\n        // Create a map of scene ID to scene data\n        const sceneMap = new Map(\n          transformedScenes.map((s) =&gt; [s.id, s])\n        );\n\n        // Attach scene data to each playlist item\n        // Note: Items with restricted/hidden scenes will have scene: null\n        const itemsWithScenes = playlist.items.map((item) =&gt; ({\n          ...item,\n          scene: sceneMap.get(item.sceneId) || null,\n        }));\n\n        res.json({\n          playlist: {\n            ...playlist,\n            items: itemsWithScenes,\n          },\n        });\n      } catch (cacheError) {\n        console.error(\"Error fetching scenes from cache:\", cacheError);\n        // Return playlist without scene details if cache fails\n        res.json({ playlist });\n      }\n    } else {\n      res.json({ playlist });\n    }\n  } catch (error) {\n    console.error(\"Error getting playlist:\", error);\n    res.status(500).json({ error: \"Failed to get playlist\" });\n  }\n};\n</code></pre> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/playlist.ts\ngit commit -m \"fix: use cache for getPlaylist scene data\n\n- Replace Stash GraphQL query with StashEntityService cache lookup\n- Apply user restrictions to filter hidden/restricted scenes\n- Fixes bug where Stash O-counter/favorite showed instead of user's values\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-3-fix-getuserplaylists-scene-fetching","title":"Task 3: Fix getUserPlaylists Scene Fetching","text":"<p>Same pattern for the playlists list endpoint (preview thumbnails).</p> <p>Files: - Modify: <code>server/controllers/playlist.ts:30-118</code> (getUserPlaylists function)</p> <p>Step 1: Replace getUserPlaylists implementation</p> <p>Replace the entire <code>getUserPlaylists</code> function (lines 30-118) with:</p> <pre><code>/**\n * Get all playlists for current user\n * Includes first 4 items with scene preview data for thumbnail display\n */\nexport const getUserPlaylists = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    const playlists = await prisma.playlist.findMany({\n      where: {\n        userId,\n      },\n      include: {\n        _count: {\n          select: { items: true },\n        },\n        items: {\n          orderBy: {\n            position: \"asc\",\n          },\n          take: 4, // Only fetch first 4 items for preview\n        },\n      },\n      orderBy: {\n        updatedAt: \"desc\",\n      },\n    });\n\n    // Fetch scene details for preview items from cache\n    const playlistsWithScenes = await Promise.all(\n      playlists.map(async (playlist) =&gt; {\n        if (playlist.items.length === 0) {\n          return playlist;\n        }\n\n        const sceneIds = playlist.items.map((item) =&gt; item.sceneId);\n\n        try {\n          // 1. Fetch scenes from cache with relations\n          const scenes = await stashEntityService.getScenesByIdsWithRelations(sceneIds);\n\n          // 2. Apply user restrictions (filter out hidden/restricted scenes)\n          const isAdmin = req.user?.role === \"ADMIN\";\n          const visibleScenes = isAdmin\n            ? scenes\n            : await userRestrictionService.filterScenesForUser(scenes, userId);\n\n          // 3. Transform scenes to add proxy URLs\n          const transformedScenes = visibleScenes.map((s) =&gt;\n            transformScene(s as unknown as Scene)\n          );\n\n          // Create a map of scene ID to scene data\n          const sceneMap = new Map(\n            transformedScenes.map((s) =&gt; [s.id, s])\n          );\n\n          // Attach scene data to each playlist item (only paths.screenshot needed for preview)\n          const itemsWithScenes = playlist.items.map((item) =&gt; ({\n            ...item,\n            scene: sceneMap.get(item.sceneId) || null,\n          }));\n\n          return {\n            ...playlist,\n            items: itemsWithScenes,\n          };\n        } catch (cacheError) {\n          console.error(\n            `Error fetching scenes for playlist ${playlist.id}:`,\n            cacheError\n          );\n          // Return playlist without scene details if cache fails\n          return playlist;\n        }\n      })\n    );\n\n    res.json({ playlists: playlistsWithScenes });\n  } catch (error) {\n    console.error(\"Error getting playlists:\", error);\n    res.status(500).json({ error: \"Failed to get playlists\" });\n  }\n};\n</code></pre> <p>Step 2: Remove unused Stash import pattern</p> <p>The dynamic import of <code>stashInstanceManager</code> is no longer used in this file. Search for any remaining references:</p> <pre><code>// These lines should no longer exist anywhere in the file:\n// const { stashInstanceManager } = await import(\"../services/StashInstanceManager.js\");\n// const stash = stashInstanceManager.getDefault();\n</code></pre> <p>Verify there are no remaining Stash imports.</p> <p>Step 3: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/playlist.ts\ngit commit -m \"fix: use cache for getUserPlaylists scene previews\n\n- Replace Stash GraphQL query with StashEntityService cache lookup\n- Apply user restrictions to filter hidden/restricted scenes from previews\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#task-4-manual-testing","title":"Task 4: Manual Testing","text":"<p>Step 1: Test playlist display with user data</p> <ol> <li>Start the server: <code>npm run dev</code></li> <li>Create a playlist with several scenes</li> <li>Rate one scene 5 stars in Peek</li> <li>Mark another scene as favorite in Peek</li> <li>Increment O-counter on a scene</li> <li>View the playlist</li> <li>Verify: Scenes show YOUR rating/favorite/O-counter, not Stash's global values</li> </ol> <p>Step 2: Test restricted content filtering</p> <ol> <li>As admin, add a tag restriction for a test user (e.g., exclude tag \"Test\")</li> <li>Add a scene with that tag to a playlist</li> <li>Log in as the restricted user</li> <li>View the playlist</li> <li>Verify: The restricted scene does not appear in the playlist</li> </ol> <p>Step 3: Test watch history duration</p> <ol> <li>Play a video in Peek</li> <li>Let it play for 30+ seconds</li> <li>Check server logs</li> <li>Verify: No Stash GraphQL calls for duration</li> <li>Verify: Resume time is saved correctly</li> </ol> <p>Step 4: Test edge cases</p> <ol> <li>Create a playlist with a scene, then delete that scene from Stash</li> <li>Run a sync</li> <li>View the playlist</li> <li>Verify: Deleted scene shows as <code>scene: null</code>, playlist doesn't crash</li> </ol> <p>Step 5: Final commit with test confirmation</p> <pre><code>git add -A\ngit commit -m \"test: verify direct stash query fixes work correctly\n\nManual testing confirmed:\n- Playlist scenes show user's personal O-counter/favorite/ratings\n- Restricted scenes are filtered from playlist display\n- Watch history uses cached duration (no Stash calls)\n- Deleted scenes handled gracefully\n\"\n</code></pre>"},{"location":"plans/2025-01-02-fix-direct-stash-queries-impl/#summary","title":"Summary","text":"Task Description Files Changed 1 Fix watchHistory duration lookup <code>server/controllers/watchHistory.ts</code> 2 Fix getPlaylist scene fetching <code>server/controllers/playlist.ts</code> 3 Fix getUserPlaylists scene previews <code>server/controllers/playlist.ts</code> 4 Manual testing (verification only) <p>Total commits: 4-5 small, focused commits</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/","title":"Image Gallery Inheritance","text":"<p>Branch: <code>feature/image-gallery-inheritance</code> Status: Design Complete Complexity: Medium</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#problem-statement","title":"Problem Statement","text":"<p>Images in Stash can exist within Galleries, and in many workflows the Gallery serves as the \"container\" with metadata that logically applies to all its images. For example: - A Gallery titled \"Beach Shoot 2024\" has performers, tags, studio, date, photographer - The individual images inside have no metadata \u2014 just filenames</p> <p>Currently, Peek stores Images with only their directly-assigned metadata. This means: - Images with no direct metadata appear \"empty\" in the UI - Filtering by performer/tag/studio misses images that should match via their Gallery - Content restrictions don't cascade properly from Gallery metadata to Images</p> <p>Goal: During sync, inherit metadata from Gallery to Image when the Image has none.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#solution-overview","title":"Solution Overview","text":"<p>Inheritance Rules:</p> <p>During sync, for each Image in a Gallery, copy these fields from Gallery \u2192 Image only if the Image has none:</p> Field Inherit? Notes Performers Yes Copy Gallery's performers if Image has no performers Tags Yes Copy Gallery's tags if Image has no tags Studio Yes Copy Gallery's studio if Image has no studio Date Yes Copy Gallery's date if Image has no date Photographer Yes Copy Gallery's photographer if Image has no photographer Details Yes Copy Gallery's details if Image has no details Title No Each image keeps its own name <p>When inheritance happens: - During initial full sync - During incremental sync when an Image or its Gallery is updated - NOT at query time \u2014 this is a denormalization at sync time</p> <p>Storage approach: - Inherited values are stored directly on the <code>StashImage</code> record - No separate \"inherited\" flag \u2014 we treat them as the image's effective values - If user later adds metadata directly in Stash, next sync overwrites with direct values</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#file-serverservicesstashsyncservicets","title":"File: <code>server/services/StashSyncService.ts</code>","text":"<p>The sync service already processes Images. We need to add a post-processing step after Images are synced but Galleries are available.</p> <pre><code>// After syncing images, apply gallery inheritance\nasync function applyGalleryInheritance(images: StashImage[], galleries: Map&lt;string, StashGallery&gt;): Promise&lt;void&gt; {\n  for (const image of images) {\n    // Get galleries this image belongs to (via ImageGallery junction)\n    const imageGalleries = await prisma.imageGallery.findMany({\n      where: { imageId: image.id },\n      include: { gallery: true }\n    });\n\n    if (imageGalleries.length === 0) continue;\n\n    // Use first gallery for inheritance (images rarely span multiple galleries)\n    const gallery = imageGalleries[0].gallery;\n\n    const updates: Partial&lt;StashImage&gt; = {};\n\n    // Inherit scalar fields if image has none\n    if (!image.studioId &amp;&amp; gallery.studioId) updates.studioId = gallery.studioId;\n    if (!image.date &amp;&amp; gallery.date) updates.date = gallery.date;\n    if (!image.photographer &amp;&amp; gallery.photographer) updates.photographer = gallery.photographer;\n    if (!image.details &amp;&amp; gallery.details) updates.details = gallery.details;\n\n    // Apply scalar updates\n    if (Object.keys(updates).length &gt; 0) {\n      await prisma.stashImage.update({ where: { id: image.id }, data: updates });\n    }\n\n    // Inherit performers if image has none\n    const imagePerformers = await prisma.imagePerformer.count({ where: { imageId: image.id } });\n    if (imagePerformers === 0) {\n      const galleryPerformers = await prisma.galleryPerformer.findMany({ where: { galleryId: gallery.id } });\n      await prisma.imagePerformer.createMany({\n        data: galleryPerformers.map(gp =&gt; ({ imageId: image.id, performerId: gp.performerId })),\n        skipDuplicates: true\n      });\n    }\n\n    // Inherit tags if image has none\n    const imageTags = await prisma.imageTag.count({ where: { imageId: image.id } });\n    if (imageTags === 0) {\n      const galleryTags = await prisma.galleryTag.findMany({ where: { galleryId: gallery.id } });\n      await prisma.imageTag.createMany({\n        data: galleryTags.map(gt =&gt; ({ imageId: image.id, tagId: gt.tagId })),\n        skipDuplicates: true\n      });\n    }\n  }\n}\n</code></pre> <p>Sync order matters: Galleries must be synced before Images, or inheritance must run as a separate pass after both are complete.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Basic inheritance:</li> <li>In Stash, create a Gallery with performers, tags, studio, date, photographer, details</li> <li>Add images to the Gallery that have no metadata</li> <li>Run Peek sync</li> <li>Verify images now show the Gallery's performers, tags, studio, date, photographer, details</li> <li> <p>Verify image titles are NOT overwritten (each keeps its filename/title)</p> </li> <li> <p>Partial inheritance:</p> </li> <li>In Stash, create an Image with its own performer but no tags</li> <li>Add it to a Gallery that has both performers and tags</li> <li>Run sync</li> <li>Verify Image keeps its own performer (not overwritten)</li> <li> <p>Verify Image inherits Gallery's tags</p> </li> <li> <p>Filtering works:</p> </li> <li>Filter images by a performer that's only on the Gallery (not directly on images)</li> <li> <p>Verify inherited images appear in results</p> </li> <li> <p>Restriction cascade:</p> </li> <li>Create a Gallery with a restricted tag</li> <li>Add images with no direct tags</li> <li> <p>Verify images inherit the tag and are properly restricted</p> </li> <li> <p>Re-sync behavior:</p> </li> <li>Add metadata directly to an Image in Stash</li> <li>Run sync</li> <li>Verify direct metadata overwrites previously inherited values</li> </ol>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Image in multiple galleries (use first gallery \u2014 rare case)</li> <li>Image not in any gallery (no inheritance, keep as-is)</li> <li>Gallery with no metadata (nothing to inherit)</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/services/StashSyncService.ts</code> \u2014 Add <code>applyGalleryInheritance()</code> function, call after image sync</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents Image Gallery Inheritance under \"Pseudo-Relationships\"</li> </ul>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/","title":"Image Gallery Inheritance Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Denormalize gallery metadata (studio, date, photographer, details, performers, tags) to images at sync time so images can be filtered and displayed without loading their parent gallery.</p> <p>Architecture: After images are synced and ImageGallery junction records exist, run a post-processing pass that copies gallery metadata to images that have none. Uses SQL for efficient bulk operations matching the existing EntityImageCountService pattern.</p> <p>Tech Stack: Prisma, SQLite raw queries, TypeScript</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-1-create-imagegalleryinheritanceservice","title":"Task 1: Create ImageGalleryInheritanceService","text":"<p>Create a new service to handle gallery \u2192 image inheritance logic.</p> <p>Files: - Create: <code>server/services/ImageGalleryInheritanceService.ts</code> - Test: <code>server/services/__tests__/ImageGalleryInheritanceService.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create the test file with basic tests for the inheritance logic.</p> <pre><code>// server/services/__tests__/ImageGalleryInheritanceService.test.ts\nimport { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { imageGalleryInheritanceService } from \"../ImageGalleryInheritanceService.js\";\n\ndescribe(\"ImageGalleryInheritanceService\", () =&gt; {\n  // Clean up test data\n  beforeEach(async () =&gt; {\n    await prisma.imageGallery.deleteMany({});\n    await prisma.imagePerformer.deleteMany({});\n    await prisma.imageTag.deleteMany({});\n    await prisma.galleryPerformer.deleteMany({});\n    await prisma.galleryTag.deleteMany({});\n    await prisma.stashImage.deleteMany({});\n    await prisma.stashGallery.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.imageGallery.deleteMany({});\n    await prisma.imagePerformer.deleteMany({});\n    await prisma.imageTag.deleteMany({});\n    await prisma.galleryPerformer.deleteMany({});\n    await prisma.galleryTag.deleteMany({});\n    await prisma.stashImage.deleteMany({});\n    await prisma.stashGallery.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n  });\n\n  describe(\"applyGalleryInheritance\", () =&gt; {\n    it(\"should inherit studio from gallery when image has none\", async () =&gt; {\n      // Create studio\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n\n      // Create gallery with studio\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\", studioId: \"studio-1\" },\n      });\n\n      // Create image without studio\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited studio\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-1\");\n    });\n\n    it(\"should NOT overwrite image studio when image already has one\", async () =&gt; {\n      // Create two studios\n      await prisma.stashStudio.createMany({\n        data: [\n          { id: \"studio-1\", name: \"Gallery Studio\" },\n          { id: \"studio-2\", name: \"Image Studio\" },\n        ],\n      });\n\n      // Create gallery with studio-1\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\", studioId: \"studio-1\" },\n      });\n\n      // Create image with its own studio-2\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\", studioId: \"studio-2\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image kept its own studio\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-2\");\n    });\n\n    it(\"should inherit performers from gallery when image has none\", async () =&gt; {\n      // Create performer\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n\n      // Create gallery and link performer\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryPerformer.create({\n        data: { galleryId: \"gallery-1\", performerId: \"performer-1\" },\n      });\n\n      // Create image without performers\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited performer\n      const imagePerformers = await prisma.imagePerformer.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imagePerformers).toHaveLength(1);\n      expect(imagePerformers[0].performerId).toBe(\"performer-1\");\n    });\n\n    it(\"should inherit tags from gallery when image has none\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Test Tag\" },\n      });\n\n      // Create gallery and link tag\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryTag.create({\n        data: { galleryId: \"gallery-1\", tagId: \"tag-1\" },\n      });\n\n      // Create image without tags\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image inherited tag\n      const imageTags = await prisma.imageTag.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imageTags).toHaveLength(1);\n      expect(imageTags[0].tagId).toBe(\"tag-1\");\n    });\n\n    it(\"should NOT inherit performers when image already has performers\", async () =&gt; {\n      // Create two performers\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"performer-1\", name: \"Gallery Performer\" },\n          { id: \"performer-2\", name: \"Image Performer\" },\n        ],\n      });\n\n      // Create gallery with performer-1\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Test Gallery\" },\n      });\n      await prisma.galleryPerformer.create({\n        data: { galleryId: \"gallery-1\", performerId: \"performer-1\" },\n      });\n\n      // Create image with performer-2\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n      await prisma.imagePerformer.create({\n        data: { imageId: \"image-1\", performerId: \"performer-2\" },\n      });\n\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image kept only its own performer\n      const imagePerformers = await prisma.imagePerformer.findMany({\n        where: { imageId: \"image-1\" },\n      });\n      expect(imagePerformers).toHaveLength(1);\n      expect(imagePerformers[0].performerId).toBe(\"performer-2\");\n    });\n\n    it(\"should handle image in multiple galleries (use first)\", async () =&gt; {\n      // Create two studios\n      await prisma.stashStudio.createMany({\n        data: [\n          { id: \"studio-1\", name: \"First Gallery Studio\" },\n          { id: \"studio-2\", name: \"Second Gallery Studio\" },\n        ],\n      });\n\n      // Create two galleries\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"First Gallery\", studioId: \"studio-1\" },\n      });\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-2\", title: \"Second Gallery\", studioId: \"studio-2\" },\n      });\n\n      // Create image without studio\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Test Image\" },\n      });\n\n      // Link image to both galleries (gallery-1 first)\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-1\" },\n      });\n      await prisma.imageGallery.create({\n        data: { imageId: \"image-1\", galleryId: \"gallery-2\" },\n      });\n\n      // Apply inheritance\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image got studio from first gallery\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBe(\"studio-1\");\n    });\n\n    it(\"should handle image not in any gallery (no inheritance)\", async () =&gt; {\n      // Create image without gallery\n      await prisma.stashImage.create({\n        data: { id: \"image-1\", title: \"Standalone Image\" },\n      });\n\n      // Apply inheritance (should not fail)\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n\n      // Verify image unchanged\n      const image = await prisma.stashImage.findUnique({\n        where: { id: \"image-1\" },\n      });\n      expect(image?.studioId).toBeNull();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run ImageGalleryInheritanceService</code></p> <p>Expected: FAIL with \"Cannot find module '../ImageGalleryInheritanceService.js'\"</p> <p>Step 3: Write the service implementation</p> <pre><code>// server/services/ImageGalleryInheritanceService.ts\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * ImageGalleryInheritanceService\n *\n * Applies gallery metadata to images that have none.\n * Called after sync completes to denormalize gallery data for efficient filtering.\n *\n * Inheritance rules:\n * - Only copies metadata if the image field is NULL/empty\n * - Never overwrites existing image metadata\n * - Uses first gallery if image is in multiple galleries\n *\n * Fields inherited:\n * - studioId, date, photographer, details (scalar fields)\n * - performers (via ImagePerformer junction)\n * - tags (via ImageTag junction)\n */\nclass ImageGalleryInheritanceService {\n  /**\n   * Apply gallery inheritance to all images.\n   * Uses SQL for efficient bulk operations.\n   */\n  async applyGalleryInheritance(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"Applying gallery inheritance to images...\");\n\n    try {\n      // Step 1: Inherit scalar fields (studioId, date, photographer, details)\n      await this.inheritScalarFields();\n\n      // Step 2: Inherit performers\n      await this.inheritPerformers();\n\n      // Step 3: Inherit tags\n      await this.inheritTags();\n\n      const duration = Date.now() - startTime;\n      logger.info(`Gallery inheritance applied in ${duration}ms`);\n    } catch (error) {\n      logger.error(\"Failed to apply gallery inheritance\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Inherit scalar fields from gallery to image where image has none.\n   * Uses a single UPDATE with subquery for efficiency.\n   */\n  private async inheritScalarFields(): Promise&lt;void&gt; {\n    // For each scalar field, update images that:\n    // 1. Have no value for that field\n    // 2. Are in a gallery that has a value\n\n    // StudioId inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET studioId = (\n        SELECT g.studioId\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.studioId IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE studioId IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.studioId IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Date inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET date = (\n        SELECT g.date\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.date IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE date IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.date IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Photographer inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET photographer = (\n        SELECT g.photographer\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.photographer IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE photographer IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.photographer IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n\n    // Details inheritance\n    await prisma.$executeRaw`\n      UPDATE StashImage\n      SET details = (\n        SELECT g.details\n        FROM ImageGallery ig\n        JOIN StashGallery g ON g.id = ig.galleryId\n        WHERE ig.imageId = StashImage.id\n          AND g.details IS NOT NULL\n          AND g.deletedAt IS NULL\n        ORDER BY ig.galleryId\n        LIMIT 1\n      )\n      WHERE details IS NULL\n        AND deletedAt IS NULL\n        AND id IN (\n          SELECT ig.imageId\n          FROM ImageGallery ig\n          JOIN StashGallery g ON g.id = ig.galleryId\n          WHERE g.details IS NOT NULL AND g.deletedAt IS NULL\n        )\n    `;\n  }\n\n  /**\n   * Inherit performers from gallery to image where image has none.\n   * Uses INSERT OR IGNORE to handle duplicates.\n   */\n  private async inheritPerformers(): Promise&lt;void&gt; {\n    // Insert gallery performers for images that have no performers\n    await prisma.$executeRaw`\n      INSERT OR IGNORE INTO ImagePerformer (imageId, performerId)\n      SELECT DISTINCT ig.imageId, gp.performerId\n      FROM ImageGallery ig\n      JOIN GalleryPerformer gp ON gp.galleryId = ig.galleryId\n      JOIN StashImage i ON i.id = ig.imageId\n      JOIN StashGallery g ON g.id = ig.galleryId\n      WHERE i.deletedAt IS NULL\n        AND g.deletedAt IS NULL\n        AND ig.imageId NOT IN (\n          SELECT DISTINCT imageId FROM ImagePerformer\n        )\n    `;\n  }\n\n  /**\n   * Inherit tags from gallery to image where image has none.\n   * Uses INSERT OR IGNORE to handle duplicates.\n   */\n  private async inheritTags(): Promise&lt;void&gt; {\n    // Insert gallery tags for images that have no tags\n    await prisma.$executeRaw`\n      INSERT OR IGNORE INTO ImageTag (imageId, tagId)\n      SELECT DISTINCT ig.imageId, gt.tagId\n      FROM ImageGallery ig\n      JOIN GalleryTag gt ON gt.galleryId = ig.galleryId\n      JOIN StashImage i ON i.id = ig.imageId\n      JOIN StashGallery g ON g.id = ig.galleryId\n      WHERE i.deletedAt IS NULL\n        AND g.deletedAt IS NULL\n        AND ig.imageId NOT IN (\n          SELECT DISTINCT imageId FROM ImageTag\n        )\n    `;\n  }\n}\n\nexport const imageGalleryInheritanceService = new ImageGalleryInheritanceService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run ImageGalleryInheritanceService</code></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageGalleryInheritanceService.ts server/services/__tests__/ImageGalleryInheritanceService.test.ts\ngit commit -m \"feat: add ImageGalleryInheritanceService\n\nDenormalizes gallery metadata (studio, date, photographer, details,\nperformers, tags) to images at sync time. Uses efficient SQL bulk\noperations matching EntityImageCountService pattern.\"\n</code></pre>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-2-integrate-with-stashsyncservice","title":"Task 2: Integrate with StashSyncService","text":"<p>Wire up the inheritance service to run after image sync completes.</p> <p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Add import for the new service</p> <p>At the top of <code>server/services/StashSyncService.ts</code>, add the import alongside other service imports:</p> <pre><code>import { imageGalleryInheritanceService } from \"./ImageGalleryInheritanceService.js\";\n</code></pre> <p>Step 2: Call inheritance after image sync in fullSync</p> <p>In the <code>fullSync</code> method, after images are synced (around line 217), add the inheritance call before <code>rebuildAllImageCounts</code>:</p> <p>Find this section: <pre><code>      result = await this.syncImages(stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n      // Rebuild user stats to reflect current entity relationships\n      // Rebuild inherited image counts (must happen after images and galleries are synced)\n      logger.info(\"Rebuilding inherited image counts...\");\n</code></pre></p> <p>Change to: <pre><code>      result = await this.syncImages(stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n\n      // Apply gallery inheritance to images (must happen after images and galleries are synced)\n      logger.info(\"Applying gallery inheritance to images...\");\n      await imageGalleryInheritanceService.applyGalleryInheritance();\n      logger.info(\"Gallery inheritance complete\");\n\n      // Rebuild inherited image counts (must happen after gallery inheritance)\n      logger.info(\"Rebuilding inherited image counts...\");\n</code></pre></p> <p>Step 3: Call inheritance after incremental sync</p> <p>Find the <code>smartIncrementalSync</code> method (around line 256). After the sync loop completes and before stats rebuild, add inheritance.</p> <p>Find this section (around line 340): <pre><code>      // Rebuild stats after sync\n      if (results.some((r) =&gt; r.synced &gt; 0)) {\n</code></pre></p> <p>Add before it: <pre><code>      // Apply gallery inheritance if images were synced\n      const imageResult = results.find((r) =&gt; r.entityType === \"image\");\n      if (imageResult &amp;&amp; imageResult.synced &gt; 0) {\n        logger.info(\"Applying gallery inheritance after incremental sync...\");\n        await imageGalleryInheritanceService.applyGalleryInheritance();\n        logger.info(\"Gallery inheritance complete\");\n      }\n</code></pre></p> <p>Step 4: Verify the file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code></p> <p>Expected: No errors</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: integrate gallery inheritance into sync pipeline\n\nCalls ImageGalleryInheritanceService.applyGalleryInheritance() after\nimage sync completes, both in full sync and incremental sync.\nRuns before image count rebuild to ensure accurate counts.\"\n</code></pre>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-3-manual-testing","title":"Task 3: Manual Testing","text":"<p>Verify the feature works end-to-end.</p> <p>Step 1: Start the development server</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code></p> <p>Step 2: Create test data in Stash</p> <ol> <li>In Stash, create a Gallery with:</li> <li>Title: \"Test Gallery\"</li> <li>Date: Any date</li> <li>Studio: Create or select one</li> <li>Photographer: \"Test Photographer\"</li> <li>Details: \"Gallery description\"</li> <li>Add 2-3 performers</li> <li> <p>Add 2-3 tags</p> </li> <li> <p>Add 2-3 images to the Gallery (images should have no metadata)</p> </li> </ol> <p>Step 3: Run sync in Peek</p> <ol> <li>Go to Peek Admin \u2192 Sync</li> <li>Run a full sync or incremental sync</li> <li>Check server logs for:</li> <li>\"Applying gallery inheritance to images...\"</li> <li>\"Gallery inheritance applied in Xms\"</li> </ol> <p>Step 4: Verify inheritance worked</p> <ol> <li>Go to Library \u2192 Images</li> <li>Find the images from the test gallery</li> <li>Verify each image shows:</li> <li>The gallery's studio</li> <li>The gallery's date</li> <li>The gallery's performers</li> <li>The gallery's tags</li> </ol> <p>Step 5: Verify filtering works</p> <ol> <li>Filter images by the gallery's performer</li> <li>Verify inherited images appear in results</li> <li>Filter images by the gallery's tag</li> <li>Verify inherited images appear in results</li> </ol> <p>Step 6: Verify no-overwrite behavior</p> <ol> <li>In Stash, add a direct performer to one of the gallery images</li> <li>Run sync</li> <li>Verify that image kept its own performer (not replaced with gallery's)</li> </ol>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-4-run-full-test-suite","title":"Task 4: Run Full Test Suite","text":"<p>Ensure no regressions in existing tests.</p> <p>Step 1: Run all tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass</p> <p>Step 2: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors</p> <p>Step 3: Commit any fixes if needed</p> <p>If tests or lint fail, fix and commit.</p>"},{"location":"plans/2025-01-02-image-gallery-inheritance-impl/#task-summary","title":"Task Summary","text":"Task Description Files Changed 1 Create ImageGalleryInheritanceService <code>server/services/ImageGalleryInheritanceService.ts</code>, <code>server/services/__tests__/ImageGalleryInheritanceService.test.ts</code> 2 Integrate with StashSyncService <code>server/services/StashSyncService.ts</code> 3 Manual testing (verification only) 4 Run full test suite (verification only) <p>Total commits: 2-3 focused commits</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/","title":"Pre-Computed Exclusions","text":"<p>Branch: <code>feature/pre-computed-exclusions</code> Status: Design Complete Complexity: High</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#problem-statement","title":"Problem Statement","text":"<p>Peek's content filtering (restrictions + hidden items) currently works by: 1. Loading ALL entities into memory 2. Filtering in JavaScript 3. Paginating the filtered results</p> <p>This doesn't scale. Problems include: - Memory: 1M+ scenes loaded into memory per request - CPU: Filtering logic runs on every request, for every user - Pagination: To get page 5 of 25 items, we load and filter ALL items first - Counts: Total visible count requires processing entire dataset</p> <p>Current flow (slow): <pre><code>Controller (e.g., scenes.ts)\n    \u2193\n1. userRestrictionService.getExcludedSceneIds(userId)  \u2190 6-10 DB queries per request\n    \u2193\n2. sceneQueryBuilder.execute({ excludedSceneIds, ... })  \u2190 passes exclusions as Set\n    \u2193\n3. SceneQueryBuilder uses NOT IN (excludedIds) in SQL  \u2190 parameter limits, chunking needed\n</code></pre></p> <p>Target scale: Users with 100TB+ collections containing millions of scenes and images.</p> <p>Goal: Pre-compute excluded entity IDs per user, stored in a database table. Queries become simple JOINs with proper pagination and counts at the database level.</p> <p>New flow (fast): <pre><code>Controller (e.g., scenes.ts)\n    \u2193\n1. sceneQueryBuilder.execute({ userId, ... })  \u2190 no pre-computation needed\n    \u2193\n2. SceneQueryBuilder adds LEFT JOIN UserExcludedEntity + WHERE e.id IS NULL\n</code></pre></p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#solution-overview","title":"Solution Overview","text":"<p>Core concept: Instead of filtering at query time, pre-compute and store which entities each user cannot see. Queries become:</p> <pre><code>SELECT s.* FROM StashScene s\nLEFT JOIN UserExcludedEntity e\n  ON e.userId = 5 AND e.entityType = 'scene' AND e.entityId = s.id\nWHERE e.id IS NULL  -- Not excluded\nORDER BY s.stashCreatedAt DESC\nLIMIT 25 OFFSET 100\n</code></pre> <p>Two new tables:</p> Table Purpose <code>UserExcludedEntity</code> Stores (userId, entityType, entityId, reason) for every excluded item <code>UserEntityStats</code> Stores pre-computed visible counts per entity type per user <p>Exclusion reasons tracked: - <code>restricted</code> \u2014 Admin set a restriction rule matching this entity - <code>hidden</code> \u2014 User explicitly hid this entity - <code>cascade</code> \u2014 Excluded due to a related entity (e.g., scene excluded because its performer is hidden) - <code>empty</code> \u2014 Organizational entity with no visible content</p> <p>Design simplification: We store one row per excluded entity without tracking the source of cascades (<code>sourceType</code>/<code>sourceId</code>). This simplifies the schema and queries. The tradeoff is that unhide operations trigger a targeted recompute rather than a simple DELETE, but unhide is rare and recompute is fast.</p> <p>Recomputation triggers: - Stash sync completes \u2192 <code>recomputeAllUsers()</code> - Admin changes user's restrictions \u2192 <code>recomputeForUser(userId)</code> - User hides entity \u2192 <code>addHiddenEntity()</code> (synchronous, incremental) - User unhides entity \u2192 Remove from <code>UserHiddenEntity</code>, queue <code>recomputeForUser()</code> (async)</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#schema-design","title":"Schema Design","text":"<pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])      // Primary query index\n  @@index([entityType, entityId])    // For cascade lookups\n}\n\n// Pre-computed visible counts (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  visibleCount Int      // total - excluded\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre> <p>ID uniqueness: Stash IDs are per-entity-type (Scene #1 and Performer #1 can coexist). The composite unique constraint <code>@@unique([userId, entityType, entityId])</code> handles this.</p> <p>Index strategy: - <code>[userId, entityType]</code> \u2014 Primary query pattern: \"get all excluded scenes for user 5\" - <code>[entityType, entityId]</code> \u2014 Cascade lookups: \"which users have this performer excluded?\"</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#cascade-rules","title":"Cascade Rules","text":"<p>When an entity is hidden or restricted, related entities are cascade-excluded:</p> When this is hidden/restricted... These are cascade-excluded... Performer Scenes with that performer Studio Scenes from that studio Tag Scenes with that tag (direct OR inherited via <code>inheritedTagIds</code>), Performers with that tag, Studios with that tag, Groups with that tag Group Scenes in that group Gallery Scenes linked to that gallery, Images in that gallery Scene (no cascade \u2014 scenes are leaf content) Image (no cascade \u2014 images are leaf content) <p>Empty entity cascades (organizational entities with no remaining visible content):</p> Entity type Empty when... Gallery Has 0 visible images Group Has 0 visible scenes AND no sub-groups with content (tree traversal) Studio Has 0 visible scenes AND 0 visible images AND no child studios with content (tree traversal) Performer Has 0 visible scenes AND 0 visible images Tag Not attached to any visible scene/performer/studio/group/gallery/image (DAG traversal) <p>Empty exclusions computed at sync time only \u2014 not during hide/unhide operations. This keeps incremental operations fast. Users won't notice if an empty performer briefly appears until next sync.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#new-services","title":"New Services","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#file-serverservicesexclusioncomputationservicets","title":"File: <code>server/services/ExclusionComputationService.ts</code>","text":"<p>Responsible for computing and maintaining exclusions.</p> <pre><code>class ExclusionComputationService {\n  // Full recompute for a user (initial setup, restriction change, after sync)\n  async recomputeForUser(userId: number): Promise&lt;void&gt;\n\n  // Recompute for all users (after sync)\n  async recomputeAllUsers(): Promise&lt;void&gt;\n\n  // Incremental: user hid an entity (synchronous)\n  async addHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt;\n\n  // Incremental: user unhid an entity (queues async recompute)\n  async removeHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt;\n\n  // Internal phases\n  private async computeDirectExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async computeCascadeExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async computeEmptyExclusions(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n  private async updateEntityStats(tx: PrismaTransaction, userId: number): Promise&lt;void&gt;\n}\n</code></pre> <p>Full recompute algorithm:</p> <p>The entire recompute runs in a transaction. If any phase fails, the transaction rolls back and the user keeps their previous exclusions \u2014 they never see unrestricted content due to a partial failure.</p> <pre><code>async recomputeForUser(userId: number): Promise&lt;void&gt; {\n  await prisma.$transaction(async (tx) =&gt; {\n    // Phase 1: Clear existing exclusions\n    await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n    // Phase 2: Direct exclusions (restrictions + hidden)\n    await this.computeDirectExclusions(tx, userId);\n\n    // Phase 3: Cascade exclusions\n    await this.computeCascadeExclusions(tx, userId);\n\n    // Phase 4: Empty entity exclusions (sync-time only)\n    await this.computeEmptyExclusions(tx, userId);\n\n    // Phase 5: Update stats\n    await this.updateEntityStats(tx, userId);\n  });\n}\n</code></pre> <p>Computation order in Phase 3 (cascades):</p> <ol> <li>For each hidden/restricted performer \u2192 exclude their scenes</li> <li>For each hidden/restricted studio \u2192 exclude their scenes</li> <li>For each hidden/restricted tag \u2192 exclude scenes (using <code>inheritedTagIds</code>), performers, studios, groups</li> <li>For each hidden/restricted group \u2192 exclude their scenes</li> <li>For each hidden/restricted gallery \u2192 exclude linked scenes, images in gallery</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#file-serverservicesexclusionquerybuilderts","title":"File: <code>server/services/ExclusionQueryBuilder.ts</code>","text":"<p>Provides JOIN clause utilities for filtered queries.</p> <pre><code>class ExclusionQueryBuilder {\n  /**\n   * Build the exclusion JOIN clause for raw SQL\n   */\n  buildExclusionJoin(\n    entityType: string,\n    tableAlias: string\n  ): { sql: string } {\n    return {\n      sql: `LEFT JOIN UserExcludedEntity e_${tableAlias}\n            ON e_${tableAlias}.userId = ?\n            AND e_${tableAlias}.entityType = '${entityType}'\n            AND e_${tableAlias}.entityId = ${tableAlias}.id`,\n    };\n  }\n\n  /**\n   * Build the WHERE clause for exclusion filtering\n   */\n  buildExclusionWhere(tableAlias: string): string {\n    return `e_${tableAlias}.id IS NULL`;\n  }\n}\n</code></pre> <p>This utility is used by <code>SceneQueryBuilder</code> and similar query builders for other entity types.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#query-architecture-changes","title":"Query Architecture Changes","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#scenequerybuilder-updates","title":"SceneQueryBuilder Updates","text":"<p>Interface change:</p> <pre><code>// Before\ninterface SceneQueryOptions {\n  userId: number;\n  excludedSceneIds?: Set&lt;string&gt;;  // Remove this\n  // ...\n}\n\n// After\ninterface SceneQueryOptions {\n  userId: number;\n  applyExclusions?: boolean;  // Default true, false for admin override\n  // ...\n}\n</code></pre> <p>FROM clause change:</p> <pre><code>-- Before\nFROM StashScene s\nLEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\nLEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\n\n-- After\nFROM StashScene s\nLEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\nLEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\nLEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id\n</code></pre> <p>WHERE clause addition:</p> <pre><code>WHERE s.deletedAt IS NULL\n  AND e.id IS NULL  -- Not in exclusion table\n  -- ... other filters\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#same-pattern-for-other-entities","title":"Same Pattern for Other Entities","text":"<p>The <code>UserExcludedEntity</code> table is uniform \u2014 the JOIN pattern is identical for all entity types:</p> <pre><code>LEFT JOIN UserExcludedEntity e\n  ON e.userId = ? AND e.entityType = '&lt;type&gt;' AND e.entityId = &lt;table&gt;.id\nWHERE e.id IS NULL\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#incremental-updates","title":"Incremental Updates","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#hide-operation-synchronous","title":"Hide Operation (Synchronous)","text":"<p>When a user hides an entity, we add exclusions incrementally within a transaction:</p> <pre><code>async addHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt; {\n  await prisma.$transaction(async (tx) =&gt; {\n    // 1. Add the direct exclusion\n    await tx.userExcludedEntity.upsert({\n      where: { userId_entityType_entityId: { userId, entityType, entityId } },\n      create: { userId, entityType, entityId, reason: 'hidden' },\n      update: { reason: 'hidden' },\n    });\n\n    // 2. Compute and add cascades for this entity\n    await this.addCascadesForEntity(tx, userId, entityType, entityId);\n\n    // 3. Update affected stats\n    await this.updateEntityStats(tx, userId);\n  });\n}\n</code></pre> <p>This is fast \u2014 typically a few queries and INSERTs. User sees immediate feedback.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#unhide-operation-async","title":"Unhide Operation (Async)","text":"<p>Unhide is trickier \u2014 a scene might still be excluded by another hidden performer. We use a safe approach:</p> <pre><code>async removeHiddenEntity(userId: number, entityType: string, entityId: string): Promise&lt;void&gt; {\n  // 1. Remove the source of truth entry (immediate)\n  await prisma.userHiddenEntity.delete({\n    where: { userId_entityType_entityId: { userId, entityType, entityId } },\n  });\n\n  // 2. Queue async recompute\n  setImmediate(() =&gt; {\n    this.recomputeForUser(userId).catch(err =&gt; {\n      logger.error('Failed to recompute exclusions after unhide', { userId, err });\n    });\n  });\n}\n</code></pre> <p>The response returns immediately. There's a brief window where the user might see stale exclusions, but the next request after recompute completes will be correct.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#api-integration-pattern","title":"API Integration Pattern","text":"<p>The problem: Exclusion filtering must be applied consistently across ALL endpoints that return entities \u2014 including minimal endpoints for filter dropdowns.</p> <p>Approach: Centralize all entity queries through query builders that use exclusion JOINs</p> <p>No controller should directly query Prisma or cache for user-visible entities. Instead:</p> <pre><code>// OLD (scattered, inconsistent)\nconst excludedIds = await userRestrictionService.getExcludedSceneIds(userId);\nconst result = await sceneQueryBuilder.execute({ excludedSceneIds, ... });\n\n// NEW (centralized)\nconst result = await sceneQueryBuilder.execute({ userId, ... });\n// Exclusion JOIN is built-in\n</code></pre> <p>Full endpoint audit:</p> Endpoint File Purpose Library (full) GET /api/library/scenes <code>library/scenes.ts</code> Scene grid GET /api/library/performers <code>library/performers.ts</code> Performer grid GET /api/library/studios <code>library/studios.ts</code> Studio grid GET /api/library/tags <code>library/tags.ts</code> Tag grid GET /api/library/groups <code>library/groups.ts</code> Group grid GET /api/library/galleries <code>library/galleries.ts</code> Gallery grid GET /api/library/images <code>library/images.ts</code> Image grid Library (minimal for dropdowns) POST /api/library/performers/minimal <code>library/performers.ts</code> Performer filter dropdown POST /api/library/studios/minimal <code>library/studios.ts</code> Studio filter dropdown POST /api/library/tags/minimal <code>library/tags.ts</code> Tag filter dropdown POST /api/library/groups/minimal <code>library/groups.ts</code> Group filter dropdown POST /api/library/galleries/minimal <code>library/galleries.ts</code> Gallery filter dropdown Other GET /api/recommendations <code>recommendations.ts</code> Home recommendations GET /api/search <code>search.ts</code> Global search GET /api/playlists/:id <code>playlist.ts</code> Playlist items GET /api/home/carousels <code>home.ts</code> Home page carousels GET /api/carousel/* <code>carousel.ts</code> Carousel queries <p>Why this works for all exclusion types:</p> <ul> <li>Restricted items \u2192 <code>ExclusionComputationService</code> processes admin restrictions, adds entries with <code>reason='restricted'</code> or <code>reason='cascade'</code></li> <li>Hidden items \u2192 Computation processes user hidden entities, adds entries with <code>reason='hidden'</code> or <code>reason='cascade'</code></li> <li>Empty items \u2192 Computation identifies organizational entities with no visible content, adds entries with <code>reason='empty'</code></li> </ul> <p>All three end up in the same <code>UserExcludedEntity</code> table. Query builders apply the same JOIN regardless of reason. The <code>reason</code> column is for debugging and the unhide UI.</p> <p>Enforcement: 1. Delete <code>userRestrictionService.getExcludedSceneIds()</code> after migration 2. Delete <code>userRestrictionService.filter*ForUser()</code> methods after migration 3. Delete <code>emptyEntityFilterService</code> methods after migration 4. Compile errors force all callers to use new pattern</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#migration-strategy","title":"Migration Strategy","text":"<p>Phase 1: Add tables (non-breaking) - Add <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables via Prisma migration - No changes to existing query logic yet</p> <p>Phase 2: Implement computation service - Build <code>ExclusionComputationService</code> with full recompute logic - Add admin endpoint to trigger recomputation manually - Test that exclusions are computed correctly</p> <p>Phase 3: Implement query builder utility - Build <code>ExclusionQueryBuilder</code> with JOIN clause helpers - Update <code>SceneQueryBuilder</code> to use exclusion JOIN instead of <code>excludedSceneIds</code> parameter - Test scene queries work correctly</p> <p>Phase 4: Wire up triggers - After Stash sync \u2192 call <code>recomputeAllUsers()</code> - After restriction change \u2192 call <code>recomputeForUser()</code> - After hide \u2192 call <code>addHiddenEntity()</code> - After unhide \u2192 call <code>removeHiddenEntity()</code></p> <p>Phase 5: Update remaining entity queries - Add exclusion JOINs to performer, studio, tag, group, gallery, image queries - Update all endpoints in audit list</p> <p>Phase 6: Cleanup - Remove old in-memory filtering code - Remove <code>getExcludedSceneIds()</code> and <code>filter*ForUser()</code> methods - Remove <code>EmptyEntityFilterService</code> - Remove <code>FilteredEntityCacheService</code></p> <p>Rollback plan: Keep old code paths available behind feature flag during migration. If issues arise, disable new code path instantly.</p> <p>Existing tables preserved: - <code>UserContentRestriction</code> \u2014 remains source of truth for admin restrictions - <code>UserHiddenEntity</code> \u2014 remains source of truth for user hidden items - <code>UserExcludedEntity</code> is a computed/derived table, can be rebuilt anytime</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#scalability-considerations","title":"Scalability Considerations","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#target-scale","title":"Target Scale","text":"<ul> <li>1M+ scenes per instance</li> <li>1M+ images per instance</li> <li>Multiple users with different restrictions</li> <li>Worst case: 50% of content excluded per user</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#exclusion-table-size-estimates","title":"Exclusion Table Size Estimates","text":"Scenario Exclusion Records Table Size 1M scenes, 10% excluded, 1 user ~100k rows ~10MB 1M scenes, 50% excluded, 5 users ~2.5M rows ~250MB 2M entities, 30% excluded, 10 users ~6M rows ~600MB"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#performance-characteristics","title":"Performance Characteristics","text":"<p>Query performance (with proper indexes): - Index lookup: O(log n) \u2014 ~20 comparisons for 1M rows - JOIN is efficient because all join columns are indexed - SQLite page cache keeps hot indexes in memory</p> <p>Potential bottlenecks:</p> Concern Mitigation Full recomputation time Use transactions for atomicity; recompute is seconds not minutes COUNT queries Pre-compute visible counts in <code>UserEntityStats</code> table Index memory ~250MB for 5M rows is acceptable for modern servers Failure during recompute Transaction rollback preserves previous exclusions"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#future-optimization-table-splitting","title":"Future Optimization: Table Splitting","text":"<p>If performance issues arise at 10M+ exclusion rows, consider splitting: - <code>UserExcludedScene</code> \u2014 highest volume - <code>UserExcludedImage</code> \u2014 highest volume - <code>UserExcludedEntity</code> \u2014 for performers, studios, tags, groups, galleries (lower volume)</p> <p>Start with single table; split only if actual performance issues occur.</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#unit-tests","title":"Unit Tests","text":"<ol> <li>Cascade computation:</li> <li>Hide a performer \u2192 verify all their scenes are excluded with <code>reason='cascade'</code></li> <li>Hide a tag \u2192 verify scenes/performers/studios/groups with that tag are excluded</li> <li>Hide a group \u2192 verify scenes in group are excluded</li> <li> <p>Hide a gallery \u2192 verify linked scenes and images are excluded</p> </li> <li> <p>Incremental updates:</p> </li> <li>Hide entity \u2192 verify exclusions added correctly</li> <li>Unhide entity \u2192 verify recompute removes exclusions</li> <li> <p>Unhide entity that's still excluded by another source \u2192 verify it stays excluded</p> </li> <li> <p>Transaction safety:</p> </li> <li>Simulate failure mid-recompute \u2192 verify previous exclusions preserved</li> <li>Verify user never sees unrestricted content due to partial failure</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#integration-tests","title":"Integration Tests","text":"<ol> <li>Query correctness:</li> <li>Compare old in-memory filtering results with new JOIN-based results</li> <li>Run on dataset with complex restriction rules</li> <li> <p>Verify counts match</p> </li> <li> <p>Pagination:</p> </li> <li>Get page 1, page 2, page 3 \u2192 verify no duplicates, no gaps</li> <li> <p>Verify total count is accurate</p> </li> <li> <p>Performance:</p> </li> <li>Benchmark with 100k+ scenes</li> <li>Verify query time is under 100ms for paginated results</li> <li> <p>Verify recomputation time is acceptable</p> </li> <li> <p>All endpoints covered:</p> </li> <li>Verify each endpoint in audit list uses exclusion JOINs</li> <li>Verify filter dropdowns show only visible entities</li> <li>Verify hidden performer doesn't appear in performer dropdown</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Fresh user \u2192 verify initial exclusion computation works</li> <li>Admin changes restrictions \u2192 verify recomputation triggers</li> <li>User hides/unhides \u2192 verify incremental update works</li> <li>Stash sync with new content \u2192 verify new items checked against rules</li> <li>Filter dropdown \u2192 verify restricted/hidden/empty entities don't appear</li> </ol>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#files-changed","title":"Files Changed","text":""},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#new-files","title":"New Files","text":"<ul> <li><code>server/services/ExclusionComputationService.ts</code> \u2014 Computes and maintains exclusions</li> <li><code>server/services/ExclusionQueryBuilder.ts</code> \u2014 JOIN clause utilities for filtered queries</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#modified-files","title":"Modified Files","text":"<ul> <li><code>server/prisma/schema.prisma</code> \u2014 Add <code>UserExcludedEntity</code> and <code>UserEntityStats</code> tables</li> <li><code>server/services/SceneQueryBuilder.ts</code> \u2014 Use exclusion JOIN instead of <code>excludedSceneIds</code></li> <li><code>server/controllers/library/scenes.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/controllers/library/performers.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/studios.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/tags.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/groups.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/galleries.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/library/images.ts</code> \u2014 Add exclusion JOIN to queries</li> <li><code>server/controllers/recommendations.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/controllers/search.ts</code> \u2014 Add exclusion JOINs</li> <li><code>server/controllers/playlist.ts</code> \u2014 Add exclusion JOINs</li> <li><code>server/controllers/carousel.ts</code> \u2014 Remove <code>getExcludedSceneIds()</code> calls</li> <li><code>server/services/StashSyncService.ts</code> \u2014 Trigger <code>recomputeAllUsers()</code> after sync</li> <li><code>server/controllers/user.ts</code> \u2014 Use <code>addHiddenEntity()</code>/<code>removeHiddenEntity()</code></li> <li><code>server/controllers/admin.ts</code> \u2014 Trigger <code>recomputeForUser()</code> on restriction change</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#deleted-files-after-migration-complete","title":"Deleted Files (after migration complete)","text":"<ul> <li><code>server/services/UserRestrictionService.ts</code> \u2014 Replaced by <code>ExclusionComputationService</code> + query JOINs</li> <li><code>server/services/EmptyEntityFilterService.ts</code> \u2014 Replaced by <code>ExclusionComputationService</code></li> <li><code>server/services/FilteredEntityCacheService.ts</code> \u2014 No longer needed</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#admin-endpoints","title":"Admin Endpoints","text":"<p>New endpoints for monitoring and manual control:</p> <pre><code>POST /api/admin/recompute-exclusions/:userId  \u2014 Recompute for one user\nPOST /api/admin/recompute-exclusions/all      \u2014 Recompute for all users\nGET  /api/admin/exclusion-stats               \u2014 View exclusion table size, per-user counts\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Full architecture documentation</li> <li>Fix Direct Stash Queries \u2014 Prerequisite fix (completed)</li> <li>Image Gallery Inheritance \u2014 Similar denormalization pattern (completed)</li> <li>Scene Tag Inheritance \u2014 Similar denormalization pattern (completed)</li> </ul>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/","title":"Pre-Computed Exclusions Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace runtime exclusion filtering with pre-computed database JOINs for scalable content filtering.</p> <p>Architecture: Pre-compute excluded entity IDs per user into a <code>UserExcludedEntity</code> table. Query builders use LEFT JOIN + WHERE NULL to filter instead of loading exclusions into memory. Computation triggered on sync, restriction change, and hide/unhide operations.</p> <p>Tech Stack: TypeScript, Prisma, SQLite, Vitest</p> <p>Design Document: Pre-Computed Exclusions Design</p>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-1-add-database-schema","title":"Task 1: Add Database Schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Add UserExcludedEntity model</p> <p>Add after the <code>UserHiddenEntity</code> model (around line 375):</p> <pre><code>// Pre-computed exclusions (refreshed on sync/restriction changes)\n// This is a derived/cached table - can be rebuilt anytime from UserContentRestriction + UserHiddenEntity\nmodel UserExcludedEntity {\n  id         Int      @id @default(autoincrement())\n  userId     Int\n  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  entityId   String   // Stash entity ID\n\n  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'\n  computedAt DateTime @default(now())\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType, entityId])\n  @@index([userId, entityType])\n  @@index([entityType, entityId])\n}\n\n// Pre-computed visible counts (avoids expensive COUNT queries)\nmodel UserEntityStats {\n  id           Int      @id @default(autoincrement())\n  userId       Int\n  entityType   String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'\n  visibleCount Int      // total - excluded\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, entityType])\n}\n</code></pre> <p>Step 2: Add relations to User model</p> <p>Find the User model (around line 10) and add these relations after <code>hiddenEntities</code>:</p> <pre><code>  // Pre-computed exclusions cache\n  excludedEntities UserExcludedEntity[]\n  entityStats      UserEntityStats[]\n</code></pre> <p>Step 3: Generate Prisma client and run migration</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma migrate dev --name add_exclusion_tables\n</code></pre></p> <p>Expected: Migration created and applied successfully.</p> <p>Step 4: Verify schema</p> <p>Run: <pre><code>cd server &amp;&amp; npx prisma db push --dry-run\n</code></pre></p> <p>Expected: \"Your database is in sync\"</p> <p>Step 5: Commit</p> <pre><code>git add server/prisma/\ngit commit -m \"feat: add UserExcludedEntity and UserEntityStats tables\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-2-create-exclusioncomputationservice-core-structure","title":"Task 2: Create ExclusionComputationService - Core Structure","text":"<p>Files: - Create: <code>server/services/ExclusionComputationService.ts</code> - Create: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for basic structure</p> <p>Create <code>server/services/__tests__/ExclusionComputationService.test.ts</code>:</p> <pre><code>import { describe, it, expect, vi, beforeEach } from \"vitest\";\n\n// Mock prisma before importing service\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $transaction: vi.fn(),\n    userExcludedEntity: {\n      deleteMany: vi.fn(),\n      createMany: vi.fn(),\n      findMany: vi.fn(),\n    },\n    userEntityStats: {\n      upsert: vi.fn(),\n    },\n    userContentRestriction: {\n      findMany: vi.fn(),\n    },\n    userHiddenEntity: {\n      findMany: vi.fn(),\n    },\n    user: {\n      findMany: vi.fn(),\n    },\n  },\n}));\n\nimport { exclusionComputationService } from \"../ExclusionComputationService.js\";\n\ndescribe(\"ExclusionComputationService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"recomputeForUser\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.recomputeForUser).toBe(\"function\");\n    });\n  });\n\n  describe(\"recomputeAllUsers\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.recomputeAllUsers).toBe(\"function\");\n    });\n  });\n\n  describe(\"addHiddenEntity\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.addHiddenEntity).toBe(\"function\");\n    });\n  });\n\n  describe(\"removeHiddenEntity\", () =&gt; {\n    it(\"should be a callable method\", () =&gt; {\n      expect(typeof exclusionComputationService.removeHiddenEntity).toBe(\"function\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL - Cannot find module '../ExclusionComputationService.js'</p> <p>Step 3: Create minimal service skeleton</p> <p>Create <code>server/services/ExclusionComputationService.ts</code>:</p> <pre><code>/**\n * ExclusionComputationService\n *\n * Computes and maintains the UserExcludedEntity table which stores\n * pre-computed exclusions for each user. This enables efficient\n * JOIN-based filtering instead of loading exclusions into memory.\n *\n * Exclusion sources:\n * - UserContentRestriction (admin restrictions) -&gt; reason='restricted'\n * - UserHiddenEntity (user hidden items) -&gt; reason='hidden'\n * - Cascades from hidden entities -&gt; reason='cascade'\n * - Empty organizational entities -&gt; reason='empty'\n */\n\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\nclass ExclusionComputationService {\n  /**\n   * Full recompute for a user.\n   * Runs in a transaction - if any phase fails, previous exclusions are preserved.\n   */\n  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n    // Implementation in next task\n  }\n\n  /**\n   * Recompute exclusions for all users.\n   * Called after Stash sync completes.\n   */\n  async recomputeAllUsers(): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.recomputeAllUsers starting\");\n    // Implementation in next task\n  }\n\n  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n}\n\nexport const exclusionComputationService = new ExclusionComputationService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: add ExclusionComputationService skeleton\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-3-implement-direct-exclusions-restrictions-hidden","title":"Task 3: Implement Direct Exclusions (Restrictions + Hidden)","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for direct exclusions</p> <p>Add to <code>ExclusionComputationService.test.ts</code>:</p> <pre><code>import prisma from \"../../prisma/singleton.js\";\n\nconst mockPrisma = prisma as any;\n\ndescribe(\"computeDirectExclusions\", () =&gt; {\n  it(\"should process UserContentRestriction EXCLUDE mode\", async () =&gt; {\n    // Setup: user has restriction excluding specific tags\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([\n      {\n        userId: 1,\n        entityType: \"tags\",\n        mode: \"EXCLUDE\",\n        entityIds: JSON.stringify([\"tag1\", \"tag2\"]),\n      },\n    ]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    // Mock transaction to execute callback\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    // Verify createMany was called with the excluded tags\n    expect(mockPrisma.userExcludedEntity.createMany).toHaveBeenCalled();\n    const createCall = mockPrisma.userExcludedEntity.createMany.mock.calls[0][0];\n    expect(createCall.data).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          userId: 1,\n          entityType: \"tag\",\n          entityId: \"tag1\",\n          reason: \"restricted\",\n        }),\n        expect.objectContaining({\n          userId: 1,\n          entityType: \"tag\",\n          entityId: \"tag2\",\n          reason: \"restricted\",\n        }),\n      ])\n    );\n  });\n\n  it(\"should process UserHiddenEntity records\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\" },\n      { userId: 1, entityType: \"scene\", entityId: \"scene1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    expect(mockPrisma.userExcludedEntity.createMany).toHaveBeenCalled();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL - createMany not called or called with wrong data</p> <p>Step 3: Implement direct exclusions</p> <p>Update <code>server/services/ExclusionComputationService.ts</code>:</p> <pre><code>/**\n * ExclusionComputationService\n *\n * Computes and maintains the UserExcludedEntity table which stores\n * pre-computed exclusions for each user. This enables efficient\n * JOIN-based filtering instead of loading exclusions into memory.\n *\n * Exclusion sources:\n * - UserContentRestriction (admin restrictions) -&gt; reason='restricted'\n * - UserHiddenEntity (user hidden items) -&gt; reason='hidden'\n * - Cascades from hidden entities -&gt; reason='cascade'\n * - Empty organizational entities -&gt; reason='empty'\n */\n\nimport type { Prisma, PrismaClient } from \"@prisma/client\";\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Type for Prisma transaction client\ntype TransactionClient = Omit&lt;\n  PrismaClient,\n  \"$connect\" | \"$disconnect\" | \"$on\" | \"$transaction\" | \"$use\" | \"$extends\"\n&gt;;\n\n// Entity type mapping from restriction entityType to exclusion entityType\nconst RESTRICTION_ENTITY_MAP: Record&lt;string, string&gt; = {\n  tags: \"tag\",\n  studios: \"studio\",\n  groups: \"group\",\n  galleries: \"gallery\",\n  performers: \"performer\",\n};\n\nclass ExclusionComputationService {\n  /**\n   * Full recompute for a user.\n   * Runs in a transaction - if any phase fails, previous exclusions are preserved.\n   */\n  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Phase 1: Clear existing exclusions\n      await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n      // Phase 2: Compute direct exclusions (restrictions + hidden)\n      await this.computeDirectExclusions(tx, userId);\n\n      // Phase 3: Compute cascade exclusions (to be implemented)\n      // await this.computeCascadeExclusions(tx, userId);\n\n      // Phase 4: Compute empty exclusions (to be implemented)\n      // await this.computeEmptyExclusions(tx, userId);\n\n      // Phase 5: Update stats (to be implemented)\n      // await this.updateEntityStats(tx, userId);\n    });\n\n    logger.info(\"ExclusionComputationService.recomputeForUser complete\", {\n      userId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Recompute exclusions for all users.\n   * Called after Stash sync completes.\n   */\n  async recomputeAllUsers(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeAllUsers starting\");\n\n    const users = await prisma.user.findMany({ select: { id: true } });\n\n    for (const user of users) {\n      await this.recomputeForUser(user.id);\n    }\n\n    logger.info(\"ExclusionComputationService.recomputeAllUsers complete\", {\n      userCount: users.length,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n    // Implementation in later task\n  }\n\n  /**\n   * Phase 2: Compute direct exclusions from restrictions and hidden entities.\n   */\n  private async computeDirectExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const exclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Process UserContentRestriction rules\n    const restrictions = await tx.userContentRestriction.findMany({\n      where: { userId },\n    });\n\n    for (const restriction of restrictions) {\n      const entityType = RESTRICTION_ENTITY_MAP[restriction.entityType];\n      if (!entityType) {\n        logger.warn(\"Unknown restriction entityType\", {\n          entityType: restriction.entityType,\n        });\n        continue;\n      }\n\n      const entityIds: string[] = JSON.parse(restriction.entityIds || \"[]\");\n\n      if (restriction.mode === \"EXCLUDE\") {\n        // Direct exclusion: these entities are excluded\n        for (const entityId of entityIds) {\n          exclusions.push({\n            userId,\n            entityType,\n            entityId,\n            reason: \"restricted\",\n          });\n        }\n      } else if (restriction.mode === \"INCLUDE\") {\n        // Invert: exclude everything NOT in this list\n        // This requires fetching all entity IDs of this type\n        const allIds = await this.getAllEntityIds(tx, entityType);\n        const includedSet = new Set(entityIds);\n        for (const entityId of allIds) {\n          if (!includedSet.has(entityId)) {\n            exclusions.push({\n              userId,\n              entityType,\n              entityId,\n              reason: \"restricted\",\n            });\n          }\n        }\n      }\n    }\n\n    // Process UserHiddenEntity records\n    const hiddenEntities = await tx.userHiddenEntity.findMany({\n      where: { userId },\n    });\n\n    for (const hidden of hiddenEntities) {\n      exclusions.push({\n        userId,\n        entityType: hidden.entityType,\n        entityId: hidden.entityId,\n        reason: \"hidden\",\n      });\n    }\n\n    // Batch insert all exclusions\n    if (exclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: exclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeDirectExclusions complete\", {\n      userId,\n      restrictionCount: restrictions.length,\n      hiddenCount: hiddenEntities.length,\n      exclusionCount: exclusions.length,\n    });\n  }\n\n  /**\n   * Get all entity IDs of a given type (for INCLUDE mode inversion).\n   */\n  private async getAllEntityIds(\n    tx: TransactionClient,\n    entityType: string\n  ): Promise&lt;string[]&gt; {\n    switch (entityType) {\n      case \"scene\":\n        return (\n          await tx.stashScene.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"performer\":\n        return (\n          await tx.stashPerformer.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"studio\":\n        return (\n          await tx.stashStudio.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"tag\":\n        return (\n          await tx.stashTag.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"group\":\n        return (\n          await tx.stashGroup.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"gallery\":\n        return (\n          await tx.stashGallery.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      case \"image\":\n        return (\n          await tx.stashImage.findMany({\n            where: { deletedAt: null },\n            select: { id: true },\n          })\n        ).map((e) =&gt; e.id);\n      default:\n        logger.warn(\"Unknown entity type in getAllEntityIds\", { entityType });\n        return [];\n    }\n  }\n}\n\nexport const exclusionComputationService = new ExclusionComputationService();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement direct exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-4-implement-cascade-exclusions","title":"Task 4: Implement Cascade Exclusions","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for cascade exclusions</p> <p>Add to the test file:</p> <pre><code>describe(\"computeCascadeExclusions\", () =&gt; {\n  it(\"should cascade performer exclusion to their scenes\", async () =&gt; {\n    // Setup: performer1 is excluded\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"performer\", entityId: \"perf1\", reason: \"hidden\" },\n    ]);\n    mockPrisma.scenePerformer.findMany.mockResolvedValue([\n      { sceneId: \"scene1\", performerId: \"perf1\" },\n      { sceneId: \"scene2\", performerId: \"perf1\" },\n    ]);\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 3 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    // Verify scenes were cascade-excluded\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          entityType: \"scene\",\n          entityId: \"scene1\",\n          reason: \"cascade\",\n        }),\n        expect.objectContaining({\n          entityType: \"scene\",\n          entityId: \"scene2\",\n          reason: \"cascade\",\n        }),\n      ])\n    );\n  });\n\n  it(\"should cascade tag exclusion to scenes with that tag (direct and inherited)\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"tag\", entityId: \"tag1\" },\n    ]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([\n      { userId: 1, entityType: \"tag\", entityId: \"tag1\", reason: \"hidden\" },\n    ]);\n    // Direct tag association\n    mockPrisma.sceneTag.findMany.mockResolvedValue([\n      { sceneId: \"scene1\", tagId: \"tag1\" },\n    ]);\n    // Inherited tags - raw query mock\n    mockPrisma.$queryRaw = vi.fn().mockResolvedValue([{ id: \"scene2\" }]);\n    mockPrisma.performerTag.findMany.mockResolvedValue([]);\n    mockPrisma.studioTag.findMany.mockResolvedValue([]);\n    mockPrisma.groupTag.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 3 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({ entityType: \"scene\", entityId: \"scene1\" }),\n        expect.objectContaining({ entityType: \"scene\", entityId: \"scene2\" }),\n      ])\n    );\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL</p> <p>Step 3: Implement cascade exclusions</p> <p>Add to <code>ExclusionComputationService.ts</code> after <code>computeDirectExclusions</code>:</p> <pre><code>  /**\n   * Phase 3: Compute cascade exclusions from hidden/restricted entities.\n   */\n  private async computeCascadeExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    // Get all directly excluded entities\n    const directExclusions = await tx.userExcludedEntity.findMany({\n      where: {\n        userId,\n        reason: { in: [\"restricted\", \"hidden\"] },\n      },\n    });\n\n    // Group by entity type\n    const byType = new Map&lt;string, string[]&gt;();\n    for (const exc of directExclusions) {\n      const list = byType.get(exc.entityType) || [];\n      list.push(exc.entityId);\n      byType.set(exc.entityType, list);\n    }\n\n    const cascadeExclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Cascade: excluded performers \u2192 their scenes\n    const excludedPerformers = byType.get(\"performer\") || [];\n    if (excludedPerformers.length &gt; 0) {\n      const scenePerformers = await tx.scenePerformer.findMany({\n        where: { performerId: { in: excludedPerformers } },\n        select: { sceneId: true },\n      });\n      for (const sp of scenePerformers) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sp.sceneId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded studios \u2192 their scenes\n    const excludedStudios = byType.get(\"studio\") || [];\n    if (excludedStudios.length &gt; 0) {\n      const scenes = await tx.stashScene.findMany({\n        where: { studioId: { in: excludedStudios }, deletedAt: null },\n        select: { id: true },\n      });\n      for (const s of scenes) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: s.id,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded tags \u2192 scenes (direct + inherited), performers, studios, groups\n    const excludedTags = byType.get(\"tag\") || [];\n    if (excludedTags.length &gt; 0) {\n      // Scenes with direct tag\n      const directTagScenes = await tx.sceneTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { sceneId: true },\n      });\n      for (const st of directTagScenes) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: st.sceneId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Scenes with inherited tag (using raw SQL for JSON search)\n      // Build a query that finds scenes where inheritedTagIds contains any of the excluded tags\n      for (const tagId of excludedTags) {\n        const inheritedScenes = await (tx as any).$queryRaw`\n          SELECT id FROM StashScene\n          WHERE deletedAt IS NULL\n          AND EXISTS (\n            SELECT 1 FROM json_each(inheritedTagIds)\n            WHERE json_each.value = ${tagId}\n          )\n        `;\n        for (const s of inheritedScenes as { id: string }[]) {\n          cascadeExclusions.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n      }\n\n      // Performers with excluded tag\n      const taggedPerformers = await tx.performerTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { performerId: true },\n      });\n      for (const pt of taggedPerformers) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"performer\",\n          entityId: pt.performerId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Studios with excluded tag\n      const taggedStudios = await tx.studioTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { studioId: true },\n      });\n      for (const st of taggedStudios) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"studio\",\n          entityId: st.studioId,\n          reason: \"cascade\",\n        });\n      }\n\n      // Groups with excluded tag\n      const taggedGroups = await tx.groupTag.findMany({\n        where: { tagId: { in: excludedTags } },\n        select: { groupId: true },\n      });\n      for (const gt of taggedGroups) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"group\",\n          entityId: gt.groupId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded groups \u2192 their scenes\n    const excludedGroups = byType.get(\"group\") || [];\n    if (excludedGroups.length &gt; 0) {\n      const sceneGroups = await tx.sceneGroup.findMany({\n        where: { groupId: { in: excludedGroups } },\n        select: { sceneId: true },\n      });\n      for (const sg of sceneGroups) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sg.sceneId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Cascade: excluded galleries \u2192 linked scenes, images in gallery\n    const excludedGalleries = byType.get(\"gallery\") || [];\n    if (excludedGalleries.length &gt; 0) {\n      const sceneGalleries = await tx.sceneGallery.findMany({\n        where: { galleryId: { in: excludedGalleries } },\n        select: { sceneId: true },\n      });\n      for (const sg of sceneGalleries) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"scene\",\n          entityId: sg.sceneId,\n          reason: \"cascade\",\n        });\n      }\n\n      const galleryImages = await tx.imageGallery.findMany({\n        where: { galleryId: { in: excludedGalleries } },\n        select: { imageId: true },\n      });\n      for (const gi of galleryImages) {\n        cascadeExclusions.push({\n          userId,\n          entityType: \"image\",\n          entityId: gi.imageId,\n          reason: \"cascade\",\n        });\n      }\n    }\n\n    // Batch insert cascade exclusions\n    if (cascadeExclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: cascadeExclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeCascadeExclusions complete\", {\n      userId,\n      cascadeCount: cascadeExclusions.length,\n    });\n  }\n</code></pre> <p>Also update <code>recomputeForUser</code> to call this method:</p> <pre><code>  async recomputeForUser(userId: number): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.recomputeForUser starting\", { userId });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Phase 1: Clear existing exclusions\n      await tx.userExcludedEntity.deleteMany({ where: { userId } });\n\n      // Phase 2: Compute direct exclusions (restrictions + hidden)\n      await this.computeDirectExclusions(tx, userId);\n\n      // Phase 3: Compute cascade exclusions\n      await this.computeCascadeExclusions(tx, userId);\n\n      // Phase 4: Compute empty exclusions (to be implemented)\n      // await this.computeEmptyExclusions(tx, userId);\n\n      // Phase 5: Update stats (to be implemented)\n      // await this.updateEntityStats(tx, userId);\n    });\n\n    logger.info(\"ExclusionComputationService.recomputeForUser complete\", {\n      userId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement cascade exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-5-implement-empty-entity-exclusions","title":"Task 5: Implement Empty Entity Exclusions","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Write failing test for empty exclusions</p> <p>Add to test file:</p> <pre><code>describe(\"computeEmptyExclusions\", () =&gt; {\n  it(\"should exclude galleries with no visible images\", async () =&gt; {\n    mockPrisma.userContentRestriction.findMany.mockResolvedValue([]);\n    mockPrisma.userHiddenEntity.findMany.mockResolvedValue([]);\n    mockPrisma.userExcludedEntity.deleteMany.mockResolvedValue({ count: 0 });\n    mockPrisma.userExcludedEntity.findMany.mockResolvedValue([]);\n\n    // Mock raw query for empty galleries\n    mockPrisma.$queryRaw = vi.fn().mockResolvedValue([\n      { id: \"gallery1\" },\n      { id: \"gallery2\" },\n    ]);\n\n    mockPrisma.userExcludedEntity.createMany.mockResolvedValue({ count: 2 });\n\n    mockPrisma.$transaction.mockImplementation(async (callback: any) =&gt; {\n      return callback(mockPrisma);\n    });\n\n    await exclusionComputationService.recomputeForUser(1);\n\n    const calls = mockPrisma.userExcludedEntity.createMany.mock.calls;\n    const allData = calls.flatMap((c: any) =&gt; c[0].data || []);\n\n    expect(allData).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          entityType: \"gallery\",\n          reason: \"empty\",\n        }),\n      ])\n    );\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: FAIL</p> <p>Step 3: Implement empty exclusions</p> <p>Add to <code>ExclusionComputationService.ts</code>:</p> <pre><code>  /**\n   * Phase 4: Compute empty entity exclusions.\n   * Excludes organizational entities with no visible content.\n   */\n  private async computeEmptyExclusions(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const emptyExclusions: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    // Empty galleries: galleries with 0 visible images\n    const emptyGalleries = await (tx as any).$queryRaw`\n      SELECT g.id FROM StashGallery g\n      WHERE g.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM ImageGallery ig\n        JOIN StashImage i ON ig.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ig.galleryId = g.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const g of emptyGalleries as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"gallery\",\n        entityId: g.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty performers: performers with 0 visible scenes AND 0 visible images\n    const emptyPerformers = await (tx as any).$queryRaw`\n      SELECT p.id FROM StashPerformer p\n      WHERE p.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM ScenePerformer sp\n        JOIN StashScene s ON sp.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE sp.performerId = p.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM ImagePerformer ip\n        JOIN StashImage i ON ip.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ip.performerId = p.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const p of emptyPerformers as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"performer\",\n        entityId: p.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty studios: studios with 0 visible scenes AND 0 visible images AND no visible child studios\n    // Note: This requires recursive CTE for hierarchy, simplified version first\n    const emptyStudios = await (tx as any).$queryRaw`\n      SELECT st.id FROM StashStudio st\n      WHERE st.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM StashScene s\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE s.studioId = st.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM ImageStudio ims\n        JOIN StashImage i ON ims.imageId = i.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'image' AND e.entityId = i.id\n        WHERE ims.studioId = st.id AND i.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const s of emptyStudios as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"studio\",\n        entityId: s.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty groups: groups with 0 visible scenes\n    const emptyGroups = await (tx as any).$queryRaw`\n      SELECT g.id FROM StashGroup g\n      WHERE g.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM SceneGroup sg\n        JOIN StashScene s ON sg.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE sg.groupId = g.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const g of emptyGroups as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"group\",\n        entityId: g.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Empty tags: tags not attached to any visible entity\n    const emptyTags = await (tx as any).$queryRaw`\n      SELECT t.id FROM StashTag t\n      WHERE t.deletedAt IS NULL\n      AND NOT EXISTS (\n        SELECT 1 FROM SceneTag st\n        JOIN StashScene s ON st.sceneId = s.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'scene' AND e.entityId = s.id\n        WHERE st.tagId = t.id AND s.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM PerformerTag pt\n        JOIN StashPerformer p ON pt.performerId = p.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'performer' AND e.entityId = p.id\n        WHERE pt.tagId = t.id AND p.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM StudioTag stt\n        JOIN StashStudio st ON stt.studioId = st.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'studio' AND e.entityId = st.id\n        WHERE stt.tagId = t.id AND st.deletedAt IS NULL AND e.id IS NULL\n      )\n      AND NOT EXISTS (\n        SELECT 1 FROM GroupTag gt\n        JOIN StashGroup g ON gt.groupId = g.id\n        LEFT JOIN UserExcludedEntity e ON e.userId = ${userId} AND e.entityType = 'group' AND e.entityId = g.id\n        WHERE gt.tagId = t.id AND g.deletedAt IS NULL AND e.id IS NULL\n      )\n    `;\n    for (const t of emptyTags as { id: string }[]) {\n      emptyExclusions.push({\n        userId,\n        entityType: \"tag\",\n        entityId: t.id,\n        reason: \"empty\",\n      });\n    }\n\n    // Batch insert empty exclusions\n    if (emptyExclusions.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: emptyExclusions,\n        skipDuplicates: true,\n      });\n    }\n\n    logger.debug(\"computeEmptyExclusions complete\", {\n      userId,\n      emptyCount: emptyExclusions.length,\n    });\n  }\n</code></pre> <p>Update <code>recomputeForUser</code> to call this method:</p> <pre><code>      // Phase 4: Compute empty exclusions\n      await this.computeEmptyExclusions(tx, userId);\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement empty entity exclusions computation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-6-implement-entity-stats-update","title":"Task 6: Implement Entity Stats Update","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code></p> <p>Step 1: Implement stats update</p> <p>Add to <code>ExclusionComputationService.ts</code>:</p> <pre><code>  /**\n   * Phase 5: Update visible entity counts for the user.\n   */\n  private async updateEntityStats(\n    tx: TransactionClient,\n    userId: number\n  ): Promise&lt;void&gt; {\n    const entityTypes = [\"scene\", \"performer\", \"studio\", \"tag\", \"group\", \"gallery\", \"image\"];\n\n    for (const entityType of entityTypes) {\n      const total = await this.getEntityCount(tx, entityType);\n      const excluded = await tx.userExcludedEntity.count({\n        where: { userId, entityType },\n      });\n\n      await tx.userEntityStats.upsert({\n        where: { userId_entityType: { userId, entityType } },\n        create: { userId, entityType, visibleCount: total - excluded },\n        update: { visibleCount: total - excluded },\n      });\n    }\n\n    logger.debug(\"updateEntityStats complete\", { userId });\n  }\n\n  /**\n   * Get total count of entities of a given type.\n   */\n  private async getEntityCount(\n    tx: TransactionClient,\n    entityType: string\n  ): Promise&lt;number&gt; {\n    switch (entityType) {\n      case \"scene\":\n        return tx.stashScene.count({ where: { deletedAt: null } });\n      case \"performer\":\n        return tx.stashPerformer.count({ where: { deletedAt: null } });\n      case \"studio\":\n        return tx.stashStudio.count({ where: { deletedAt: null } });\n      case \"tag\":\n        return tx.stashTag.count({ where: { deletedAt: null } });\n      case \"group\":\n        return tx.stashGroup.count({ where: { deletedAt: null } });\n      case \"gallery\":\n        return tx.stashGallery.count({ where: { deletedAt: null } });\n      case \"image\":\n        return tx.stashImage.count({ where: { deletedAt: null } });\n      default:\n        return 0;\n    }\n  }\n</code></pre> <p>Update <code>recomputeForUser</code> to call this method:</p> <pre><code>      // Phase 5: Update stats\n      await this.updateEntityStats(tx, userId);\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts\ngit commit -m \"feat: implement entity stats update\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-7-implement-incremental-hideunhide","title":"Task 7: Implement Incremental Hide/Unhide","text":"<p>Files: - Modify: <code>server/services/ExclusionComputationService.ts</code> - Modify: <code>server/services/__tests__/ExclusionComputationService.test.ts</code></p> <p>Step 1: Implement addHiddenEntity</p> <pre><code>  /**\n   * Incremental update when user hides an entity.\n   * Synchronous - user waits for completion.\n   */\n  async addHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"ExclusionComputationService.addHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n\n    await prisma.$transaction(async (tx) =&gt; {\n      // Add the direct exclusion\n      await tx.userExcludedEntity.upsert({\n        where: {\n          userId_entityType_entityId: { userId, entityType, entityId },\n        },\n        create: { userId, entityType, entityId, reason: \"hidden\" },\n        update: { reason: \"hidden\" },\n      });\n\n      // Compute cascades for this specific entity\n      await this.addCascadesForEntity(tx, userId, entityType, entityId);\n    });\n\n    logger.info(\"ExclusionComputationService.addHiddenEntity complete\", {\n      userId,\n      entityType,\n      entityId,\n      durationMs: Date.now() - startTime,\n    });\n  }\n\n  /**\n   * Compute and add cascade exclusions for a single hidden entity.\n   */\n  private async addCascadesForEntity(\n    tx: TransactionClient,\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    const cascades: Array&lt;{\n      userId: number;\n      entityType: string;\n      entityId: string;\n      reason: string;\n    }&gt; = [];\n\n    switch (entityType) {\n      case \"performer\": {\n        const scenes = await tx.scenePerformer.findMany({\n          where: { performerId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"studio\": {\n        const scenes = await tx.stashScene.findMany({\n          where: { studioId: entityId, deletedAt: null },\n          select: { id: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"tag\": {\n        // Scenes with direct tag\n        const directScenes = await tx.sceneTag.findMany({\n          where: { tagId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of directScenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n\n        // Scenes with inherited tag\n        const inheritedScenes = await (tx as any).$queryRaw`\n          SELECT id FROM StashScene\n          WHERE deletedAt IS NULL\n          AND EXISTS (\n            SELECT 1 FROM json_each(inheritedTagIds)\n            WHERE json_each.value = ${entityId}\n          )\n        `;\n        for (const s of inheritedScenes as { id: string }[]) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.id,\n            reason: \"cascade\",\n          });\n        }\n\n        // Performers, studios, groups with this tag\n        const performers = await tx.performerTag.findMany({\n          where: { tagId: entityId },\n          select: { performerId: true },\n        });\n        for (const p of performers) {\n          cascades.push({\n            userId,\n            entityType: \"performer\",\n            entityId: p.performerId,\n            reason: \"cascade\",\n          });\n        }\n\n        const studios = await tx.studioTag.findMany({\n          where: { tagId: entityId },\n          select: { studioId: true },\n        });\n        for (const s of studios) {\n          cascades.push({\n            userId,\n            entityType: \"studio\",\n            entityId: s.studioId,\n            reason: \"cascade\",\n          });\n        }\n\n        const groups = await tx.groupTag.findMany({\n          where: { tagId: entityId },\n          select: { groupId: true },\n        });\n        for (const g of groups) {\n          cascades.push({\n            userId,\n            entityType: \"group\",\n            entityId: g.groupId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"group\": {\n        const scenes = await tx.sceneGroup.findMany({\n          where: { groupId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n\n      case \"gallery\": {\n        const scenes = await tx.sceneGallery.findMany({\n          where: { galleryId: entityId },\n          select: { sceneId: true },\n        });\n        for (const s of scenes) {\n          cascades.push({\n            userId,\n            entityType: \"scene\",\n            entityId: s.sceneId,\n            reason: \"cascade\",\n          });\n        }\n\n        const images = await tx.imageGallery.findMany({\n          where: { galleryId: entityId },\n          select: { imageId: true },\n        });\n        for (const i of images) {\n          cascades.push({\n            userId,\n            entityType: \"image\",\n            entityId: i.imageId,\n            reason: \"cascade\",\n          });\n        }\n        break;\n      }\n    }\n\n    if (cascades.length &gt; 0) {\n      await tx.userExcludedEntity.createMany({\n        data: cascades,\n        skipDuplicates: true,\n      });\n    }\n  }\n</code></pre> <p>Step 2: Implement removeHiddenEntity</p> <pre><code>  /**\n   * Handle user unhiding an entity.\n   * Queues async recompute since cascades need recalculation.\n   */\n  async removeHiddenEntity(\n    userId: number,\n    entityType: string,\n    entityId: string\n  ): Promise&lt;void&gt; {\n    logger.info(\"ExclusionComputationService.removeHiddenEntity\", {\n      userId,\n      entityType,\n      entityId,\n    });\n\n    // Queue async recompute - the unhide might affect cascade exclusions\n    // that need to be recalculated based on remaining hidden entities\n    setImmediate(() =&gt; {\n      this.recomputeForUser(userId).catch((err) =&gt; {\n        logger.error(\"Failed to recompute exclusions after unhide\", {\n          userId,\n          entityType,\n          entityId,\n          error: err,\n        });\n      });\n    });\n  }\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/__tests__/ExclusionComputationService.test.ts\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/services/ExclusionComputationService.ts server/services/__tests__/ExclusionComputationService.test.ts\ngit commit -m \"feat: implement incremental hide/unhide operations\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-8-update-scenequerybuilder-to-use-exclusion-join","title":"Task 8: Update SceneQueryBuilder to Use Exclusion JOIN","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/SceneQueryBuilder.test.ts</code></p> <p>Step 1: Update SceneQueryOptions interface</p> <p>In <code>SceneQueryBuilder.ts</code>, change the interface:</p> <pre><code>// Query builder options\nexport interface SceneQueryOptions {\n  userId: number;\n  filters?: PeekSceneFilter;\n  applyExclusions?: boolean;  // Default true, replaces excludedSceneIds\n  sort: string;\n  sortDirection: \"ASC\" | \"DESC\";\n  page: number;\n  perPage: number;\n  randomSeed?: number;\n}\n</code></pre> <p>Step 2: Update buildFromClause to include exclusion JOIN</p> <pre><code>  // Base FROM clause with user data JOINs and exclusion filter\n  private buildFromClause(userId: number, applyExclusions: boolean = true): { sql: string; params: number[] } {\n    const baseJoins = `\n      FROM StashScene s\n      LEFT JOIN SceneRating r ON s.id = r.sceneId AND r.userId = ?\n      LEFT JOIN WatchHistory w ON s.id = w.sceneId AND w.userId = ?\n    `.trim();\n\n    if (applyExclusions) {\n      return {\n        sql: `${baseJoins}\n      LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'scene' AND e.entityId = s.id`,\n        params: [userId, userId, userId],\n      };\n    }\n\n    return {\n      sql: baseJoins,\n      params: [userId, userId],\n    };\n  }\n</code></pre> <p>Step 3: Update buildBaseWhere to include exclusion filter</p> <pre><code>  // Base WHERE clause (always filter deleted, optionally filter excluded)\n  private buildBaseWhere(applyExclusions: boolean = true): FilterClause {\n    if (applyExclusions) {\n      return {\n        sql: \"s.deletedAt IS NULL AND e.id IS NULL\",\n        params: [],\n      };\n    }\n    return {\n      sql: \"s.deletedAt IS NULL\",\n      params: [],\n    };\n  }\n</code></pre> <p>Step 4: Remove buildExclusionFilter method</p> <p>Delete the <code>buildExclusionFilter</code> method (lines 88-125) - it's no longer needed.</p> <p>Step 5: Update execute method</p> <p>Update the <code>execute</code> method to use <code>applyExclusions</code> instead of <code>excludedSceneIds</code>:</p> <pre><code>  async execute(options: SceneQueryOptions): Promise&lt;SceneQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage, applyExclusions = true, filters } = options;\n\n    // Build FROM clause\n    const fromClause = this.buildFromClause(userId, applyExclusions);\n\n    // Build WHERE clauses\n    const whereClauses: FilterClause[] = [this.buildBaseWhere(applyExclusions)];\n\n    // Remove the exclusion filter call - it's now in the JOIN\n    // const exclusionFilter = this.buildExclusionFilter(excludedSceneIds || new Set());\n    // if (exclusionFilter.sql) {\n    //   whereClauses.push(exclusionFilter);\n    // }\n\n    // ... rest of the method stays the same\n</code></pre> <p>Step 6: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test -- services/\n</code></pre></p> <p>Expected: PASS (some tests may need updates for new interface)</p> <p>Step 7: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/services/__tests__/\ngit commit -m \"refactor: update SceneQueryBuilder to use exclusion JOIN\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-9-update-scene-controllers-to-remove-getexcludedsceneids-calls","title":"Task 9: Update Scene Controllers to Remove getExcludedSceneIds Calls","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Update scenes.ts</p> <p>Find all calls to <code>userRestrictionService.getExcludedSceneIds</code> and remove them. Update <code>sceneQueryBuilder.execute</code> calls to remove <code>excludedSceneIds</code> parameter.</p> <p>Before: <pre><code>const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\nconst result = await sceneQueryBuilder.execute({\n  userId,\n  excludedSceneIds: excludedIds,\n  // ...\n});\n</code></pre></p> <p>After: <pre><code>const result = await sceneQueryBuilder.execute({\n  userId,\n  // applyExclusions defaults to true\n  // ...\n});\n</code></pre></p> <p>Step 2: Update carousel.ts</p> <p>Same pattern - remove <code>getExcludedSceneIds</code> calls and <code>excludedSceneIds</code> parameters.</p> <p>Step 3: Run tests and verify server starts</p> <p>Run: <pre><code>cd server &amp;&amp; npm run build &amp;&amp; npm test\n</code></pre></p> <p>Expected: Build succeeds, tests pass</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/\ngit commit -m \"refactor: remove getExcludedSceneIds calls from scene controllers\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-10-wire-up-sync-trigger","title":"Task 10: Wire Up Sync Trigger","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Import ExclusionComputationService</p> <p>Add at top of file: <pre><code>import { exclusionComputationService } from \"./ExclusionComputationService.js\";\n</code></pre></p> <p>Step 2: Call recomputeAllUsers after sync completes</p> <p>Find the sync completion point (after all entity types are synced) and add:</p> <pre><code>// After sync completes, recompute exclusions for all users\nlogger.info(\"Sync complete, recomputing user exclusions...\");\nawait exclusionComputationService.recomputeAllUsers();\nlogger.info(\"User exclusions recomputed\");\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: trigger exclusion recompute after Stash sync\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-11-wire-up-hideunhide-triggers","title":"Task 11: Wire Up Hide/Unhide Triggers","text":"<p>Files: - Modify: <code>server/services/UserHiddenEntityService.ts</code></p> <p>Step 1: Import ExclusionComputationService</p> <p>Add at top of file: <pre><code>import { exclusionComputationService } from \"./ExclusionComputationService.js\";\n</code></pre></p> <p>Step 2: Update hide method</p> <p>After adding to <code>UserHiddenEntity</code> table, call: <pre><code>await exclusionComputationService.addHiddenEntity(userId, entityType, entityId);\n</code></pre></p> <p>Step 3: Update unhide method</p> <p>After removing from <code>UserHiddenEntity</code> table, call: <pre><code>await exclusionComputationService.removeHiddenEntity(userId, entityType, entityId);\n</code></pre></p> <p>Step 4: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/UserHiddenEntityService.ts\ngit commit -m \"feat: trigger exclusion updates on hide/unhide\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-12-wire-up-restriction-change-trigger","title":"Task 12: Wire Up Restriction Change Trigger","text":"<p>Files: - Modify: <code>server/controllers/user.ts</code> (or wherever restrictions are updated)</p> <p>Step 1: Find restriction update endpoint</p> <p>Look for the endpoint that handles <code>PUT /api/user/restrictions</code> or similar.</p> <p>Step 2: Add recompute call after restriction change</p> <pre><code>import { exclusionComputationService } from \"../services/ExclusionComputationService.js\";\n\n// After updating UserContentRestriction:\nawait exclusionComputationService.recomputeForUser(userId);\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/\ngit commit -m \"feat: trigger exclusion recompute on restriction change\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-13-add-admin-endpoints-for-manual-recompute","title":"Task 13: Add Admin Endpoints for Manual Recompute","text":"<p>Files: - Create or modify: <code>server/controllers/admin.ts</code> or <code>server/routes/admin.ts</code></p> <p>Step 1: Add recompute endpoints</p> <pre><code>import { exclusionComputationService } from \"../services/ExclusionComputationService.js\";\n\n// POST /api/admin/recompute-exclusions/:userId\nrouter.post(\"/recompute-exclusions/:userId\", requireAdmin, async (req, res) =&gt; {\n  const userId = parseInt(req.params.userId, 10);\n  await exclusionComputationService.recomputeForUser(userId);\n  res.json({ success: true, message: `Recomputed exclusions for user ${userId}` });\n});\n\n// POST /api/admin/recompute-exclusions/all\nrouter.post(\"/recompute-exclusions/all\", requireAdmin, async (req, res) =&gt; {\n  await exclusionComputationService.recomputeAllUsers();\n  res.json({ success: true, message: \"Recomputed exclusions for all users\" });\n});\n\n// GET /api/admin/exclusion-stats\nrouter.get(\"/exclusion-stats\", requireAdmin, async (req, res) =&gt; {\n  const stats = await prisma.userExcludedEntity.groupBy({\n    by: [\"userId\", \"entityType\"],\n    _count: true,\n  });\n  res.json(stats);\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm test\n</code></pre></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/ server/routes/\ngit commit -m \"feat: add admin endpoints for exclusion management\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-14-update-other-entity-controllers-performers-studios-tags-groups-galleries-images","title":"Task 14: Update Other Entity Controllers (Performers, Studios, Tags, Groups, Galleries, Images)","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/studios.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/groups.ts</code> - Modify: <code>server/controllers/library/galleries.ts</code> - Modify: <code>server/controllers/library/images.ts</code></p> <p>For each controller, add exclusion JOIN to queries. The pattern is:</p> <pre><code>LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = '&lt;type&gt;' AND e.entityId = &lt;table&gt;.id\nWHERE ... AND e.id IS NULL\n</code></pre> <p>This is a large task - break into sub-tasks per controller.</p> <p>Commit after each controller is updated:</p> <pre><code>git add server/controllers/library/&lt;entity&gt;.ts\ngit commit -m \"refactor: add exclusion JOIN to &lt;entity&gt; queries\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-15-remove-old-filtering-services","title":"Task 15: Remove Old Filtering Services","text":"<p>Files: - Delete: <code>server/services/UserRestrictionService.ts</code> - Delete: <code>server/services/EmptyEntityFilterService.ts</code> - Delete: <code>server/services/FilteredEntityCacheService.ts</code></p> <p>Step 1: Search for imports</p> <p>Run: <pre><code>cd server &amp;&amp; grep -r \"UserRestrictionService\\|EmptyEntityFilterService\\|FilteredEntityCacheService\" --include=\"*.ts\"\n</code></pre></p> <p>Update any remaining imports to use the new services.</p> <p>Step 2: Delete old files</p> <pre><code>rm server/services/UserRestrictionService.ts\nrm server/services/EmptyEntityFilterService.ts\nrm server/services/FilteredEntityCacheService.ts\n</code></pre> <p>Step 3: Run build and tests</p> <p>Run: <pre><code>cd server &amp;&amp; npm run build &amp;&amp; npm test\n</code></pre></p> <p>Expected: Build succeeds, tests pass</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: remove deprecated filtering services\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#task-16-final-integration-test","title":"Task 16: Final Integration Test","text":"<p>Step 1: Start the server</p> <pre><code>cd server &amp;&amp; npm run dev\n</code></pre> <p>Step 2: Manual testing checklist</p> <ol> <li>Fresh user login \u2192 verify initial exclusion computation works</li> <li>Admin changes restrictions \u2192 verify recomputation triggers</li> <li>User hides entity \u2192 verify it disappears immediately</li> <li>User unhides entity \u2192 verify it reappears after brief delay</li> <li>Stash sync \u2192 verify new items are checked against rules</li> <li>Filter dropdowns \u2192 verify hidden entities don't appear</li> </ol> <p>Step 3: Final commit</p> <pre><code>git add -A\ngit commit -m \"feat: complete pre-computed exclusions implementation\"\n</code></pre>"},{"location":"plans/2025-01-02-pre-computed-exclusions-implementation/#summary","title":"Summary","text":"<p>This implementation plan covers:</p> <ol> <li>Database schema - New tables for exclusions and stats</li> <li>Computation service - Full recompute algorithm with phases</li> <li>Cascade logic - Performer\u2192scene, tag\u2192everything, etc.</li> <li>Empty entity detection - Galleries, performers, studios, groups, tags</li> <li>Incremental updates - Sync hide, async unhide</li> <li>Query changes - JOIN-based filtering in SceneQueryBuilder</li> <li>Controller updates - Remove old filtering calls</li> <li>Triggers - Sync, hide/unhide, restriction changes</li> <li>Admin endpoints - Manual recompute, stats</li> <li>Cleanup - Remove deprecated services</li> </ol> <p>Plan complete and saved to <code>docs/plans/2025-01-02-pre-computed-exclusions-implementation.md</code>. Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/","title":"Scene Tag Inheritance","text":"<p>Branch: <code>feature/scene-tag-inheritance</code> Status: Design Complete Complexity: Medium</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#problem-statement","title":"Problem Statement","text":"<p>Scenes display and filter by \"inherited\" tags from related entities. Currently: - Direct Scene Tags \u2014 works - Performer Tags \u2014 works (tags on performers in the scene) - Studio Tags \u2014 works (tags on the scene's studio) - Group Tags \u2014 MISSING (tags on groups the scene belongs to)</p> <p>Additionally, this inheritance is computed at render time on the client, causing: 1. Duplicated logic in multiple components (<code>SceneCard.jsx</code>, <code>SceneMetadata.jsx</code>) 2. Inefficient re-computation on every render 3. Inconsistency between UI display and server-side restriction filtering</p> <p>Goal: Denormalize inherited tags at sync time, storing them directly on the Scene. This matches the pattern proposed for Image Gallery Inheritance.</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#solution-overview","title":"Solution Overview","text":"<p>Approach: Store inherited tags on the Scene at sync time, similar to Image Gallery Inheritance.</p> <p>New field on <code>StashScene</code>: <pre><code>inheritedTagIds String? // JSON array of tag IDs inherited from performers, studio, groups\n</code></pre></p> <p>Why a separate field instead of adding to SceneTag junction? - Keeps direct tags distinct from inherited (important for editing in Stash) - Easy to recompute on sync without touching user's direct assignments - Client can merge for display: <code>[...scene.tags, ...inheritedTags]</code></p> <p>Inheritance sources (collected at sync):</p> Source When Performer Tags For each performer in scene, collect their tags Studio Tags If scene has a studio, collect its tags Group Tags For each group the scene belongs to, collect their tags <p>Deduplication: Store as a Set of tag IDs, converted to JSON array. Tags already directly on the scene are excluded from <code>inheritedTagIds</code> to avoid duplicates.</p> <p>Client changes: - Remove runtime tag merging logic from <code>SceneCard.jsx</code> and <code>SceneMetadata.jsx</code> - Scene response includes both <code>tags</code> (direct) and <code>inheritedTags</code> (denormalized) - Components display combined list</p> <p>Server changes: - <code>UserRestrictionService.getSceneEntityIds()</code> \u2014 simplify to use <code>inheritedTagIds</code> instead of runtime collection - Restriction filtering becomes a simple array check</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#implementation-details","title":"Implementation Details","text":""},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#schema-change","title":"Schema Change","text":"<pre><code>model StashScene {\n  // ... existing fields ...\n\n  // Inherited tags (denormalized at sync time)\n  // JSON array of tag IDs from performers, studio, and groups\n  inheritedTagIds String? // e.g., '[\"1\",\"5\",\"12\"]'\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesstashsyncservicets","title":"File: <code>server/services/StashSyncService.ts</code>","text":"<p>After syncing scenes with their relationships, compute inherited tags:</p> <pre><code>async function computeInheritedTags(sceneId: string): Promise&lt;string[]&gt; {\n  const tagIds = new Set&lt;string&gt;();\n\n  // Get scene's direct tag IDs (to exclude from inherited)\n  const directTags = await prisma.sceneTag.findMany({\n    where: { sceneId },\n    select: { tagId: true }\n  });\n  const directTagIds = new Set(directTags.map(t =&gt; t.tagId));\n\n  // Collect performer tags\n  const scenePerformers = await prisma.scenePerformer.findMany({\n    where: { sceneId },\n    select: { performerId: true }\n  });\n  for (const sp of scenePerformers) {\n    const performerTags = await prisma.performerTag.findMany({\n      where: { performerId: sp.performerId },\n      select: { tagId: true }\n    });\n    performerTags.forEach(pt =&gt; {\n      if (!directTagIds.has(pt.tagId)) tagIds.add(pt.tagId);\n    });\n  }\n\n  // Collect studio tags\n  const scene = await prisma.stashScene.findUnique({\n    where: { id: sceneId },\n    select: { studioId: true }\n  });\n  if (scene?.studioId) {\n    const studioTags = await prisma.studioTag.findMany({\n      where: { studioId: scene.studioId },\n      select: { tagId: true }\n    });\n    studioTags.forEach(st =&gt; {\n      if (!directTagIds.has(st.tagId)) tagIds.add(st.tagId);\n    });\n  }\n\n  // Collect group tags\n  const sceneGroups = await prisma.sceneGroup.findMany({\n    where: { sceneId },\n    select: { groupId: true }\n  });\n  for (const sg of sceneGroups) {\n    const groupTags = await prisma.groupTag.findMany({\n      where: { groupId: sg.groupId },\n      select: { tagId: true }\n    });\n    groupTags.forEach(gt =&gt; {\n      if (!directTagIds.has(gt.tagId)) tagIds.add(gt.tagId);\n    });\n  }\n\n  return Array.from(tagIds);\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesstashentityservicets","title":"File: <code>server/services/StashEntityService.ts</code>","text":"<p>Update <code>transformScene</code> to include inherited tags:</p> <pre><code>private transformScene(scene: any): NormalizedScene {\n  // ... existing transform ...\n\n  // Parse inherited tag IDs and hydrate with tag data\n  const inheritedTagIds = scene.inheritedTagIds\n    ? JSON.parse(scene.inheritedTagIds)\n    : [];\n\n  return {\n    ...base,\n    inheritedTagIds, // Raw IDs for filtering\n    // inheritedTags will be hydrated in controller if needed for display\n  };\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#file-serverservicesuserrestrictionservicets","title":"File: <code>server/services/UserRestrictionService.ts</code>","text":"<p>Simplify <code>getSceneEntityIds()</code>:</p> <pre><code>// Before: complex runtime collection from nested objects\n// After: simple array concat\ncase \"tags\": {\n  const directTagIds = (scene.tags || []).map(t =&gt; String(t.id));\n  const inheritedTagIds = scene.inheritedTagIds || [];\n  return [...new Set([...directTagIds, ...inheritedTagIds])];\n}\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#client-changes","title":"Client Changes","text":"<p>Remove <code>getAllTags()</code> / <code>mergeAllTags()</code> functions from: - <code>client/src/components/ui/SceneCard.jsx</code> (lines 82-98) - <code>client/src/components/scene/SceneMetadata.jsx</code> (lines 7-30)</p> <p>Replace with: <pre><code>const allTags = [...(scene.tags || []), ...(scene.inheritedTags || [])];\n</code></pre></p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#testing-acceptance-criteria","title":"Testing &amp; Acceptance Criteria","text":""},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#manual-testing","title":"Manual Testing","text":"<ol> <li>Basic inheritance display:</li> <li>Create a Scene with no direct tags</li> <li>Add it to a Performer with tags, a Studio with tags, and a Group with tags</li> <li>Run sync</li> <li>Verify Scene cards show all inherited tags</li> <li> <p>Verify Scene detail page shows all inherited tags</p> </li> <li> <p>Deduplication:</p> </li> <li>Create a Scene with tag \"Action\" directly assigned</li> <li>Add a Performer to the scene who also has tag \"Action\"</li> <li>Run sync</li> <li> <p>Verify \"Action\" appears only once (not duplicated)</p> </li> <li> <p>Group tags now work:</p> </li> <li>Create a Group with tag \"Series A\"</li> <li>Add scenes to the Group (scenes have no direct tags)</li> <li>Run sync</li> <li> <p>Verify scenes display \"Series A\" tag</p> </li> <li> <p>Restriction filtering:</p> </li> <li>Restrict tag \"Explicit\" for a user</li> <li>Create a Group with tag \"Explicit\"</li> <li>Add scenes to the Group</li> <li>Verify those scenes are hidden for the restricted user</li> <li> <p>Verify same works for Performer tags and Studio tags</p> </li> <li> <p>Tag filtering in library:</p> </li> <li>Filter scenes by a tag that only exists on a Performer (not directly on scenes)</li> <li> <p>Verify scenes with that performer appear in results</p> </li> <li> <p>Re-sync behavior:</p> </li> <li>Change a Performer's tags in Stash</li> <li>Run sync</li> <li>Verify scenes with that performer update their inherited tags</li> </ol>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#edge-cases","title":"Edge Cases","text":"<ul> <li>Scene with no performers, no studio, no groups (inheritedTagIds = [])</li> <li>Scene removed from a group (inherited tags from that group should disappear on next sync)</li> <li>Performer removed from scene (inherited tags from that performer should disappear)</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#files-changed","title":"Files Changed","text":"<ul> <li><code>server/prisma/schema.prisma</code> \u2014 Add <code>inheritedTagIds</code> field to <code>StashScene</code></li> <li><code>server/services/StashSyncService.ts</code> \u2014 Add <code>computeInheritedTags()</code>, call after scene sync</li> <li><code>server/services/StashEntityService.ts</code> \u2014 Parse and include <code>inheritedTagIds</code> in transform</li> <li><code>server/services/UserRestrictionService.ts</code> \u2014 Simplify <code>getSceneEntityIds()</code> for tags</li> <li><code>client/src/components/ui/SceneCard.jsx</code> \u2014 Remove <code>getAllTags()</code>, use <code>inheritedTags</code> from response</li> <li><code>client/src/components/scene/SceneMetadata.jsx</code> \u2014 Remove <code>mergeAllTags()</code>, use <code>inheritedTags</code> from response</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-design/#related-documentation","title":"Related Documentation","text":"<ul> <li>Technical Overview \u2014 Documents Scene Tag Inheritance under \"Pseudo-Relationships\"</li> <li>Image Gallery Inheritance \u2014 Same pattern for Images</li> </ul>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/","title":"Scene Tag Inheritance Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Denormalize inherited tags at sync time, storing them on the Scene for efficient filtering and display.</p> <p>Architecture: Add <code>inheritedTagIds</code> field to StashScene schema, create SceneTagInheritanceService to compute inherited tags from performers, studio, and groups at sync time. Update client to use server-provided inherited tags instead of computing at render time.</p> <p>Tech Stack: Prisma/SQLite, TypeScript, React</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-1-add-inheritedtagids-field-to-schema","title":"Task 1: Add inheritedTagIds Field to Schema","text":"<p>Files: - Modify: <code>server/prisma/schema.prisma</code> (StashScene model, lines 423-495)</p> <p>Step 1: Add the field to StashScene model</p> <p>Add after line 471 (<code>syncedAt</code> field):</p> <pre><code>  inheritedTagIds String? // JSON array of tag IDs from performers, studio, groups\n</code></pre> <p>Step 2: Generate migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add-scene-inherited-tag-ids</code> Expected: Migration created successfully</p> <p>Step 3: Verify schema</p> <p>Run: <code>cd server &amp;&amp; npx prisma generate</code> Expected: Prisma Client generated successfully</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/schema.prisma server/prisma/migrations/\ngit commit -m \"feat: add inheritedTagIds field to StashScene schema\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-2-create-scenetaginheritanceservice","title":"Task 2: Create SceneTagInheritanceService","text":"<p>Files: - Create: <code>server/services/SceneTagInheritanceService.ts</code> - Create: <code>server/services/__tests__/SceneTagInheritanceService.test.ts</code></p> <p>Step 1: Write the test file</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { sceneTagInheritanceService } from \"../SceneTagInheritanceService.js\";\n\ndescribe(\"SceneTagInheritanceService\", () =&gt; {\n  // Clean up test data\n  beforeEach(async () =&gt; {\n    await prisma.sceneTag.deleteMany({});\n    await prisma.scenePerformer.deleteMany({});\n    await prisma.sceneGroup.deleteMany({});\n    await prisma.performerTag.deleteMany({});\n    await prisma.studioTag.deleteMany({});\n    await prisma.groupTag.deleteMany({});\n    await prisma.stashScene.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n    await prisma.stashGroup.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.sceneTag.deleteMany({});\n    await prisma.scenePerformer.deleteMany({});\n    await prisma.sceneGroup.deleteMany({});\n    await prisma.performerTag.deleteMany({});\n    await prisma.studioTag.deleteMany({});\n    await prisma.groupTag.deleteMany({});\n    await prisma.stashScene.deleteMany({});\n    await prisma.stashPerformer.deleteMany({});\n    await prisma.stashStudio.deleteMany({});\n    await prisma.stashGroup.deleteMany({});\n    await prisma.stashTag.deleteMany({});\n  });\n\n  describe(\"computeInheritedTags\", () =&gt; {\n    it(\"should inherit tags from performer\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Performer Tag\" },\n      });\n\n      // Create performer with tag\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with performer\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.scenePerformer.create({\n        data: { sceneId: \"scene-1\", performerId: \"performer-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should inherit tags from studio\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Studio Tag\" },\n      });\n\n      // Create studio with tag\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n      await prisma.studioTag.create({\n        data: { studioId: \"studio-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with studio\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\", studioId: \"studio-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should inherit tags from group\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Group Tag\" },\n      });\n\n      // Create group with tag\n      await prisma.stashGroup.create({\n        data: { id: \"group-1\", name: \"Test Group\" },\n      });\n      await prisma.groupTag.create({\n        data: { groupId: \"group-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene in group\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.sceneGroup.create({\n        data: { sceneId: \"scene-1\", groupId: \"group-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited tag\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n    });\n\n    it(\"should NOT include direct scene tags in inheritedTagIds\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Direct Tag\" },\n      });\n\n      // Create scene with direct tag\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.sceneTag.create({\n        data: { sceneId: \"scene-1\", tagId: \"tag-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify direct tag is NOT in inheritedTagIds\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).not.toContain(\"tag-1\");\n    });\n\n    it(\"should deduplicate tags from multiple sources\", async () =&gt; {\n      // Create tag\n      await prisma.stashTag.create({\n        data: { id: \"tag-1\", name: \"Shared Tag\" },\n      });\n\n      // Create performer with tag\n      await prisma.stashPerformer.create({\n        data: { id: \"performer-1\", name: \"Test Performer\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n\n      // Create studio with same tag\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Test Studio\" },\n      });\n      await prisma.studioTag.create({\n        data: { studioId: \"studio-1\", tagId: \"tag-1\" },\n      });\n\n      // Create scene with both performer and studio\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\", studioId: \"studio-1\" },\n      });\n      await prisma.scenePerformer.create({\n        data: { sceneId: \"scene-1\", performerId: \"performer-1\" },\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify tag appears only once\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      const tagCount = inheritedTagIds.filter((id: string) =&gt; id === \"tag-1\").length;\n      expect(tagCount).toBe(1);\n    });\n\n    it(\"should handle scene with no related entities\", async () =&gt; {\n      // Create scene with nothing\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Standalone Scene\" },\n      });\n\n      // Apply inheritance (should not fail)\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify empty inherited tags\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toEqual([]);\n    });\n\n    it(\"should collect tags from multiple performers\", async () =&gt; {\n      // Create tags\n      await prisma.stashTag.createMany({\n        data: [\n          { id: \"tag-1\", name: \"Performer 1 Tag\" },\n          { id: \"tag-2\", name: \"Performer 2 Tag\" },\n        ],\n      });\n\n      // Create two performers with different tags\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"performer-1\", name: \"Performer 1\" },\n          { id: \"performer-2\", name: \"Performer 2\" },\n        ],\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-1\", tagId: \"tag-1\" },\n      });\n      await prisma.performerTag.create({\n        data: { performerId: \"performer-2\", tagId: \"tag-2\" },\n      });\n\n      // Create scene with both performers\n      await prisma.stashScene.create({\n        data: { id: \"scene-1\", title: \"Test Scene\" },\n      });\n      await prisma.scenePerformer.createMany({\n        data: [\n          { sceneId: \"scene-1\", performerId: \"performer-1\" },\n          { sceneId: \"scene-1\", performerId: \"performer-2\" },\n        ],\n      });\n\n      // Apply inheritance\n      await sceneTagInheritanceService.computeInheritedTags();\n\n      // Verify scene inherited both tags\n      const scene = await prisma.stashScene.findUnique({\n        where: { id: \"scene-1\" },\n      });\n      const inheritedTagIds = JSON.parse(scene?.inheritedTagIds || \"[]\");\n      expect(inheritedTagIds).toContain(\"tag-1\");\n      expect(inheritedTagIds).toContain(\"tag-2\");\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneTagInheritanceService</code> Expected: FAIL - module not found</p> <p>Step 3: Write the service</p> <pre><code>import prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n/**\n * SceneTagInheritanceService\n *\n * Computes inherited tags for scenes from related entities.\n * Called after sync completes to denormalize tag data for efficient filtering.\n *\n * Inheritance sources:\n * - Performer tags (from performers in the scene)\n * - Studio tags (from the scene's studio)\n * - Group tags (from groups the scene belongs to)\n *\n * Rules:\n * - Direct scene tags are NOT included in inheritedTagIds (they're already in SceneTag)\n * - Tags are deduplicated across all sources\n * - Stored as JSON array for efficient querying\n */\nclass SceneTagInheritanceService {\n  /**\n   * Compute and store inherited tags for all scenes.\n   * Uses SQL for efficient bulk operations.\n   */\n  async computeInheritedTags(): Promise&lt;void&gt; {\n    const startTime = Date.now();\n    logger.info(\"Computing inherited tags for scenes...\");\n\n    try {\n      // Get all scenes that need processing\n      const scenes = await prisma.stashScene.findMany({\n        where: { deletedAt: null },\n        select: { id: true, studioId: true },\n      });\n\n      // Process in batches for memory efficiency\n      const BATCH_SIZE = 500;\n      let processedCount = 0;\n\n      for (let i = 0; i &lt; scenes.length; i += BATCH_SIZE) {\n        const batch = scenes.slice(i, i + BATCH_SIZE);\n        await this.processBatch(batch);\n        processedCount += batch.length;\n\n        if (processedCount % 1000 === 0) {\n          logger.info(`Processed ${processedCount}/${scenes.length} scenes`);\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      logger.info(`Scene tag inheritance computed in ${duration}ms for ${scenes.length} scenes`);\n    } catch (error) {\n      logger.error(\"Failed to compute scene tag inheritance\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Process a batch of scenes\n   */\n  private async processBatch(\n    scenes: { id: string; studioId: string | null }[]\n  ): Promise&lt;void&gt; {\n    const sceneIds = scenes.map((s) =&gt; s.id);\n\n    // Get direct tags for all scenes in batch\n    const directTags = await prisma.sceneTag.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, tagId: true },\n    });\n    const directTagsByScene = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const dt of directTags) {\n      if (!directTagsByScene.has(dt.sceneId)) {\n        directTagsByScene.set(dt.sceneId, new Set());\n      }\n      directTagsByScene.get(dt.sceneId)!.add(dt.tagId);\n    }\n\n    // Get performer tags for all scenes in batch\n    const scenePerformers = await prisma.scenePerformer.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, performerId: true },\n    });\n    const performerIds = [...new Set(scenePerformers.map((sp) =&gt; sp.performerId))];\n    const performerTags = await prisma.performerTag.findMany({\n      where: { performerId: { in: performerIds } },\n      select: { performerId: true, tagId: true },\n    });\n    const tagsByPerformer = new Map&lt;string, string[]&gt;();\n    for (const pt of performerTags) {\n      if (!tagsByPerformer.has(pt.performerId)) {\n        tagsByPerformer.set(pt.performerId, []);\n      }\n      tagsByPerformer.get(pt.performerId)!.push(pt.tagId);\n    }\n\n    // Get studio tags\n    const studioIds = [...new Set(scenes.filter((s) =&gt; s.studioId).map((s) =&gt; s.studioId!))] ;\n    const studioTags = await prisma.studioTag.findMany({\n      where: { studioId: { in: studioIds } },\n      select: { studioId: true, tagId: true },\n    });\n    const tagsByStudio = new Map&lt;string, string[]&gt;();\n    for (const st of studioTags) {\n      if (!tagsByStudio.has(st.studioId)) {\n        tagsByStudio.set(st.studioId, []);\n      }\n      tagsByStudio.get(st.studioId)!.push(st.tagId);\n    }\n\n    // Get group tags for all scenes in batch\n    const sceneGroups = await prisma.sceneGroup.findMany({\n      where: { sceneId: { in: sceneIds } },\n      select: { sceneId: true, groupId: true },\n    });\n    const groupIds = [...new Set(sceneGroups.map((sg) =&gt; sg.groupId))];\n    const groupTags = await prisma.groupTag.findMany({\n      where: { groupId: { in: groupIds } },\n      select: { groupId: true, tagId: true },\n    });\n    const tagsByGroup = new Map&lt;string, string[]&gt;();\n    for (const gt of groupTags) {\n      if (!tagsByGroup.has(gt.groupId)) {\n        tagsByGroup.set(gt.groupId, []);\n      }\n      tagsByGroup.get(gt.groupId)!.push(gt.tagId);\n    }\n\n    // Build scene -&gt; performer mapping\n    const performersByScene = new Map&lt;string, string[]&gt;();\n    for (const sp of scenePerformers) {\n      if (!performersByScene.has(sp.sceneId)) {\n        performersByScene.set(sp.sceneId, []);\n      }\n      performersByScene.get(sp.sceneId)!.push(sp.performerId);\n    }\n\n    // Build scene -&gt; group mapping\n    const groupsByScene = new Map&lt;string, string[]&gt;();\n    for (const sg of sceneGroups) {\n      if (!groupsByScene.has(sg.sceneId)) {\n        groupsByScene.set(sg.sceneId, []);\n      }\n      groupsByScene.get(sg.sceneId)!.push(sg.groupId);\n    }\n\n    // Compute inherited tags for each scene\n    const updates: { id: string; inheritedTagIds: string }[] = [];\n\n    for (const scene of scenes) {\n      const inheritedTags = new Set&lt;string&gt;();\n      const directTagsForScene = directTagsByScene.get(scene.id) || new Set();\n\n      // Collect performer tags\n      const performers = performersByScene.get(scene.id) || [];\n      for (const performerId of performers) {\n        const tags = tagsByPerformer.get(performerId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      // Collect studio tags\n      if (scene.studioId) {\n        const tags = tagsByStudio.get(scene.studioId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      // Collect group tags\n      const groups = groupsByScene.get(scene.id) || [];\n      for (const groupId of groups) {\n        const tags = tagsByGroup.get(groupId) || [];\n        for (const tagId of tags) {\n          if (!directTagsForScene.has(tagId)) {\n            inheritedTags.add(tagId);\n          }\n        }\n      }\n\n      updates.push({\n        id: scene.id,\n        inheritedTagIds: JSON.stringify(Array.from(inheritedTags)),\n      });\n    }\n\n    // Batch update using raw SQL for efficiency\n    // SQLite doesn't support UPDATE ... FROM with VALUES, so we use CASE WHEN\n    if (updates.length &gt; 0) {\n      // Split into smaller batches for the SQL update\n      const SQL_BATCH_SIZE = 100;\n      for (let i = 0; i &lt; updates.length; i += SQL_BATCH_SIZE) {\n        const sqlBatch = updates.slice(i, i + SQL_BATCH_SIZE);\n        const ids = sqlBatch.map((u) =&gt; u.id);\n\n        // Use individual updates - more compatible with SQLite\n        await Promise.all(\n          sqlBatch.map((u) =&gt;\n            prisma.stashScene.update({\n              where: { id: u.id },\n              data: { inheritedTagIds: u.inheritedTagIds },\n            })\n          )\n        );\n      }\n    }\n  }\n}\n\nexport const sceneTagInheritanceService = new SceneTagInheritanceService();\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneTagInheritanceService</code> Expected: All tests PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/SceneTagInheritanceService.ts server/services/__tests__/SceneTagInheritanceService.test.ts\ngit commit -m \"feat: add SceneTagInheritanceService for denormalizing inherited tags\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-3-integrate-with-stashsyncservice","title":"Task 3: Integrate with StashSyncService","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code></p> <p>Step 1: Add import at top of file</p> <p>Add after other service imports (around line 20):</p> <pre><code>import { sceneTagInheritanceService } from \"./SceneTagInheritanceService.js\";\n</code></pre> <p>Step 2: Add call after full sync (after line 222)</p> <p>Find the section where <code>imageGalleryInheritanceService.applyGalleryInheritance()</code> is called in <code>syncFromStash()</code> method. Add scene tag inheritance right before it:</p> <pre><code>      // Compute inherited tags for scenes (must happen after scenes, performers, studios, groups are synced)\n      logger.info(\"Computing inherited tags for scenes...\");\n      await sceneTagInheritanceService.computeInheritedTags();\n      logger.info(\"Scene tag inheritance complete\");\n</code></pre> <p>Step 3: Add call after incremental sync (around line 547)</p> <p>Find the section in <code>incrementalSync()</code> after gallery inheritance. Add scene tag inheritance when scenes were synced:</p> <pre><code>      // Compute inherited tags for scenes if scenes were updated\n      const sceneResult = results.find((r) =&gt; r.entityType === \"scene\");\n      if (sceneResult &amp;&amp; sceneResult.synced &gt; 0) {\n        logger.info(\"Computing inherited tags for scenes after incremental sync...\");\n        await sceneTagInheritanceService.computeInheritedTags();\n        logger.info(\"Scene tag inheritance complete\");\n      }\n</code></pre> <p>Step 4: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: integrate SceneTagInheritanceService with sync pipeline\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-4-update-userrestrictionservice-to-use-inheritedtagids","title":"Task 4: Update UserRestrictionService to Use inheritedTagIds","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code> (lines 837-876)</p> <p>Step 1: Simplify getSceneEntityIds for tags case</p> <p>Replace the current \"tags\" case (lines 848-876) with:</p> <pre><code>      case \"tags\": {\n        // Direct scene tags\n        const directTagIds = (scene.tags || []).map((t: EntityWithId) =&gt; String(t.id));\n\n        // Inherited tags (pre-computed at sync time)\n        const inheritedTagIds = (scene as any).inheritedTagIds || [];\n\n        // Combine and deduplicate\n        return [...new Set([...directTagIds, ...inheritedTagIds])];\n      }\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"refactor: simplify UserRestrictionService to use pre-computed inheritedTagIds\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-5-update-stashentityservice-to-include-inheritedtagids","title":"Task 5: Update StashEntityService to Include inheritedTagIds","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Update transformScene method (around line 1414)</p> <p>Add inheritedTagIds parsing after the existing fields:</p> <pre><code>      // Inherited tag IDs (pre-computed at sync time)\n      inheritedTagIds: scene.inheritedTagIds ? JSON.parse(scene.inheritedTagIds) : [],\n</code></pre> <p>Step 2: Update transformSceneForBrowse method (around line 1478)</p> <p>Add the same inheritedTagIds parsing:</p> <pre><code>      // Inherited tag IDs (pre-computed at sync time)\n      inheritedTagIds: scene.inheritedTagIds ? JSON.parse(scene.inheritedTagIds) : [],\n</code></pre> <p>Step 3: Update NormalizedScene type if needed</p> <p>Check <code>server/types/stash.ts</code> for NormalizedScene type. Add inheritedTagIds field if not present:</p> <pre><code>inheritedTagIds?: string[];\n</code></pre> <p>Step 4: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 5: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/stash.ts\ngit commit -m \"feat: include inheritedTagIds in scene transforms\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-6-update-client-components","title":"Task 6: Update Client Components","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCard.jsx</code> (lines 82-100) - Modify: <code>client/src/components/scene/SceneMetadata.jsx</code> (lines 7-37)</p> <p>Step 1: Update SceneCard.jsx</p> <p>Replace the <code>getAllTags</code> function and its usage (lines 82-100) with:</p> <pre><code>    // Combine direct tags with server-computed inherited tags\n    const allTags = useMemo(() =&gt; {\n      const tagMap = new Map();\n      // Direct scene tags\n      if (scene.tags) {\n        scene.tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n      }\n      // Inherited tags (pre-computed on server)\n      if (scene.inheritedTags) {\n        scene.inheritedTags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n      }\n      return Array.from(tagMap.values());\n    }, [scene.tags, scene.inheritedTags]);\n</code></pre> <p>Note: Add <code>useMemo</code> to imports if not already present.</p> <p>Step 2: Update SceneMetadata.jsx</p> <p>Replace <code>mergeAllTags</code> function (lines 7-30) and its usage with:</p> <pre><code>/**\n * Combine direct tags with inherited tags from server\n */\nconst getAllTags = (scene) =&gt; {\n  const tagMap = new Map();\n  // Direct scene tags\n  if (scene.tags) {\n    scene.tags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  }\n  // Inherited tags (pre-computed on server)\n  if (scene.inheritedTags) {\n    scene.inheritedTags.forEach((tag) =&gt; tagMap.set(tag.id, tag));\n  }\n  return Array.from(tagMap.values());\n};\n</code></pre> <p>Update the component to use this:</p> <pre><code>  const allTags = getAllTags(scene);\n</code></pre> <p>Step 3: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add client/src/components/ui/SceneCard.jsx client/src/components/scene/SceneMetadata.jsx\ngit commit -m \"refactor: use server-provided inheritedTags instead of client-side computation\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-7-add-inheritedtags-hydration-to-api-response","title":"Task 7: Add inheritedTags Hydration to API Response","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Update transformSceneWithRelations to hydrate inheritedTags</p> <p>In <code>transformSceneWithRelations</code> method (around line 1555), after parsing inheritedTagIds, add hydration:</p> <pre><code>    // Hydrate inherited tags with full tag objects\n    if (scene.inheritedTagIds) {\n      const inheritedTagIds = JSON.parse(scene.inheritedTagIds);\n      if (inheritedTagIds.length &gt; 0) {\n        // Look up tags in the tags array we already have, or query if needed\n        base.inheritedTags = inheritedTagIds.map((tagId: string) =&gt; {\n          // Find in existing tags or create minimal stub\n          const existingTag = base.tags?.find((t: any) =&gt; t.id === tagId);\n          return existingTag || { id: tagId, name: \"Unknown\" };\n        });\n      }\n    }\n</code></pre> <p>Step 2: Add inheritedTags to NormalizedScene type</p> <p>Update <code>server/types/stash.ts</code>:</p> <pre><code>inheritedTags?: { id: string; name: string }[];\n</code></pre> <p>Step 3: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/stash.ts\ngit commit -m \"feat: hydrate inheritedTags with full tag objects in API response\"\n</code></pre>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-8-run-full-test-suite-and-verify","title":"Task 8: Run Full Test Suite and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Run TypeScript check</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No type errors</p> <p>Step 4: Commit any remaining fixes</p> <p>If any fixes were needed, commit them.</p>"},{"location":"plans/2025-01-02-scene-tag-inheritance-impl/#task-9-create-pull-request","title":"Task 9: Create Pull Request","text":"<p>Step 1: Push branch</p> <pre><code>git push -u origin feature/scene-tag-inheritance\n</code></pre> <p>Step 2: Create PR</p> <pre><code>gh pr create --title \"feat: denormalize scene inherited tags at sync time\" --body \"$(cat &lt;&lt;'EOF'\n## Summary\n- Adds `inheritedTagIds` field to StashScene schema to store tags inherited from performers, studio, and groups\n- Creates SceneTagInheritanceService to compute inherited tags at sync time\n- Simplifies UserRestrictionService to use pre-computed inherited tags\n- Updates client components to use server-provided inheritedTags instead of client-side computation\n- **Fixes group tag inheritance** which was previously missing\n\n## Changes\n- Schema migration adding `inheritedTagIds` to StashScene\n- New `SceneTagInheritanceService` with comprehensive tests\n- Integration with sync pipeline (full and incremental)\n- Updated `StashEntityService` transforms to include inheritedTagIds\n- Refactored `UserRestrictionService.getSceneEntityIds()` to use pre-computed tags\n- Updated `SceneCard.jsx` and `SceneMetadata.jsx` to use server-provided tags\n\n## Test Plan\n- [x] Unit tests for SceneTagInheritanceService\n- [ ] Manual test: Scene with no direct tags shows inherited tags from performer\n- [ ] Manual test: Scene with no direct tags shows inherited tags from studio\n- [ ] Manual test: Scene with no direct tags shows inherited tags from group (NEW!)\n- [ ] Manual test: Tags inherited from multiple sources are deduplicated\n- [ ] Manual test: Direct tags are NOT duplicated in inheritedTagIds\n- [ ] Manual test: Restriction filtering works with inherited tags\nEOF\n)\"\n</code></pre> <p>Step 3: Return PR URL</p>"},{"location":"plans/2025-01-12-card-grid-followup/","title":"Card/Grid Refactor Follow-up Tasks","text":"<p>Created: 2025-01-12 Status: Pending Priority: Low</p> <p>Follow-up items identified during code review of the card/grid refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#background","title":"Background","text":"<p>The card/grid refactor (completed 2025-01-12) introduced: - Three-layer card architecture: Primitives -&gt; BaseCard -&gt; Entity Cards - Two-layer grid architecture: BaseGrid -&gt; SearchableGrid/Entity Grids</p> <p>Code review identified minor improvements that were not blockers for the initial refactor.</p>"},{"location":"plans/2025-01-12-card-grid-followup/#tasks","title":"Tasks","text":""},{"location":"plans/2025-01-12-card-grid-followup/#1-complete-search-page-migration-important","title":"1. Complete Search Page Migration (Important)","text":"<p>Current state: Search pages (Galleries, Groups, Studios, Tags) still have inline grid implementations instead of using entity grids.</p> <p>Blocker: TV navigation (<code>useGridPageTVNavigation</code>) needs to be integrated into SearchableGrid first.</p> <p>Files to migrate: - <code>client/src/components/pages/Galleries.jsx</code> - <code>client/src/components/pages/Groups.jsx</code> - <code>client/src/components/pages/Studios.jsx</code> - <code>client/src/components/pages/Tags.jsx</code></p> <p>Benefit: Removes ~250 lines of duplicated code across 4 search pages.</p> <p>Steps: 1. Add TV navigation support to SearchableGrid or entity grids 2. Add <code>isInitializing</code> state support to SearchableGrid for SyncProgressBanner 3. Migrate each search page to use its corresponding entity grid</p>"},{"location":"plans/2025-01-12-card-grid-followup/#2-add-entitytitle-to-rating-controls-nice-to-have","title":"2. Add entityTitle to Rating Controls (Nice to Have)","text":"<p>Issue: Entity cards don't pass <code>entityTitle</code> to ratingControlsProps, so rating dialogs show generic \"Rate this [entity]\" instead of \"Rate Studio Name\".</p> <p>Files to update: - <code>client/src/components/cards/PerformerCard.jsx</code> - add <code>entityTitle: performer.name</code> - <code>client/src/components/cards/GalleryCard.jsx</code> - add <code>entityTitle: gallery.title</code> - <code>client/src/components/cards/GroupCard.jsx</code> - add <code>entityTitle: group.name</code> - <code>client/src/components/cards/StudioCard.jsx</code> - add <code>entityTitle: studio.name</code> - <code>client/src/components/cards/TagCard.jsx</code> - add <code>entityTitle: tag.name</code> - <code>client/src/components/cards/ImageCard.jsx</code> - add <code>entityTitle: image.title</code></p>"},{"location":"plans/2025-01-12-card-grid-followup/#3-add-defensive-rating-fallback-nice-to-have","title":"3. Add Defensive Rating Fallback (Nice to Have)","text":"<p>Issue: GalleryCard uses only <code>gallery.rating100</code> but old implementation had fallback to <code>gallery.rating</code>.</p> <p>File: <code>client/src/components/cards/GalleryCard.jsx</code></p> <p>Change: <pre><code>// From\ninitialRating: gallery.rating100,\n\n// To\ninitialRating: gallery.rating100 ?? gallery.rating,\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#4-document-filter-merge-behavior-nice-to-have","title":"4. Document Filter Merge Behavior (Nice to Have)","text":"<p>Issue: SearchableGrid uses shallow merge for filters which could cause issues if both <code>newQuery</code> and <code>lockedFilters</code> have nested filter objects.</p> <p>File: <code>client/src/components/ui/SearchableGrid.jsx</code></p> <p>Change: Add explanatory comment: <pre><code>// Merge locked filters into query\n// Note: Uses shallow merge. Assumes lockedFilters and newQuery\n// use different filter keys (e.g., gallery_filter vs filter)\nconst mergedQuery = {\n  ...newQuery,\n  ...lockedFilters,\n};\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-followup/#5-verify-conditional-rating-controls-design-question","title":"5. Verify Conditional Rating Controls (Design Question)","text":"<p>Issue: TagCard and ImageCard conditionally render rating controls based on <code>rating100 !== undefined</code>. This may cause height inconsistency if some cards show rating row and others don't.</p> <p>Question: Should all entities always show rating controls (even when undefined/0)?</p> <p>Files: - <code>client/src/components/cards/TagCard.jsx</code> - <code>client/src/components/cards/ImageCard.jsx</code></p> <p>Action: Verify with product requirements whether all entities should show rating controls consistently.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/","title":"Card &amp; Grid Component Refactor Design","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#overview","title":"Overview","text":"<p>Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#goals","title":"Goals","text":"<ul> <li>Reduce duplication/drift risk across all card types</li> <li>Improve developer velocity for adding new entity types</li> <li>Maintain visual consistency with type-specific variants</li> <li>Keep SceneCard's full feature set (selection, sprites, TV mode, progress)</li> <li>Nested grids = full search pages with locked parent filter</li> <li>Design for future list item compatibility (don't implement yet)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#architecture","title":"Architecture","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#three-layer-card-system","title":"Three-Layer Card System","text":"<pre><code>Primitives (ui/CardComponents.jsx)\n    \u2514\u2500\u2500 CardContainer, CardImage, CardTitle, CardDescription,\n        CardIndicators, CardRatingRow, CardOverlay, useLazyLoad\n\nBaseCard (ui/BaseCard.jsx)\n    \u2514\u2500\u2500 Composes primitives, provides render slots for customization\n\nEntity Cards (components/cards/)\n    \u2514\u2500\u2500 SceneCard, PerformerCard, GalleryCard, GroupCard,\n        StudioCard, TagCard, ImageCard\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#two-layer-grid-system","title":"Two-Layer Grid System","text":"<pre><code>BaseGrid (ui/BaseGrid.jsx)\n    \u2514\u2500\u2500 Layout, responsive columns, pagination, loading/empty states\n\nSearchableGrid (ui/SearchableGrid.jsx)\n    \u2514\u2500\u2500 BaseGrid + search controls + data fetching + locked filters\n\nEntity Grids (components/grids/)\n    \u2514\u2500\u2500 SceneGrid, PerformerGrid, GalleryGrid, GroupGrid,\n        StudioGrid, TagGrid, ImageGrid\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#component-specifications","title":"Component Specifications","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#primitives-uicardcomponentsjsx","title":"Primitives (ui/CardComponents.jsx)","text":"<p>Existing components to keep: - <code>CardContainer</code> - Wrapper (Link or div) - <code>CardImage</code> - Image with aspect ratio, unified lazy loading - <code>CardTitle</code> - Title + optional subtitle - <code>CardDescription</code> - Clamped description text - <code>CardIndicators</code> - Row of icon+count badges - <code>CardRatingRow</code> - Rating, O-counter, favorite, menu</p> <p>New component: - <code>CardOverlay</code> - Positioned overlay for progress bars, selection checkboxes</p> <p>Remove: - <code>LazyImage</code> - fold into CardImage - <code>CardDefaultImage</code> - fold into CardImage</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basecard-uibasecardjsx","title":"BaseCard (ui/BaseCard.jsx)","text":"<pre><code>interface BaseCardProps {\n  // Data\n  entityType: EntityType;\n  imagePath: string;\n  title: ReactNode;\n  subtitle?: ReactNode;\n  description?: ReactNode;\n  linkTo?: string;\n\n  // Indicators &amp; Rating\n  indicators?: IndicatorConfig[];\n  ratingControlsProps?: RatingControlsProps;\n\n  // Display options\n  hideDescription?: boolean;\n  hideSubtitle?: boolean;\n  maxTitleLines?: number;\n  maxDescriptionLines?: number;\n\n  // Customization slots\n  renderOverlay?: () =&gt; ReactNode;\n  renderImageContent?: () =&gt; ReactNode;\n  renderAfterTitle?: () =&gt; ReactNode;\n\n  // Events &amp; behavior\n  onClick?: (e) =&gt; void;\n  onLongPress?: () =&gt; void;\n  className?: string;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-cards-componentscards","title":"Entity Cards (components/cards/)","text":"Component Complexity Type-Specific Behavior SceneCard Complex Selection mode, sprite preview, progress bar, TV mode, long-press PerformerCard Thin Gender icon after title, performer indicators GalleryCard Thin Image count indicator GroupCard Thin Scene count, performer count StudioCard Thin Scene count, child studio indicators TagCard Thin Scene/performer/gallery counts ImageCard Thin Resolution indicator, gallery link"},{"location":"plans/2025-01-12-card-grid-refactor-design/#basegrid-uibasegridjsx","title":"BaseGrid (ui/BaseGrid.jsx)","text":"<pre><code>interface BaseGridProps {\n  items: any[];\n  renderItem: (item, index) =&gt; ReactNode;\n  gridType: 'scene' | 'standard';\n  loading?: boolean;\n  error?: Error;\n  emptyMessage?: string;\n  emptyDescription?: string;\n  currentPage?: number;\n  totalPages?: number;\n  onPageChange?: (page: number) =&gt; void;\n  skeletonCount?: number;\n  renderSkeleton?: () =&gt; ReactNode;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#searchablegrid-uisearchablegridjsx","title":"SearchableGrid (ui/SearchableGrid.jsx)","text":"<pre><code>interface SearchableGridProps {\n  entityType: EntityType;\n  lockedFilters?: FilterObject;\n  hideLockedFilters?: boolean;\n  gridType?: 'scene' | 'standard';\n  renderItem: (item) =&gt; ReactNode;\n  defaultSort?: SortConfig;\n  defaultFilters?: FilterObject;\n  onResultsChange?: (results) =&gt; void;\n}\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#entity-grids-componentsgrids","title":"Entity Grids (components/grids/)","text":"<p>SceneGrid includes selection mode and bulk actions. All others are thin wrappers around SearchableGrid.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#usage-examples","title":"Usage Examples","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#main-search-page","title":"Main search page","text":"<pre><code>&lt;SceneGrid /&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#nested-grid-on-detail-page","title":"Nested grid on detail page","text":"<pre><code>&lt;SceneGrid\n  lockedFilters={{ performer_id: performer.id }}\n  hideLockedFilters\n/&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#multiple-nested-grids","title":"Multiple nested grids","text":"<pre><code>// PerformerDetail.jsx\n&lt;Tabs&gt;\n  &lt;Tab label=\"Scenes\"&gt;\n    &lt;SceneGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Groups\"&gt;\n    &lt;GroupGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n  &lt;Tab label=\"Galleries\"&gt;\n    &lt;GalleryGrid lockedFilters={{ performer_id: id }} hideLockedFilters /&gt;\n  &lt;/Tab&gt;\n&lt;/Tabs&gt;\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#file-structure","title":"File Structure","text":"<pre><code>client/src/\n  components/\n    cards/\n      SceneCard.jsx\n      PerformerCard.jsx\n      GalleryCard.jsx\n      GroupCard.jsx\n      StudioCard.jsx\n      TagCard.jsx\n      ImageCard.jsx\n      index.js\n\n    grids/\n      SceneGrid.jsx\n      PerformerGrid.jsx\n      GalleryGrid.jsx\n      GroupGrid.jsx\n      StudioGrid.jsx\n      TagGrid.jsx\n      ImageGrid.jsx\n      index.js\n\n    ui/\n      CardComponents.jsx\n      BaseCard.jsx\n      BaseGrid.jsx\n      SearchableGrid.jsx\n      useEntityImageAspectRatio.js\n\n  constants/\n    grids.js\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#migration-plan","title":"Migration Plan","text":""},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-delete","title":"Files to DELETE","text":"<ul> <li><code>ui/GridCard.jsx</code> - Replaced by BaseCard</li> <li><code>ui/EntityGrid.jsx</code> - Replaced by components/grids/*</li> <li><code>scene-search/SceneGrid.jsx</code> - Moved to components/grids/</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-move","title":"Files to MOVE","text":"<ul> <li><code>ui/SceneCard.jsx</code> \u2192 <code>components/cards/SceneCard.jsx</code></li> <li><code>ui/PerformerCard.jsx</code> \u2192 <code>components/cards/PerformerCard.jsx</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-create","title":"Files to CREATE","text":"<ul> <li><code>ui/BaseCard.jsx</code></li> <li><code>ui/BaseGrid.jsx</code></li> <li><code>ui/SearchableGrid.jsx</code></li> <li><code>components/cards/GalleryCard.jsx</code></li> <li><code>components/cards/GroupCard.jsx</code></li> <li><code>components/cards/StudioCard.jsx</code></li> <li><code>components/cards/TagCard.jsx</code></li> <li><code>components/cards/ImageCard.jsx</code></li> <li><code>components/cards/index.js</code></li> <li><code>components/grids/SceneGrid.jsx</code></li> <li><code>components/grids/PerformerGrid.jsx</code></li> <li><code>components/grids/GalleryGrid.jsx</code></li> <li><code>components/grids/GroupGrid.jsx</code></li> <li><code>components/grids/StudioGrid.jsx</code></li> <li><code>components/grids/TagGrid.jsx</code></li> <li><code>components/grids/ImageGrid.jsx</code></li> <li><code>components/grids/index.js</code></li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#files-to-refactor","title":"Files to REFACTOR","text":"<ul> <li><code>ui/CardComponents.jsx</code> - Remove LazyImage/CardDefaultImage, add CardOverlay</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-design/#pages-to-update","title":"Pages to UPDATE","text":"<ul> <li>Scenes, Performers, Galleries, Groups, Studios, Tags, Images (search pages)</li> <li>PerformerDetail, StudioDetail, TagDetail, GroupDetail, GalleryDetail (detail pages)</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/","title":"Card &amp; Grid Component Refactor Implementation Plan","text":"<p>Status: COMPLETED - All 25 tasks implemented successfully on 2025-01-12.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#implementation-summary","title":"Implementation Summary","text":"<p>The card and grid refactor has been fully implemented with the following results:</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#new-architecture","title":"New Architecture","text":"<ul> <li>Card Layer 1 (Primitives): <code>CardComponents.jsx</code> - CardImage, CardTitle, CardOverlay, etc.</li> <li>Card Layer 2: <code>BaseCard.jsx</code> - Composable card with render slots</li> <li>Card Layer 3: Entity cards in <code>components/cards/</code> - PerformerCard, GalleryCard, GroupCard, StudioCard, TagCard, ImageCard</li> <li>Grid Layer 1: <code>BaseGrid.jsx</code> - Layout, pagination, loading/empty states</li> <li>Grid Layer 2: <code>SearchableGrid.jsx</code> - Integrated search controls and data fetching</li> <li>Grid Layer 3: Entity grids in <code>components/grids/</code> - PerformerGrid, GalleryGrid, GroupGrid, StudioGrid, TagGrid, ImageGrid</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#files-deleted","title":"Files Deleted","text":"<ul> <li><code>GridCard.jsx</code> - Replaced by BaseCard + entity cards</li> <li><code>EntityGrid.jsx</code> - Replaced by SearchableGrid + entity grids</li> </ul>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#additional-migrations","title":"Additional Migrations","text":"<p>During implementation, 4 main search pages (Galleries, Groups, Studios, Tags) were discovered to still use the deprecated GridCard. These were migrated to use the new shared entity cards.</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#test-results","title":"Test Results","text":"<ul> <li>All 346 tests pass</li> <li>No lint errors (only pre-existing warnings in unrelated files)</li> </ul> <p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Refactor the card and grid system to reduce duplication, improve consistency, and enable full-featured nested grids with locked filters.</p> <p>Architecture: Three-layer card system (Primitives \u2192 BaseCard \u2192 Entity Cards) + Two-layer grid system (BaseGrid \u2192 SearchableGrid \u2192 Entity Grids). This eliminates the current duplication between SceneCard, PerformerCard, GridCard, and EntityGrid while preserving SceneCard's full feature set.</p> <p>Tech Stack: React 18, React Router 6, Tailwind CSS, CSS variables for theming, Lucide React icons</p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-1-card-primitives-cleanup","title":"Phase 1: Card Primitives Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-1-add-cardoverlay-to-cardcomponentsjsx","title":"Task 1: Add CardOverlay to CardComponents.jsx","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:155-171</code> (after CardDefaultImage) - Modify: <code>client/src/components/ui/index.js:9-19</code> (add export)</p> <p>Step 1: Write the failing test</p> <p>Create test file first:</p> <pre><code>// client/src/components/ui/__tests__/CardComponents.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { CardOverlay } from \"../CardComponents\";\n\ndescribe(\"CardOverlay\", () =&gt; {\n  it(\"renders children in positioned overlay\", () =&gt; {\n    render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Test Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(screen.getByText(\"Test Content\")).toBeInTheDocument();\n  });\n\n  it(\"applies correct position classes for bottom-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for top-left\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"top-left\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"top-0\", \"left-0\");\n  });\n\n  it(\"applies correct position classes for bottom-right\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"bottom-right\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"bottom-0\", \"right-0\");\n  });\n\n  it(\"applies correct position classes for full\", () =&gt; {\n    const { container } = render(\n      &lt;CardOverlay position=\"full\"&gt;\n        &lt;span&gt;Content&lt;/span&gt;\n      &lt;/CardOverlay&gt;\n    );\n    expect(container.firstChild).toHaveClass(\"absolute\", \"inset-0\");\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL with \"Cannot find module '../CardComponents'\" or similar</p> <p>Step 3: Write CardOverlay implementation</p> <p>Add to <code>client/src/components/ui/CardComponents.jsx</code> after line 171 (after CardDefaultImage):</p> <pre><code>/**\n * CardOverlay - Positioned overlay container for progress bars, selection checkboxes, etc.\n * @param {Object} props\n * @param {'top-left'|'top-right'|'bottom-left'|'bottom-right'|'full'} props.position - Position of overlay\n * @param {React.ReactNode} props.children - Content to render in overlay\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const CardOverlay = ({ position = \"bottom-left\", children, className = \"\" }) =&gt; {\n  const positionClasses = {\n    \"top-left\": \"absolute top-0 left-0\",\n    \"top-right\": \"absolute top-0 right-0\",\n    \"bottom-left\": \"absolute bottom-0 left-0\",\n    \"bottom-right\": \"absolute bottom-0 right-0\",\n    \"full\": \"absolute inset-0\",\n  };\n\n  return (\n    &lt;div className={`${positionClasses[position]} ${className}`}&gt;\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Update barrel export</p> <p>In <code>client/src/components/ui/index.js</code>, update the CardComponents export:</p> <pre><code>export {\n  CardContainer,\n  CardDefaultImage,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardOverlay,  // Add this\n  CardRatingRow,\n  CardTitle,\n  LazyImage,\n  useLazyLoad,\n} from \"./CardComponents.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/index.js client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"feat(cards): add CardOverlay primitive for positioned overlays\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-2-fold-lazyimage-into-cardimage","title":"Task 2: Fold LazyImage into CardImage","text":"<p>Files: - Modify: <code>client/src/components/ui/CardComponents.jsx:76-148</code> (CardImage and LazyImage sections)</p> <p>Step 1: Write the failing test</p> <p>Add to <code>client/src/components/ui/__tests__/CardComponents.test.jsx</code>:</p> <pre><code>import { CardImage } from \"../CardComponents\";\n\ndescribe(\"CardImage\", () =&gt; {\n  it(\"renders image with lazy loading when src provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\" /&gt;\n    );\n    expect(screen.getByRole(\"img\")).toHaveAttribute(\"src\", \"/test.jpg\");\n  });\n\n  it(\"renders placeholder when no src provided\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage aspectRatio=\"16/9\" entityType=\"scene\" /&gt;\n    );\n    // Should render default icon, not an img tag\n    expect(container.querySelector(\"img\")).toBeNull();\n    expect(container.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"applies aspect ratio style\", () =&gt; {\n    const { container } = render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"2/3\" /&gt;\n    );\n    expect(container.firstChild).toHaveStyle({ aspectRatio: \"2/3\" });\n  });\n\n  it(\"renders children overlay when provided\", () =&gt; {\n    render(\n      &lt;CardImage src=\"/test.jpg\" alt=\"Test\" aspectRatio=\"16/9\"&gt;\n        &lt;span&gt;Overlay Content&lt;/span&gt;\n      &lt;/CardImage&gt;\n    );\n    expect(screen.getByText(\"Overlay Content\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: FAIL (CardImage doesn't accept src prop yet)</p> <p>Step 3: Refactor CardImage to include lazy loading</p> <p>Replace CardImage in <code>client/src/components/ui/CardComponents.jsx</code>:</p> <pre><code>/**\n * CardImage - Image container with aspect ratio and built-in lazy loading\n * @param {Object} props\n * @param {string} [props.src] - Image source URL\n * @param {string} [props.alt] - Alt text for image\n * @param {string} [props.aspectRatio] - CSS aspect ratio (e.g., \"16/9\", \"2/3\")\n * @param {string} [props.entityType] - Entity type for placeholder icon\n * @param {React.ReactNode} [props.children] - Overlay content\n * @param {string} [props.className] - Additional CSS classes\n * @param {Object} [props.style] - Additional inline styles\n * @param {Function} [props.onClick] - Click handler\n */\nexport const CardImage = ({\n  src,\n  alt = \"\",\n  aspectRatio = \"16/9\",\n  entityType,\n  children,\n  className = \"\",\n  style = {},\n  onClick,\n}) =&gt; {\n  const [ref, isVisible] = useLazyLoad();\n  const [hasError, setHasError] = useState(false);\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  const showPlaceholder = !src || hasError;\n\n  const getPlaceholderIcon = () =&gt; {\n    const icons = {\n      performer: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      scene: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm3 2h6v4H7V5zm8 8v2h1v-2h-1zm-2-2H7v4h6v-4zm2 0h1V9h-1v2zm1-4V5h-1v2h1zM5 5v2H4V5h1zm0 4H4v2h1V9zm-1 4h1v2H4v-2z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      gallery: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n      default: (\n        &lt;svg className=\"w-16 h-16\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n          &lt;path fillRule=\"evenodd\" d=\"M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z\" clipRule=\"evenodd\" /&gt;\n        &lt;/svg&gt;\n      ),\n    };\n    return icons[entityType] || icons.default;\n  };\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`relative overflow-hidden ${className}`}\n      style={{\n        aspectRatio,\n        backgroundColor: \"var(--bg-secondary)\",\n        ...style,\n      }}\n      onClick={onClick}\n    &gt;\n      {showPlaceholder ? (\n        &lt;div\n          className=\"absolute inset-0 flex items-center justify-center\"\n          style={{ color: \"var(--text-muted)\" }}\n        &gt;\n          {getPlaceholderIcon()}\n        &lt;/div&gt;\n      ) : (\n        &lt;&gt;\n          {/* Placeholder shown while loading */}\n          {!isLoaded &amp;&amp; (\n            &lt;div\n              className=\"absolute inset-0 animate-pulse\"\n              style={{ backgroundColor: \"var(--bg-tertiary)\" }}\n            /&gt;\n          )}\n          {/* Actual image - only render when visible for lazy loading */}\n          {isVisible &amp;&amp; (\n            &lt;img\n              src={src}\n              alt={alt}\n              className={`absolute inset-0 w-full h-full object-cover transition-opacity duration-200 ${\n                isLoaded ? \"opacity-100\" : \"opacity-0\"\n              }`}\n              onLoad={() =&gt; setIsLoaded(true)}\n              onError={() =&gt; setHasError(true)}\n            /&gt;\n          )}\n        &lt;/&gt;\n      )}\n      {/* Children rendered as overlay */}\n      {children}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"CardComponents.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/CardComponents.jsx client/src/components/ui/__tests__/CardComponents.test.jsx\ngit commit -m \"refactor(cards): fold LazyImage into CardImage with built-in lazy loading\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-2-basecard-implementation","title":"Phase 2: BaseCard Implementation","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-3-create-basecard-component","title":"Task 3: Create BaseCard Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseCard.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseCard.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (add export)</p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseCard } from \"../BaseCard\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseCard\", () =&gt; {\n  const defaultProps = {\n    entityType: \"scene\",\n    imagePath: \"/test.jpg\",\n    title: \"Test Title\",\n  };\n\n  it(\"renders title\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} /&gt;);\n    expect(screen.getByText(\"Test Title\")).toBeInTheDocument();\n  });\n\n  it(\"renders subtitle when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" /&gt;);\n    expect(screen.getByText(\"Test Subtitle\")).toBeInTheDocument();\n  });\n\n  it(\"hides subtitle when hideSubtitle is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} subtitle=\"Test Subtitle\" hideSubtitle /&gt;\n    );\n    expect(screen.queryByText(\"Test Subtitle\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders description when provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} description=\"Test Description\" /&gt;);\n    expect(screen.getByText(\"Test Description\")).toBeInTheDocument();\n  });\n\n  it(\"hides description when hideDescription is true\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard {...defaultProps} description=\"Test Description\" hideDescription /&gt;\n    );\n    expect(screen.queryByText(\"Test Description\")).not.toBeInTheDocument();\n  });\n\n  it(\"renders as link when linkTo provided\", () =&gt; {\n    renderWithRouter(&lt;BaseCard {...defaultProps} linkTo=\"/test\" /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/test\");\n  });\n\n  it(\"renders indicators when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        indicators={[{ type: \"SCENES\", count: 5 }]}\n      /&gt;\n    );\n    expect(screen.getByText(\"5\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderOverlay slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderOverlay={() =&gt; &lt;span&gt;Custom Overlay&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"Custom Overlay\")).toBeInTheDocument();\n  });\n\n  it(\"calls renderAfterTitle slot when provided\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseCard\n        {...defaultProps}\n        renderAfterTitle={() =&gt; &lt;span&gt;After Title&lt;/span&gt;}\n      /&gt;\n    );\n    expect(screen.getByText(\"After Title\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write BaseCard implementation</p> <pre><code>// client/src/components/ui/BaseCard.jsx\nimport { forwardRef } from \"react\";\nimport { useEntityImageAspectRatio } from \"../../hooks/useEntityImageAspectRatio.js\";\nimport {\n  CardContainer,\n  CardDescription,\n  CardImage,\n  CardIndicators,\n  CardRatingRow,\n  CardTitle,\n} from \"./CardComponents.jsx\";\n\n/**\n * BaseCard - Composable card component that assembles primitives\n * Provides render slots for entity-specific customization\n */\nexport const BaseCard = forwardRef(\n  (\n    {\n      // Data\n      entityType,\n      imagePath,\n      title,\n      subtitle,\n      description,\n      linkTo,\n\n      // Indicators &amp; Rating\n      indicators = [],\n      ratingControlsProps,\n\n      // Display options\n      hideDescription = false,\n      hideSubtitle = false,\n      maxTitleLines = 2,\n      maxDescriptionLines = 3,\n\n      // Customization slots\n      renderOverlay,\n      renderImageContent,\n      renderAfterTitle,\n\n      // Events &amp; behavior\n      onClick,\n      onLongPress,\n      className = \"\",\n      referrerUrl,\n      tabIndex,\n      style,\n      ...rest\n    },\n    ref\n  ) =&gt; {\n    const aspectRatio = useEntityImageAspectRatio(entityType);\n\n    return (\n      &lt;CardContainer\n        ref={ref}\n        entityType={entityType}\n        linkTo={linkTo}\n        onClick={onClick}\n        referrerUrl={referrerUrl}\n        className={className}\n        tabIndex={tabIndex}\n        style={style}\n        {...rest}\n      &gt;\n        {/* Image Section */}\n        &lt;CardImage\n          src={imagePath}\n          alt={typeof title === \"string\" ? title : \"\"}\n          aspectRatio={aspectRatio}\n          entityType={entityType}\n        &gt;\n          {/* Custom image content (e.g., sprite preview) */}\n          {renderImageContent?.()}\n          {/* Custom overlay (e.g., progress bar, selection checkbox) */}\n          {renderOverlay?.()}\n        &lt;/CardImage&gt;\n\n        {/* Title Section */}\n        &lt;CardTitle\n          title={title}\n          subtitle={hideSubtitle ? null : subtitle}\n          maxTitleLines={maxTitleLines}\n        /&gt;\n\n        {/* After Title Slot (e.g., gender icon) */}\n        {renderAfterTitle?.()}\n\n        {/* Description */}\n        {!hideDescription &amp;&amp; description &amp;&amp; (\n          &lt;CardDescription\n            description={description}\n            maxLines={maxDescriptionLines}\n          /&gt;\n        )}\n\n        {/* Indicators */}\n        {indicators.length &gt; 0 &amp;&amp; &lt;CardIndicators indicators={indicators} /&gt;}\n\n        {/* Rating Controls */}\n        {ratingControlsProps &amp;&amp; (\n          &lt;CardRatingRow entityType={entityType} {...ratingControlsProps} /&gt;\n        )}\n      &lt;/CardContainer&gt;\n    );\n  }\n);\n\nBaseCard.displayName = \"BaseCard\";\n\nexport default BaseCard;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseCard } from \"./BaseCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseCard.jsx client/src/components/ui/__tests__/BaseCard.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(cards): add BaseCard component with render slots\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-3-entity-cards-directory-structure","title":"Phase 3: Entity Cards Directory Structure","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-4-create-cards-directory-and-move-performercard","title":"Task 4: Create cards directory and move PerformerCard","text":"<p>Files: - Create: <code>client/src/components/cards/</code> - Move: <code>client/src/components/ui/PerformerCard.jsx</code> \u2192 <code>client/src/components/cards/PerformerCard.jsx</code> - Create: <code>client/src/components/cards/index.js</code> - Modify: <code>client/src/components/ui/index.js</code> (re-export from new location)</p> <p>Step 1: Create directory and index file</p> <pre><code>// client/src/components/cards/index.js\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 2: Move PerformerCard</p> <p>Move file from <code>client/src/components/ui/PerformerCard.jsx</code> to <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Update imports in the moved file:</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { GenderIcon, GridCard } from \"../ui/index.js\";\n// ... rest of imports unchanged\n</code></pre> <p>Step 3: Update ui/index.js to re-export</p> <p>Replace the PerformerCard export in <code>client/src/components/ui/index.js</code>:</p> <pre><code>// Replace:\n// export { default as PerformerCard } from \"./PerformerCard.jsx\";\n// With:\nexport { PerformerCard } from \"../cards/index.js\";\n</code></pre> <p>Step 4: Run existing app to verify no breaking changes</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS with no errors</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/cards/ client/src/components/ui/index.js\ngit rm client/src/components/ui/PerformerCard.jsx\ngit commit -m \"refactor(cards): move PerformerCard to components/cards/\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-5-migrate-performercard-to-use-basecard","title":"Task 5: Migrate PerformerCard to use BaseCard","text":"<p>Files: - Modify: <code>client/src/components/cards/PerformerCard.jsx</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/PerformerCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerCard\", () =&gt; {\n  const mockPerformer = {\n    id: \"1\",\n    name: \"Test Performer\",\n    gender: \"FEMALE\",\n    image_path: \"/test.jpg\",\n    scene_count: 10,\n    o_counter: 5,\n    rating100: 80,\n    favorite: true,\n  };\n\n  it(\"renders performer name\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n  });\n\n  it(\"renders gender icon\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    // GenderIcon should be present\n    expect(document.querySelector(\"svg\")).toBeInTheDocument();\n  });\n\n  it(\"links to performer detail page\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/performer/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;PerformerCard performer={mockPerformer} /&gt;);\n    expect(screen.getByText(\"10\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify current implementation passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS (existing implementation should pass)</p> <p>Step 3: Refactor to use BaseCard</p> <pre><code>// client/src/components/cards/PerformerCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { GenderIcon } from \"../ui/GenderIcon.jsx\";\n\n/**\n * PerformerCard - Card for displaying performer entities\n * Uses BaseCard with performer-specific configuration\n */\nconst PerformerCard = forwardRef(\n  ({ performer, referrerUrl, isTVMode, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const indicators = [\n      { type: \"PLAY_COUNT\", count: performer.play_count },\n      { type: \"SCENES\", count: performer.scene_count },\n      { type: \"GROUPS\", count: performer.group_count },\n      { type: \"IMAGES\", count: performer.image_count },\n      { type: \"GALLERIES\", count: performer.gallery_count },\n      { type: \"TAGS\", count: performer.tags?.length || 0 },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"performer\"\n        imagePath={performer.image_path}\n        title={performer.name}\n        linkTo={`/performer/${performer.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={indicators}\n        ratingControlsProps={{\n          entityId: performer.id,\n          initialRating: performer.rating100,\n          initialFavorite: performer.favorite || false,\n          initialOCounter: performer.o_counter,\n          onHideSuccess,\n        }}\n        renderAfterTitle={() =&gt; (\n          &lt;div className=\"flex items-center gap-1 mt-1\"&gt;\n            &lt;GenderIcon gender={performer.gender} size={16} /&gt;\n          &lt;/div&gt;\n        )}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nPerformerCard.displayName = \"PerformerCard\";\n\nexport default PerformerCard;\n</code></pre> <p>Step 4: Run test to verify it still passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 5: Run full build to verify no regressions</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/PerformerCard.jsx client/src/components/cards/__tests__/PerformerCard.test.jsx\ngit commit -m \"refactor(cards): migrate PerformerCard to use BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-6-create-gallerycard","title":"Task 6: Create GalleryCard","text":"<p>Files: - Create: <code>client/src/components/cards/GalleryCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GalleryCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryCard\", () =&gt; {\n  const mockGallery = {\n    id: \"1\",\n    title: \"Test Gallery\",\n    paths: { cover: \"/cover.jpg\" },\n    image_count: 25,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    performers: [{ id: \"1\", name: \"Performer 1\" }],\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 70,\n    favorite: false,\n  };\n\n  it(\"renders gallery title\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n  });\n\n  it(\"renders studio and date subtitle\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(/Test Studio/)).toBeInTheDocument();\n  });\n\n  it(\"links to gallery detail page\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/gallery/1\");\n  });\n\n  it(\"renders image count indicator\", () =&gt; {\n    renderWithRouter(&lt;GalleryCard gallery={mockGallery} /&gt;);\n    expect(screen.getByText(\"25\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: FAIL with module not found</p> <p>Step 3: Write GalleryCard implementation</p> <pre><code>// client/src/components/cards/GalleryCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\nimport { TooltipEntityGrid } from \"../ui/TooltipEntityGrid.jsx\";\nimport { galleryTitle } from \"../../utils/gallery.js\";\n\n/**\n * GalleryCard - Card for displaying gallery entities\n */\nconst GalleryCard = forwardRef(\n  ({ gallery, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const galleryDate = gallery.date\n      ? new Date(gallery.date).toLocaleDateString()\n      : null;\n    const subtitle = (() =&gt; {\n      if (gallery.studio &amp;&amp; galleryDate) {\n        return `${gallery.studio.name} \u2022 ${galleryDate}`;\n      } else if (gallery.studio) {\n        return gallery.studio.name;\n      } else if (galleryDate) {\n        return galleryDate;\n      }\n      return null;\n    })();\n\n    // Build rich tooltip content for performers and tags\n    const performersTooltip =\n      gallery.performers &amp;&amp;\n      gallery.performers.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"performer\"\n          entities={gallery.performers}\n          title=\"Performers\"\n        /&gt;\n      );\n\n    const tagsTooltip =\n      gallery.tags &amp;&amp;\n      gallery.tags.length &gt; 0 &amp;&amp; (\n        &lt;TooltipEntityGrid\n          entityType=\"tag\"\n          entities={gallery.tags}\n          title=\"Tags\"\n        /&gt;\n      );\n\n    const indicators = [\n      {\n        type: \"IMAGES\",\n        count: gallery.image_count,\n        tooltipContent:\n          gallery.image_count === 1 ? \"1 Image\" : `${gallery.image_count} Images`,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: gallery.performers?.length || 0,\n        tooltipContent: performersTooltip,\n        onClick:\n          gallery.performers?.length &gt; 0\n            ? () =&gt; navigate(`/performers?galleryId=${gallery.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: gallery.tags?.length || 0,\n        tooltipContent: tagsTooltip,\n        onClick:\n          gallery.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?galleryId=${gallery.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"gallery\"\n        imagePath={gallery.paths?.cover}\n        title={galleryTitle(gallery)}\n        subtitle={subtitle}\n        description={gallery.description}\n        linkTo={`/gallery/${gallery.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: gallery.id,\n          initialRating: gallery.rating100,\n          initialFavorite: gallery.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGalleryCard.displayName = \"GalleryCard\";\n\nexport default GalleryCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>// client/src/components/cards/index.js\nexport { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GalleryCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GalleryCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GalleryCard.test.jsx\ngit commit -m \"feat(cards): add GalleryCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-7-create-groupcard","title":"Task 7: Create GroupCard","text":"<p>Files: - Create: <code>client/src/components/cards/GroupCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/GroupCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GroupCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GroupCard\", () =&gt; {\n  const mockGroup = {\n    id: \"1\",\n    name: \"Test Collection\",\n    front_image_path: \"/front.jpg\",\n    scene_count: 15,\n    sub_group_count: 3,\n    performer_count: 5,\n    studio: { name: \"Test Studio\" },\n    date: \"2024-01-15\",\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    rating100: 85,\n    favorite: true,\n  };\n\n  it(\"renders group name\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"Test Collection\")).toBeInTheDocument();\n  });\n\n  it(\"links to collection detail page\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/collection/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;GroupCard group={mockGroup} /&gt;);\n    expect(screen.getByText(\"15\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write GroupCard implementation</p> <pre><code>// client/src/components/cards/GroupCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * GroupCard - Card for displaying group/collection entities\n */\nconst GroupCard = forwardRef(\n  ({ group, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    // Build subtitle from studio and date\n    const subtitle = (() =&gt; {\n      if (group.studio &amp;&amp; group.date) {\n        return `${group.studio.name} \u2022 ${group.date}`;\n      } else if (group.studio) {\n        return group.studio.name;\n      } else if (group.date) {\n        return group.date;\n      }\n      return null;\n    })();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: group.scene_count,\n        onClick:\n          group.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"GROUPS\",\n        count: group.sub_group_count,\n        onClick:\n          group.sub_group_count &gt; 0\n            ? () =&gt; navigate(`/collections?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: group.performer_count,\n        onClick:\n          group.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?groupIds=${group.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: group.tags?.length || 0,\n        onClick:\n          group.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?groupIds=${group.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"group\"\n        imagePath={group.front_image_path || group.back_image_path}\n        title={group.name}\n        subtitle={subtitle}\n        description={group.description}\n        linkTo={`/collection/${group.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: group.id,\n          initialRating: group.rating100,\n          initialFavorite: group.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nGroupCard.displayName = \"GroupCard\";\n\nexport default GroupCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"GroupCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/GroupCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/GroupCard.test.jsx\ngit commit -m \"feat(cards): add GroupCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-8-create-studiocard","title":"Task 8: Create StudioCard","text":"<p>Files: - Create: <code>client/src/components/cards/StudioCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/StudioCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { StudioCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"StudioCard\", () =&gt; {\n  const mockStudio = {\n    id: \"1\",\n    name: \"Test Studio\",\n    image_path: \"/studio.jpg\",\n    scene_count: 50,\n    tags: [{ id: \"1\", name: \"Tag 1\" }],\n    details: \"Studio description\",\n    rating100: 90,\n    favorite: false,\n  };\n\n  it(\"renders studio name\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"Test Studio\")).toBeInTheDocument();\n  });\n\n  it(\"links to studio detail page\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/studio/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;StudioCard studio={mockStudio} /&gt;);\n    expect(screen.getByText(\"50\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write StudioCard implementation</p> <pre><code>// client/src/components/cards/StudioCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * StudioCard - Card for displaying studio entities\n */\nconst StudioCard = forwardRef(\n  ({ studio, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: studio.scene_count,\n        onClick:\n          studio.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?studioId=${studio.id}`)\n            : undefined,\n      },\n      {\n        type: \"TAGS\",\n        count: studio.tags?.length || 0,\n        onClick:\n          studio.tags?.length &gt; 0\n            ? () =&gt; navigate(`/tags?studioId=${studio.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"studio\"\n        imagePath={studio.image_path}\n        title={studio.name}\n        description={studio.details}\n        linkTo={`/studio/${studio.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={{\n          entityId: studio.id,\n          initialRating: studio.rating100,\n          initialFavorite: studio.favorite || false,\n          onHideSuccess,\n        }}\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nStudioCard.displayName = \"StudioCard\";\n\nexport default StudioCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"StudioCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/StudioCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/StudioCard.test.jsx\ngit commit -m \"feat(cards): add StudioCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-9-create-tagcard","title":"Task 9: Create TagCard","text":"<p>Files: - Create: <code>client/src/components/cards/TagCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/TagCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { TagCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"TagCard\", () =&gt; {\n  const mockTag = {\n    id: \"1\",\n    name: \"Test Tag\",\n    image_path: \"/tag.jpg\",\n    scene_count: 30,\n    studio_count: 5,\n    performer_count: 10,\n    gallery_count: 8,\n    description: \"Tag description\",\n  };\n\n  it(\"renders tag name\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"Test Tag\")).toBeInTheDocument();\n  });\n\n  it(\"links to tag detail page\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/tags/1\");\n  });\n\n  it(\"renders scene count indicator\", () =&gt; {\n    renderWithRouter(&lt;TagCard tag={mockTag} /&gt;);\n    expect(screen.getByText(\"30\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write TagCard implementation</p> <pre><code>// client/src/components/cards/TagCard.jsx\nimport { forwardRef } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * TagCard - Card for displaying tag entities\n */\nconst TagCard = forwardRef(\n  ({ tag, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    const navigate = useNavigate();\n\n    const indicators = [\n      {\n        type: \"SCENES\",\n        count: tag.scene_count,\n        onClick:\n          tag.scene_count &gt; 0\n            ? () =&gt; navigate(`/scenes?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"STUDIOS\",\n        count: tag.studio_count,\n        onClick:\n          tag.studio_count &gt; 0\n            ? () =&gt; navigate(`/studios?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"PERFORMERS\",\n        count: tag.performer_count,\n        onClick:\n          tag.performer_count &gt; 0\n            ? () =&gt; navigate(`/performers?tagIds=${tag.id}`)\n            : undefined,\n      },\n      {\n        type: \"GALLERIES\",\n        count: tag.gallery_count,\n        onClick:\n          tag.gallery_count &gt; 0\n            ? () =&gt; navigate(`/galleries?tagIds=${tag.id}`)\n            : undefined,\n      },\n    ];\n\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"tag\"\n        imagePath={tag.image_path}\n        title={tag.name}\n        description={tag.description}\n        linkTo={`/tags/${tag.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        indicators={indicators}\n        maxTitleLines={2}\n        ratingControlsProps={\n          tag.rating100 !== undefined\n            ? {\n                entityId: tag.id,\n                initialRating: tag.rating100,\n                initialFavorite: tag.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nTagCard.displayName = \"TagCard\";\n\nexport default TagCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"TagCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/TagCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/TagCard.test.jsx\ngit commit -m \"feat(cards): add TagCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-10-create-imagecard","title":"Task 10: Create ImageCard","text":"<p>Files: - Create: <code>client/src/components/cards/ImageCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/cards/__tests__/ImageCard.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { ImageCard } from \"../index\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"ImageCard\", () =&gt; {\n  const mockImage = {\n    id: \"1\",\n    title: \"Test Image\",\n    paths: { thumbnail: \"/thumb.jpg\", image: \"/full.jpg\" },\n  };\n\n  it(\"renders image title\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByText(\"Test Image\")).toBeInTheDocument();\n  });\n\n  it(\"links to image detail page\", () =&gt; {\n    renderWithRouter(&lt;ImageCard image={mockImage} /&gt;);\n    expect(screen.getByRole(\"link\")).toHaveAttribute(\"href\", \"/image/1\");\n  });\n\n  it(\"uses fallback title when no title provided\", () =&gt; {\n    const imageNoTitle = { ...mockImage, title: null };\n    renderWithRouter(&lt;ImageCard image={imageNoTitle} /&gt;);\n    expect(screen.getByText(\"Image 1\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write ImageCard implementation</p> <pre><code>// client/src/components/cards/ImageCard.jsx\nimport { forwardRef } from \"react\";\nimport { BaseCard } from \"../ui/BaseCard.jsx\";\n\n/**\n * ImageCard - Card for displaying image entities\n */\nconst ImageCard = forwardRef(\n  ({ image, referrerUrl, tabIndex, onHideSuccess, ...rest }, ref) =&gt; {\n    return (\n      &lt;BaseCard\n        ref={ref}\n        entityType=\"image\"\n        imagePath={image.paths?.thumbnail || image.paths?.image}\n        title={image.title || `Image ${image.id}`}\n        linkTo={`/image/${image.id}`}\n        referrerUrl={referrerUrl}\n        tabIndex={tabIndex}\n        hideDescription\n        hideSubtitle\n        indicators={[]}\n        ratingControlsProps={\n          image.rating100 !== undefined\n            ? {\n                entityId: image.id,\n                initialRating: image.rating100,\n                initialFavorite: image.favorite || false,\n                onHideSuccess,\n              }\n            : undefined\n        }\n        {...rest}\n      /&gt;\n    );\n  }\n);\n\nImageCard.displayName = \"ImageCard\";\n\nexport default ImageCard;\n</code></pre> <p>Step 4: Update cards/index.js</p> <pre><code>export { default as GalleryCard } from \"./GalleryCard.jsx\";\nexport { default as GroupCard } from \"./GroupCard.jsx\";\nexport { default as ImageCard } from \"./ImageCard.jsx\";\nexport { default as PerformerCard } from \"./PerformerCard.jsx\";\nexport { default as StudioCard } from \"./StudioCard.jsx\";\nexport { default as TagCard } from \"./TagCard.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"ImageCard.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/cards/ImageCard.jsx client/src/components/cards/index.js client/src/components/cards/__tests__/ImageCard.test.jsx\ngit commit -m \"feat(cards): add ImageCard using BaseCard\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-4-grid-components","title":"Phase 4: Grid Components","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-11-create-basegrid-component","title":"Task 11: Create BaseGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/BaseGrid.jsx</code> - Create: <code>client/src/components/ui/__tests__/BaseGrid.test.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/BaseGrid.test.jsx\nimport { render, screen } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { BaseGrid } from \"../BaseGrid\";\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"BaseGrid\", () =&gt; {\n  const mockItems = [\n    { id: \"1\", name: \"Item 1\" },\n    { id: \"2\", name: \"Item 2\" },\n    { id: \"3\", name: \"Item 3\" },\n  ];\n\n  it(\"renders items using renderItem function\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n      /&gt;\n    );\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 3\")).toBeInTheDocument();\n  });\n\n  it(\"shows loading skeleton when loading=true\", () =&gt; {\n    const { container } = renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        loading={true}\n        skeletonCount={3}\n      /&gt;\n    );\n    expect(container.querySelectorAll(\".animate-pulse\")).toHaveLength(3);\n  });\n\n  it(\"shows empty message when items is empty\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={[]}\n        renderItem={() =&gt; null}\n        gridType=\"standard\"\n        emptyMessage=\"No items found\"\n      /&gt;\n    );\n    expect(screen.getByText(\"No items found\")).toBeInTheDocument();\n  });\n\n  it(\"renders pagination when totalPages &gt; 1\", () =&gt; {\n    renderWithRouter(\n      &lt;BaseGrid\n        items={mockItems}\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n        gridType=\"standard\"\n        currentPage={1}\n        totalPages={5}\n        onPageChange={() =&gt; {}}\n      /&gt;\n    );\n    // Should have pagination controls\n    expect(screen.getByRole(\"navigation\")).toBeInTheDocument();\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write BaseGrid implementation</p> <pre><code>// client/src/components/ui/BaseGrid.jsx\nimport { SCENE_GRID_CONTAINER_CLASSNAMES, STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport EmptyState from \"./EmptyState.jsx\";\nimport Pagination from \"./Pagination.jsx\";\n\n/**\n * BaseGrid - Base grid component for layout, responsive columns, pagination, and loading/empty states\n *\n * @param {Object} props\n * @param {any[]} props.items - Array of items to render\n * @param {Function} props.renderItem - Function to render each item (item, index) =&gt; ReactNode\n * @param {'scene'|'standard'} props.gridType - Grid type for responsive columns\n * @param {boolean} [props.loading] - Show loading skeleton\n * @param {Error} [props.error] - Error to display\n * @param {string} [props.emptyMessage] - Message when no items\n * @param {string} [props.emptyDescription] - Description for empty state\n * @param {number} [props.currentPage] - Current page number\n * @param {number} [props.totalPages] - Total number of pages\n * @param {Function} [props.onPageChange] - Page change handler (page: number) =&gt; void\n * @param {number} [props.skeletonCount] - Number of skeleton cards to show while loading\n * @param {Function} [props.renderSkeleton] - Custom skeleton renderer\n * @param {string} [props.className] - Additional CSS classes\n */\nexport const BaseGrid = ({\n  items,\n  renderItem,\n  gridType = \"standard\",\n  loading = false,\n  error,\n  emptyMessage = \"No items found\",\n  emptyDescription,\n  currentPage,\n  totalPages,\n  onPageChange,\n  skeletonCount = 12,\n  renderSkeleton,\n  className = \"\",\n}) =&gt; {\n  const gridClasses =\n    gridType === \"scene\"\n      ? SCENE_GRID_CONTAINER_CLASSNAMES\n      : STANDARD_GRID_CONTAINER_CLASSNAMES;\n\n  // Default skeleton renderer\n  const defaultRenderSkeleton = () =&gt; (\n    &lt;div\n      className=\"rounded-lg animate-pulse\"\n      style={{\n        backgroundColor: \"var(--bg-tertiary)\",\n        height: gridType === \"scene\" ? \"20rem\" : \"24rem\",\n      }}\n    /&gt;\n  );\n\n  const skeletonRenderer = renderSkeleton || defaultRenderSkeleton;\n\n  // Loading state\n  if (loading) {\n    return (\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {[...Array(skeletonCount)].map((_, i) =&gt; (\n          &lt;div key={i}&gt;{skeletonRenderer()}&lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n\n  // Error state\n  if (error) {\n    return (\n      &lt;EmptyState\n        title=\"Error loading items\"\n        description={error.message || \"An error occurred\"}\n      /&gt;\n    );\n  }\n\n  // Empty state\n  if (!items || items.length === 0) {\n    return &lt;EmptyState title={emptyMessage} description={emptyDescription} /&gt;;\n  }\n\n  return (\n    &lt;&gt;\n      &lt;div className={`${gridClasses} ${className}`}&gt;\n        {items.map((item, index) =&gt; renderItem(item, index))}\n      &lt;/div&gt;\n\n      {/* Pagination */}\n      {totalPages &gt; 1 &amp;&amp; onPageChange &amp;&amp; (\n        &lt;nav role=\"navigation\" aria-label=\"Pagination\" className=\"mt-6\"&gt;\n          &lt;Pagination\n            currentPage={currentPage}\n            totalPages={totalPages}\n            onPageChange={onPageChange}\n          /&gt;\n        &lt;/nav&gt;\n      )}\n    &lt;/&gt;\n  );\n};\n\nexport default BaseGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { BaseGrid } from \"./BaseGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"BaseGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/BaseGrid.jsx client/src/components/ui/__tests__/BaseGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add BaseGrid component for grid layout and pagination\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-12-create-searchablegrid-component","title":"Task 12: Create SearchableGrid Component","text":"<p>Files: - Create: <code>client/src/components/ui/SearchableGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/ui/__tests__/SearchableGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { SearchableGrid } from \"../SearchableGrid\";\n\n// Mock the libraryApi\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"SearchableGrid\", () =&gt; {\n  it(\"renders search controls\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    // Wait for initial load\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"applies locked filters without showing them in UI\", async () =&gt; {\n    renderWithRouter(\n      &lt;SearchableGrid\n        entityType=\"performer\"\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n        renderItem={(item) =&gt; &lt;div key={item.id}&gt;{item.name}&lt;/div&gt;}\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write SearchableGrid implementation</p> <pre><code>// client/src/components/ui/SearchableGrid.jsx\nimport { useCallback, useRef, useState } from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\nimport deepEqual from \"fast-deep-equal\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport BaseGrid from \"./BaseGrid.jsx\";\nimport SearchControls from \"./SearchControls.jsx\";\n\n/**\n * SearchableGrid - BaseGrid with integrated search controls and data fetching\n *\n * @param {Object} props\n * @param {'scene'|'performer'|'gallery'|'group'|'studio'|'tag'|'image'} props.entityType\n * @param {Object} [props.lockedFilters] - Filters that cannot be changed by user\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {'scene'|'standard'} [props.gridType] - Grid layout type\n * @param {Function} props.renderItem - Function to render each item\n * @param {Object} [props.defaultSort] - Default sort configuration\n * @param {Object} [props.defaultFilters] - Default filters\n * @param {Function} [props.onResultsChange] - Callback when results change\n * @param {string} [props.emptyMessage] - Empty state message\n * @param {string} [props.emptyDescription] - Empty state description\n * @param {number} [props.skeletonCount] - Number of skeleton items during loading\n * @param {boolean} [props.syncToUrl] - Whether to sync state to URL (default: true)\n */\nexport const SearchableGrid = ({\n  entityType,\n  lockedFilters = {},\n  hideLockedFilters = false,\n  gridType = \"standard\",\n  renderItem,\n  defaultSort = \"name\",\n  defaultFilters = {},\n  onResultsChange,\n  emptyMessage,\n  emptyDescription,\n  skeletonCount = 24,\n  syncToUrl = true,\n}) =&gt; {\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n  const [searchParams] = useSearchParams();\n\n  const [lastQuery, setLastQuery] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n\n  // API method mapping\n  const apiMethods = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Response key mapping\n  const responseKeys = {\n    scene: \"findScenes\",\n    performer: \"findPerformers\",\n    gallery: \"findGalleries\",\n    group: \"findGroups\",\n    studio: \"findStudios\",\n    tag: \"findTags\",\n    image: \"findImages\",\n  };\n\n  // Data array key mapping\n  const dataKeys = {\n    scene: \"scenes\",\n    performer: \"performers\",\n    gallery: \"galleries\",\n    group: \"groups\",\n    studio: \"studios\",\n    tag: \"tags\",\n    image: \"images\",\n  };\n\n  const handleQueryChange = useCallback(\n    async (newQuery) =&gt; {\n      if (isAuthLoading || !isAuthenticated) {\n        return;\n      }\n\n      // Merge locked filters into query\n      const mergedQuery = {\n        ...newQuery,\n        ...lockedFilters,\n      };\n\n      // Avoid duplicate queries\n      if (lastQuery &amp;&amp; deepEqual(mergedQuery, lastQuery)) {\n        return;\n      }\n\n      try {\n        setIsLoading(true);\n        setLastQuery(mergedQuery);\n        setError(null);\n\n        const apiMethod = apiMethods[entityType];\n        const responseKey = responseKeys[entityType];\n        const dataKey = dataKeys[entityType];\n\n        const result = await libraryApi[apiMethod](mergedQuery);\n        const items = result[responseKey]?.[dataKey] || [];\n        const count = result[responseKey]?.count || 0;\n\n        setData(items);\n        setTotalCount(count);\n        onResultsChange?.({ items, count });\n      } catch (err) {\n        setError(err);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [entityType, lockedFilters, lastQuery, isAuthLoading, isAuthenticated, onResultsChange]\n  );\n\n  // Handle successful hide - remove item from local state\n  const handleHideSuccess = useCallback((entityId) =&gt; {\n    setData((prevData) =&gt; prevData.filter((item) =&gt; item.id !== entityId));\n    setTotalCount((prevCount) =&gt; Math.max(0, prevCount - 1));\n  }, []);\n\n  // Calculate pagination\n  const currentPerPage = lastQuery?.filter?.per_page || 24;\n  const totalPages = Math.ceil(totalCount / currentPerPage);\n\n  // Build filter key for locked filters if we need to hide them\n  const permanentFiltersMetadata = hideLockedFilters ? {} : lockedFilters;\n\n  return (\n    &lt;SearchControls\n      artifactType={entityType}\n      initialSort={defaultSort}\n      onQueryChange={handleQueryChange}\n      permanentFilters={lockedFilters}\n      permanentFiltersMetadata={permanentFiltersMetadata}\n      totalPages={totalPages}\n      totalCount={totalCount}\n      syncToUrl={syncToUrl}\n    &gt;\n      &lt;BaseGrid\n        items={data}\n        renderItem={(item, index) =&gt;\n          renderItem(item, index, { onHideSuccess: handleHideSuccess })\n        }\n        gridType={gridType}\n        loading={isLoading}\n        error={error}\n        emptyMessage={emptyMessage || `No ${entityType}s found`}\n        emptyDescription={emptyDescription}\n        skeletonCount={skeletonCount}\n      /&gt;\n    &lt;/SearchControls&gt;\n  );\n};\n\nexport default SearchableGrid;\n</code></pre> <p>Step 4: Add export to index.js</p> <p>Add to <code>client/src/components/ui/index.js</code>:</p> <pre><code>export { SearchableGrid } from \"./SearchableGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"SearchableGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/ui/SearchableGrid.jsx client/src/components/ui/__tests__/SearchableGrid.test.jsx client/src/components/ui/index.js\ngit commit -m \"feat(grids): add SearchableGrid with integrated search controls and data fetching\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-13-create-grids-directory-structure","title":"Task 13: Create grids directory structure","text":"<p>Files: - Create: <code>client/src/components/grids/</code> - Create: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Create directory and index</p> <pre><code>// client/src/components/grids/index.js\n// Entity grid components will be exported here\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/grids/\ngit commit -m \"chore: create grids directory structure\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-14-create-performergrid","title":"Task 14: Create PerformerGrid","text":"<p>Files: - Create: <code>client/src/components/grids/PerformerGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/PerformerGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { PerformerGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findPerformers: jest.fn().mockResolvedValue({\n      findPerformers: {\n        performers: [\n          { id: \"1\", name: \"Test Performer\", image_path: \"/test.jpg\" },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"PerformerGrid\", () =&gt; {\n  it(\"renders performers from API\", async () =&gt; {\n    renderWithRouter(&lt;PerformerGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n\n  it(\"supports locked filters for nested grids\", async () =&gt; {\n    renderWithRouter(\n      &lt;PerformerGrid\n        lockedFilters={{ studio_id: \"123\" }}\n        hideLockedFilters\n      /&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Performer\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: FAIL</p> <p>Step 3: Write PerformerGrid implementation</p> <pre><code>// client/src/components/grids/PerformerGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { PerformerCard } from \"../cards/index.js\";\n\n/**\n * PerformerGrid - Grid for displaying performers with search and filtering\n *\n * @param {Object} [props.lockedFilters] - Filters locked for nested grid use\n * @param {boolean} [props.hideLockedFilters] - Hide locked filters from UI\n * @param {string} [props.emptyMessage] - Custom empty state message\n */\nconst PerformerGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No performers found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"performer\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"o_counter\"\n      renderItem={(performer, _index, { onHideSuccess }) =&gt; (\n        &lt;PerformerCard\n          key={performer.id}\n          performer={performer}\n          onHideSuccess={() =&gt; onHideSuccess(performer.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default PerformerGrid;\n</code></pre> <p>Step 4: Update grids/index.js</p> <pre><code>export { default as PerformerGrid } from \"./PerformerGrid.jsx\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm test -- --testPathPattern=\"PerformerGrid.test\" --watchAll=false</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add client/src/components/grids/PerformerGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/PerformerGrid.test.jsx\ngit commit -m \"feat(grids): add PerformerGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-15-create-gallerygrid","title":"Task 15: Create GalleryGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GalleryGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Step 1: Write the failing test</p> <pre><code>// client/src/components/grids/__tests__/GalleryGrid.test.jsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { GalleryGrid } from \"../index\";\n\njest.mock(\"../../../services/api\", () =&gt; ({\n  libraryApi: {\n    findGalleries: jest.fn().mockResolvedValue({\n      findGalleries: {\n        galleries: [\n          { id: \"1\", title: \"Test Gallery\", paths: { cover: \"/test.jpg\" } },\n        ],\n        count: 1,\n      },\n    }),\n  },\n}));\n\nconst renderWithRouter = (ui) =&gt; render(&lt;BrowserRouter&gt;{ui}&lt;/BrowserRouter&gt;);\n\ndescribe(\"GalleryGrid\", () =&gt; {\n  it(\"renders galleries from API\", async () =&gt; {\n    renderWithRouter(&lt;GalleryGrid /&gt;);\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText(\"Test Gallery\")).toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test, write implementation, verify</p> <pre><code>// client/src/components/grids/GalleryGrid.jsx\nimport { SearchableGrid } from \"../ui/SearchableGrid.jsx\";\nimport { GalleryCard } from \"../cards/index.js\";\n\nconst GalleryGrid = ({\n  lockedFilters,\n  hideLockedFilters,\n  emptyMessage = \"No galleries found\",\n  ...rest\n}) =&gt; {\n  return (\n    &lt;SearchableGrid\n      entityType=\"gallery\"\n      gridType=\"standard\"\n      lockedFilters={lockedFilters}\n      hideLockedFilters={hideLockedFilters}\n      emptyMessage={emptyMessage}\n      defaultSort=\"date\"\n      renderItem={(gallery, _index, { onHideSuccess }) =&gt; (\n        &lt;GalleryCard\n          key={gallery.id}\n          gallery={gallery}\n          onHideSuccess={() =&gt; onHideSuccess(gallery.id)}\n        /&gt;\n      )}\n      {...rest}\n    /&gt;\n  );\n};\n\nexport default GalleryGrid;\n</code></pre> <p>Step 3: Update index, run test, commit</p> <pre><code>git add client/src/components/grids/GalleryGrid.jsx client/src/components/grids/index.js client/src/components/grids/__tests__/GalleryGrid.test.jsx\ngit commit -m \"feat(grids): add GalleryGrid component\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-16-create-groupgrid","title":"Task 16: Create GroupGrid","text":"<p>Files: - Create: <code>client/src/components/grids/GroupGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern to GalleryGrid - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add GroupGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-17-create-studiogrid","title":"Task 17: Create StudioGrid","text":"<p>Files: - Create: <code>client/src/components/grids/StudioGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add StudioGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-18-create-taggrid","title":"Task 18: Create TagGrid","text":"<p>Files: - Create: <code>client/src/components/grids/TagGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add TagGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-19-create-imagegrid","title":"Task 19: Create ImageGrid","text":"<p>Files: - Create: <code>client/src/components/grids/ImageGrid.jsx</code> - Modify: <code>client/src/components/grids/index.js</code></p> <p>Similar pattern - implement and test.</p> <p>Commit: <pre><code>git commit -m \"feat(grids): add ImageGrid component\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#phase-5-migration-cleanup","title":"Phase 5: Migration &amp; Cleanup","text":""},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-20-update-performerdetail-to-use-new-grid-components","title":"Task 20: Update PerformerDetail to use new grid components","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code></p> <p>Step 1: Verify existing behavior works</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to a performer detail page and verify tabs work.</p> <p>Step 2: Update imports</p> <pre><code>// In PerformerDetail.jsx, replace:\nimport { EntityGrid } from \"../ui/index.js\";\n\n// With:\nimport { GalleryGrid, GroupGrid } from \"../grids/index.js\";\n</code></pre> <p>Step 3: Replace EntityGrid usage</p> <p>Replace galleries tab content: <pre><code>{activeTab === 'galleries' &amp;&amp; (\n  &lt;GalleryGrid\n    lockedFilters={{\n      gallery_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No galleries found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Replace groups tab content: <pre><code>{activeTab === 'groups' &amp;&amp; (\n  &lt;GroupGrid\n    lockedFilters={{\n      group_filter: {\n        performers: {\n          value: [parseInt(performerId, 10)],\n          modifier: \"INCLUDES\",\n        },\n      },\n    }}\n    hideLockedFilters\n    emptyMessage={`No collections found for ${performer.name}`}\n  /&gt;\n)}\n</code></pre></p> <p>Step 4: Verify changes work</p> <p>Run: <code>cd client &amp;&amp; npm run build &amp;&amp; npm run preview</code> Navigate to performer detail page, verify all tabs still work.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx\ngit commit -m \"refactor(pages): update PerformerDetail to use new grid components\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-21-update-remaining-detail-pages","title":"Task 21: Update remaining detail pages","text":"<p>Files: - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code> - Modify: <code>client/src/components/pages/GroupDetail.jsx</code> - Modify: <code>client/src/components/pages/GalleryDetail.jsx</code></p> <p>Follow same pattern as Task 20 for each page.</p> <p>Commit after each page: <pre><code>git commit -m \"refactor(pages): update StudioDetail to use new grid components\"\ngit commit -m \"refactor(pages): update TagDetail to use new grid components\"\n# etc.\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-22-delete-deprecated-gridcardjsx","title":"Task 22: Delete deprecated GridCard.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/GridCard.jsx</code> - Modify: <code>client/src/components/ui/index.js</code> (remove export)</p> <p>Step 1: Search for GridCard usages</p> <p>Run: <code>grep -r \"GridCard\" client/src --include=\"*.jsx\" --include=\"*.js\"</code></p> <p>Step 2: Ensure no remaining usages</p> <p>All usages should have been replaced by BaseCard-based components.</p> <p>Step 3: Delete and update exports</p> <pre><code>git rm client/src/components/ui/GridCard.jsx\n</code></pre> <p>Update index.js to remove: <pre><code>// Remove this line:\nexport { GridCard } from \"./GridCard.jsx\";\n</code></pre></p> <p>Step 4: Verify build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: SUCCESS</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/ui/index.js\ngit commit -m \"refactor(cards): delete deprecated GridCard.jsx\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-23-delete-deprecated-entitygridjsx","title":"Task 23: Delete deprecated EntityGrid.jsx","text":"<p>Files: - Delete: <code>client/src/components/ui/EntityGrid.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Follow same pattern as Task 22.</p> <p>Commit: <pre><code>git commit -m \"refactor(grids): delete deprecated EntityGrid.jsx\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-24-run-full-test-suite-and-fix-any-issues","title":"Task 24: Run full test suite and fix any issues","text":"<p>Step 1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --watchAll=false</code></p> <p>Step 2: Fix any failing tests</p> <p>Update snapshots if needed, fix any regressions.</p> <p>Step 3: Run build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Step 4: Manual testing</p> <p>Test all pages in browser: - Scenes page - Performers page + detail - Galleries page + detail - Collections page + detail - Studios page + detail - Tags page + detail</p> <p>Step 5: Commit any fixes</p> <pre><code>git commit -m \"fix: address test failures after card/grid refactor\"\n</code></pre>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#task-25-update-documentation","title":"Task 25: Update documentation","text":"<p>Files: - Modify: <code>docs/architecture/components.md</code> (if exists) - Or create brief documentation in README</p> <p>Document the new component hierarchy: - Primitives (CardComponents.jsx) - BaseCard + BaseGrid - Entity Cards (components/cards/) - Entity Grids (components/grids/)</p> <p>Commit: <pre><code>git commit -m \"docs: update component documentation for card/grid refactor\"\n</code></pre></p>"},{"location":"plans/2025-01-12-card-grid-refactor-implementation/#final-checklist","title":"Final Checklist","text":"<ul> <li> All tests pass</li> <li> Build succeeds without warnings</li> <li> All entity types have dedicated Card components</li> <li> All entity types have dedicated Grid components</li> <li> Nested grids work with locked filters on detail pages</li> <li> No deprecated components remain (GridCard, EntityGrid)</li> <li> Visual appearance matches pre-refactor state</li> <li> TV mode still functions correctly</li> <li> Selection mode in SceneGrid still works</li> </ul> <p>Plan complete and saved to <code>docs/plans/2025-01-12-card-grid-refactor-implementation.md</code>.</p> <p>Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/","title":"Empty Entity Filtering Bug Fix Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix the bug where non-admin users see drastically reduced entity counts (Performers: 180/7000+, Studios: 941/1101) due to missing relationship data in empty entity filtering.</p> <p>Architecture: Add new scene query methods that include performer/tag junction data, update <code>filterEmptyStudios</code> with parent/child traversal and gallery lookup, update <code>filterEmptyTags</code> to accept performer data for tag lookup.</p> <p>Tech Stack: TypeScript, Prisma ORM, Express controllers</p>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-1-add-getallsceneswithperformers-method","title":"Task 1: Add getAllScenesWithPerformers Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:185</code> (after getAllScenesWithTags) - Test: <code>server/services/__tests__/StashEntityService.test.ts</code> (if exists, otherwise manual verification)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithTags()</code> method (around line 185):</p> <pre><code>  /**\n   * Get all scenes with performers relation included\n   * Used for empty entity filtering which needs to know which performers appear in visible scenes\n   */\n  async getAllScenesWithPerformers(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformers: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformers method for empty entity filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-2-add-getallsceneswithperformersandtags-method","title":"Task 2: Add getAllScenesWithPerformersAndTags Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code> (after the method added in Task 1)</p> <p>Step 1: Add the new method</p> <p>In <code>server/services/StashEntityService.ts</code>, add after <code>getAllScenesWithPerformers()</code>:</p> <pre><code>  /**\n   * Get all scenes with both performers and tags relations included\n   * Used for tags filtering which needs both performer IDs and tag IDs\n   */\n  async getAllScenesWithPerformersAndTags(): Promise&lt;NormalizedScene[]&gt; {\n    const startTotal = Date.now();\n\n    const queryStart = Date.now();\n    const cached = await prisma.stashScene.findMany({\n      where: { deletedAt: null },\n      select: {\n        ...this.BROWSE_SELECT,\n        performers: {\n          select: { performerId: true },\n        },\n        tags: {\n          select: { tagId: true },\n        },\n      },\n    });\n    const queryTime = Date.now() - queryStart;\n\n    const transformStart = Date.now();\n    const result = cached.map((c) =&gt; {\n      const scene = this.transformSceneForBrowse(c);\n      scene.performers = (c.performers?.map((p: { performerId: string }) =&gt; ({ id: p.performerId })) || []) as typeof scene.performers;\n      scene.tags = (c.tags?.map((t: { tagId: string }) =&gt; ({ id: t.tagId })) || []) as typeof scene.tags;\n      return scene;\n    });\n    const transformTime = Date.now() - transformStart;\n\n    logger.info(`getAllScenesWithPerformersAndTags: query=${queryTime}ms, transform=${transformTime}ms, total=${Date.now() - startTotal}ms, count=${cached.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: add getAllScenesWithPerformersAndTags method for tags filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-3-update-filteremptystudios-with-parentchild-traversal","title":"Task 3: Update filterEmptyStudios with Parent/Child Traversal","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:269-332</code> (replace filterEmptyStudios method)</p> <p>Step 1: Replace the filterEmptyStudios method</p> <p>Find <code>filterEmptyStudios</code> method (starts around line 269) and replace entirely with:</p> <pre><code>  /**\n   * Filter studios with no content\n   * Hide if ALL of:\n   * - Not in any visible scene\n   * - No visible groups\n   * - No images\n   * - No visible galleries\n   * - No child studios with content\n   */\n  filterEmptyStudios&lt;T extends FilterableStudio&gt;(\n    studios: T[],\n    visibleGroups: FilterableGroup[],\n    visibleGalleries: FilterableGallery[],\n    visibleScenes?: Array&lt;{ id: string; studio?: { id: string } | null }&gt;\n  ): T[] {\n    // Build set of studios in visible scenes\n    const studiosInVisibleScenes = new Set&lt;string&gt;();\n    if (visibleScenes) {\n      for (const scene of visibleScenes) {\n        if (scene.studio) {\n          studiosInVisibleScenes.add(scene.studio.id);\n        }\n      }\n    }\n\n    // Build sets of visible group and gallery IDs for fast lookup\n    const visibleGroupIds = new Set(visibleGroups.map((g) =&gt; g.id));\n    const visibleGalleryIds = new Set(visibleGalleries.map((g) =&gt; g.id));\n\n    // Build set of studios that have visible galleries\n    const studiosWithVisibleGalleries = new Set&lt;string&gt;();\n    for (const gallery of visibleGalleries) {\n      const studioId = (gallery as { studio?: { id: string } }).studio?.id;\n      if (studioId) {\n        studiosWithVisibleGalleries.add(studioId);\n      }\n    }\n\n    // Build parent -&gt; children map for recursive check\n    const studioMap = new Map(studios.map((s) =&gt; [s.id, s]));\n    const childrenMap = new Map&lt;string, string[]&gt;();\n    for (const studio of studios) {\n      const parentId = (studio as { parent_studio?: { id: string } }).parent_studio?.id;\n      if (parentId) {\n        if (!childrenMap.has(parentId)) {\n          childrenMap.set(parentId, []);\n        }\n        childrenMap.get(parentId)!.push(studio.id);\n      }\n    }\n\n    // Track which studios have content\n    const hasContent = new Map&lt;string, boolean&gt;();\n\n    const checkHasContent = (studioId: string, visited = new Set&lt;string&gt;()): boolean =&gt; {\n      if (visited.has(studioId)) return false;\n      visited.add(studioId);\n\n      if (hasContent.has(studioId)) {\n        return hasContent.get(studioId)!;\n      }\n\n      const studio = studioMap.get(studioId);\n      if (!studio) return false;\n\n      // Check if studio appears in visible scenes\n      if (visibleScenes &amp;&amp; studiosInVisibleScenes.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Fallback to scene_count if visibleScenes not provided\n      if (!visibleScenes &amp;&amp; studio.scene_count &amp;&amp; studio.scene_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has images? Keep\n      if (studio.image_count &amp;&amp; studio.image_count &gt; 0) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible galleries? Keep\n      if (studiosWithVisibleGalleries.has(studio.id)) {\n        hasContent.set(studioId, true);\n        return true;\n      }\n\n      // Has visible groups? Keep\n      if (studio.groups &amp;&amp; Array.isArray(studio.groups)) {\n        if (studio.groups.some((g) =&gt; visibleGroupIds.has(g.id))) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      // Check if any child studio has content\n      const children = childrenMap.get(studioId) || [];\n      for (const childId of children) {\n        if (checkHasContent(childId, visited)) {\n          hasContent.set(studioId, true);\n          return true;\n        }\n      }\n\n      hasContent.set(studioId, false);\n      return false;\n    };\n\n    // Check all studios\n    for (const studio of studios) {\n      checkHasContent(studio.id);\n    }\n\n    const filtered = studios.filter((studio) =&gt; hasContent.get(studio.id) === true);\n\n    logger.debug(\"Filtered empty studios\", {\n      original: studios.length,\n      filtered: filtered.length,\n      removed: studios.length - filtered.length,\n    });\n\n    return filtered;\n  }\n</code></pre> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: add parent/child traversal and gallery lookup to filterEmptyStudios\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-4-update-filteremptytags-to-accept-allperformers-parameter","title":"Task 4: Update filterEmptyTags to Accept allPerformers Parameter","text":"<p>Files: - Modify: <code>server/services/EmptyEntityFilterService.ts:342-515</code> (update filterEmptyTags method)</p> <p>Step 1: Update the method signature and add performer lookup</p> <p>Find <code>filterEmptyTags</code> method (starts around line 342). Update the signature and the performer tag lookup logic:</p> <p>Change the method signature from: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;;\n      studio?: { id: string; tags?: Array&lt;{ id: string }&gt; } | null;\n    }&gt;\n  ): T[] {\n</code></pre></p> <p>To: <pre><code>  filterEmptyTags&lt;T extends FilterableTag&gt;(\n    tags: T[],\n    visibleEntities: VisibleEntitySets,\n    visibleScenes?: Array&lt;{\n      id: string;\n      tags?: Array&lt;{ id: string }&gt;;\n      performers?: Array&lt;{ id: string }&gt;;\n      studio?: { id: string } | null;\n    }&gt;,\n    allPerformers?: Array&lt;{ id: string; tags?: Array&lt;{ id: string }&gt; }&gt;\n  ): T[] {\n</code></pre></p> <p>Then, inside the method, after line <code>const tagsOnVisibleEntities = new Set&lt;string&gt;();</code> add:</p> <pre><code>    // Build performer ID -&gt; tags lookup from allPerformers\n    const performerTagsMap = new Map&lt;string, string[]&gt;();\n    if (allPerformers) {\n      for (const performer of allPerformers) {\n        if (performer.tags) {\n          performerTagsMap.set(performer.id, performer.tags.map(t =&gt; t.id));\n        }\n      }\n    }\n</code></pre> <p>Then update the performer tags section (around lines 375-384) from: <pre><code>        // Tags on performers in visible scenes\n        if (scene.performers) {\n          for (const performer of scene.performers) {\n            if (performer.tags) {\n              for (const tag of performer.tags) {\n                tagsOnVisibleEntities.add(tag.id);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Tags on performers in visible scenes (lookup from allPerformers)\n        if (scene.performers &amp;&amp; allPerformers) {\n          for (const performer of scene.performers) {\n            const performerTags = performerTagsMap.get(performer.id);\n            if (performerTags) {\n              for (const tagId of performerTags) {\n                tagsOnVisibleEntities.add(tagId);\n              }\n            }\n          }\n        }\n</code></pre></p> <p>Also update the studio tags section (around lines 386-391) from: <pre><code>        // Tags on studio in visible scenes\n        if (scene.studio?.tags) {\n          for (const tag of scene.studio.tags) {\n            tagsOnVisibleEntities.add(tag.id);\n          }\n        }\n</code></pre></p> <p>To: <pre><code>        // Note: Studio tags are not loaded via scenes - they're on the studio entities\n        // This would require passing allStudios, but studio tags are a rare use case\n        // Skip for now - can be added later if needed\n</code></pre></p> <p>Step 2: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/EmptyEntityFilterService.ts\ngit commit -m \"fix: update filterEmptyTags to accept allPerformers for tag lookup\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-5-update-performersts-to-use-getallsceneswithperformers","title":"Task 5: Update performers.ts to Use getAllScenesWithPerformers","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts:122</code> (findPerformers) - Modify: <code>server/controllers/library/performers.ts:605</code> (findPerformersMinimal)</p> <p>Step 1: Update findPerformers (line 122)</p> <p>Find line 122: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 2: Update findPerformersMinimal (line 605)</p> <p>Find line 605: <pre><code>        let visibleScenes = await stashEntityService.getAllScenes();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformers();\n</code></pre></p> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/performers.ts\ngit commit -m \"fix: use getAllScenesWithPerformers for performer filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-6-update-tagsts-to-use-getallsceneswithperformersandtags","title":"Task 6: Update tags.ts to Use getAllScenesWithPerformersAndTags","text":"<p>Files: - Modify: <code>server/controllers/library/tags.ts:180</code> (findTags) - Modify: <code>server/controllers/library/tags.ts:234-238</code> (filterEmptyTags call in findTags) - Modify: <code>server/controllers/library/tags.ts:763</code> (findTagsMinimal) - Modify: <code>server/controllers/library/tags.ts:815-819</code> (filterEmptyTags call in findTagsMinimal)</p> <p>Step 1: Update findTags scene fetching (line 180)</p> <p>Find line 180: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 2: Update filterEmptyTags call in findTags (around line 234-238)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes // \u2190 NEW: Pass visible scenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 3: Update findTagsMinimal scene fetching (line 763)</p> <p>Find line 763: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithTags();\n</code></pre></p> <p>Change to: <pre><code>        let visibleScenes = await stashEntityService.getAllScenesWithPerformersAndTags();\n</code></pre></p> <p>Step 4: Update filterEmptyTags call in findTagsMinimal (around line 815-819)</p> <p>Find: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes\n        );\n</code></pre></p> <p>Change to: <pre><code>        filteredTags = emptyEntityFilterService.filterEmptyTags(\n          filteredTags,\n          visibilitySet,\n          visibleScenes,\n          allPerformers // Pass performers for tag lookup\n        );\n</code></pre></p> <p>Step 5: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Commit</p> <pre><code>git add server/controllers/library/tags.ts\ngit commit -m \"fix: use getAllScenesWithPerformersAndTags and pass allPerformers to tag filtering\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-7-run-tests-and-verify","title":"Task 7: Run Tests and Verify","text":"<p>Files: - Test: All existing tests</p> <p>Step 1: Run the test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Fix any failing tests</p> <p>If any tests fail due to the new method signatures, update them accordingly.</p> <p>Step 3: Commit any test fixes</p> <pre><code>git add -A\ngit commit -m \"test: fix tests for empty entity filtering changes\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#task-8-manual-verification","title":"Task 8: Manual Verification","text":"<p>Step 1: Start the server</p> <p>Run: <code>npm run dev</code> (or however the dev server starts)</p> <p>Step 2: Log in as non-admin user</p> <p>Step 3: Verify counts</p> <ul> <li>Navigate to Performers page - should show 7,000+ (not 180)</li> <li>Navigate to Studios page - should show 1,101 (not 941)</li> <li>Navigate to Tags page - verify count looks correct</li> <li>Check that parent studios with only child content are visible</li> <li>Check that studios with only galleries are visible</li> </ul> <p>Step 4: Log in as admin and verify counts still match</p> <p>Step 5: Final commit if any adjustments needed</p> <pre><code>git add -A\ngit commit -m \"fix: empty entity filtering - complete fix for performer/studio/tag counts\"\n</code></pre>"},{"location":"plans/2025-01-13-empty-entity-filtering-fix/#summary","title":"Summary","text":"Task Description Files 1 Add getAllScenesWithPerformers StashEntityService.ts 2 Add getAllScenesWithPerformersAndTags StashEntityService.ts 3 Update filterEmptyStudios with parent/child EmptyEntityFilterService.ts 4 Update filterEmptyTags to accept allPerformers EmptyEntityFilterService.ts 5 Update performers.ts call sites performers.ts 6 Update tags.ts call sites tags.ts 7 Run tests - 8 Manual verification -"},{"location":"plans/2025-12-15-filter-chip-interaction-design/","title":"Filter Chip Interaction Improvements","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#overview","title":"Overview","text":"<p>Two UX improvements to filter interactions:</p> <ol> <li>Clickable filter chips - Clicking a filter chip opens the Filter Panel and highlights the corresponding filter control</li> <li>Clear All button in SearchableSelect - Add a \"Clear All\" button to multi-select dropdowns</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-1-clickable-filter-chips","title":"Feature 1: Clickable Filter Chips","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior","title":"Current Behavior","text":"<ul> <li>Filter chips display active filters with an X button to remove</li> <li>Only the X button is interactive; the chip body does nothing</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior","title":"New Behavior","text":"<ul> <li>Clicking anywhere on a chip (except X) opens the Filter Panel</li> <li>The corresponding filter control scrolls into view</li> <li>A border-pulse animation highlights the control for 1.5 seconds</li> <li>If the filter is in a collapsed section, that section expands first</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation","title":"Implementation","text":"<p>ActiveFilterChips.jsx: - Add <code>onChipClick</code> prop that receives the filter key - Make chip body clickable with <code>cursor-pointer</code> - X button uses <code>stopPropagation</code> to prevent triggering chip click</p> <p>SearchControls.jsx: - Add state: <code>highlightedFilterKey</code> (string | null) - Add handler <code>handleFilterChipClick(filterKey)</code>:   1. Open filter panel   2. Expand collapsed section if needed   3. Set <code>highlightedFilterKey</code> - Clear highlight after 1.5s via useEffect timeout - Pass <code>highlightedFilterKey</code> to FilterPanel</p> <p>FilterControls.jsx (FilterPanel): - Accept <code>highlightedFilterKey</code> prop - Store refs for each FilterControl by key - When <code>highlightedFilterKey</code> changes:   - Scroll the ref into view   - Apply <code>filter-highlight</code> CSS class</p> <p>CSS Animation: <pre><code>@keyframes filter-highlight-pulse {\n  0% {\n    border-color: var(--accent-primary);\n    box-shadow: 0 0 0 2px var(--accent-primary);\n  }\n  100% {\n    border-color: var(--border-color);\n    box-shadow: none;\n  }\n}\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n}\n</code></pre></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#feature-2-searchableselect-clear-all-button","title":"Feature 2: SearchableSelect Clear All Button","text":""},{"location":"plans/2025-12-15-filter-chip-interaction-design/#current-behavior_1","title":"Current Behavior","text":"<ul> <li>Multi-select shows selected items as chips inside the trigger area</li> <li>Each chip has an X to remove that individual item</li> <li>No way to clear all selections at once without opening dropdown</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#new-behavior_1","title":"New Behavior","text":"<ul> <li>A \"Clear All\" X button appears next to the chevron when there are selections</li> <li>Clicking it clears all selections without opening the dropdown</li> <li>Visually distinct from individual chip X buttons (slightly larger)</li> </ul>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#implementation_1","title":"Implementation","text":"<p>SearchableSelect.jsx:</p> <p>New handler: <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre></p> <p>Updated trigger layout: - From: <code>[selected chips] [chevron]</code> - To: <code>[selected chips] [clear-all X] [chevron]</code></p> <p>Clear button: - Only visible when <code>selectedItems.length &gt; 0</code> - <code>LucideX</code> icon at size 16 (vs 14 for chip X buttons) - Subtle gray color, darkens on hover - <code>aria-label=\"Clear all selections\"</code></p>"},{"location":"plans/2025-12-15-filter-chip-interaction-design/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>client/src/components/ui/ActiveFilterChips.jsx</code> - Add click handler to chips</li> <li><code>client/src/components/ui/SearchControls.jsx</code> - Add highlight state and chip click handler</li> <li><code>client/src/components/ui/FilterControls.jsx</code> - Add highlight styling and scroll behavior</li> <li><code>client/src/components/ui/SearchableSelect.jsx</code> - Add Clear All button</li> <li><code>client/src/index.css</code> (or appropriate CSS file) - Add highlight animation</li> </ol>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/","title":"Filter Chip Interaction Improvements - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add clickable filter chips that highlight their corresponding filter control, and add a \"Clear All\" button to SearchableSelect dropdowns.</p> <p>Architecture: Two independent features: (1) Filter chips get click handlers that open the filter panel, expand collapsed sections, scroll to the control, and apply a pulse animation. (2) SearchableSelect gets a clear-all button in the trigger area.</p> <p>Tech Stack: React, Tailwind CSS, Lucide React icons, Vitest for testing</p>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-1-add-css-animation-for-filter-highlight","title":"Task 1: Add CSS Animation for Filter Highlight","text":"<p>Files: - Modify: <code>client/src/index.css</code></p> <p>Step 1: Add the highlight pulse animation</p> <p>Add at the end of <code>client/src/index.css</code>:</p> <pre><code>/* Filter control highlight animation - used when clicking filter chips */\n@keyframes filter-highlight-pulse {\n  0% {\n    box-shadow: 0 0 0 3px var(--accent-primary);\n  }\n  100% {\n    box-shadow: none;\n  }\n}\n\n.filter-highlight {\n  animation: filter-highlight-pulse 1.5s ease-out;\n  border-radius: 0.375rem;\n}\n</code></pre> <p>Step 2: Verify the CSS is valid</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds without CSS errors</p> <p>Step 3: Commit</p> <pre><code>git add client/src/index.css\ngit commit -m \"feat: add filter highlight pulse animation\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-2-add-clear-all-button-to-searchableselect","title":"Task 2: Add Clear All Button to SearchableSelect","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchableSelect.jsx</code> - Create: <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code></p> <p>Step 2.1: Write the failing test for clear all functionality</p> <p>Create <code>client/src/components/ui/__tests__/SearchableSelect.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport SearchableSelect from \"../SearchableSelect\";\n\n// Mock the API\nvi.mock(\"../../../services/api.js\", () =&gt; ({\n  libraryApi: {\n    findPerformers: vi.fn().mockResolvedValue({ findPerformers: { performers: [] } }),\n    findPerformersMinimal: vi.fn().mockResolvedValue([]),\n  },\n}));\n\n// Mock the filter cache\nvi.mock(\"../../../utils/filterCache.js\", () =&gt; ({\n  getCache: vi.fn().mockReturnValue(null),\n  setCache: vi.fn(),\n}));\n\ndescribe(\"SearchableSelect\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(SearchableSelect).toBeDefined();\n    expect(typeof SearchableSelect).toBe(\"function\");\n  });\n\n  describe(\"Clear All button\", () =&gt; {\n    it(\"shows clear all button when there are selections in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      // Wait for component to load selected items\n      // The clear all button should be visible\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      expect(clearButton).toBeInTheDocument();\n    });\n\n    it(\"does not show clear all button when no selections\", () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = screen.queryByLabelText(\"Clear all selections\");\n      expect(clearButton).not.toBeInTheDocument();\n    });\n\n    it(\"calls onChange with empty array when clear all is clicked in multi mode\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      expect(onChange).toHaveBeenCalledWith([]);\n    });\n\n    it(\"does not open dropdown when clear all is clicked\", async () =&gt; {\n      const onChange = vi.fn();\n      render(\n        &lt;SearchableSelect\n          entityType=\"performers\"\n          value={[\"1\", \"2\"]}\n          onChange={onChange}\n          multi={true}\n          placeholder=\"Select performers\"\n        /&gt;\n      );\n\n      const clearButton = await screen.findByLabelText(\"Clear all selections\");\n      fireEvent.click(clearButton);\n\n      // Dropdown search input should not be visible\n      const searchInput = screen.queryByPlaceholderText(\"Search performers...\");\n      expect(searchInput).not.toBeInTheDocument();\n    });\n  });\n});\n</code></pre> <p>Step 2.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: FAIL - \"Clear all selections\" button not found</p> <p>Step 2.3: Implement the clear all button in SearchableSelect</p> <p>In <code>client/src/components/ui/SearchableSelect.jsx</code>, make these changes:</p> <ol> <li>Add the <code>handleClearAll</code> function after <code>handleRemove</code> (around line 272):</li> </ol> <pre><code>const handleClearAll = (e) =&gt; {\n  e.stopPropagation(); // Don't toggle dropdown\n  onChange(multi ? [] : \"\");\n};\n</code></pre> <ol> <li>Update the trigger area JSX (starting around line 281). Replace the existing return statement's outer div content with:</li> </ol> <p>Find this section (lines ~281-336): <pre><code>return (\n  &lt;div ref={dropdownRef} className=\"relative w-full\"&gt;\n    {/* Selected items display / Trigger button */}\n    &lt;div\n      onClick={() =&gt; setIsOpen(!isOpen)}\n      className=\"w-full pl-3 pr-[2px] py-2 rounded-md cursor-pointer border text-sm flex items-center justify-between gap-2\"\n      style={{\n        backgroundColor: \"var(--bg-card)\",\n        borderColor: \"var(--border-color)\",\n        color: \"var(--text-primary)\",\n      }}\n    &gt;\n      &lt;div className=\"flex flex-wrap gap-1 flex-1\"&gt;\n        {selectedItems.length === 0 ? (\n          &lt;span style={{ color: \"var(--text-muted)\" }}&gt;{placeholder}&lt;/span&gt;\n        ) : multi ? (\n          selectedItems.map((item) =&gt; (\n            ...\n          ))\n        ) : (\n          ...\n        )}\n      &lt;/div&gt;\n      &lt;LucideChevronDown\n        ...\n      /&gt;\n    &lt;/div&gt;\n</code></pre></p> <p>Replace the closing section (after the <code>&lt;/div&gt;</code> that wraps selected items, before <code>&lt;LucideChevronDown&gt;</code>) with:</p> <pre><code>      &lt;/div&gt;\n      &lt;div className=\"flex items-center gap-1 flex-shrink-0\"&gt;\n        {selectedItems.length &gt; 0 &amp;&amp; (\n          &lt;Button\n            onClick={handleClearAll}\n            variant=\"tertiary\"\n            className=\"hover:opacity-70 !p-1 !border-0\"\n            aria-label=\"Clear all selections\"\n            title=\"Clear all\"\n            icon={&lt;LucideX size={16} style={{ color: \"var(--text-muted)\" }} /&gt;}\n          /&gt;\n        )}\n        &lt;LucideChevronDown\n          size={14}\n          style={{\n            transform: isOpen ? \"rotate(180deg)\" : \"rotate(0deg)\",\n            transition: \"transform 0.2s\",\n            color: \"var(--text-muted)\",\n          }}\n        /&gt;\n      &lt;/div&gt;\n</code></pre> <p>Step 2.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/SearchableSelect.test.jsx</code> Expected: PASS</p> <p>Step 2.5: Commit</p> <pre><code>git add client/src/components/ui/SearchableSelect.jsx client/src/components/ui/__tests__/SearchableSelect.test.jsx\ngit commit -m \"feat: add clear all button to SearchableSelect\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-3-add-onchipclick-prop-to-activefilterchips","title":"Task 3: Add onChipClick Prop to ActiveFilterChips","text":"<p>Files: - Modify: <code>client/src/components/ui/ActiveFilterChips.jsx</code> - Create: <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code></p> <p>Step 3.1: Write failing test for chip click behavior</p> <p>Create <code>client/src/components/ui/__tests__/ActiveFilterChips.test.jsx</code>:</p> <pre><code>import { describe, it, expect, vi } from \"vitest\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport ActiveFilterChips from \"../ActiveFilterChips\";\n\nconst mockFilterOptions = [\n  { key: \"rating\", label: \"Rating\", type: \"range\" },\n  { key: \"favorite\", label: \"Favorite\", type: \"checkbox\" },\n  { key: \"performers\", label: \"Performers\", type: \"searchable-select\" },\n];\n\ndescribe(\"ActiveFilterChips\", () =&gt; {\n  it(\"is defined as a component\", () =&gt; {\n    expect(ActiveFilterChips).toBeDefined();\n    expect(typeof ActiveFilterChips).toBe(\"function\");\n  });\n\n  describe(\"chip click behavior\", () =&gt; {\n    it(\"calls onChipClick with filter key when chip body is clicked\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the chip body (the text part)\n      const chipText = screen.getByText(\"Favorite\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).toHaveBeenCalledWith(\"favorite\");\n      expect(onRemoveFilter).not.toHaveBeenCalled();\n    });\n\n    it(\"calls onRemoveFilter when X button is clicked, not onChipClick\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n        /&gt;\n      );\n\n      // Click the remove button\n      const removeButton = screen.getByLabelText(\"Remove filter: Favorite\");\n      fireEvent.click(removeButton);\n\n      expect(onRemoveFilter).toHaveBeenCalledWith(\"favorite\");\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"does not call onChipClick for permanent filter chips\", () =&gt; {\n      const onRemoveFilter = vi.fn();\n      const onChipClick = vi.fn();\n\n      render(\n        &lt;ActiveFilterChips\n          filters={{}}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={onRemoveFilter}\n          onChipClick={onChipClick}\n          permanentFilters={{ performers: [\"1\"] }}\n          permanentFiltersMetadata={{ performers: [{ id: \"1\", name: \"Test Performer\" }] }}\n        /&gt;\n      );\n\n      // Click the permanent chip\n      const chipText = screen.getByText(\"Performer: Test Performer\");\n      fireEvent.click(chipText);\n\n      expect(onChipClick).not.toHaveBeenCalled();\n    });\n\n    it(\"shows pointer cursor on clickable chips\", () =&gt; {\n      render(\n        &lt;ActiveFilterChips\n          filters={{ favorite: true }}\n          filterOptions={mockFilterOptions}\n          onRemoveFilter={vi.fn()}\n          onChipClick={vi.fn()}\n        /&gt;\n      );\n\n      const chip = screen.getByText(\"Favorite\").closest(\"div\");\n      expect(chip).toHaveClass(\"cursor-pointer\");\n    });\n  });\n});\n</code></pre> <p>Step 3.2: Run test to verify it fails</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: FAIL - onChipClick not called / cursor-pointer class not found</p> <p>Step 3.3: Implement chip click handler in ActiveFilterChips</p> <p>In <code>client/src/components/ui/ActiveFilterChips.jsx</code>:</p> <ol> <li>Add <code>onChipClick</code> to the props (around line 14):</li> </ol> <pre><code>const ActiveFilterChips = ({\n  filters,\n  filterOptions,\n  onRemoveFilter,\n  onChipClick,\n  permanentFilters = {},\n  permanentFiltersMetadata = {},\n}) =&gt; {\n</code></pre> <ol> <li>Update the JSDoc to include the new prop (around line 4):</li> </ol> <pre><code>/**\n * Display active filters as removable chips/badges\n *\n * @param {Object} props\n * @param {Object} props.filters - Current filter values\n * @param {Array} props.filterOptions - Filter configuration from filterConfig.js\n * @param {Function} props.onRemoveFilter - Callback when a filter is removed\n * @param {Function} props.onChipClick - Callback when a chip body is clicked (receives filter key)\n * @param {Object} props.permanentFilters - Filters that can't be removed\n * @param {Object} props.permanentFiltersMetadata - Display names for permanent filters\n */\n</code></pre> <ol> <li>Update the chip rendering (around line 156-185). Replace the chip <code>&lt;div&gt;</code> with:</li> </ol> <pre><code>{allChips.map((chip) =&gt; (\n  &lt;div\n    key={chip.key}\n    onClick={() =&gt; !chip.isPermanent &amp;&amp; onChipClick?.(chip.key)}\n    className={`inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-sm border transition-colors ${\n      !chip.isPermanent ? \"cursor-pointer hover:opacity-80\" : \"\"\n    }`}\n    style={{\n      backgroundColor: chip.isPermanent\n        ? \"var(--bg-tertiary)\"\n        : \"var(--bg-secondary)\",\n      borderColor: chip.isPermanent\n        ? \"var(--border-color)\"\n        : \"var(--accent-primary)\",\n      color: chip.isPermanent\n        ? \"var(--text-secondary)\"\n        : \"var(--text-primary)\",\n      opacity: chip.isPermanent ? 0.7 : 1,\n    }}\n  &gt;\n    &lt;span&gt;{chip.label}&lt;/span&gt;\n    {!chip.isPermanent &amp;&amp; (\n      &lt;Button\n        onClick={(e) =&gt; {\n          e.stopPropagation();\n          onRemoveFilter(chip.key);\n        }}\n        variant=\"tertiary\"\n        className=\"hover:opacity-70 !p-0 !border-0\"\n        aria-label={`Remove filter: ${chip.label}`}\n        title={`Remove filter: ${chip.label}`}\n        icon={&lt;LucideX className=\"w-3.5 h-3.5\" /&gt;}\n      /&gt;\n    )}\n  &lt;/div&gt;\n))}\n</code></pre> <p>Step 3.4: Run test to verify it passes</p> <p>Run: <code>cd client &amp;&amp; npm run test:run -- src/components/ui/__tests__/ActiveFilterChips.test.jsx</code> Expected: PASS</p> <p>Step 3.5: Commit</p> <pre><code>git add client/src/components/ui/ActiveFilterChips.jsx client/src/components/ui/__tests__/ActiveFilterChips.test.jsx\ngit commit -m \"feat: add onChipClick prop to ActiveFilterChips\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-4-add-highlight-support-to-filterpanel","title":"Task 4: Add Highlight Support to FilterPanel","text":"<p>Files: - Modify: <code>client/src/components/ui/FilterControls.jsx</code></p> <p>Step 4.1: Update FilterPanel to accept highlight props</p> <p>In <code>client/src/components/ui/FilterControls.jsx</code>, update the <code>FilterPanel</code> component (around line 431):</p> <ol> <li>Add new props to FilterPanel:</li> </ol> <pre><code>export const FilterPanel = ({\n  children,\n  onClear,\n  hasActiveFilters,\n  isOpen,\n  onToggle,\n  onSubmit,\n  highlightedFilterKey,\n  filterRefs,\n}) =&gt; {\n</code></pre> <ol> <li>Add useEffect for scroll and highlight behavior. Add this inside FilterPanel, before the <code>if (!isOpen)</code> check:</li> </ol> <pre><code>// Scroll to highlighted filter when it changes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey &amp;&amp; filterRefs?.current?.[highlightedFilterKey]) {\n    const element = filterRefs.current[highlightedFilterKey];\n\n    // Small delay to ensure panel is rendered\n    setTimeout(() =&gt; {\n      element.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n    }, 100);\n  }\n}, [highlightedFilterKey, filterRefs]);\n</code></pre> <ol> <li>Add the useEffect import at the top of the file if not already present:</li> </ol> <pre><code>import { useEffect } from \"react\";\n</code></pre> <p>Step 4.2: Update FilterControl to accept ref and highlight class</p> <p>Update <code>FilterControl</code> component (around line 50) to forward a ref and apply highlight class:</p> <ol> <li>Import <code>forwardRef</code> at the top:</li> </ol> <pre><code>import { forwardRef, useEffect } from \"react\";\n</code></pre> <ol> <li>Wrap FilterControl with forwardRef and add highlight styling:</li> </ol> <pre><code>export const FilterControl = forwardRef(({\n  type = \"select\",\n  label,\n  value,\n  onChange,\n  options = [],\n  placeholder = \"\",\n  min,\n  max,\n  entityType,\n  multi,\n  modifierOptions,\n  modifierValue,\n  onModifierChange,\n  supportsHierarchy = false,\n  hierarchyLabel = \"Include children\",\n  hierarchyValue,\n  onHierarchyChange,\n  isHighlighted = false,\n}, ref) =&gt; {\n  // ... existing code ...\n\n  return (\n    &lt;div\n      ref={ref}\n      className={`flex flex-col ${isHighlighted ? \"filter-highlight\" : \"\"}`}\n    &gt;\n      {/* ... rest of the component */}\n    &lt;/div&gt;\n  );\n});\n\nFilterControl.displayName = \"FilterControl\";\n</code></pre> <p>Step 4.3: Verify changes compile</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 4.4: Commit</p> <pre><code>git add client/src/components/ui/FilterControls.jsx\ngit commit -m \"feat: add highlight support to FilterPanel and FilterControl\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-5-wire-up-chip-click-in-searchcontrols","title":"Task 5: Wire Up Chip Click in SearchControls","text":"<p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 5.1: Add state and refs for highlighting</p> <p>In <code>client/src/components/ui/SearchControls.jsx</code>:</p> <ol> <li>Add <code>useRef</code> to the imports if not already there (line 1):</li> </ol> <pre><code>import React, { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n</code></pre> <ol> <li>Add state for highlighted filter key (around line 99, after other useState calls):</li> </ol> <pre><code>const [highlightedFilterKey, setHighlightedFilterKey] = useState(null);\nconst filterRefs = useRef({});\n</code></pre> <ol> <li>Add useEffect to clear highlight after animation (add after other useEffects, around line 400):</li> </ol> <pre><code>// Clear highlight after animation completes\nuseEffect(() =&gt; {\n  if (highlightedFilterKey) {\n    const timer = setTimeout(() =&gt; {\n      setHighlightedFilterKey(null);\n    }, 1500);\n    return () =&gt; clearTimeout(timer);\n  }\n}, [highlightedFilterKey]);\n</code></pre> <p>Step 5.2: Add handler for chip clicks</p> <p>Add this handler after <code>handleRemoveFilter</code> (around line 486):</p> <pre><code>// Handle clicking on a filter chip to highlight that filter\nconst handleFilterChipClick = useCallback(\n  (filterKey) =&gt; {\n    // Open filter panel if not already open\n    setIsFilterPanelOpen(true);\n\n    // Find which section this filter belongs to\n    let sectionKey = null;\n    for (let i = 0; i &lt; filterOptions.length; i++) {\n      if (filterOptions[i].type === \"section-header\") {\n        sectionKey = filterOptions[i].key;\n      } else if (filterOptions[i].key === filterKey) {\n        break;\n      }\n    }\n\n    // Expand the section if it's collapsed\n    if (sectionKey &amp;&amp; collapsedSections[sectionKey]) {\n      setCollapsedSections((prev) =&gt; ({\n        ...prev,\n        [sectionKey]: false,\n      }));\n    }\n\n    // Set the highlighted filter key (triggers scroll and animation)\n    setHighlightedFilterKey(filterKey);\n  },\n  [filterOptions, collapsedSections]\n);\n</code></pre> <p>Step 5.3: Pass onChipClick to ActiveFilterChips</p> <p>Update the <code>ActiveFilterChips</code> component usage (around line 796):</p> <pre><code>{/* Active Filter Chips */}\n&lt;ActiveFilterChips\n  filters={filters}\n  filterOptions={filterOptions}\n  onRemoveFilter={handleRemoveFilter}\n  onChipClick={handleFilterChipClick}\n  permanentFilters={permanentFilters}\n  permanentFiltersMetadata={permanentFiltersMetadata}\n/&gt;\n</code></pre> <p>Step 5.4: Pass highlight props to FilterPanel</p> <p>Update the <code>FilterPanel</code> component usage (around line 831):</p> <pre><code>{/* Filter Panel */}\n&lt;FilterPanel\n  isOpen={isFilterPanelOpen}\n  onToggle={handleToggleFilterPanel}\n  onClear={clearFilters}\n  onSubmit={handleFilterSubmit}\n  hasActiveFilters={hasActiveFilters}\n  highlightedFilterKey={highlightedFilterKey}\n  filterRefs={filterRefs}\n&gt;\n</code></pre> <p>Step 5.5: Pass ref and isHighlighted to each FilterControl</p> <p>Update the FilterControl rendering in the map (around line 923-945):</p> <pre><code>return (\n  &lt;FilterControl\n    key={`FilterControl-${key}`}\n    ref={(el) =&gt; {\n      if (el) filterRefs.current[key] = el;\n    }}\n    isHighlighted={highlightedFilterKey === key}\n    onChange={(value) =&gt; handleFilterChange(key, value)}\n    value={filters[key] || defaultValue}\n    type={type}\n    modifierOptions={modifierOptions}\n    modifierValue={filters[modifierKey] || defaultModifier}\n    onModifierChange={(value) =&gt;\n      modifierKey &amp;&amp; handleFilterChange(modifierKey, value)\n    }\n    supportsHierarchy={supportsHierarchy}\n    hierarchyLabel={hierarchyLabel}\n    hierarchyValue={hierarchyKey ? filters[hierarchyKey] : undefined}\n    onHierarchyChange={\n      hierarchyKey\n        ? (value) =&gt; handleFilterChange(hierarchyKey, value)\n        : undefined\n    }\n    {...filterProps}\n  /&gt;\n);\n</code></pre> <p>Step 5.6: Verify changes compile and app works</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 5.7: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: wire up filter chip click to highlight filter controls\"\n</code></pre>"},{"location":"plans/2025-12-15-filter-chip-interaction-implementation/#task-6-manual-testing-and-final-verification","title":"Task 6: Manual Testing and Final Verification","text":"<p>Step 6.1: Run all tests</p> <p>Run: <code>cd client &amp;&amp; npm run test:run</code> Expected: All tests pass</p> <p>Step 6.2: Run linting</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 6.3: Build for production</p> <p>Run: <code>cd client &amp;&amp; npm run build</code> Expected: Build succeeds</p> <p>Step 6.4: Manual testing checklist</p> <p>Start the dev server and verify:</p> <ol> <li>SearchableSelect Clear All:</li> <li> Clear button appears when items are selected</li> <li> Clear button disappears when no selections</li> <li> Clicking clear removes all selections</li> <li> <p> Dropdown does not open when clear is clicked</p> </li> <li> <p>Filter Chip Click:</p> </li> <li> Clicking a filter chip opens the filter panel</li> <li> The corresponding filter control scrolls into view</li> <li> A pulse animation highlights the control</li> <li> Animation fades after ~1.5 seconds</li> <li> Clicking the X still removes the filter (doesn't trigger chip click)</li> <li> <p> Permanent filter chips are not clickable</p> </li> <li> <p>Collapsed Sections:</p> </li> <li> Clicking a chip for a filter in a collapsed section expands that section</li> <li> Then scrolls to and highlights the filter</li> </ol> <p>Step 6.5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: address issues from manual testing\"\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/","title":"Issues Found in v3.0.0-beta.9","text":"<p>Date: December 15, 2025 To be addressed in separate branches before or after 3.0.0 release</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-1-detail-page-tabs-not-loading-non-scenes-tabs","title":"Issue 1: Detail Page Tabs Not Loading (Non-Scenes Tabs)","text":"<p>Severity: HIGH - User-facing navigation broken</p> <p>Symptoms: - On Performer Detail, Studio Detail, Tag Detail, and Collection/Group Detail pages - Clicking non-Scenes tabs (Galleries, Images, Groups) causes a flicker - URL briefly shows <code>?tab=galleries</code> but immediately switches back to default (Scenes) - Manually typing URL with <code>?tab=galleries</code> also reverts</p> <p>Root Cause Analysis:</p> <p>The issue is NOT related to tab filtering or counts. The <code>SearchControls</code> component completely replaces URL query params when syncing state to URL, obliterating the <code>?tab=</code> parameter.</p> <p>The Problem:</p> <p>In <code>client/src/components/ui/SearchControls.jsx:384</code>: <pre><code>setSearchParams(params, { replace: true });\n</code></pre></p> <p>And in <code>client/src/utils/urlParams.js:169</code>, <code>buildSearchParams()</code> creates a brand new URLSearchParams() that only includes filter/sort/page params - it does NOT preserve unknown params like <code>tab</code>.</p> <p>The Flow: 1. User clicks \"Galleries\" tab \u2192 <code>TabNavigation</code> sets <code>?tab=galleries</code> 2. Tab content changes, <code>GalleryGrid</code> (via <code>SearchableGrid</code> \u2192 <code>SearchControls</code>) mounts 3. <code>SearchControls</code> initializes and calls <code>setSearchParams(params)</code> with only its filter params 4. <code>?tab=galleries</code> is obliterated, replaced with filter params (or empty string) 5. <code>activeTab</code> reads from URL, sees no <code>tab</code> param, defaults back to <code>scenes</code></p> <p>Files to Fix: - <code>client/src/components/ui/SearchControls.jsx</code> - URL sync logic - <code>client/src/utils/urlParams.js</code> - <code>buildSearchParams</code> function</p> <p>Fix Options: 1. Pass <code>syncToUrl={false}</code> to grids rendered inside tabs (quick fix, breaks URL bookmarking for nested grids) 2. Preserve unknown params in <code>buildSearchParams</code> - accept existing params and merge rather than replace 3. Namespace params - use prefixes like <code>scene_sort=</code>, <code>gallery_sort=</code> to avoid conflicts</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-2-tags-query-performance","title":"Issue 2: Tags Query Performance","text":"<p>Severity: MEDIUM - Usability issue, not broken</p> <p>Symptoms: - Tags list page is slow to load - Tag detail page is slow - Not unusable but noticeably slower than other entity types</p> <p>Root Cause Analysis:</p> <p>The <code>enhanceTagsWithPerformerScenes()</code> function at <code>server/controllers/library/tags.ts:19-75</code> is O(n*m) where n=scenes and m=performers. It loads ALL scenes and ALL performers to calculate counts.</p> <p>Key Finding: The real performance issue is that <code>enhanceTagsWithPerformerScenes()</code> is called at <code>tags.ts:261</code>, which is AFTER the filtered entity cache check (lines 151-254). This means:</p> <ul> <li>Tag filtering IS cached (via <code>filteredEntityCacheService</code>)</li> <li>But performer scene enhancement runs on every single request, even cache hits</li> </ul> <p>The caching only helps with content restriction filtering, not with the expensive enhancement step.</p> <p>Files to Fix: - <code>server/controllers/library/tags.ts</code> - Move enhancement inside cache block or cache separately</p> <p>Fix Options: 1. Move enhancement inside cache block - Include enhanced data in the cached result (simplest) 2. Pre-compute counts on sync - Store <code>scene_count_via_performers</code> in the StashTag table 3. Use SQL aggregation - Replace the in-memory calculation with a SQL COUNT query 4. Separate cache for enhancement - Cache the enhancement result with its own TTL 5. Lazy load - Only calculate performer scene counts when specifically requested (detail page)</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-3-o-history-stored-in-json-column","title":"Issue 3: O History Stored in JSON Column","text":"<p>Severity: LOW - Technical debt, not user-facing</p> <p>Current Implementation:</p> <p>From <code>server/prisma/schema.prisma</code> line 72: <pre><code>oHistory Json @default(\"[]\") // Array of timestamp strings when O was incremented\n</code></pre></p> <p>The O history is stored as a JSON array of timestamp strings within the WatchHistory table.</p> <p>Problems with this approach: 1. Cannot efficiently query \"all O events in the last week\" 2. Cannot aggregate O events across scenes/performers without loading all JSON 3. JSON arrays don't scale well for users with thousands of O events 4. No referential integrity</p> <p>Proposed Schema:</p> <pre><code>model OEvent {\n  id           Int       @id @default(autoincrement())\n  userId       Int\n  sceneId      String\n  timestamp    DateTime  @default(now())\n\n  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  watchHistory WatchHistory? @relation(fields: [userId, sceneId], references: [userId, sceneId])\n\n  @@index([userId])\n  @@index([sceneId])\n  @@index([timestamp])\n  @@index([userId, timestamp])\n}\n</code></pre> <p>Migration Strategy: 1. Create the new OEvent table 2. Write a data migration to move existing oHistory JSON arrays to the new table 3. Update all services that read/write oHistory to use the new table 4. Keep oHistory JSON for backward compatibility during migration period 5. Eventually deprecate and remove oHistory column</p> <p>Files to Change: - <code>server/prisma/schema.prisma</code> - Add OEvent model - <code>server/controllers/watchHistory.ts</code> - Update increment-o endpoint - <code>server/services/UserStatsService.ts</code> - Update O counter aggregation - <code>server/services/SceneQueryBuilder.ts</code> - Update any O history queries</p>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#issue-4-o-counter-ui-shows-stale-value-after-playlist-navigation","title":"Issue 4: O Counter UI Shows Stale Value After Playlist Navigation","text":"<p>Severity: MEDIUM - Confusing UX</p> <p>Symptoms: 1. User increments O counter on Scene A (e.g., 0 \u2192 1) 2. User navigates to next scene (Scene B) in playlist 3. Scene B shows O counter value of 1 (from Scene A) instead of Scene B's actual value 4. This persists as user navigates through playlist 5. If user goes back to Scene A and then navigates away again, it resets correctly</p> <p>Root Cause Analysis:</p> <p>The <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> reducer actions do NOT reset <code>oCounter</code>, but <code>LOAD_SCENE_SUCCESS</code> does set it from the new scene's data at <code>client/src/contexts/scenePlayerReducer.js:108</code>:</p> <pre><code>oCounter: action.payload.oCounter || 0,\n</code></pre> <p>The <code>useEffect</code> at <code>client/src/contexts/ScenePlayerContext.jsx:126-134</code> triggers <code>loadScene()</code> when <code>currentIndex</code> changes, which dispatches <code>LOAD_SCENE_SUCCESS</code>.</p> <p>Why the stale value persists:</p> <p>The issue is a race condition or render timing issue: 1. <code>NEXT_SCENE</code> dispatches \u2192 state updates with old <code>oCounter</code> 2. Component re-renders showing stale <code>oCounter</code> 3. <code>useEffect</code> fires (async) \u2192 <code>loadScene()</code> called 4. API request completes \u2192 <code>LOAD_SCENE_SUCCESS</code> dispatches with correct <code>oCounter</code> 5. Component re-renders with correct value</p> <p>The user sees step 2 (stale) before step 5 (correct). If the API is slow or there's a render batching issue, the stale value is visible longer.</p> <p>Files to Fix: - <code>client/src/contexts/scenePlayerReducer.js</code> - Reset <code>oCounter</code> in navigation actions</p> <p>Recommended Fix: Reset <code>oCounter: 0</code> in <code>NEXT_SCENE</code> and <code>PREV_SCENE</code> cases. This provides immediate feedback that scene is changing, and <code>LOAD_SCENE_SUCCESS</code> will set the correct value once the API responds:</p> <pre><code>// In NEXT_SCENE case (around line 244)\nreturn {\n  ...state,\n  currentIndex: nextIndex,\n  // ... existing resets\n  oCounter: 0,  // ADD THIS - immediate reset\n  // ...\n};\n\n// Same for PREV_SCENE case (around line 313)\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#summary-table","title":"Summary Table","text":"# Issue Severity Effort Recommend Fix Before Release 1 Detail page tabs not loading HIGH Medium Yes 2 Tags query slow MEDIUM High No (post-release) 3 O History JSON schema LOW High No (post-release) 4 O Counter stale UI MEDIUM Low Yes"},{"location":"plans/2025-12-15-v3.0.0-beta9-issues/#recommended-branch-strategy","title":"Recommended Branch Strategy","text":"<ol> <li>Branch: <code>bugfix/detail-page-tabs</code> - Fix issue #1</li> <li>Branch: <code>bugfix/o-counter-stale-state</code> - Fix issue #4</li> <li>Branch: <code>perf/tags-query-optimization</code> - Fix issue #2 (post-release)</li> <li>Branch: <code>refactor/o-history-table</code> - Fix issue #3 (post-release)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/","title":"Peek v3.0.0 Release Announcement","text":"<p>Copy/paste-ready for Discord and Discourse</p>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discord-announcement-short","title":"Discord Announcement (short)","text":"<pre><code>**Peek v3.0.0 Released!**\n\nMajor update with SQLite-based entity storage for massive scalability improvements:\n\n- **100k+ scene support** - No more memory limits\n- **3-minute sync** for 22k scenes (was 3.6 hours)\n- **Persistent library** - Data survives restarts\n- **Comprehensive filtering** - All performer/scene filters now work correctly\n\n**Upgrading:**\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart container\n4. Wait for automatic sync\n\nAll user data (watch history, playlists, ratings) is preserved.\n\n**Beta users:** Run a full sync after upgrading to populate new fields.\n\nDocs: https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/\nIssues: https://github.com/carrotwaxr/peek-stash-browser/issues\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#discourse-announcement-detailed","title":"Discourse Announcement (detailed)","text":"<pre><code># Peek v3.0.0 Released - SQLite Entity Cache\n\nAfter 13 beta versions, Peek 3.0.0 is now stable!\n\n## What's New\n\nVersion 3.0.0 is a major architectural change: your Stash library data is now stored in SQLite tables instead of in-memory. This provides:\n\n| Improvement | Before | After |\n|-------------|--------|-------|\n| Library size limit | ~50k scenes (memory) | 100k+ scenes (disk) |\n| Sync time (22k scenes) | ~3.6 hours | ~3 minutes |\n| Data persistence | Lost on restart | Survives restarts |\n| Query speed | Slow on large libs | Sub-100ms |\n\n## New Features in 3.0\n\n- **Unit Preference** - Choose metric or imperial for performer measurements\n- **Comprehensive Filters** - All performer attributes now filterable (career length, ethnicity, eye color, etc.)\n- **Filter Chip Interactions** - Click filter chips to highlight the corresponding control\n- **Improved Gallery Display** - Better fallback titles for unnamed galleries\n- **Filename Search** - Scene search now includes filepath/filename\n- **Tag Alias Search** - Tag search now includes aliases\n\n## Upgrading\n\n**From any previous version:**\n\n1. Back up your database (copy `peek.db` from your data volume)\n2. Pull the new image: `docker pull carrotwaxr/peek-stash-browser:latest`\n3. Restart your container\n4. Wait for the automatic sync to complete\n\nYour user data is fully preserved:\n- User accounts\n- Watch history &amp; resume positions\n- Playlists\n- All ratings and favorites\n- Filter presets\n- Hidden entities\n\n**From 3.0.0 beta versions:**\n\nWe recommend running a **full sync** after upgrading to ensure new fields are populated:\n1. Settings &gt; Server Settings\n2. Click \"Sync from Stash\"\n3. Select \"Full Sync\"\n\nThis populates `fileBasename` (gallery display) and `fakeTits` (performer filtering) for existing data.\n\n## Breaking Changes from 2.x\n\n- Initial sync is required after upgrade (automatic)\n- Sync time depends on library size (see table in upgrade guide)\n\n## Documentation\n\n- [Upgrade Guide](https://carrotwaxr.github.io/peek-stash-browser/getting-started/upgrading/)\n- [Full Documentation](https://carrotwaxr.github.io/peek-stash-browser/)\n\n## Issues\n\nPlease report bugs on [GitHub Issues](https://github.com/carrotwaxr/peek-stash-browser/issues) with:\n- Your Peek version\n- Your Stash version\n- Library size\n- Steps to reproduce\n\nThanks to everyone who tested the beta versions!\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-announcement/#github-release-notes","title":"GitHub Release Notes","text":"<pre><code>## What's Changed\n\n### Major Changes\n- **SQLite Entity Cache** - Library data now stored in SQLite for 100k+ scene support\n- **Persistent Storage** - Library data survives container restarts\n- **3x faster sync** - Initial sync is ~3 minutes for 22k scenes\n\n### New Features\n- Unit preference setting (metric/imperial) for performer measurements\n- Filter chip click-to-highlight interaction\n- Comprehensive performer filtering (career length, ethnicity, eye color, breast type)\n- Improved gallery title fallback display\n- Scene search now includes filepath/filename\n- Tag search now includes aliases\n\n### Bug Fixes (across beta cycle)\n- Fixed performer filter case sensitivity\n- Fixed sorting by path, last_o_at, performer_count\n- Fixed O counter aggregation for performers/studios/tags\n- Fixed watch history tracking event timing\n- Fixed gallery cards showing \"Untitled Gallery\"\n- Fixed user menu accessibility in collapsed sidebar\n- Fixed long filename overflow on scene cards\n- Fixed last sync time showing only full syncs (now shows most recent)\n\n### Breaking Changes\n- Initial sync required after upgrade (automatic)\n- Migration adds new tables only - all user data preserved\n\n### Upgrade Instructions\n\n1. Back up your database\n2. `docker pull carrotwaxr/peek-stash-browser:3.0.0`\n3. Restart container\n4. Wait for automatic sync\n\n**Beta users:** Run a full sync to populate new fields (Settings &gt; Sync from Stash &gt; Full Sync)\n\n**Full Changelog**: https://github.com/carrotwaxr/peek-stash-browser/compare/v2.1.0...v3.0.0\n</code></pre>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/","title":"Peek v3.0.0 Release Evaluation","text":"<p>Date: December 15, 2025 Evaluator: Claude Code (AI-assisted) Version Evaluated: v3.0.0-beta.9</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#executive-summary","title":"Executive Summary","text":"<p>Peek v3.0.0 represents a major architectural change from in-memory caching to SQLite-based entity storage. After 9 beta versions, the release is conditionally ready for production with the following considerations:</p> Area Status Notes Database Migrations Ready Clean upgrade paths from 1.x and 2.x verified Core Functionality Ready Major bugs addressed across beta cycle Filtering/Sorting Stable 13 fixes in beta cycle, now comprehensive Security Review Needed Non-blocking issues identified Documentation Needs Update Outdated references to beta.2 <p>Recommendation: Proceed with 3.0.0 release after updating documentation and noting user action items.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#1-database-migration-analysis","title":"1. Database Migration Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#migration-chain-7-migrations","title":"Migration Chain (7 migrations)","text":"# Migration Description Added In 1 <code>0_baseline</code> Core user tables (User, WatchHistory, Playlist, Ratings, etc.) v2.0.0 2 <code>20251126202944_add_user_carousel</code> UserCarousel table v2.1.0 3 <code>20251211000000_stash_entities</code> StashScene, StashPerformer, junction tables (23 new tables) v3.0.0-beta.1 4 <code>20251211100000_entity_counts</code> Count columns on Stash* tables v3.0.0-beta.1 5 <code>20251214000000_add_unit_preference</code> User.unitPreference column v3.0.0-beta.5 6 <code>20251214100000_gallery_file_basename</code> StashGallery.fileBasename v3.0.0-beta.6 7 <code>20251215000000_add_performer_fake_tits</code> StashPerformer.fakeTits v3.0.0-beta.9"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#upgrade-path-verification","title":"Upgrade Path Verification","text":"Source Version Migration Handling Status v1.x (pre-migration) schemaCatchup creates missing tables, marks baseline+carousel applied Verified v2.0.x schemaCatchup handles broken states, Prisma applies remaining Verified v2.1.x Prisma applies migrations 3-7 Verified v3.0.0-beta.1-4 Prisma applies migrations 4-7 Verified v3.0.0-beta.5-8 Prisma applies migrations 5-7 Verified v3.0.0-beta.9 No migrations needed Verified Fresh install All 7 migrations applied Verified"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#data-preservation","title":"Data Preservation","text":"<p>User data is fully preserved during upgrade: - User accounts and passwords - Watch history and resume positions - Playlists and playlist items - All ratings and favorites (Scene, Performer, Studio, Tag, Gallery, Group, Image) - Filter presets and carousel preferences - Content restrictions and hidden entities - Custom themes</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#potential-migration-issues","title":"Potential Migration Issues","text":"<p>None identified. The schemaCatchup.ts module handles all legacy database scenarios correctly.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#2-breaking-changes-v2x-to-v30","title":"2. Breaking Changes (v2.x to v3.0)","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#architectural-changes","title":"Architectural Changes","text":"<ol> <li>In-Memory Cache \u2192 SQLite Tables</li> <li>Entity data now persisted in SQLite</li> <li>Initial sync required after upgrade</li> <li> <p>Subsequent syncs are incremental</p> </li> <li> <p>Environment Variables</p> </li> <li><code>STASH_URL</code> and <code>STASH_API_KEY</code> no longer needed as env vars</li> <li>Connection configured via Setup Wizard, stored in database</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#removed-features","title":"Removed Features","text":"<ol> <li>Local Transcoding (removed in v2.0)</li> <li>Peek now proxies streams directly through Stash</li> <li> <p>No more FFmpeg dependency for streaming</p> </li> <li> <p>Path Mappings (removed in v2.0)</p> </li> <li>No longer needed since streaming proxies through Stash</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#new-features-requiring-user-action","title":"New Features Requiring User Action","text":"Feature User Action Unit Preference Optional: Set metric/imperial in Settings Full Sync Post-Beta Recommended: Run full sync to populate new fields (fileBasename, fakeTits)"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#3-beta-fix-analysis","title":"3. Beta Fix Analysis","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#fix-distribution-by-beta-version","title":"Fix Distribution by Beta Version","text":"Version Fix Count Primary Focus beta.1 \u2192 beta.2 1 Permissions beta.2 \u2192 beta.3 0 - beta.3 \u2192 beta.4 5 Filter data loading beta.4 \u2192 beta.5 13 Sorting/filtering (major) beta.5 \u2192 beta.6 6 UI, watch history, settings beta.6 \u2192 beta.7 1 O counter aggregation beta.7 \u2192 beta.8 1 Performer filter parsing beta.8 \u2192 beta.9 1 Case sensitivity, new field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#recurring-issue-patterns","title":"Recurring Issue Patterns","text":"<ol> <li>Performer Filters (4 fix iterations)</li> <li>Initial data loading issues</li> <li>Career length parsing complexity</li> <li>Case sensitivity</li> <li> <p>Missing fields (fakeTits)</p> </li> <li> <p>Sorting Implementation (8 fixes in beta.5)</p> </li> <li>Missing sort options</li> <li>Wrong SQL column names</li> <li> <p>Rating field confusion (Stash vs user)</p> </li> <li> <p>Schema/Migration Mismatches (3 fixes)</p> </li> <li>unitPreference migration missing</li> <li>fakeTits field sync</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#risk-assessment","title":"Risk Assessment","text":"Area Risk Level Notes Performer Filters LOW Comprehensive overhaul completed in beta.5, edge cases addressed in beta.8-9 Sorting LOW All 8 issues fixed in beta.5 Watch History LOW Event timing fixed in beta.5-6 Gallery Display LOW fileBasename fallback added"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#4-core-system-stability","title":"4. Core System Stability","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#stashsyncservice-stable-with-notes","title":"StashSyncService - STABLE with notes","text":"<p>Strengths: - Proper abort handling for cancellable syncs - Entity ID validation for SQL injection defense - Progress events for UI feedback - Soft-delete preserves data</p> <p>Areas for Future Improvement (non-blocking): - Transaction wrapping for atomic sync operations - Consider parameterized queries for additional safety</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#scenequerybuilder-stable","title":"SceneQueryBuilder - STABLE","text":"<p>Strengths: - Parameterized SQL queries throughout - Efficient exclusion filter handling - Count query optimization - Proper hierarchy expansion</p> <p>Minor Notes: - Exclusion sets &gt;500 items are truncated with warning (documented behavior)</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#database-initialization-stable","title":"Database Initialization - STABLE","text":"<p>Strengths: - Comprehensive legacy database handling - Idempotent schema catchup - Clear migration flow</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#authentication-stable","title":"Authentication - STABLE","text":"<p>Strengths: - HTTP-only cookies prevent XSS - bcrypt password hashing - Role-based access control</p> <p>Future Improvements (non-blocking): - Rate limiting on login endpoint - Token revocation on logout</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#5-issues-categorized-by-priority","title":"5. Issues Categorized by Priority","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#blockers-must-fix-before-release","title":"BLOCKERS (must fix before release)","text":"<p>None identified.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#should-fix-recommended-before-release","title":"SHOULD-FIX (recommended before release)","text":"Issue Description Effort Documentation Outdated upgrading.md references beta.2, needs update to beta.9/3.0.0 Low docs/index.md Outdated References transcoding, default credentials Low README Beta Banner Remove beta warning for stable release Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#nice-to-have-can-be-addressed-post-release","title":"NICE-TO-HAVE (can be addressed post-release)","text":"Issue Description Priority Rate Limiting Add to login endpoint Medium Token Revocation Implement logout blacklist Medium Query Timeout Add timeout for complex queries Low"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#6-user-action-items-for-v300","title":"6. User Action Items for v3.0.0","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#all-users","title":"All Users","text":"<ol> <li>Back up database before upgrading</li> <li>Wait for initial sync after upgrade (varies by library size)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-300-betax","title":"Users Upgrading from 3.0.0-beta.x","text":"<ol> <li>Run full sync via Settings \u2192 Sync to populate new fields:</li> <li><code>fileBasename</code> for gallery display (beta.6+)</li> <li><code>fakeTits</code> for performer filters (beta.9+)</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-2x","title":"Users Upgrading from 2.x","text":"<p>No special action needed beyond backup and sync wait.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#users-upgrading-from-1x","title":"Users Upgrading from 1.x","text":"<p>No special action needed beyond backup and sync wait. schemaCatchup handles legacy databases automatically.</p>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#7-recommended-documentation-updates","title":"7. Recommended Documentation Updates","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#files-to-update","title":"Files to Update","text":"<ol> <li>README.md</li> <li>Remove beta warning banner</li> <li> <p>Update version references</p> </li> <li> <p>docs/getting-started/upgrading.md</p> </li> <li>Update \"Latest\" from beta.2 to 3.0.0</li> <li>Add beta.x \u2192 3.0.0 upgrade notes</li> <li> <p>Add full sync recommendation for beta upgraders</p> </li> <li> <p>docs/index.md</p> </li> <li>Remove transcoding references</li> <li> <p>Remove default credentials section (Setup Wizard now handles)</p> </li> <li> <p>CLAUDE.md</p> </li> <li>Update release status if needed</li> </ol>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#8-release-checklist","title":"8. Release Checklist","text":"<ul> <li> Update README.md (remove beta banner)</li> <li> Update docs/getting-started/upgrading.md (comprehensive update)</li> <li> Update docs/index.md (remove outdated info)</li> <li> Verify all tests pass</li> <li> Verify lint passes</li> <li> Tag v3.0.0</li> <li> Create GitHub release with release notes</li> <li> Update Docker Hub description</li> <li> Post to Discourse/Discord</li> </ul>"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#appendix-version-history","title":"Appendix: Version History","text":""},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#v300-beta-timeline","title":"v3.0.0 Beta Timeline","text":"Version Date Key Changes beta.1 Dec 10 Initial SQLite entity cache beta.2 Dec 10 Tag visibility fix beta.3 Dec 12 Video player improvements beta.4 Dec 12 Filter data loading fixes beta.5 Dec 12 Major sorting/filtering overhaul beta.6 Dec 14 UI fixes, watch history, unit preference beta.7 Dec 14 O counter aggregation fix beta.8 Dec 14 Performer filter parsing beta.9 Dec 15 Case sensitivity, fakeTits field"},{"location":"plans/2025-12-15-v3.0.0-release-evaluation/#breaking-changes-by-major-version","title":"Breaking Changes by Major Version","text":"Version Breaking Changes v1.x \u2192 v2.0 Removed local transcoding, removed path mappings v2.x \u2192 v3.0 Architecture change (memory \u2192 SQLite), initial sync required"},{"location":"plans/2025-12-16-query-architecture-consolidation/","title":"Query Architecture Consolidation","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#problem","title":"Problem","text":"<p>Scene queries return inconsistent objects depending on which code path is used:</p> <ul> <li><code>SceneQueryBuilder.execute()</code> returns scenes with full relations (performers, tags, studio, groups, galleries)</li> <li><code>StashEntityService.getAllScenes()</code> returns scenes with empty relation arrays</li> <li>Various <code>getAllScenesWith*()</code> variants return partial relation data (IDs only)</li> </ul> <p>This causes bugs like Similar Scenes and Recommended Scenes cards not displaying performer/tag indicators.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#goal","title":"Goal","text":"<p>Single query architecture where every scene object returned has consistent shape with populated relations. DRY principle - one path, one place for bugs.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#design","title":"Design","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-1-lightweight-scoring-query","title":"Phase 1: Lightweight Scoring Query","text":"<p>Create a new method for scoring operations that returns minimal data needed:</p> <pre><code>// New method in StashEntityService\nasync getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n  // Returns: { id, performerIds, tagIds, studioId, oCounter, date }\n  // Single efficient query joining scene + junction tables\n  // No full entity hydration - just IDs for scoring\n}\n</code></pre> <p>This supports Similar Scenes and Recommended Scenes which need to score all scenes but only need IDs for the scoring logic.</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-2-consolidate-to-scenequerybuilder","title":"Phase 2: Consolidate to SceneQueryBuilder","text":"<p>All scene queries that return <code>NormalizedScene[]</code> go through <code>SceneQueryBuilder</code>, which already has <code>populateRelations()</code>.</p> <p>Methods to remove from StashEntityService: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code></p> <p>Methods to keep/modify: - <code>getScenesByIds()</code> - Keep, but have it use SceneQueryBuilder internally - <code>getScenesByIdsWithRelations()</code> - Remove, redundant after consolidation</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#phase-3-update-all-callers","title":"Phase 3: Update All Callers","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#similar-scenes-scenests1235","title":"Similar Scenes (<code>scenes.ts:1235</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: 1. Call <code>getScenesForScoring()</code> for lightweight scoring data 2. Score and sort to get top N scene IDs 3. Call <code>SceneQueryBuilder.execute({ filters: { ids } })</code> for final results</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#recommended-scenes-scenests1472","title":"Recommended Scenes (<code>scenes.ts:1472</code>)","text":"<p>Before: Load all scenes, score in memory, paginate After: Same pattern as Similar Scenes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#standard-carousels-carouselts402","title":"Standard Carousels (<code>carousel.ts:402</code>)","text":"<p>Before: <code>getAllScenes()</code> then filter/sort in memory After: <code>SceneQueryBuilder.execute()</code> with appropriate filters</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenes-browse-fallback-scenests994","title":"Scenes Browse Fallback (<code>scenes.ts:994</code>)","text":"<p>Before: <code>getAllScenes()</code> when SQL query builder disabled After: Always use <code>SceneQueryBuilder.execute()</code></p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#entity-visibility-filtering-tagsts-performersts-studiosts","title":"Entity Visibility Filtering (<code>tags.ts</code>, <code>performers.ts</code>, <code>studios.ts</code>)","text":"<p>Before: <code>getAllScenes*()</code> to check which entities have visible scenes After: New dedicated method <code>getVisibleEntityIds(userId, entityType)</code> that queries junction tables directly - doesn't need full scene data</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-enhancements","title":"SceneQueryBuilder Enhancements","text":"<p>Add support for: - Unpaginated mode (for getting all matching IDs) - ID-only mode (returns just scene IDs, no hydration)</p> <pre><code>interface SceneQueryOptions {\n  // ... existing options\n  returnIdsOnly?: boolean;  // Skip hydration, return string[]\n  unpaginated?: boolean;    // Return all matches, no LIMIT\n}\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#data-flow","title":"Data Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Scene Query Requests                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Browse  \u2502  Similar  \u2502  Recommended  \u2502  Carousels  \u2502  Details   \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502           \u2502             \u2502              \u2502            \u2502\n     \u2502           \u25bc             \u25bc              \u2502            \u2502\n     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502            \u2502\n     \u2502    \u2502 getScenesForScoring()   \u2502        \u2502            \u2502\n     \u2502    \u2502 (lightweight IDs only)  \u2502        \u2502            \u2502\n     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u2502                \u25bc                      \u2502            \u2502\n     \u2502         Score &amp; Get IDs              \u2502            \u2502\n     \u2502                \u2502                      \u2502            \u2502\n     \u25bc                \u25bc                      \u25bc            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SceneQueryBuilder.execute()                   \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Build WHERE  \u2502\u2192 \u2502 Execute SQL  \u2502\u2192 \u2502 populateRelations()    \u2502 \u2502\n\u2502  \u2502 clauses      \u2502  \u2502 query        \u2502  \u2502 (batch load relations) \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n                    NormalizedScene[] with\n                    consistent relations\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#migration-checklist","title":"Migration Checklist","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#stashentityservice-changes","title":"StashEntityService Changes","text":"<ul> <li> Add <code>getScenesForScoring()</code> method</li> <li> Add <code>getVisibleSceneIdsByEntity()</code> for entity filtering</li> <li> Deprecate <code>getAllScenes()</code> and variants</li> <li> Update <code>getScenesByIds()</code> to use SceneQueryBuilder</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenequerybuilder-changes","title":"SceneQueryBuilder Changes","text":"<ul> <li> Add <code>returnIdsOnly</code> option</li> <li> Add <code>unpaginated</code> option</li> <li> Ensure all relation types populated (verify galleries, groups)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#controller-updates","title":"Controller Updates","text":"<ul> <li> <code>scenes.ts</code> - findSimilarScenes</li> <li> <code>scenes.ts</code> - getRecommendedScenes</li> <li> <code>scenes.ts</code> - findScenes fallback path</li> <li> <code>carousel.ts</code> - executeCarouselQuery standard path</li> <li> <code>carousel.ts</code> - custom carousel path (verify already correct)</li> <li> <code>tags.ts</code> - enhanceTagsWithPerformerScenes</li> <li> <code>tags.ts</code> - getTagsWithFilters visibility check</li> <li> <code>tags.ts</code> - getTag scene/group counts</li> <li> <code>tags.ts</code> - related tags visibility check</li> <li> <code>performers.ts</code> - getPerformersWithFilters visibility check</li> <li> <code>performers.ts</code> - getPerformer visibility check</li> <li> <code>studios.ts</code> - getStudiosWithFilters visibility check</li> <li> <code>studios.ts</code> - getStudio visibility check</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#testing","title":"Testing","text":"<ul> <li> Similar Scenes shows performer/tag indicators on cards</li> <li> Recommended Scenes shows performer/tag indicators on cards</li> <li> Homepage carousels show indicators</li> <li> Scenes browse works with all filter combinations</li> <li> Entity pages (performers, tags, studios) filter correctly for non-admin users</li> <li> Performance acceptable (measure query times)</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#risks-mitigations","title":"Risks &amp; Mitigations","text":"<p>Risk: Regression in filtering behavior Mitigation: Comprehensive manual testing of all entity pages with non-admin user</p> <p>Risk: Performance degradation from additional relation loading Mitigation: <code>getScenesForScoring()</code> keeps scoring lightweight; only final page of results gets full hydration</p> <p>Risk: Edge cases in SceneQueryBuilder not covered Mitigation: Existing integration tests + add new tests for ID-only and unpaginated modes</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#ui-impact-assessment","title":"UI Impact Assessment","text":""},{"location":"plans/2025-12-16-query-architecture-consolidation/#scenecardjsx-data-requirements","title":"SceneCard.jsx Data Requirements","text":"<p>The frontend expects these fields on every scene object:</p> Field Used For Currently Broken? <code>scene.performers</code> Count indicator + tooltip grid Yes - empty array <code>scene.performers[].tags</code> Squashed tags calculation Yes - empty <code>scene.groups</code> Count indicator + tooltip grid Yes - empty array <code>scene.galleries</code> Count indicator + tooltip grid Yes - empty array <code>scene.tags</code> Count indicator + tooltip grid Yes - empty array <code>scene.studio</code> Subtitle display Yes - null <code>scene.studio.name</code> Studio name in subtitle Yes - null <code>scene.studio.tags</code> Squashed tags calculation Yes - null <code>scene.paths.*</code> Thumbnails, previews No - works <code>scene.files[0].*</code> Duration, resolution No - works <code>scene.rating/favorite/o_counter</code> Rating row No - works <code>scene.play_count</code> Play count indicator No - works <code>scene.resumeTime</code> Progress bar No - works"},{"location":"plans/2025-12-16-query-architecture-consolidation/#affected-ui-components","title":"Affected UI Components","text":"Component Data Source Issue ScenesLikeThis.jsx <code>/api/library/scenes/:id/similar</code> Missing relation data RecommendedSidebar.jsx <code>/api/library/scenes/:id/similar</code> Missing studio data SceneCard.jsx Various endpoints Shows \"0\" for all entity counts Home.jsx carousels Standard carousel endpoints Missing relation data"},{"location":"plans/2025-12-16-query-architecture-consolidation/#verification","title":"Verification","text":"<p>No UI code changes needed. The frontend already expects full scene objects with relations. The consolidation will fix the backend to return complete data.</p> <p>After implementation, verify: - [ ] Scene cards show correct performer counts (not 0) - [ ] Scene cards show correct tag counts (not 0) - [ ] Scene cards show correct group counts (not 0) - [ ] Scene cards show correct gallery counts (not 0) - [ ] Hovering indicators shows entity tooltip grids - [ ] Studio name appears in card subtitles - [ ] Similar Scenes section displays full card data - [ ] Recommended sidebar shows studio names</p>"},{"location":"plans/2025-12-16-query-architecture-consolidation/#out-of-scope-future-work","title":"Out of Scope (Future Work)","text":"<ul> <li>Tag hierarchy normalization (<code>parentIds</code> JSON \u2192 <code>TagRelation</code> table)</li> <li>Alias normalization (performer/tag aliases \u2192 separate tables)</li> <li>Studio hierarchy improvements</li> </ul>"},{"location":"plans/2025-12-16-query-architecture-implementation/","title":"Query Architecture Consolidation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Consolidate all scene queries to use SceneQueryBuilder so every scene object has consistent relations (performers, tags, studio, groups, galleries).</p> <p>Architecture: Two-phase query for scoring operations (lightweight IDs for scoring, then SceneQueryBuilder for final results). All other paths use SceneQueryBuilder directly.</p> <p>Tech Stack: TypeScript, Prisma, SQLite, Vitest</p>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-1-add-scenescoringdata-type","title":"Task 1: Add SceneScoringData Type","text":"<p>Files: - Modify: <code>server/types/entities.ts</code></p> <p>Step 1: Add the type definition</p> <p>Add after the existing type exports (around line 200):</p> <pre><code>/**\n * Lightweight scene data for scoring operations\n * Contains only IDs needed for similarity/recommendation scoring\n */\nexport interface SceneScoringData {\n  id: string;\n  studioId: string | null;\n  performerIds: string[];\n  tagIds: string[];\n  oCounter: number;\n  date: string | null;\n}\n</code></pre> <p>Step 2: Export from index</p> <p>Modify <code>server/types/index.ts</code> to add export:</p> <pre><code>export type {\n  NormalizedScene,\n  NormalizedPerformer,\n  NormalizedStudio,\n  NormalizedTag,\n  NormalizedGallery,\n  NormalizedGroup,\n  SceneScoringData,  // Add this line\n} from \"./entities.js\";\n</code></pre> <p>Step 3: Verify TypeScript compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/types/entities.ts server/types/index.ts\ngit commit -m \"feat: add SceneScoringData type for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-2-add-getscenesforscoring-method","title":"Task 2: Add getScenesForScoring Method","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>server/services/__tests__/StashEntityService.scoring.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, vi } from \"vitest\";\nimport { StashEntityService } from \"../StashEntityService.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: {\n    $queryRawUnsafe: vi.fn(),\n  },\n}));\n\ndescribe(\"StashEntityService.getScenesForScoring\", () =&gt; {\n  let service: StashEntityService;\n\n  beforeEach(() =&gt; {\n    service = new StashEntityService();\n    vi.clearAllMocks();\n  });\n\n  it(\"should return lightweight scoring data for all scenes\", async () =&gt; {\n    const mockRows = [\n      {\n        id: \"scene-1\",\n        studioId: \"studio-1\",\n        oCounter: 5,\n        date: \"2024-01-15\",\n        performerIds: \"perf-1,perf-2\",\n        tagIds: \"tag-1,tag-2,tag-3\",\n      },\n      {\n        id: \"scene-2\",\n        studioId: null,\n        oCounter: 0,\n        date: null,\n        performerIds: \"\",\n        tagIds: \"tag-1\",\n      },\n    ];\n\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue(mockRows);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toHaveLength(2);\n    expect(result[0]).toEqual({\n      id: \"scene-1\",\n      studioId: \"studio-1\",\n      performerIds: [\"perf-1\", \"perf-2\"],\n      tagIds: [\"tag-1\", \"tag-2\", \"tag-3\"],\n      oCounter: 5,\n      date: \"2024-01-15\",\n    });\n    expect(result[1]).toEqual({\n      id: \"scene-2\",\n      studioId: null,\n      performerIds: [],\n      tagIds: [\"tag-1\"],\n      oCounter: 0,\n      date: null,\n    });\n  });\n\n  it(\"should return empty array when no scenes exist\", async () =&gt; {\n    vi.mocked(prisma.$queryRawUnsafe).mockResolvedValue([]);\n\n    const result = await service.getScenesForScoring();\n\n    expect(result).toEqual([]);\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: FAIL with \"getScenesForScoring is not a function\"</p> <p>Step 3: Implement the method</p> <p>Add to <code>server/services/StashEntityService.ts</code> after line 161 (after <code>getAllScenes</code>):</p> <pre><code>  /**\n   * Get lightweight scene data for scoring operations\n   * Returns only IDs needed for similarity/recommendation calculations\n   * Much more efficient than loading full scene objects\n   */\n  async getScenesForScoring(): Promise&lt;SceneScoringData[]&gt; {\n    const startTime = Date.now();\n\n    // Single query that aggregates performer and tag IDs\n    const sql = `\n      SELECT\n        s.id,\n        s.studioId,\n        s.oCounter,\n        s.date,\n        COALESCE(GROUP_CONCAT(DISTINCT sp.performerId), '') as performerIds,\n        COALESCE(GROUP_CONCAT(DISTINCT st.tagId), '') as tagIds\n      FROM StashScene s\n      LEFT JOIN ScenePerformer sp ON s.id = sp.sceneId\n      LEFT JOIN SceneTag st ON s.id = st.sceneId\n      WHERE s.deletedAt IS NULL\n      GROUP BY s.id\n    `;\n\n    const rows = await prisma.$queryRawUnsafe&lt;Array&lt;{\n      id: string;\n      studioId: string | null;\n      oCounter: number;\n      date: string | null;\n      performerIds: string;\n      tagIds: string;\n    }&gt;&gt;(sql);\n\n    const result: SceneScoringData[] = rows.map(row =&gt; ({\n      id: row.id,\n      studioId: row.studioId,\n      performerIds: row.performerIds ? row.performerIds.split(',').filter(Boolean) : [],\n      tagIds: row.tagIds ? row.tagIds.split(',').filter(Boolean) : [],\n      oCounter: row.oCounter || 0,\n      date: row.date,\n    }));\n\n    logger.info(`getScenesForScoring: ${Date.now() - startTime}ms, count=${result.length}`);\n\n    return result;\n  }\n</code></pre> <p>Step 4: Add import for SceneScoringData</p> <p>Update the import at top of <code>StashEntityService.ts</code>:</p> <pre><code>import type {\n  NormalizedGallery,\n  NormalizedGroup,\n  NormalizedPerformer,\n  NormalizedScene,\n  NormalizedStudio,\n  NormalizedTag,\n  SceneScoringData,  // Add this\n} from \"../types/index.js\";\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashEntityService.scoring.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/services/__tests__/StashEntityService.scoring.test.ts\ngit commit -m \"feat: add getScenesForScoring for lightweight scoring queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-3-add-getscenesbyids-to-scenequerybuilder","title":"Task 3: Add getScenesByIds to SceneQueryBuilder","text":"<p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code>:</p> <pre><code>  it(\"should fetch scenes by IDs with full relations\", async () =&gt; {\n    // First get some scene IDs\n    const initial = await sceneQueryBuilder.execute({\n      userId: 1,\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: 3,\n    });\n\n    if (initial.scenes.length &lt; 2) {\n      console.log(\"Skipping getByIds test - not enough scenes\");\n      return;\n    }\n\n    const idsToFetch = initial.scenes.slice(0, 2).map(s =&gt; s.id);\n\n    const result = await sceneQueryBuilder.getByIds({\n      userId: 1,\n      ids: idsToFetch,\n    });\n\n    expect(result.scenes).toHaveLength(2);\n    expect(result.scenes.map(s =&gt; s.id).sort()).toEqual(idsToFetch.sort());\n\n    // Verify relations are populated\n    for (const scene of result.scenes) {\n      expect(scene).toHaveProperty(\"performers\");\n      expect(scene).toHaveProperty(\"tags\");\n      expect(scene).toHaveProperty(\"groups\");\n      expect(scene).toHaveProperty(\"galleries\");\n      expect(Array.isArray(scene.performers)).toBe(true);\n      expect(Array.isArray(scene.tags)).toBe(true);\n    }\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: FAIL with \"getByIds is not a function\"</p> <p>Step 3: Add the interface</p> <p>Add after <code>SceneQueryResult</code> interface (around line 34) in <code>SceneQueryBuilder.ts</code>:</p> <pre><code>// Query by IDs options\nexport interface SceneByIdsOptions {\n  userId: number;\n  ids: string[];\n}\n</code></pre> <p>Step 4: Implement getByIds method</p> <p>Add before the closing brace of the class (around line 1760):</p> <pre><code>  /**\n   * Get scenes by IDs with full relations\n   * Used after scoring to fetch the final paginated results\n   */\n  async getByIds(options: SceneByIdsOptions): Promise&lt;SceneQueryResult&gt; {\n    const { userId, ids } = options;\n\n    if (ids.length === 0) {\n      return { scenes: [], total: 0 };\n    }\n\n    // Use execute with ID filter\n    return this.execute({\n      userId,\n      filters: {\n        ids: { value: ids, modifier: \"INCLUDES\" },\n      },\n      sort: \"created_at\", // Default sort, results will be reordered by caller if needed\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: ids.length, // Get all requested IDs\n    });\n  }\n</code></pre> <p>Step 5: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/services/SceneQueryBuilder.integration.test.ts</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"feat: add getByIds method to SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-4-refactor-findsimilarscenes-to-use-new-architecture","title":"Task 4: Refactor findSimilarScenes to Use New Architecture","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Add imports</p> <p>At top of <code>scenes.ts</code>, add:</p> <pre><code>import { sceneQueryBuilder } from \"../../services/SceneQueryBuilder.js\";\n</code></pre> <p>And update the stashEntityService import to include SceneScoringData type.</p> <p>Step 2: Refactor findSimilarScenes</p> <p>Replace the <code>findSimilarScenes</code> function (lines 1219-1374) with:</p> <pre><code>/**\n * Find similar scenes based on weighted scoring\n * Performers: 3 points each\n * Tags: 1 point each\n * Studio: 1 point\n *\n * Uses two-phase query:\n * 1. Lightweight scoring query to score all scenes\n * 2. SceneQueryBuilder to fetch final results with relations\n */\nexport const findSimilarScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const { id } = req.params;\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = 12;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Get excluded scene IDs for this user\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n\n    // Filter out excluded scenes and current scene\n    const scoringData = allScoringData.filter(\n      s =&gt; s.id !== id &amp;&amp; !excludedIds.has(s.id)\n    );\n\n    // Find the current scene's data\n    const currentScene = allScoringData.find(s =&gt; s.id === id);\n    if (!currentScene) {\n      return res.status(404).json({ error: \"Scene not found\" });\n    }\n\n    // Check if current scene has any metadata\n    const hasMetadata =\n      currentScene.performerIds.length &gt; 0 ||\n      currentScene.studioId ||\n      currentScene.tagIds.length &gt; 0;\n\n    if (!hasMetadata) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n      });\n    }\n\n    // Build sets for fast lookup\n    const currentPerformerIds = new Set(currentScene.performerIds);\n    const currentTagIds = new Set(currentScene.tagIds);\n    const currentStudioId = currentScene.studioId;\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n      date: string | null;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n\n    for (const scene of scoringData) {\n      let score = 0;\n\n      // Score for matching performers (3 points each)\n      for (const performerId of scene.performerIds) {\n        if (currentPerformerIds.has(performerId)) {\n          score += 3;\n        }\n      }\n\n      // Score for matching studio (1 point)\n      if (currentStudioId &amp;&amp; scene.studioId === currentStudioId) {\n        score += 1;\n      }\n\n      // Score for matching tags (1 point each)\n      for (const tagId of scene.tagIds) {\n        if (currentTagIds.has(tagId)) {\n          score += 1;\n        }\n      }\n\n      if (score &gt; 0) {\n        scoredScenes.push({ id: scene.id, score, date: scene.date });\n      }\n    }\n\n    // Sort by score descending, then by date descending\n    scoredScenes.sort((a, b) =&gt; {\n      if (b.score !== a.score) {\n        return b.score - a.score;\n      }\n      const dateA = a.date ? new Date(a.date).getTime() : 0;\n      const dateB = b.date ? new Date(b.date).getTime() : 0;\n      return dateB - dateA;\n    });\n\n    // Paginate\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = scoredScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: scoredScenes.length,\n        page,\n        perPage,\n      });\n    }\n\n    // Phase 2: Fetch full scene data via SceneQueryBuilder\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order (getByIds may return in different order)\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: scoredScenes.length,\n      page,\n      perPage,\n    });\n  } catch (error) {\n    logger.error(\"Error finding similar scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to find similar scenes\" });\n  }\n};\n</code></pre> <p>Step 3: Run the application and test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Open a scene detail page and verify Similar Scenes shows performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: findSimilarScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-5-add-getexcludedsceneids-to-userrestrictionservice","title":"Task 5: Add getExcludedSceneIds to UserRestrictionService","text":"<p>Files: - Modify: <code>server/services/UserRestrictionService.ts</code></p> <p>Step 1: Check if method exists</p> <p>Search for existing <code>getExcludedSceneIds</code> method. If it doesn't exist:</p> <p>Step 2: Add the method</p> <pre><code>  /**\n   * Get set of scene IDs that should be excluded for a user\n   * @param userId - User ID\n   * @param hiddenOnly - If true, only return hidden entities (not content restrictions)\n   */\n  async getExcludedSceneIds(userId: number, hiddenOnly: boolean = false): Promise&lt;Set&lt;string&gt;&gt; {\n    const scenes = await stashEntityService.getAllScenes();\n    const filtered = await this.filterScenesForUser(scenes, userId, hiddenOnly);\n\n    const allIds = new Set(scenes.map(s =&gt; s.id));\n    const visibleIds = new Set(filtered.map(s =&gt; s.id));\n\n    const excludedIds = new Set&lt;string&gt;();\n    for (const id of allIds) {\n      if (!visibleIds.has(id)) {\n        excludedIds.add(id);\n      }\n    }\n\n    return excludedIds;\n  }\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/UserRestrictionService.ts\ngit commit -m \"feat: add getExcludedSceneIds helper method\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-6-refactor-getrecommendedscenes","title":"Task 6: Refactor getRecommendedScenes","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Refactor the function</p> <p>Replace <code>getRecommendedScenes</code> (around line 1380) with similar two-phase pattern:</p> <pre><code>/**\n * Get recommended scenes based on user preferences and watch history\n * Uses favorites, ratings (80+), watch status, and engagement quality\n *\n * Two-phase query:\n * 1. Lightweight scoring data for all scenes\n * 2. SceneQueryBuilder for final paginated results\n */\nexport const getRecommendedScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const page = parseInt(req.query.page as string) || 1;\n    const perPage = parseInt(req.query.per_page as string) || 24;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"User not authenticated\" });\n    }\n\n    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n\n    // Build preference sets\n    const favoritePerformers = new Set(\n      performerRatings.filter(r =&gt; r.favorite).map(r =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter(r =&gt; r.favorite).map(r =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter(r =&gt; r.favorite).map(r =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings.filter(r =&gt; r.rating &amp;&amp; r.rating &gt;= 80).map(r =&gt; r.tagId)\n    );\n\n    // Build watch history map\n    const watchMap = new Map(\n      watchHistory.map(wh =&gt; [\n        wh.sceneId,\n        {\n          playCount: wh.playCount || 0,\n          lastPlayedAt: wh.lastPlayedAt,\n        },\n      ])\n    );\n\n    // Get excluded scene IDs\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, true);\n\n    // Phase 1: Get lightweight scoring data\n    const allScoringData = await stashEntityService.getScenesForScoring();\n    const scoringData = allScoringData.filter(s =&gt; !excludedIds.has(s.id));\n\n    // Count criteria for feedback\n    const criteriaCounts = {\n      favoritePerformers: favoritePerformers.size,\n      highlyRatedPerformers: highlyRatedPerformers.size,\n      favoriteStudios: favoriteStudios.size,\n      highlyRatedStudios: highlyRatedStudios.size,\n      favoriteTags: favoriteTags.size,\n      highlyRatedTags: highlyRatedTags.size,\n    };\n\n    // Score all scenes\n    interface ScoredScene {\n      id: string;\n      score: number;\n    }\n\n    const scoredScenes: ScoredScene[] = [];\n    const now = new Date();\n\n    for (const scene of scoringData) {\n      let baseScore = 0;\n\n      // Score performers\n      for (const performerId of scene.performerIds) {\n        if (favoritePerformers.has(performerId)) {\n          baseScore += 50;\n        } else if (highlyRatedPerformers.has(performerId)) {\n          baseScore += 30;\n        }\n      }\n\n      // Score studio\n      if (scene.studioId) {\n        if (favoriteStudios.has(scene.studioId)) {\n          baseScore += 25;\n        } else if (highlyRatedStudios.has(scene.studioId)) {\n          baseScore += 15;\n        }\n      }\n\n      // Score tags\n      for (const tagId of scene.tagIds) {\n        if (favoriteTags.has(tagId)) {\n          baseScore += 10;\n        } else if (highlyRatedTags.has(tagId)) {\n          baseScore += 5;\n        }\n      }\n\n      if (baseScore === 0) continue;\n\n      // Watch status modifier\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        adjustedScore += 30; // Never watched bonus\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) / (24 * 60 * 60 * 1000);\n        if (daysSinceWatched &gt; 14) {\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          adjustedScore -= 10;\n        } else {\n          adjustedScore -= 30; // Very recently watched penalty\n        }\n      }\n\n      // Engagement multiplier\n      const engagementMultiplier = 1.0 + Math.min(scene.oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ id: scene.id, score: finalScore });\n      }\n    }\n\n    // Sort by score descending\n    scoredScenes.sort((a, b) =&gt; b.score - a.score);\n\n    // Cap at 500 and paginate\n    const cappedScenes = scoredScenes.slice(0, 500);\n    const startIndex = (page - 1) * perPage;\n    const paginatedIds = cappedScenes\n      .slice(startIndex, startIndex + perPage)\n      .map(s =&gt; s.id);\n\n    if (paginatedIds.length === 0) {\n      return res.json({\n        scenes: [],\n        count: cappedScenes.length,\n        page,\n        perPage,\n        criteria: criteriaCounts,\n      });\n    }\n\n    // Phase 2: Fetch full scene data\n    const { scenes } = await sceneQueryBuilder.getByIds({\n      userId,\n      ids: paginatedIds,\n    });\n\n    // Preserve score order\n    const sceneMap = new Map(scenes.map(s =&gt; [s.id, s]));\n    const orderedScenes = paginatedIds\n      .map(id =&gt; sceneMap.get(id))\n      .filter((s): s is NormalizedScene =&gt; s !== undefined);\n\n    res.json({\n      scenes: orderedScenes,\n      count: cappedScenes.length,\n      page,\n      perPage,\n      criteria: criteriaCounts,\n    });\n  } catch (error) {\n    logger.error(\"Error getting recommended scenes:\", { error: error as Error });\n    res.status(500).json({ error: \"Failed to get recommendations\" });\n  }\n};\n</code></pre> <p>Step 2: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Check homepage Recommended section shows performer/tag counts</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"refactor: getRecommendedScenes uses two-phase query architecture\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-7-refactor-standard-carousels","title":"Task 7: Refactor Standard Carousels","text":"<p>Files: - Modify: <code>server/controllers/carousel.ts</code></p> <p>Step 1: Find executeCarouselQuery function</p> <p>Locate the <code>executeCarouselQuery</code> function that uses <code>getAllScenes()</code>.</p> <p>Step 2: Refactor to use SceneQueryBuilder</p> <p>Replace the <code>getAllScenes()</code> path with SceneQueryBuilder. The function should: 1. Build filters from carousel query 2. Call <code>sceneQueryBuilder.execute()</code> 3. Return scenes with full relations</p> <p>Step 3: Test manually</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code> Test: Homepage carousels show performer/tag counts</p> <p>Step 4: Commit</p> <pre><code>git add server/controllers/carousel.ts\ngit commit -m \"refactor: standard carousels use SceneQueryBuilder\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-8-remove-deprecated-methods","title":"Task 8: Remove Deprecated Methods","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Mark methods as deprecated</p> <p>Add JSDoc <code>@deprecated</code> tags to: - <code>getAllScenes()</code> - <code>getAllScenesWithTags()</code> - <code>getAllScenesWithPerformers()</code> - <code>getAllScenesWithPerformersAndTags()</code> - <code>getScenesPaginated()</code> - <code>getScenesByIdsWithRelations()</code></p> <p>Step 2: Update remaining callers</p> <p>Search for any remaining usages and update them to use SceneQueryBuilder or <code>getScenesForScoring()</code>.</p> <p>Step 3: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: deprecate old scene query methods, update remaining callers\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-9-update-entity-visibility-filtering","title":"Task 9: Update Entity Visibility Filtering","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code> - Modify: <code>server/controllers/library/tags.ts</code> - Modify: <code>server/controllers/library/studios.ts</code></p> <p>Step 1: Create getVisibleSceneIdsByEntity method</p> <p>Add to <code>StashEntityService.ts</code>:</p> <pre><code>  /**\n   * Get scene IDs visible to a user, grouped by entity type\n   * Used for empty entity filtering without loading full scenes\n   */\n  async getVisibleSceneIdsByPerformer(userId: number): Promise&lt;Map&lt;string, Set&lt;string&gt;&gt;&gt; {\n    const excludedIds = await userRestrictionService.getExcludedSceneIds(userId, false);\n\n    const junctions = await prisma.scenePerformer.findMany({\n      where: {\n        scene: { deletedAt: null },\n        sceneId: { notIn: Array.from(excludedIds) },\n      },\n      select: { sceneId: true, performerId: true },\n    });\n\n    const result = new Map&lt;string, Set&lt;string&gt;&gt;();\n    for (const j of junctions) {\n      const set = result.get(j.performerId) || new Set();\n      set.add(j.sceneId);\n      result.set(j.performerId, set);\n    }\n\n    return result;\n  }\n</code></pre> <p>Step 2: Update performers.ts visibility checks</p> <p>Replace <code>getAllScenesWithPerformers()</code> calls with the new method.</p> <p>Step 3: Test manually</p> <p>Test non-admin user can browse performers page correctly.</p> <p>Step 4: Commit</p> <pre><code>git add -A\ngit commit -m \"refactor: entity visibility uses direct junction queries\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#task-10-final-cleanup-and-testing","title":"Task 10: Final Cleanup and Testing","text":"<p>Files: - All modified files</p> <p>Step 1: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Manual verification checklist</p> <ul> <li> Scene cards show correct performer counts (not 0)</li> <li> Scene cards show correct tag counts (not 0)</li> <li> Scene cards show correct group counts (not 0)</li> <li> Scene cards show correct gallery counts (not 0)</li> <li> Hovering indicators shows entity tooltip grids</li> <li> Studio name appears in card subtitles</li> <li> Similar Scenes section displays full card data</li> <li> Recommended sidebar shows studio names</li> <li> Homepage carousels show full card data</li> <li> Scenes browse works with filters</li> <li> Non-admin user filtering works correctly</li> </ul> <p>Step 4: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: query architecture consolidation complete\"\n</code></pre>"},{"location":"plans/2025-12-16-query-architecture-implementation/#summary","title":"Summary","text":"<p>This plan consolidates all scene queries to use <code>SceneQueryBuilder</code>, ensuring consistent scene objects with populated relations. The key changes are:</p> <ol> <li>New <code>getScenesForScoring()</code> - Lightweight query for scoring operations</li> <li>New <code>getByIds()</code> on SceneQueryBuilder - Fetch specific scenes with relations</li> <li>Two-phase query pattern - Score with lightweight data, fetch with full relations</li> <li>Deprecated old methods - <code>getAllScenes*()</code> variants marked deprecated</li> <li>Direct junction queries - For entity visibility filtering</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/","title":"Recommendations Improvements Design","text":"<p>Date: 2025-12-16 Branch: <code>feature/recommendations-improvements</code> Related Issues: #181, #172</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#problem-statement","title":"Problem Statement","text":"<p>Users report the Recommended page shows no content despite having favorited/rated scenes. The current algorithm only considers explicit Performer, Studio, and Tag ratings\u2014not Scene ratings. Users naturally rate scenes first, leading to confusion when recommendations don't appear.</p> <p>Additionally, error messages are unhelpful and logging doesn't capture enough detail to diagnose issues.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#design-overview","title":"Design Overview","text":"<p>Four improvements:</p> <ol> <li>Scene-based recommendations - Derive entity preferences from rated/favorited scenes</li> <li>Inline user feedback - Show users what's missing when recommendations are empty</li> <li>Better error handling - Improved logging and user-facing error messages</li> <li>Unit tests - Test coverage for recommendation scoring logic</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#1-scene-based-recommendations","title":"1. Scene-Based Recommendations","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#concept","title":"Concept","text":"<p>When a user favorites or rates a scene highly, we extract its entities (performers, studio, tags) and add them to the preference pool with diminished weights compared to explicit entity ratings.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-formula","title":"Weight Formula","text":"<pre><code>// Skip scenes rated below threshold\nif (sceneRating &lt; 40) continue;\n\n// Favorited-only scenes get implicit rating\nconst effectiveRating = sceneRating ?? (isFavorited ? 85 : null);\nif (effectiveRating === null) continue;\n\n// Calculate weight multiplier\nconst BASE_WEIGHT = 0.4;\nconst FAVORITE_BONUS = 0.15;\n\nlet weightMultiplier = (effectiveRating / 100) * BASE_WEIGHT;\nif (isFavorited) {\n  weightMultiplier += FAVORITE_BONUS;\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#weight-examples","title":"Weight Examples","text":"Scenario Multiplier Performer pts vs Explicit (5 pts) Scene rated 100 + favorited 0.55 2.75 55% Scene favorited only (\u219285) 0.49 2.45 49% Scene rated 100, not fav 0.40 2.00 40% Scene rated 80 + favorited 0.47 2.35 47% Scene rated 80, not fav 0.32 1.60 32% Scene rated 60, not fav 0.24 1.20 24% Scene rated 40, not fav 0.16 0.80 16% Scene rated 39 - 0 (skipped) -"},{"location":"plans/2025-12-16-recommendations-improvements-design/#implementation","title":"Implementation","text":"<p>In <code>getRecommendedScenes()</code>:</p> <ol> <li>Fetch <code>sceneRatings</code> alongside existing performer/studio/tag ratings</li> <li>Build derived preference maps from favorited/rated scenes:</li> <li><code>derivedPerformerWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedStudioWeights: Map&lt;string, number&gt;</code></li> <li><code>derivedTagWeights: Map&lt;string, number&gt;</code></li> <li>When scoring, combine explicit preferences with derived weights</li> <li>Apply same sqrt diminishing returns to derived weights</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#derived-weight-accumulation","title":"Derived Weight Accumulation","text":"<p>When multiple scenes contribute to the same entity, weights accumulate but with diminishing returns:</p> <pre><code>// For each scene's performer\nconst sceneWeight = calculateSceneWeight(scene);\nconst currentWeight = derivedPerformerWeights.get(performerId) || 0;\nderivedPerformerWeights.set(performerId, currentWeight + sceneWeight);\n\n// When scoring, apply sqrt to accumulated derived weights\nconst derivedPerformerScore = Math.sqrt(derivedPerformerWeight) * 5;\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#2-inline-user-feedback","title":"2. Inline User Feedback","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#empty-state-message","title":"Empty State Message","text":"<p>When recommendations return empty, the API response includes diagnostic info:</p> <pre><code>// Response structure\n{\n  scenes: [],\n  count: 0,\n  page: 1,\n  perPage: 24,\n  message: \"No recommendations yet\",\n  criteria: {\n    favoritedPerformers: 0,\n    ratedPerformers: 0,\n    favoritedStudios: 0,\n    ratedStudios: 0,\n    favoritedTags: 0,\n    ratedTags: 0,\n    favoritedScenes: 3,\n    ratedScenes: 5\n  }\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-display","title":"Client Display","text":"<p>The Recommended page shows:</p> <p>No Recommendations Yet</p> <p>To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.</p> <p>Your current activity: - 0 favorited performers, 0 highly-rated performers - 0 favorited studios, 0 highly-rated studios - 0 favorited tags, 0 highly-rated tags - 3 favorited scenes, 5 rated scenes</p> <p>Tip: Rating more scenes helps us learn your preferences!</p> <p>If they have scene activity but no results, clarify:</p> <p>We're analyzing your rated scenes to find recommendations...</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#3-better-error-handling","title":"3. Better Error Handling","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#server-side-logging","title":"Server-Side Logging","text":"<p>Update the catch block to capture full error details:</p> <pre><code>catch (error) {\n  const err = error as Error;\n  logger.error(\"Error getting recommended scenes:\", {\n    message: err.message,\n    name: err.name,\n    stack: err.stack,\n    userId,\n  });\n\n  const errorType = err.name || \"Unknown error\";\n  res.status(500).json({\n    error: \"Failed to get recommended scenes\",\n    errorType\n  });\n}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#client-side-display","title":"Client-Side Display","text":"<pre><code>{error &amp;&amp; (\n  &lt;ErrorMessage&gt;\n    Unable to load recommendations. ({error.errorType || \"Please try again later\"})\n  &lt;/ErrorMessage&gt;\n)}\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#4-unit-tests","title":"4. Unit Tests","text":""},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-file","title":"Test File","text":"<p>Create <code>server/tests/recommendations/recommendationScoring.test.ts</code></p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#test-cases","title":"Test Cases","text":"<p>Explicit entity scoring: - Favorited performer adds 5 points - Highly-rated performer (80+) adds 3 points - Favorited studio adds 3 points - Multiple performers use sqrt diminishing returns</p> <p>Scene-derived scoring: - Scene rated 100 derives 40% weight for entities - Scene rated 100 + favorited derives 55% weight - Scene favorited only uses implicit rating of 85 - Scene rated &lt; 40 contributes nothing - Multiple scenes for same performer accumulate with sqrt</p> <p>Edge cases: - User with no ratings/favorites returns empty with message - User with only scene ratings (no explicit) still gets recommendations - Scene with no performers/studio/tags contributes nothing - Combination of explicit + derived preferences</p> <p>Weight calculation: - <code>calculateSceneWeight(100, true)</code> returns 0.55 - <code>calculateSceneWeight(85, false)</code> returns 0.34 - <code>calculateSceneWeight(39, false)</code> returns 0 (below floor)</p>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#files-to-modify","title":"Files to Modify","text":"File Changes <code>server/controllers/library/scenes.ts</code> Update <code>getRecommendedScenes()</code> with scene-derived scoring, criteria response, error handling <code>client/src/components/pages/Recommended.jsx</code> Display criteria counts in empty state, show error type <code>server/tests/recommendations/recommendationScoring.test.ts</code> New test file"},{"location":"plans/2025-12-16-recommendations-improvements-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Negative signals from low-rated scenes (future enhancement)</li> <li>Collaborative filtering (\"users like you also liked\")</li> <li>Watch time / percentage watched as signal</li> <li>Admin diagnostic endpoint (replaced by inline feedback)</li> </ul>"},{"location":"plans/2025-12-16-recommendations-improvements-design/#testing-plan","title":"Testing Plan","text":"<ol> <li>Unit tests pass for scoring logic</li> <li>Manual test: User with only scene favorites sees recommendations</li> <li>Manual test: Empty state shows correct criteria counts</li> <li>Manual test: Error state shows error type</li> <li>Verify existing explicit-rating users still get correct recommendations</li> </ol>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/","title":"Recommendations Improvements Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Enable scene-based recommendations, add inline user feedback, improve error handling, and add unit tests.</p> <p>Architecture: Extract a pure <code>RecommendationScoringService</code> from the controller to make scoring logic testable. The service calculates entity weights from both explicit ratings and scene-derived preferences. Controller handles HTTP concerns only.</p> <p>Tech Stack: TypeScript, Vitest, Prisma, React</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-1-extract-recommendation-scoring-service","title":"Task 1: Extract Recommendation Scoring Service","text":"<p>Create a pure service with testable scoring functions.</p> <p>Files: - Create: <code>server/services/RecommendationScoringService.ts</code></p> <p>Step 1: Create the service file with types and constants</p> <pre><code>// server/services/RecommendationScoringService.ts\nimport type { NormalizedScene } from \"../types/index.js\";\n\n// Configuration constants\nexport const SCENE_WEIGHT_BASE = 0.4;\nexport const SCENE_WEIGHT_FAVORITE_BONUS = 0.15;\nexport const SCENE_RATING_FLOOR = 40;\nexport const SCENE_FAVORITED_IMPLICIT_RATING = 85;\n\n// Explicit entity scoring weights (from current algorithm)\nexport const PERFORMER_FAVORITE_WEIGHT = 5;\nexport const PERFORMER_RATED_WEIGHT = 3;\nexport const STUDIO_FAVORITE_WEIGHT = 3;\nexport const STUDIO_RATED_WEIGHT = 2;\nexport const TAG_SCENE_FAVORITE_WEIGHT = 1.0;\nexport const TAG_SCENE_RATED_WEIGHT = 0.5;\nexport const TAG_PERFORMER_FAVORITE_WEIGHT = 0.3;\nexport const TAG_PERFORMER_RATED_WEIGHT = 0.15;\nexport const TAG_STUDIO_FAVORITE_WEIGHT = 0.5;\nexport const TAG_STUDIO_RATED_WEIGHT = 0.25;\n\nexport interface SceneRatingInput {\n  sceneId: string;\n  rating: number | null;\n  favorite: boolean;\n}\n\nexport interface EntityPreferences {\n  favoritePerformers: Set&lt;string&gt;;\n  highlyRatedPerformers: Set&lt;string&gt;;\n  favoriteStudios: Set&lt;string&gt;;\n  highlyRatedStudios: Set&lt;string&gt;;\n  favoriteTags: Set&lt;string&gt;;\n  highlyRatedTags: Set&lt;string&gt;;\n  // Derived weights from scenes (accumulated per entity)\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n}\n\nexport interface UserCriteriaCounts {\n  favoritedPerformers: number;\n  ratedPerformers: number;\n  favoritedStudios: number;\n  ratedStudios: number;\n  favoritedTags: number;\n  ratedTags: number;\n  favoritedScenes: number;\n  ratedScenes: number;\n}\n\n/**\n * Calculate weight multiplier for a scene based on rating and favorite status\n * Returns 0 if scene should be skipped (below floor, no rating/favorite)\n */\nexport function calculateSceneWeightMultiplier(\n  rating: number | null,\n  favorite: boolean\n): number {\n  // Determine effective rating\n  let effectiveRating: number | null = rating;\n\n  if (effectiveRating === null &amp;&amp; favorite) {\n    effectiveRating = SCENE_FAVORITED_IMPLICIT_RATING;\n  }\n\n  if (effectiveRating === null) {\n    return 0;\n  }\n\n  if (effectiveRating &lt; SCENE_RATING_FLOOR) {\n    return 0;\n  }\n\n  let multiplier = (effectiveRating / 100) * SCENE_WEIGHT_BASE;\n\n  if (favorite) {\n    multiplier += SCENE_WEIGHT_FAVORITE_BONUS;\n  }\n\n  return multiplier;\n}\n\n/**\n * Build derived entity weights from rated/favorited scenes\n */\nexport function buildDerivedWeightsFromScenes(\n  sceneRatings: SceneRatingInput[],\n  getSceneById: (sceneId: string) =&gt; NormalizedScene | undefined\n): {\n  derivedPerformerWeights: Map&lt;string, number&gt;;\n  derivedStudioWeights: Map&lt;string, number&gt;;\n  derivedTagWeights: Map&lt;string, number&gt;;\n} {\n  const derivedPerformerWeights = new Map&lt;string, number&gt;();\n  const derivedStudioWeights = new Map&lt;string, number&gt;();\n  const derivedTagWeights = new Map&lt;string, number&gt;();\n\n  for (const sceneRating of sceneRatings) {\n    const multiplier = calculateSceneWeightMultiplier(\n      sceneRating.rating,\n      sceneRating.favorite\n    );\n\n    if (multiplier === 0) continue;\n\n    const scene = getSceneById(sceneRating.sceneId);\n    if (!scene) continue;\n\n    // Accumulate performer weights\n    if (scene.performers) {\n      for (const performer of scene.performers) {\n        const performerId = String(performer.id);\n        const current = derivedPerformerWeights.get(performerId) || 0;\n        derivedPerformerWeights.set(performerId, current + multiplier);\n      }\n    }\n\n    // Accumulate studio weight\n    if (scene.studio) {\n      const studioId = String(scene.studio.id);\n      const current = derivedStudioWeights.get(studioId) || 0;\n      derivedStudioWeights.set(studioId, current + multiplier);\n    }\n\n    // Accumulate tag weights (scene tags only, not performer/studio tags)\n    if (scene.tags) {\n      for (const tag of scene.tags) {\n        const tagId = String(tag.id);\n        const current = derivedTagWeights.get(tagId) || 0;\n        derivedTagWeights.set(tagId, current + multiplier);\n      }\n    }\n  }\n\n  return {\n    derivedPerformerWeights,\n    derivedStudioWeights,\n    derivedTagWeights,\n  };\n}\n\n/**\n * Score a scene based on user preferences (explicit + derived)\n * Returns the base score before watch status modifiers\n */\nexport function scoreSceneByPreferences(\n  scene: NormalizedScene,\n  prefs: EntityPreferences\n): number {\n  let baseScore = 0;\n\n  // Score performers with diminishing returns (sqrt scaling)\n  if (scene.performers) {\n    let favoritePerformerCount = 0;\n    let highlyRatedPerformerCount = 0;\n    let derivedPerformerWeight = 0;\n\n    for (const performer of scene.performers) {\n      const performerId = String(performer.id);\n\n      if (prefs.favoritePerformers.has(performerId)) {\n        favoritePerformerCount++;\n      } else if (prefs.highlyRatedPerformers.has(performerId)) {\n        highlyRatedPerformerCount++;\n      }\n\n      // Add derived weight\n      const derived = prefs.derivedPerformerWeights.get(performerId);\n      if (derived) {\n        derivedPerformerWeight += derived;\n      }\n    }\n\n    if (favoritePerformerCount &gt; 0) {\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerCount);\n    }\n    if (highlyRatedPerformerCount &gt; 0) {\n      baseScore += PERFORMER_RATED_WEIGHT * Math.sqrt(highlyRatedPerformerCount);\n    }\n    if (derivedPerformerWeight &gt; 0) {\n      // Apply sqrt to accumulated derived weight, scale by favorite weight\n      baseScore += PERFORMER_FAVORITE_WEIGHT * Math.sqrt(derivedPerformerWeight);\n    }\n  }\n\n  // Score studio\n  if (scene.studio) {\n    const studioId = String(scene.studio.id);\n\n    if (prefs.favoriteStudios.has(studioId)) {\n      baseScore += STUDIO_FAVORITE_WEIGHT;\n    } else if (prefs.highlyRatedStudios.has(studioId)) {\n      baseScore += STUDIO_RATED_WEIGHT;\n    }\n\n    // Add derived studio weight\n    const derivedStudio = prefs.derivedStudioWeights.get(studioId);\n    if (derivedStudio) {\n      baseScore += STUDIO_FAVORITE_WEIGHT * Math.sqrt(derivedStudio);\n    }\n  }\n\n  // Score tags with source weighting\n  const sceneTags = new Set&lt;string&gt;();\n  const performerTags = new Set&lt;string&gt;();\n  const studioTags = new Set&lt;string&gt;();\n\n  (scene.tags || []).forEach((t) =&gt; sceneTags.add(String(t.id)));\n  (scene.performers || []).forEach((p) =&gt; {\n    (p.tags || []).forEach((t) =&gt; performerTags.add(String(t.id)));\n  });\n  if (scene.studio?.tags) {\n    scene.studio.tags.forEach((t) =&gt; studioTags.add(String(t.id)));\n  }\n\n  let favoriteSceneTagCount = 0;\n  let favoritePerformerTagCount = 0;\n  let favoriteStudioTagCount = 0;\n  let ratedSceneTagCount = 0;\n  let ratedPerformerTagCount = 0;\n  let ratedStudioTagCount = 0;\n  let derivedTagWeight = 0;\n\n  for (const tagId of sceneTags) {\n    if (prefs.favoriteTags.has(tagId)) favoriteSceneTagCount++;\n    else if (prefs.highlyRatedTags.has(tagId)) ratedSceneTagCount++;\n\n    const derived = prefs.derivedTagWeights.get(tagId);\n    if (derived) derivedTagWeight += derived;\n  }\n\n  for (const tagId of performerTags) {\n    if (!sceneTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoritePerformerTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedPerformerTagCount++;\n    }\n  }\n\n  for (const tagId of studioTags) {\n    if (!sceneTags.has(tagId) &amp;&amp; !performerTags.has(tagId)) {\n      if (prefs.favoriteTags.has(tagId)) favoriteStudioTagCount++;\n      else if (prefs.highlyRatedTags.has(tagId)) ratedStudioTagCount++;\n    }\n  }\n\n  if (favoriteSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(favoriteSceneTagCount);\n  }\n  if (favoritePerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_FAVORITE_WEIGHT * Math.sqrt(favoritePerformerTagCount);\n  }\n  if (favoriteStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_FAVORITE_WEIGHT * Math.sqrt(favoriteStudioTagCount);\n  }\n  if (ratedSceneTagCount &gt; 0) {\n    baseScore += TAG_SCENE_RATED_WEIGHT * Math.sqrt(ratedSceneTagCount);\n  }\n  if (ratedPerformerTagCount &gt; 0) {\n    baseScore += TAG_PERFORMER_RATED_WEIGHT * Math.sqrt(ratedPerformerTagCount);\n  }\n  if (ratedStudioTagCount &gt; 0) {\n    baseScore += TAG_STUDIO_RATED_WEIGHT * Math.sqrt(ratedStudioTagCount);\n  }\n  if (derivedTagWeight &gt; 0) {\n    baseScore += TAG_SCENE_FAVORITE_WEIGHT * Math.sqrt(derivedTagWeight);\n  }\n\n  return baseScore;\n}\n\n/**\n * Count user's criteria for feedback display\n */\nexport function countUserCriteria(\n  performerRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  studioRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  tagRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;,\n  sceneRatings: Array&lt;{ favorite: boolean; rating: number | null }&gt;\n): UserCriteriaCounts {\n  return {\n    favoritedPerformers: performerRatings.filter((r) =&gt; r.favorite).length,\n    ratedPerformers: performerRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedStudios: studioRatings.filter((r) =&gt; r.favorite).length,\n    ratedStudios: studioRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedTags: tagRatings.filter((r) =&gt; r.favorite).length,\n    ratedTags: tagRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80).length,\n    favoritedScenes: sceneRatings.filter((r) =&gt; r.favorite).length,\n    ratedScenes: sceneRatings.filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= SCENE_RATING_FLOOR).length,\n  };\n}\n\n/**\n * Check if user has any criteria that could generate recommendations\n */\nexport function hasAnyCriteria(counts: UserCriteriaCounts): boolean {\n  return (\n    counts.favoritedPerformers &gt; 0 ||\n    counts.ratedPerformers &gt; 0 ||\n    counts.favoritedStudios &gt; 0 ||\n    counts.ratedStudios &gt; 0 ||\n    counts.favoritedTags &gt; 0 ||\n    counts.ratedTags &gt; 0 ||\n    counts.favoritedScenes &gt; 0 ||\n    counts.ratedScenes &gt; 0\n  );\n}\n</code></pre> <p>Step 2: Run TypeScript compiler to verify no errors</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/services/RecommendationScoringService.ts\ngit commit -m \"feat: extract RecommendationScoringService with scoring logic\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-2-unit-tests-for-scene-weight-calculation","title":"Task 2: Unit Tests for Scene Weight Calculation","text":"<p>Files: - Create: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Create test file with weight calculation tests</p> <pre><code>// server/tests/recommendations/recommendationScoring.test.ts\nimport { describe, it, expect } from \"vitest\";\nimport {\n  calculateSceneWeightMultiplier,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n} from \"../../services/RecommendationScoringService.js\";\n\ndescribe(\"RecommendationScoringService\", () =&gt; {\n  describe(\"calculateSceneWeightMultiplier\", () =&gt; {\n    it(\"returns 0 for null rating without favorite\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(null, false)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for favorited-only scene (implicit 85)\", () =&gt; {\n      const expected = (SCENE_FAVORITED_IMPLICIT_RATING / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(expected, 5);\n      // Should be ~0.49 (0.34 + 0.15)\n      expect(calculateSceneWeightMultiplier(null, true)).toBeCloseTo(0.49, 2);\n    });\n\n    it(\"returns 0 for rating below floor (39)\", () =&gt; {\n      expect(calculateSceneWeightMultiplier(39, false)).toBe(0);\n      expect(calculateSceneWeightMultiplier(39, true)).toBe(0);\n    });\n\n    it(\"returns correct multiplier for rating at floor (40)\", () =&gt; {\n      const expected = (40 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(expected, 5);\n      // Should be 0.16\n      expect(calculateSceneWeightMultiplier(40, false)).toBeCloseTo(0.16, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 without favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(expected, 5);\n      // Should be 0.40\n      expect(calculateSceneWeightMultiplier(100, false)).toBeCloseTo(0.40, 2);\n    });\n\n    it(\"returns correct multiplier for rating 100 with favorite\", () =&gt; {\n      const expected = (100 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(expected, 5);\n      // Should be 0.55\n      expect(calculateSceneWeightMultiplier(100, true)).toBeCloseTo(0.55, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 without favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(expected, 5);\n      // Should be 0.32\n      expect(calculateSceneWeightMultiplier(80, false)).toBeCloseTo(0.32, 2);\n    });\n\n    it(\"returns correct multiplier for rating 80 with favorite\", () =&gt; {\n      const expected = (80 / 100) * SCENE_WEIGHT_BASE + SCENE_WEIGHT_FAVORITE_BONUS;\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(expected, 5);\n      // Should be 0.47\n      expect(calculateSceneWeightMultiplier(80, true)).toBeCloseTo(0.47, 2);\n    });\n\n    it(\"returns correct multiplier for rating 60 without favorite\", () =&gt; {\n      const expected = (60 / 100) * SCENE_WEIGHT_BASE;\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(expected, 5);\n      // Should be 0.24\n      expect(calculateSceneWeightMultiplier(60, false)).toBeCloseTo(0.24, 2);\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene weight calculation\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-3-unit-tests-for-derived-weights-and-scoring","title":"Task 3: Unit Tests for Derived Weights and Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for buildDerivedWeightsFromScenes</p> <p>Add to the existing test file:</p> <pre><code>import {\n  calculateSceneWeightMultiplier,\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  SCENE_WEIGHT_BASE,\n  SCENE_WEIGHT_FAVORITE_BONUS,\n  SCENE_RATING_FLOOR,\n  SCENE_FAVORITED_IMPLICIT_RATING,\n  PERFORMER_FAVORITE_WEIGHT,\n  type SceneRatingInput,\n  type EntityPreferences,\n} from \"../../services/RecommendationScoringService.js\";\nimport type { NormalizedScene } from \"../../types/index.js\";\n\n// ... existing tests ...\n\ndescribe(\"buildDerivedWeightsFromScenes\", () =&gt; {\n  const mockScene1: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene 1\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" },\n      { id: \"perf2\", name: \"Performer 2\" },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\" },\n    tags: [\n      { id: \"tag1\", name: \"Tag 1\" },\n      { id: \"tag2\", name: \"Tag 2\" },\n    ],\n  } as NormalizedScene;\n\n  const mockScene2: NormalizedScene = {\n    id: \"scene2\",\n    title: \"Test Scene 2\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\" }, // Same performer\n      { id: \"perf3\", name: \"Performer 3\" },\n    ],\n    studio: { id: \"studio2\", name: \"Studio 2\" },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }], // Same tag\n  } as NormalizedScene;\n\n  const sceneMap = new Map&lt;string, NormalizedScene&gt;([\n    [\"scene1\", mockScene1],\n    [\"scene2\", mockScene2],\n  ]);\n\n  const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n  it(\"extracts performer weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts studio weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedStudioWeights.get(\"studio1\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"extracts tag weights from rated scene\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedTagWeights.get(\"tag1\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedTagWeights.get(\"tag2\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"accumulates weights for same entity across multiple scenes\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 100, favorite: false }, // perf1: 0.4\n      { sceneId: \"scene2\", rating: 100, favorite: false }, // perf1: +0.4 = 0.8\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.8, 2);\n    expect(result.derivedPerformerWeights.get(\"perf2\")).toBeCloseTo(0.4, 2);\n    expect(result.derivedPerformerWeights.get(\"perf3\")).toBeCloseTo(0.4, 2);\n  });\n\n  it(\"skips scenes rated below floor\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: 39, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n    expect(result.derivedStudioWeights.size).toBe(0);\n    expect(result.derivedTagWeights.size).toBe(0);\n  });\n\n  it(\"handles favorited-only scenes with implicit rating\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"scene1\", rating: null, favorite: true },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    // Implicit 85 + favorite bonus = 0.49\n    expect(result.derivedPerformerWeights.get(\"perf1\")).toBeCloseTo(0.49, 2);\n  });\n\n  it(\"handles scene not found in cache\", () =&gt; {\n    const sceneRatings: SceneRatingInput[] = [\n      { sceneId: \"nonexistent\", rating: 100, favorite: false },\n    ];\n\n    const result = buildDerivedWeightsFromScenes(sceneRatings, getSceneById);\n\n    expect(result.derivedPerformerWeights.size).toBe(0);\n  });\n});\n\ndescribe(\"countUserCriteria\", () =&gt; {\n  it(\"counts favorited and rated entities correctly\", () =&gt; {\n    const performerRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 85 },\n      { favorite: false, rating: 70 }, // Below 80, not counted as rated\n    ];\n    const studioRatings = [{ favorite: true, rating: 90 }];\n    const tagRatings = [\n      { favorite: false, rating: 80 },\n      { favorite: false, rating: 80 },\n    ];\n    const sceneRatings = [\n      { favorite: true, rating: null },\n      { favorite: false, rating: 50 },\n      { favorite: false, rating: 30 }, // Below 40, not counted\n    ];\n\n    const counts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    expect(counts.favoritedPerformers).toBe(1);\n    expect(counts.ratedPerformers).toBe(1);\n    expect(counts.favoritedStudios).toBe(1);\n    expect(counts.ratedStudios).toBe(1);\n    expect(counts.favoritedTags).toBe(0);\n    expect(counts.ratedTags).toBe(2);\n    expect(counts.favoritedScenes).toBe(1);\n    expect(counts.ratedScenes).toBe(1); // Only rating &gt;= 40 counts\n  });\n});\n\ndescribe(\"hasAnyCriteria\", () =&gt; {\n  it(\"returns false when all counts are zero\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(false);\n  });\n\n  it(\"returns true when only scene favorites exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 1,\n      ratedScenes: 0,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n\n  it(\"returns true when only scene ratings exist\", () =&gt; {\n    const counts = {\n      favoritedPerformers: 0,\n      ratedPerformers: 0,\n      favoritedStudios: 0,\n      ratedStudios: 0,\n      favoritedTags: 0,\n      ratedTags: 0,\n      favoritedScenes: 0,\n      ratedScenes: 3,\n    };\n\n    expect(hasAnyCriteria(counts)).toBe(true);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for derived weights and criteria counting\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-4-unit-tests-for-scene-scoring","title":"Task 4: Unit Tests for Scene Scoring","text":"<p>Files: - Modify: <code>server/tests/recommendations/recommendationScoring.test.ts</code></p> <p>Step 1: Add tests for scoreSceneByPreferences</p> <p>Add to the existing test file:</p> <pre><code>describe(\"scoreSceneByPreferences\", () =&gt; {\n  const createEmptyPrefs = (): EntityPreferences =&gt; ({\n    favoritePerformers: new Set(),\n    highlyRatedPerformers: new Set(),\n    favoriteStudios: new Set(),\n    highlyRatedStudios: new Set(),\n    favoriteTags: new Set(),\n    highlyRatedTags: new Set(),\n    derivedPerformerWeights: new Map(),\n    derivedStudioWeights: new Map(),\n    derivedTagWeights: new Map(),\n  });\n\n  const mockScene: NormalizedScene = {\n    id: \"scene1\",\n    title: \"Test Scene\",\n    performers: [\n      { id: \"perf1\", name: \"Performer 1\", tags: [] },\n      { id: \"perf2\", name: \"Performer 2\", tags: [] },\n    ],\n    studio: { id: \"studio1\", name: \"Studio 1\", tags: [] },\n    tags: [{ id: \"tag1\", name: \"Tag 1\" }],\n  } as NormalizedScene;\n\n  it(\"returns 0 for scene with no matching preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    const score = scoreSceneByPreferences(mockScene, prefs);\n    expect(score).toBe(0);\n  });\n\n  it(\"scores favorite performer correctly (5 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT, 2); // 5 * sqrt(1) = 5\n  });\n\n  it(\"applies sqrt diminishing returns for multiple favorite performers\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\");\n    prefs.favoritePerformers.add(\"perf2\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(2) \u2248 7.07\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(2), 2);\n  });\n\n  it(\"scores favorite studio correctly (3 points)\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoriteStudios.add(\"studio1\");\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    expect(score).toBe(3);\n  });\n\n  it(\"scores derived performer weights with sqrt scaling\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    // Accumulated weight of 0.8 from two scenes\n    prefs.derivedPerformerWeights.set(\"perf1\", 0.8);\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    // 5 * sqrt(0.8) \u2248 4.47\n    expect(score).toBeCloseTo(PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.8), 2);\n  });\n\n  it(\"combines explicit and derived preferences\", () =&gt; {\n    const prefs = createEmptyPrefs();\n    prefs.favoritePerformers.add(\"perf1\"); // 5 points\n    prefs.favoriteStudios.add(\"studio1\"); // 3 points\n    prefs.derivedPerformerWeights.set(\"perf2\", 0.4); // 5 * sqrt(0.4) \u2248 3.16\n\n    const score = scoreSceneByPreferences(mockScene, prefs);\n\n    const expected =\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(1) + // perf1 explicit\n      3 + // studio\n      PERFORMER_FAVORITE_WEIGHT * Math.sqrt(0.4); // perf2 derived\n\n    expect(score).toBeCloseTo(expected, 1);\n  });\n});\n</code></pre> <p>Step 2: Run tests to verify they pass</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run tests/recommendations/recommendationScoring.test.ts</code> Expected: All tests PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/recommendations/recommendationScoring.test.ts\ngit commit -m \"test: add unit tests for scene scoring with preferences\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-5-update-controller-to-use-scoring-service","title":"Task 5: Update Controller to Use Scoring Service","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1372-1687)</p> <p>Step 1: Add import for the scoring service</p> <p>At the top of the file with other imports, add:</p> <pre><code>import {\n  buildDerivedWeightsFromScenes,\n  scoreSceneByPreferences,\n  countUserCriteria,\n  hasAnyCriteria,\n  type EntityPreferences,\n  type SceneRatingInput,\n} from \"../../services/RecommendationScoringService.js\";\n</code></pre> <p>Step 2: Update getRecommendedScenes to fetch scene ratings</p> <p>Replace lines 1385-1392 (the Promise.all that fetches ratings):</p> <pre><code>    // Fetch user ratings and watch history\n    const [performerRatings, studioRatings, tagRatings, sceneRatings, watchHistory] =\n      await Promise.all([\n        prisma.performerRating.findMany({ where: { userId } }),\n        prisma.studioRating.findMany({ where: { userId } }),\n        prisma.tagRating.findMany({ where: { userId } }),\n        prisma.sceneRating.findMany({ where: { userId } }),\n        prisma.watchHistory.findMany({ where: { userId } }),\n      ]);\n</code></pre> <p>Step 3: Update criteria checking to include scenes</p> <p>Replace lines 1394-1438 (building sets and hasCriteria check):</p> <pre><code>    // Build sets of favorite and highly-rated entities\n    const favoritePerformers = new Set(\n      performerRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.performerId)\n    );\n    const highlyRatedPerformers = new Set(\n      performerRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.performerId)\n    );\n    const favoriteStudios = new Set(\n      studioRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.studioId)\n    );\n    const highlyRatedStudios = new Set(\n      studioRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.studioId)\n    );\n    const favoriteTags = new Set(\n      tagRatings.filter((r) =&gt; r.favorite).map((r) =&gt; r.tagId)\n    );\n    const highlyRatedTags = new Set(\n      tagRatings\n        .filter((r) =&gt; r.rating !== null &amp;&amp; r.rating &gt;= 80)\n        .map((r) =&gt; r.tagId)\n    );\n\n    // Count user criteria for feedback\n    const criteriaCounts = countUserCriteria(\n      performerRatings,\n      studioRatings,\n      tagRatings,\n      sceneRatings\n    );\n\n    // Check if user has any criteria (now includes scenes)\n    if (!hasAnyCriteria(criteriaCounts)) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No recommendations yet\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 4: Build derived weights from scene ratings</p> <p>After the hidden entities filtering (after line ~1468), add:</p> <pre><code>    // Build derived weights from rated/favorited scenes\n    const sceneRatingsForDerived: SceneRatingInput[] = sceneRatings.map((r) =&gt; ({\n      sceneId: r.sceneId,\n      rating: r.rating,\n      favorite: r.favorite,\n    }));\n\n    const sceneMap = new Map(allScenes.map((s) =&gt; [s.id, s]));\n    const getSceneById = (id: string) =&gt; sceneMap.get(id);\n\n    const {\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    } = buildDerivedWeightsFromScenes(sceneRatingsForDerived, getSceneById);\n\n    // Build entity preferences object\n    const prefs: EntityPreferences = {\n      favoritePerformers,\n      highlyRatedPerformers,\n      favoriteStudios,\n      highlyRatedStudios,\n      favoriteTags,\n      highlyRatedTags,\n      derivedPerformerWeights,\n      derivedStudioWeights,\n      derivedTagWeights,\n    };\n</code></pre> <p>Step 5: Update scoring loop to use service</p> <p>Replace the scoring loop (lines ~1496-1619) with:</p> <pre><code>    for (const scene of allScenes) {\n      const baseScore = scoreSceneByPreferences(scene, prefs);\n\n      // Skip if no base score (doesn't match any criteria)\n      if (baseScore === 0) continue;\n\n      // Watch status modifier (reduced dominance: was +100/-100, now +30/-30)\n      let adjustedScore = baseScore;\n      const watchData = watchMap.get(scene.id);\n      if (!watchData || watchData.playCount === 0) {\n        // Never watched\n        adjustedScore += 30;\n      } else if (watchData.lastPlayedAt) {\n        const daysSinceWatched =\n          (now.getTime() - watchData.lastPlayedAt.getTime()) /\n          (24 * 60 * 60 * 1000);\n\n        if (daysSinceWatched &gt; 14) {\n          // Not recently watched\n          adjustedScore += 20;\n        } else if (daysSinceWatched &gt;= 1) {\n          // Recently watched (1-14 days)\n          adjustedScore -= 10;\n        } else {\n          // Very recently watched (&lt;24 hours)\n          adjustedScore -= 30;\n        }\n      }\n\n      // Engagement quality multiplier\n      const oCounter = scene.o_counter || 0;\n      const engagementMultiplier = 1.0 + Math.min(oCounter, 10) * 0.03;\n      const finalScore = adjustedScore * engagementMultiplier;\n\n      // Only include scenes with positive final scores\n      if (finalScore &gt; 0) {\n        scoredScenes.push({ scene, score: finalScore });\n      }\n    }\n</code></pre> <p>Step 6: Run TypeScript compiler and lint</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: integrate scene-derived preferences into recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-6-add-criteria-to-empty-response","title":"Task 6: Add Criteria to Empty Response","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Update response when scenes found but scored to zero</p> <p>After the diversification/pagination logic, before the final res.json, add a check for empty results:</p> <pre><code>    // If no recommendations after scoring, include criteria for feedback\n    if (cappedScenes.length === 0) {\n      return res.json({\n        scenes: [],\n        count: 0,\n        page,\n        perPage,\n        message: \"No matching recommendations found\",\n        criteria: criteriaCounts,\n      });\n    }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: include criteria counts in empty recommendation responses\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-7-improve-error-handling-in-controller","title":"Task 7: Improve Error Handling in Controller","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code> (lines 1681-1686)</p> <p>Step 1: Update catch block with better error logging</p> <p>Replace the catch block:</p> <pre><code>  } catch (error) {\n    const err = error as Error;\n    logger.error(\"Error getting recommended scenes:\", {\n      message: err.message,\n      name: err.name,\n      stack: err.stack,\n      userId: req.user?.id,\n    });\n\n    const errorType = err.name || \"Unknown error\";\n    res.status(500).json({\n      error: \"Failed to get recommended scenes\",\n      errorType,\n    });\n  }\n</code></pre> <p>Step 2: Run lint</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"fix: improve error logging and response for recommendations\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-8-update-client-to-display-criteria-feedback","title":"Task 8: Update Client to Display Criteria Feedback","text":"<p>Files: - Modify: <code>client/src/components/pages/Recommended.jsx</code></p> <p>Step 1: Add state for criteria</p> <p>Add to the state declarations (around line 25):</p> <pre><code>const [criteria, setCriteria] = useState(null);\n</code></pre> <p>Step 2: Update fetch handler to capture criteria</p> <p>Update the response destructuring (around line 52):</p> <pre><code>const { scenes: fetchedScenes, count, message: msg, criteria: criteriaCounts } = response.data;\n\nsetScenes(fetchedScenes);\nsetTotalCount(count);\nsetCriteria(criteriaCounts || null);\nif (msg) {\n  setMessage(msg);\n}\n</code></pre> <p>Step 3: Update error handling to capture errorType</p> <p>Update the error handling (around line 76):</p> <pre><code>setError({\n  message: err.response?.data?.error || \"Failed to load recommendations\",\n  errorType: err.response?.data?.errorType || null,\n});\n</code></pre> <p>Step 4: Update error display</p> <p>Update error prop passed to SceneGrid (around line 160):</p> <pre><code>error={!initMessage &amp;&amp; error ? error.message : null}\n</code></pre> <p>And add error type display after the PageHeader:</p> <pre><code>{error &amp;&amp; error.errorType &amp;&amp; (\n  &lt;div className=\"mb-4 text-sm text-gray-500\"&gt;\n    (Error type: {error.errorType})\n  &lt;/div&gt;\n)}\n</code></pre> <p>Step 5: Create criteria display component</p> <p>Add helper function before the return statement:</p> <pre><code>const renderCriteriaFeedback = () =&gt; {\n  if (!criteria) return null;\n\n  const hasAnyActivity =\n    criteria.favoritedPerformers &gt; 0 ||\n    criteria.ratedPerformers &gt; 0 ||\n    criteria.favoritedStudios &gt; 0 ||\n    criteria.ratedStudios &gt; 0 ||\n    criteria.favoritedTags &gt; 0 ||\n    criteria.ratedTags &gt; 0 ||\n    criteria.favoritedScenes &gt; 0 ||\n    criteria.ratedScenes &gt; 0;\n\n  if (!hasAnyActivity) {\n    return (\n      &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n        &lt;p&gt;To get personalized suggestions, try favoriting or rating (7.0+) performers, studios, tags, or scenes you enjoy.&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\"text-gray-400 text-sm mt-2\"&gt;\n      &lt;p className=\"mb-2\"&gt;Your current activity:&lt;/p&gt;\n      &lt;ul className=\"list-disc list-inside space-y-1\"&gt;\n        &lt;li&gt;{criteria.favoritedPerformers} favorited performer{criteria.favoritedPerformers !== 1 ? 's' : ''}, {criteria.ratedPerformers} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedStudios} favorited studio{criteria.favoritedStudios !== 1 ? 's' : ''}, {criteria.ratedStudios} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedTags} favorited tag{criteria.favoritedTags !== 1 ? 's' : ''}, {criteria.ratedTags} highly-rated&lt;/li&gt;\n        &lt;li&gt;{criteria.favoritedScenes} favorited scene{criteria.favoritedScenes !== 1 ? 's' : ''}, {criteria.ratedScenes} rated scene{criteria.ratedScenes !== 1 ? 's' : ''}&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;p className=\"mt-2 italic\"&gt;Tip: Rating more scenes helps us learn your preferences!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Step 6: Update SceneGrid props to include criteria</p> <p>Update the SceneGrid component to pass criteria:</p> <pre><code>&lt;SceneGrid\n  scenes={scenes}\n  loading={loading}\n  error={!initMessage &amp;&amp; error ? error.message : null}\n  currentPage={page}\n  totalPages={totalPages}\n  onPageChange={handlePageChange}\n  onHideSuccess={handleHideSuccess}\n  perPage={perPage}\n  onPerPageChange={handlePerPageChange}\n  totalCount={totalCount}\n  emptyMessage={message || \"No Recommendations Yet\"}\n  emptyDescription={\n    criteria ? renderCriteriaFeedback() : \"Rate or Favorite more items to get personalized recommendations.\"\n  }\n/&gt;\n</code></pre> <p>Step 7: Run client lint</p> <p>Run: <code>cd client &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing warnings)</p> <p>Step 8: Commit</p> <pre><code>git add client/src/components/pages/Recommended.jsx\ngit commit -m \"feat: display criteria feedback on empty recommendations page\"\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-9-integration-test-manual-verification","title":"Task 9: Integration Test - Manual Verification","text":"<p>Files: None (manual testing)</p> <p>Step 1: Start the dev server</p> <p>Run: <code>npm run dev</code> (or your dev command)</p> <p>Step 2: Test with no ratings</p> <ol> <li>Log in as a user with no ratings/favorites</li> <li>Navigate to Recommended page</li> <li>Verify: Empty state shows criteria counts (all zeros)</li> <li>Verify: Message explains how to get recommendations</li> </ol> <p>Step 3: Test with only scene favorites</p> <ol> <li>Favorite 2-3 scenes from the library</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations appear (derived from scene content)</li> <li>Verify: Scenes with matching performers/studios/tags are shown</li> </ol> <p>Step 4: Test with explicit + scene ratings</p> <ol> <li>Also favorite a performer explicitly</li> <li>Navigate to Recommended page</li> <li>Verify: Recommendations include both explicit matches and derived matches</li> </ol> <p>Step 5: Test error display</p> <ol> <li>Temporarily break the database connection</li> <li>Navigate to Recommended page</li> <li>Verify: Error message shows with error type</li> </ol> <p>Step 6: Document results</p> <p>Note any issues found for follow-up.</p>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#task-10-run-full-test-suite","title":"Task 10: Run Full Test Suite","text":"<p>Files: None</p> <p>Step 1: Run all server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests PASS</p> <p>Step 2: Run client tests (if any)</p> <p>Run: <code>cd client &amp;&amp; npm test</code> (if applicable) Expected: All tests PASS</p> <p>Step 3: Final commit for any cleanup</p> <p>If any issues found, fix and commit.</p> <p>Step 4: Push branch</p> <pre><code>git push -u origin feature/recommendations-improvements\n</code></pre>"},{"location":"plans/2025-12-16-recommendations-improvements-implementation/#summary","title":"Summary","text":"Task Description Files 1 Extract RecommendationScoringService <code>server/services/RecommendationScoringService.ts</code> 2 Unit tests for weight calculation <code>server/tests/recommendations/recommendationScoring.test.ts</code> 3 Unit tests for derived weights <code>server/tests/recommendations/recommendationScoring.test.ts</code> 4 Unit tests for scene scoring <code>server/tests/recommendations/recommendationScoring.test.ts</code> 5 Update controller to use service <code>server/controllers/library/scenes.ts</code> 6 Add criteria to empty response <code>server/controllers/library/scenes.ts</code> 7 Improve error handling <code>server/controllers/library/scenes.ts</code> 8 Update client for criteria feedback <code>client/src/components/pages/Recommended.jsx</code> 9 Manual integration testing - 10 Run full test suite -"},{"location":"plans/2025-12-23-carousel-see-more-design/","title":"Carousel \"See More\" Button Design","text":"<p>Issue: #192 Branch: <code>feature/192-carousel-see-more</code> Date: 2025-12-23</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#overview","title":"Overview","text":"<p>Add a \"More\" button to each carousel on the home page that navigates to the Scenes page with the carousel's filter pre-applied.</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#design-decisions","title":"Design Decisions","text":"<ul> <li>Button placement: Header row, to the right of the scroll navigation buttons</li> <li>Button style: Small pill button (<code>size=\"sm\"</code>, <code>variant=\"secondary\"</code>)</li> <li>Button text: \"More\" on all screen sizes (simple and consistent)</li> <li>Continue Watching: Links to <code>/watch-history</code> instead of Scenes</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#filter-to-url-mapping","title":"Filter-to-URL Mapping","text":""},{"location":"plans/2025-12-23-carousel-see-more-design/#hardcoded-carousels","title":"Hardcoded Carousels","text":"fetchKey URL <code>recentlyAddedScenes</code> <code>/scenes?sort=created_at&amp;dir=DESC</code> <code>highRatedScenes</code> <code>/scenes?rating_min=80</code> <code>favoritePerformerScenes</code> <code>/scenes?performerFavorite=true</code> <code>favoriteTagScenes</code> <code>/scenes?tagFavorite=true</code> <code>favoriteStudioScenes</code> <code>/scenes?studioFavorite=true</code> <code>continueWatching</code> <code>/watch-history</code>"},{"location":"plans/2025-12-23-carousel-see-more-design/#custom-carousels","title":"Custom Carousels","text":"<p>Custom carousels store rules in API format. To build the URL: 1. Use <code>carouselRulesToFilterState()</code> to convert rules to UI filter state 2. Use <code>buildSearchParams()</code> with <code>SCENE_FILTER_OPTIONS</code> to serialize to URL params</p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-23-carousel-see-more-design/#1-clientsrccomponentsuiscenecarouseljsx","title":"1. <code>client/src/components/ui/SceneCarousel.jsx</code>","text":"<p>Add new prop: - <code>seeMoreUrl</code> (string, optional) - navigation target</p> <p>Changes: - Import <code>Link</code> from <code>react-router-dom</code> - Render \"More\" button to the right of scroll buttons when <code>seeMoreUrl</code> is provided - Button uses existing <code>Button</code> component with <code>size=\"sm\"</code>, <code>variant=\"secondary\"</code></p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#2-clientsrccomponentspageshomejsx","title":"2. <code>client/src/components/pages/Home.jsx</code>","text":"<p>Changes to <code>HomeCarousel</code> component: - Create mapping function <code>getSeeMoreUrl(fetchKey)</code> that returns the URL for each carousel type - Pass <code>seeMoreUrl</code> prop to <code>SceneCarousel</code></p> <p>Changes to <code>CustomCarousel</code> component: - Import <code>carouselRulesToFilterState</code> from <code>filterConfig.js</code> - Import <code>buildSearchParams</code> from <code>urlParams.js</code> - Import <code>SCENE_FILTER_OPTIONS</code> from <code>filterConfig.js</code> - Build URL from carousel rules and pass to <code>SceneCarousel</code></p>"},{"location":"plans/2025-12-23-carousel-see-more-design/#3-clientsrccomponentsuicontinuewatchingcarouseljsx","title":"3. <code>client/src/components/ui/ContinueWatchingCarousel.jsx</code>","text":"<ul> <li>Pass <code>seeMoreUrl=\"/watch-history\"</code> to its <code>SceneCarousel</code></li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#verification-checklist","title":"Verification Checklist","text":"<p>During implementation, manually test each carousel's \"More\" button:</p> <ul> <li> <code>recentlyAddedScenes</code> - Scenes page loads sorted by created_at DESC</li> <li> <code>highRatedScenes</code> - Scenes page shows rating &gt;= 80 filter active</li> <li> <code>favoritePerformerScenes</code> - Scenes page shows \"Favorite Performers\" filter active</li> <li> <code>favoriteTagScenes</code> - Scenes page shows \"Favorite Tags\" filter active</li> <li> <code>favoriteStudioScenes</code> - Scenes page shows \"Favorite Studios\" filter active</li> <li> <code>continueWatching</code> - Navigates to Watch History page</li> <li> Custom carousels - Scenes page loads with matching filters from carousel rules</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Shuffle/randomize carousel content (carousels already use <code>sort: \"random\"</code>, investigate separately if needed)</li> </ul>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/","title":"Carousel \"See More\" Button Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add \"More\" buttons to home page carousels that navigate to filtered Scenes views.</p> <p>Architecture: Add optional <code>seeMoreUrl</code> prop to SceneCarousel, build URLs in Home.jsx based on carousel type (hardcoded mapping for built-in carousels, dynamic URL building for custom carousels using existing filter utilities).</p> <p>Tech Stack: React, react-router-dom, existing filterConfig.js and urlParams.js utilities</p>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-1-add-seemoreurl-prop-to-scenecarousel","title":"Task 1: Add seeMoreUrl prop to SceneCarousel","text":"<p>Files: - Modify: <code>client/src/components/ui/SceneCarousel.jsx</code></p> <p>Step 1: Add Link import and seeMoreUrl prop</p> <p>At line 1, update imports: <pre><code>import { useEffect, useRef, useState } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Button from \"./Button.jsx\";\n</code></pre></p> <p>At line 6, add <code>seeMoreUrl</code> to destructured props: <pre><code>const SceneCarousel = ({\n  title,\n  titleIcon,\n  scenes,\n  loading = false,\n  onSceneClick,\n  selectedScenes = [],\n  onToggleSelect,\n  seeMoreUrl,\n}) =&gt; {\n</code></pre></p> <p>Step 2: Add \"More\" button after scroll buttons</p> <p>At line 157-158, after the right scroll button's closing tag and before the <code>&lt;/div&gt;</code> that closes the button container, add the More button:</p> <pre><code>          /&gt;\n          {seeMoreUrl &amp;&amp; (\n            &lt;Link to={seeMoreUrl}&gt;\n              &lt;Button\n                variant=\"secondary\"\n                size=\"sm\"\n                className=\"ml-2\"\n              &gt;\n                More\n              &lt;/Button&gt;\n            &lt;/Link&gt;\n          )}\n        &lt;/div&gt;\n</code></pre> <p>Step 3: Verify hot reload shows no errors</p> <p>Check browser console for any React errors. The button won't appear yet since no carousels pass <code>seeMoreUrl</code>.</p> <p>Step 4: Commit</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser\ngit add client/src/components/ui/SceneCarousel.jsx\ngit commit -m \"feat: add seeMoreUrl prop to SceneCarousel component\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-2-add-url-mapping-for-hardcoded-carousels-in-homejsx","title":"Task 2: Add URL mapping for hardcoded carousels in Home.jsx","text":"<p>Files: - Modify: <code>client/src/components/pages/Home.jsx</code></p> <p>Step 1: Add getSeeMoreUrl helper function</p> <p>After line 33 (after the <code>isCustomCarousel</code> function), add this mapping function:</p> <pre><code>/**\n * Get the \"See More\" URL for a hardcoded carousel based on its fetchKey\n */\nconst getSeeMoreUrl = (fetchKey) =&gt; {\n  const urlMap = {\n    recentlyAddedScenes: \"/scenes?sort=created_at&amp;dir=DESC\",\n    highRatedScenes: \"/scenes?rating_min=80\",\n    favoritePerformerScenes: \"/scenes?performerFavorite=true\",\n    favoriteTagScenes: \"/scenes?tagFavorite=true\",\n    favoriteStudioScenes: \"/scenes?studioFavorite=true\",\n    continueWatching: \"/watch-history\",\n  };\n  return urlMap[fetchKey] || null;\n};\n</code></pre> <p>Step 2: Pass seeMoreUrl to HomeCarousel's SceneCarousel</p> <p>In the <code>HomeCarousel</code> component (around line 325-334), update the SceneCarousel call to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title={title}\n      titleIcon={icon}\n      scenes={scenes || []}\n      onSceneClick={createSceneClickHandler(scenes || [], title)}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl={getSeeMoreUrl(fetchKey)}\n    /&gt;\n  );\n</code></pre> <p>Step 3: Add fetchKey prop to HomeCarousel signature</p> <p>The <code>HomeCarousel</code> component already receives <code>fetchKey</code> as a prop (line 275), so no change needed there.</p> <p>Step 4: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>Hardcoded carousels (Recently Added, High Rated, Favorite Performers, etc.) should show \"More\" button</li> <li>Click \"More\" on each and verify:</li> <li>Recently Added: <code>/scenes?sort=created_at&amp;dir=DESC</code></li> <li>High Rated: <code>/scenes?rating_min=80</code></li> <li>Favorite Performers: <code>/scenes?performerFavorite=true</code></li> <li>Favorite Tags: <code>/scenes?tagFavorite=true</code></li> <li>Favorite Studios: <code>/scenes?studioFavorite=true</code></li> </ul> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Home.jsx\ngit commit -m \"feat: add See More URLs for hardcoded carousels\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-3-add-seemoreurl-to-continuewatchingcarousel","title":"Task 3: Add seeMoreUrl to ContinueWatchingCarousel","text":"<p>Files: - Modify: <code>client/src/components/ui/ContinueWatchingCarousel.jsx</code></p> <p>Step 1: Add seeMoreUrl prop to SceneCarousel call</p> <p>At line 178-188, update the SceneCarousel call to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title=\"Continue Watching\"\n      titleIcon={&lt;PlayCircle className=\"w-6 h-6\" color=\"#10b981\" /&gt;}\n      scenes={scenes}\n      onSceneClick={handleSceneClick}\n      showProgress={true}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl=\"/watch-history\"\n    /&gt;\n  );\n</code></pre> <p>Step 2: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>Continue Watching carousel should show \"More\" button</li> <li>Click \"More\" and verify it navigates to <code>/watch-history</code></li> </ul> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/ContinueWatchingCarousel.jsx\ngit commit -m \"feat: add See More link to Continue Watching carousel\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-4-add-url-building-for-custom-carousels","title":"Task 4: Add URL building for custom carousels","text":"<p>Files: - Modify: <code>client/src/components/pages/Home.jsx</code></p> <p>Step 1: Add imports for filter utilities</p> <p>At the top of Home.jsx, add imports after existing imports (around line 13):</p> <pre><code>import {\n  carouselRulesToFilterState,\n  SCENE_FILTER_OPTIONS,\n} from \"../../utils/filterConfig.js\";\nimport { buildSearchParams } from \"../../utils/urlParams.js\";\n</code></pre> <p>Step 2: Add helper function to build custom carousel URL</p> <p>After the <code>getSeeMoreUrl</code> function (around line 45), add:</p> <pre><code>/**\n * Build a \"See More\" URL for a custom carousel from its rules\n */\nconst buildCustomCarouselUrl = (rules, sort, direction) =&gt; {\n  if (!rules || typeof rules !== \"object\") {\n    return \"/scenes\";\n  }\n\n  // Convert API rules format to UI filter state\n  const filterState = carouselRulesToFilterState(rules);\n\n  // Build URL params using existing utility\n  const params = buildSearchParams({\n    searchText: \"\",\n    sortField: sort || \"random\",\n    sortDirection: direction || \"DESC\",\n    currentPage: 1,\n    perPage: 24,\n    filters: filterState,\n    filterOptions: SCENE_FILTER_OPTIONS,\n  });\n\n  const queryString = params.toString();\n  return queryString ? `/scenes?${queryString}` : \"/scenes\";\n};\n</code></pre> <p>Step 3: Update CustomCarousel to fetch full carousel data and pass seeMoreUrl</p> <p>The <code>CustomCarousel</code> component needs access to the carousel's rules. Currently it only gets <code>carouselId</code>, but the full carousel data is available in <code>customCarousels</code> state from the parent.</p> <p>First, update where <code>CustomCarousel</code> is rendered (around line 206-217) to pass the full carousel:</p> <pre><code>          return (\n            &lt;CustomCarousel\n              key={carousel.prefId}\n              carouselId={id}\n              carousel={customCarousels.find((c) =&gt; c.id === id)}\n              title={title}\n              icon={icon}\n              createSceneClickHandler={createSceneClickHandler}\n              selectedScenes={selectedScenes}\n              onToggleSelect={handleToggleSelect}\n              onInitializing={handleInitializing}\n            /&gt;\n          );\n</code></pre> <p>Step 4: Update CustomCarousel component to accept and use carousel prop</p> <p>Update the CustomCarousel component signature (around line 342) to accept the new prop:</p> <pre><code>const CustomCarousel = ({\n  carouselId,\n  carousel,\n  title,\n  icon,\n  createSceneClickHandler,\n  selectedScenes,\n  onToggleSelect,\n  onInitializing,\n}) =&gt; {\n</code></pre> <p>Then update the SceneCarousel call at the end of CustomCarousel (around line 415-424) to include <code>seeMoreUrl</code>:</p> <pre><code>  return (\n    &lt;SceneCarousel\n      loading={loading || isInitializing}\n      title={title}\n      titleIcon={icon}\n      scenes={scenes}\n      onSceneClick={createSceneClickHandler(scenes, title)}\n      selectedScenes={selectedScenes}\n      onToggleSelect={onToggleSelect}\n      seeMoreUrl={carousel ? buildCustomCarouselUrl(carousel.rules, carousel.sort, carousel.direction) : null}\n    /&gt;\n  );\n</code></pre> <p>Step 5: Verify in browser</p> <ul> <li>Navigate to home page</li> <li>If you have custom carousels, they should show \"More\" button</li> <li>Click \"More\" and verify it navigates to <code>/scenes</code> with appropriate filter params</li> <li>Verify the filters are correctly applied on the Scenes page</li> </ul> <p>Step 6: Commit</p> <pre><code>git add client/src/components/pages/Home.jsx\ngit commit -m \"feat: add See More URLs for custom carousels\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-5-manual-verification-of-all-carousel-types","title":"Task 5: Manual verification of all carousel types","text":"<p>No code changes - verification only</p> <p>Step 1: Test each hardcoded carousel</p> <p>For each carousel, click \"More\" and verify:</p> Carousel Expected URL Verify Filter Active Recently Added <code>/scenes?sort=created_at&amp;dir=DESC</code> Sort dropdown shows \"Created At\", direction DESC High Rated <code>/scenes?rating_min=80</code> Rating filter shows min 80 Favorite Performers <code>/scenes?performerFavorite=true</code> \"Favorite Performers\" checkbox checked in filters Favorite Tags <code>/scenes?tagFavorite=true</code> \"Favorite Tags\" checkbox checked in filters Favorite Studios <code>/scenes?studioFavorite=true</code> \"Favorite Studios\" checkbox checked in filters Continue Watching <code>/watch-history</code> Watch History page loads <p>Step 2: Test custom carousels (if available)</p> <ul> <li>Create a custom carousel with specific filters (e.g., rating &gt; 60, specific performer)</li> <li>Go to home page, find the custom carousel</li> <li>Click \"More\"</li> <li>Verify the Scenes page loads with matching filters</li> </ul> <p>Step 3: Test edge cases</p> <ul> <li>Carousel with no scenes still shows \"More\" button (links work even if empty)</li> <li>Mobile viewport: verify \"More\" button is visible and tappable</li> <li>Verify no console errors</li> </ul> <p>Step 4: Final commit (if any fixes needed)</p> <p>If any fixes were needed during verification, commit them:</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during carousel See More verification\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#task-6-run-linting-and-tests","title":"Task 6: Run linting and tests","text":"<p>Step 1: Run ESLint</p> <pre><code>cd c:/Users/carrotwaxr/code/peek-stash-browser/client\nnpm run lint\n</code></pre> <p>Expected: No new errors (fix any that appear)</p> <p>Step 2: Run existing tests</p> <pre><code>npm test\n</code></pre> <p>Expected: All tests pass</p> <p>Step 3: Commit any lint fixes</p> <pre><code>git add -A\ngit commit -m \"fix: address linting issues\"\n</code></pre>"},{"location":"plans/2025-12-23-carousel-see-more-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li><code>SceneCarousel</code> accepts optional <code>seeMoreUrl</code> prop and renders \"More\" button when provided</li> <li>All hardcoded carousels pass appropriate URLs via <code>getSeeMoreUrl()</code> mapping</li> <li><code>ContinueWatchingCarousel</code> links to <code>/watch-history</code></li> <li>Custom carousels dynamically build URLs from their rules using existing filter utilities</li> <li>All carousel types verified working</li> <li>Linting and tests pass</li> </ol>"},{"location":"plans/2025-12-23-scene-urls-design/","title":"Scene URLs Display Design","text":"<p>Issue: #195 - Show URLs for scenes in details panel Date: 2025-12-23 Status: Approved</p>"},{"location":"plans/2025-12-23-scene-urls-design/#problem","title":"Problem","text":"<p>Users want to see URLs associated with scenes so they can purchase content from creators they enjoy. Currently, scene URLs from Stash metadata are not displayed anywhere in the Peek UI.</p>"},{"location":"plans/2025-12-23-scene-urls-design/#solution","title":"Solution","text":"<p>Add a \"Links\" section to the Scene Details card, displaying scene URLs as rich link chips with site icons.</p>"},{"location":"plans/2025-12-23-scene-urls-design/#design-decisions","title":"Design Decisions","text":""},{"location":"plans/2025-12-23-scene-urls-design/#placement","title":"Placement","text":"<ul> <li>Add \"Links\" section immediately after Tags inside the existing Details card</li> <li>Only show the section if <code>scene.urls</code> exists and has items</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-design/#visual-style","title":"Visual Style","text":"<ul> <li>Rich link chips matching the <code>PerformerDetail.jsx</code> pattern</li> <li>Styled buttons with site icons/colors and readable names</li> <li>Consistent with existing UI patterns</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-design/#site-recognition","title":"Site Recognition","text":"<p>Expand site recognition to cover:</p> <p>Major studio networks: - Brazzers, Reality Kings, Bang Bros, Naughty America, Mofos, Digital Playground, Wicked Pictures</p> <p>Premium/artistic studios: - Vixen, Tushy, Blacked, Deeper, Slayed, Bellesa, X-Art, SexArt</p> <p>Existing sites (already supported): - Social media: Twitter/X, Instagram, Facebook, OnlyFans - Databases: IAFD, FreeOnes, Babepedia, Data18, Indexxx, AFDB, IMDb</p>"},{"location":"plans/2025-12-23-scene-urls-design/#fallback-for-unknown-sites","title":"Fallback for Unknown Sites","text":"<p>For URLs not in the curated list: 1. Extract domain name from URL 2. Attempt to load favicon from <code>https://domain.com/favicon.ico</code> 3. Display domain name as label with favicon (or generic link icon if favicon fails)</p>"},{"location":"plans/2025-12-23-scene-urls-design/#implementation-plan","title":"Implementation Plan","text":"<ol> <li>Extract <code>getSiteInfo()</code> and <code>SectionLink</code> into shared utility module</li> <li>Add new site mappings for studio networks and premium studios</li> <li>Add favicon fallback logic with error handling</li> <li>Add \"Links\" section to <code>SceneDetails.jsx</code> after Tags</li> <li>Update <code>PerformerDetail.jsx</code> to use shared utility (removes duplication)</li> </ol>"},{"location":"plans/2025-12-23-scene-urls-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>client/src/utils/siteInfo.js</code> (new file)</li> <li><code>client/src/components/ui/SectionLink.jsx</code> (new file)</li> <li><code>client/src/components/pages/SceneDetails.jsx</code></li> <li><code>client/src/components/pages/PerformerDetail.jsx</code> (refactor to use shared utility)</li> </ul>"},{"location":"plans/2025-12-23-scene-urls-implementation/","title":"Scene URLs Display Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Display scene URLs in the Scene Details card so users can purchase content from creators.</p> <p>Architecture: Extract existing <code>getSiteInfo()</code> and <code>SectionLink</code> from PerformerDetail into shared utilities. Add new site mappings for major studios. Implement dynamic favicon fallback. Add URLs section to SceneDetails after Tags.</p> <p>Tech Stack: React, Lucide icons, CSS-in-JS (inline styles)</p>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-1-create-shared-site-info-utility","title":"Task 1: Create Shared Site Info Utility","text":"<p>Files: - Create: <code>client/src/utils/siteInfo.js</code></p> <p>Step 1: Create the utility file with existing + new site mappings</p> <pre><code>import {\n  LucideDatabase,\n  LucideFacebook,\n  LucideFilm,\n  LucideGlobe,\n  LucideInstagram,\n  LucideLink,\n  LucideTwitter,\n  LucideVideo,\n} from \"lucide-react\";\n\n/**\n * Site information for URL display\n * Returns name, icon component, and brand color for known sites\n */\nexport const getSiteInfo = (url) =&gt; {\n  const urlLower = url.toLowerCase();\n\n  // === Social Media ===\n  if (urlLower.includes(\"twitter.com\") || urlLower.includes(\"x.com\")) {\n    return { name: \"Twitter\", icon: LucideTwitter, color: \"#1DA1F2\" };\n  }\n  if (urlLower.includes(\"instagram.com\")) {\n    return { name: \"Instagram\", icon: LucideInstagram, color: \"#E4405F\" };\n  }\n  if (urlLower.includes(\"facebook.com\")) {\n    return { name: \"Facebook\", icon: LucideFacebook, color: \"#1877F2\" };\n  }\n  if (urlLower.includes(\"onlyfans.com\")) {\n    return { name: \"OnlyFans\", icon: LucideVideo, color: \"#00AFF0\" };\n  }\n\n  // === Entertainment Databases ===\n  if (urlLower.includes(\"imdb.com\")) {\n    return { name: \"IMDb\", icon: LucideFilm, color: \"#F5C518\" };\n  }\n\n  // === Adult Industry Databases ===\n  if (urlLower.includes(\"iafd.com\")) {\n    return { name: \"IAFD\", icon: LucideDatabase, color: \"#9B59B6\" };\n  }\n  if (urlLower.includes(\"adultfilmdatabase.com\")) {\n    return { name: \"AFDB\", icon: LucideDatabase, color: \"#16A085\" };\n  }\n  if (urlLower.includes(\"freeones.com\")) {\n    return { name: \"FreeOnes\", icon: LucideDatabase, color: \"#E67E22\" };\n  }\n  if (urlLower.includes(\"babepedia.com\")) {\n    return { name: \"Babepedia\", icon: LucideDatabase, color: \"#E91E63\" };\n  }\n  if (urlLower.includes(\"data18.com\")) {\n    return { name: \"Data18\", icon: LucideDatabase, color: \"#27AE60\" };\n  }\n  if (urlLower.includes(\"indexxx.com\")) {\n    return { name: \"Indexxx\", icon: LucideDatabase, color: \"#8E44AD\" };\n  }\n  if (urlLower.includes(\"thenude.com\")) {\n    return { name: \"The Nude\", icon: LucideDatabase, color: \"#1ABC9C\" };\n  }\n  if (urlLower.includes(\"pornteengirl.com\")) {\n    return { name: \"PornTeenGirl\", icon: LucideGlobe, color: \"#2ECC71\" };\n  }\n\n  // === Major Studio Networks ===\n  if (urlLower.includes(\"brazzers.com\")) {\n    return { name: \"Brazzers\", icon: LucideGlobe, color: \"#FFA500\" };\n  }\n  if (urlLower.includes(\"realitykings.com\")) {\n    return { name: \"Reality Kings\", icon: LucideGlobe, color: \"#FFD700\" };\n  }\n  if (urlLower.includes(\"bangbros.com\")) {\n    return { name: \"Bang Bros\", icon: LucideGlobe, color: \"#FF6B6B\" };\n  }\n  if (urlLower.includes(\"naughtyamerica.com\")) {\n    return { name: \"Naughty America\", icon: LucideGlobe, color: \"#E74C3C\" };\n  }\n  if (urlLower.includes(\"mofos.com\")) {\n    return { name: \"Mofos\", icon: LucideGlobe, color: \"#3498DB\" };\n  }\n  if (urlLower.includes(\"digitalplayground.com\")) {\n    return { name: \"Digital Playground\", icon: LucideGlobe, color: \"#9B59B6\" };\n  }\n  if (urlLower.includes(\"wicked.com\")) {\n    return { name: \"Wicked Pictures\", icon: LucideGlobe, color: \"#E91E63\" };\n  }\n\n  // === Premium/Artistic Studios ===\n  if (urlLower.includes(\"vixen.com\")) {\n    return { name: \"Vixen\", icon: LucideGlobe, color: \"#000000\" };\n  }\n  if (urlLower.includes(\"tushy.com\")) {\n    return { name: \"Tushy\", icon: LucideGlobe, color: \"#FF69B4\" };\n  }\n  if (urlLower.includes(\"blacked.com\")) {\n    return { name: \"Blacked\", icon: LucideGlobe, color: \"#1C1C1C\" };\n  }\n  if (urlLower.includes(\"deeper.com\")) {\n    return { name: \"Deeper\", icon: LucideGlobe, color: \"#2C3E50\" };\n  }\n  if (urlLower.includes(\"slayed.com\")) {\n    return { name: \"Slayed\", icon: LucideGlobe, color: \"#8B0000\" };\n  }\n  if (urlLower.includes(\"bellesa.co\") || urlLower.includes(\"bellesafilms.com\")) {\n    return { name: \"Bellesa\", icon: LucideGlobe, color: \"#FF6B9D\" };\n  }\n  if (urlLower.includes(\"x-art.com\")) {\n    return { name: \"X-Art\", icon: LucideGlobe, color: \"#C0C0C0\" };\n  }\n  if (urlLower.includes(\"sexart.com\")) {\n    return { name: \"SexArt\", icon: LucideGlobe, color: \"#D4AF37\" };\n  }\n\n  // === Unknown site - extract domain ===\n  try {\n    const domain = new URL(url).hostname.replace(\"www.\", \"\");\n    return { name: domain, icon: LucideLink, color: \"#95A5A6\", useFavicon: true };\n  } catch {\n    return { name: \"Link\", icon: LucideLink, color: \"#95A5A6\" };\n  }\n};\n\n/**\n * Extract domain from URL for favicon fetching\n */\nexport const getDomainFromUrl = (url) =&gt; {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.origin;\n  } catch {\n    return null;\n  }\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/utils/siteInfo.js\ngit commit -m \"feat: add shared site info utility with studio mappings\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-2-create-shared-sectionlink-component","title":"Task 2: Create Shared SectionLink Component","text":"<p>Files: - Create: <code>client/src/components/ui/SectionLink.jsx</code> - Modify: <code>client/src/components/ui/index.js</code></p> <p>Step 1: Create the SectionLink component with favicon fallback</p> <pre><code>import { useState } from \"react\";\nimport { getSiteInfo, getDomainFromUrl } from \"../../utils/siteInfo.js\";\n\n/**\n * External link component with site icon/favicon\n * Shows site-specific icons for known sites, attempts favicon for unknown sites\n */\nconst SectionLink = ({ url }) =&gt; {\n  const [faviconError, setFaviconError] = useState(false);\n\n  if (!url) return null;\n\n  const { name, icon: Icon, color, useFavicon } = getSiteInfo(url);\n  const domain = getDomainFromUrl(url);\n  const faviconUrl = domain ? `${domain}/favicon.ico` : null;\n\n  // Show favicon for unknown sites, fall back to icon if favicon fails\n  const showFavicon = useFavicon &amp;&amp; faviconUrl &amp;&amp; !faviconError;\n\n  return (\n    &lt;a\n      href={url}\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n      className=\"inline-flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 hover:opacity-80\"\n      style={{\n        backgroundColor: \"var(--bg-secondary)\",\n        color: \"var(--text-primary)\",\n        border: \"1px solid var(--border-color)\",\n      }}\n    &gt;\n      {showFavicon ? (\n        &lt;img\n          src={faviconUrl}\n          alt=\"\"\n          width={16}\n          height={16}\n          onError={() =&gt; setFaviconError(true)}\n          style={{ borderRadius: 2 }}\n        /&gt;\n      ) : (\n        &lt;Icon size={16} style={{ color }} /&gt;\n      )}\n      &lt;span&gt;{name}&lt;/span&gt;\n    &lt;/a&gt;\n  );\n};\n\nexport default SectionLink;\n</code></pre> <p>Step 2: Export from ui/index.js</p> <p>Add this line in alphabetical order (after SearchInput, before Sidebar):</p> <pre><code>export { default as SectionLink } from \"./SectionLink.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/ui/SectionLink.jsx client/src/components/ui/index.js\ngit commit -m \"feat: add SectionLink component with favicon fallback\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-3-add-urls-to-scenedetails-component","title":"Task 3: Add URLs to SceneDetails Component","text":"<p>Files: - Modify: <code>client/src/components/pages/SceneDetails.jsx:1-5</code> (imports) - Modify: <code>client/src/components/pages/SceneDetails.jsx:335-369</code> (after Tags section)</p> <p>Step 1: Add SectionLink import</p> <p>Change line 3 from: <pre><code>import { Paper, useLazyLoad } from \"../ui/index.js\";\n</code></pre></p> <p>To: <pre><code>import { Paper, SectionLink, useLazyLoad } from \"../ui/index.js\";\n</code></pre></p> <p>Step 2: Add URLs section after Tags</p> <p>After the Tags section (ends at line 369), add the URLs section. Insert after line 369 (after the closing of the Tags IIFE):</p> <pre><code>                {/* URLs/Links */}\n                {scene.urls &amp;&amp; scene.urls.length &gt; 0 &amp;&amp; (\n                  &lt;div className=\"mt-6\"&gt;\n                    &lt;h3\n                      className=\"text-sm font-medium mb-3\"\n                      style={{ color: \"var(--text-secondary)\" }}\n                    &gt;\n                      Links\n                    &lt;/h3&gt;\n                    &lt;div className=\"flex flex-wrap gap-2\"&gt;\n                      {scene.urls.map((url, index) =&gt; (\n                        &lt;SectionLink key={index} url={url} /&gt;\n                      ))}\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                )}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/SceneDetails.jsx\ngit commit -m \"feat: display scene URLs in details panel\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-4-add-urls-to-server-transform-functions","title":"Task 4: Add URLs to Server Transform Functions","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts:1347-1403</code> (transformScene) - Modify: <code>server/services/StashEntityService.ts:1408-1480</code> (transformSceneForBrowse)</p> <p>Step 1: Add urls to transformScene method</p> <p>In the <code>transformScene</code> method (around line 1347), after the <code>organized</code> field (line 1359), add:</p> <pre><code>      // URLs\n      urls: scene.urls ? JSON.parse(scene.urls) : [],\n</code></pre> <p>Step 2: Add urls to transformSceneForBrowse method</p> <p>In the <code>transformSceneForBrowse</code> method (around line 1408), after the <code>organized</code> field (line 1419), add the same:</p> <pre><code>      // URLs\n      urls: scene.urls ? JSON.parse(scene.urls) : [],\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts\ngit commit -m \"feat: include urls in scene transformation\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-5-refactor-performerdetail-to-use-shared-utilities","title":"Task 5: Refactor PerformerDetail to Use Shared Utilities","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx:1-35</code> (imports) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:36-92</code> (remove getSiteInfo) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:391-413</code> (remove SectionLink) - Modify: <code>client/src/components/pages/PerformerDetail.jsx:747-760</code> (update usage)</p> <p>Step 1: Update imports</p> <p>Remove these imports from the lucide-react import (lines 3-14): - <code>LucideDatabase</code> - <code>LucideFacebook</code> - <code>LucideFilm</code> - <code>LucideGlobe</code> - <code>LucideInstagram</code> - <code>LucideLink</code> - <code>LucideTwitter</code> - <code>LucideVideo</code></p> <p>Keep only: <pre><code>import {\n  ArrowLeft,\n  LucideStar,\n} from \"lucide-react\";\n</code></pre></p> <p>Add import for SectionLink after line 34: <pre><code>import { SectionLink } from \"../ui/index.js\";\n</code></pre></p> <p>Step 2: Remove local getSiteInfo function</p> <p>Delete lines 36-92 (the entire <code>getSiteInfo</code> function).</p> <p>Step 3: Remove local SectionLink component</p> <p>Delete lines 391-413 (the entire <code>SectionLink</code> component, including the comment above it).</p> <p>Step 4: Verify SectionLink usage remains correct</p> <p>The existing usage at lines 749, 751, 754, 759 should continue to work as-is since we're importing the same component interface.</p> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx\ngit commit -m \"refactor: use shared SectionLink in PerformerDetail\"\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#task-6-test-and-verify","title":"Task 6: Test and Verify","text":"<p>Step 1: Run the build to check for errors</p> <pre><code>cd server &amp;&amp; npm run build\ncd ../client &amp;&amp; npm run build\n</code></pre> <p>Step 2: Start the dev server and manually test</p> <pre><code>cd server &amp;&amp; npm run dev\n# In another terminal:\ncd client &amp;&amp; npm run dev\n</code></pre> <p>Manual testing checklist: - [ ] Navigate to a scene that has URLs in Stash - [ ] Verify URLs appear in the Details panel after Tags - [ ] Verify known sites (Brazzers, Vixen, etc.) show proper names - [ ] Verify unknown sites show domain name with favicon attempt - [ ] Verify clicking links opens in new tab - [ ] Navigate to PerformerDetail - verify links still work</p> <p>Step 3: Commit any fixes if needed, then final verification</p> <pre><code>git status\n# If clean, you're done!\n</code></pre>"},{"location":"plans/2025-12-23-scene-urls-implementation/#summary","title":"Summary","text":"<p>This implementation: 1. Extracts site info logic into a reusable utility with 20+ known sites 2. Creates a shared SectionLink component with dynamic favicon fallback 3. Adds the URLs section to SceneDetails after Tags 4. Ensures the server includes <code>urls</code> in scene data 5. Refactors PerformerDetail to use the shared utilities (DRY)</p> <p>Total: 6 tasks, ~45 minutes estimated</p>"},{"location":"plans/2025-12-24-images-page-design/","title":"Images Page Design","text":"<p>Issue: #193 - Browse standalone images outside of galleries Date: 2025-12-24</p>"},{"location":"plans/2025-12-24-images-page-design/#overview","title":"Overview","text":"<p>Add an Images page to Peek that displays ALL images in the library (both standalone and gallery-associated), with full filtering, sorting, and the ability to view images in a lightbox. Gallery metadata acts as an \"umbrella\" over its images - images inherit their gallery's performers, tags, and studio for filtering purposes.</p>"},{"location":"plans/2025-12-24-images-page-design/#key-design-decisions","title":"Key Design Decisions","text":"<ol> <li> <p>Gallery-umbrella inheritance: Images inherit performers, tags, and studio from their parent galleries. If an image is in multiple galleries, it matches filters if ANY gallery matches (union approach).</p> </li> <li> <p>Data storage: All image metadata synced to Peek's database (already implemented). Image files streamed/proxied from Stash.</p> </li> <li> <p>Image proxy: Same pattern as video streaming - <code>/api/proxy/image/:imageId/:type</code> hides Stash API key from client.</p> </li> <li> <p>Navigation: \"Images\" appears after \"Galleries\" in sidebar, respecting user hide/reorder preferences.</p> </li> <li> <p>Image viewing: Clicking an image opens the existing Lightbox component (reused from GalleryDetail).</p> </li> <li> <p>Query architecture: Query-time JOINs using CTEs for gallery inheritance, with proper indexes for million-image scale.</p> </li> <li> <p>Multi-gallery conflict resolution: Union approach - image matches if ANY of its galleries match the filter criteria.</p> </li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#database-schema-changes","title":"Database Schema Changes","text":"<p>New migration adds missing fields and performance indexes:</p> <pre><code>-- StashImage additions\nALTER TABLE StashImage ADD COLUMN code TEXT;\nALTER TABLE StashImage ADD COLUMN details TEXT;\nALTER TABLE StashImage ADD COLUMN photographer TEXT;\nALTER TABLE StashImage ADD COLUMN urls TEXT;  -- JSON array\n\n-- StashGallery additions\nALTER TABLE StashGallery ADD COLUMN photographer TEXT;\nALTER TABLE StashGallery ADD COLUMN urls TEXT;  -- JSON array\n\n-- Performance indexes for gallery-umbrella queries\nCREATE INDEX IF NOT EXISTS ImageGallery_imageId_idx ON ImageGallery(imageId);\nCREATE INDEX IF NOT EXISTS GalleryPerformer_galleryId_idx ON GalleryPerformer(galleryId);\nCREATE INDEX IF NOT EXISTS GalleryTag_galleryId_idx ON GalleryTag(galleryId);\nCREATE INDEX IF NOT EXISTS StashGallery_studioId_deletedAt_idx ON StashGallery(studioId, deletedAt);\n</code></pre> <p>Update Prisma schema to match.</p>"},{"location":"plans/2025-12-24-images-page-design/#sync-service-updates","title":"Sync Service Updates","text":""},{"location":"plans/2025-12-24-images-page-design/#processimagesbatch","title":"processImagesBatch","text":"<p>Add new fields to the INSERT statement:</p> <pre><code>// Fields to add:\ncode, details, photographer, urls\n\n// Values:\n${this.escapeNullable(image.code)},\n${this.escapeNullable(image.details)},\n${this.escapeNullable(image.photographer)},\n${this.escapeNullable(image.urls ? JSON.stringify(image.urls) : null)}\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#processgalleriesbatch","title":"processGalleriesBatch","text":"<p>Add <code>photographer</code> and <code>urls</code> fields similarly.</p>"},{"location":"plans/2025-12-24-images-page-design/#stashapp-api","title":"stashapp-api","text":"<p>Ensure GraphQL queries request: <code>code</code>, <code>details</code>, <code>photographer</code>, <code>urls</code> for both images and galleries.</p>"},{"location":"plans/2025-12-24-images-page-design/#image-proxy-endpoint","title":"Image Proxy Endpoint","text":"<p>Route: <code>GET /api/proxy/image/:imageId/:type</code></p> <p>File: <code>server/routes/proxy/images.ts</code></p> <pre><code>router.get('/image/:imageId/:type', authenticated, async (req, res) =&gt; {\n  const { imageId, type } = req.params;\n\n  // Validate type\n  if (!['thumbnail', 'preview', 'image'].includes(type)) {\n    return res.status(400).json({ error: 'Invalid image type' });\n  }\n\n  // Get image from database\n  const image = await prisma.stashImage.findFirst({\n    where: { id: imageId, deletedAt: null }\n  });\n\n  if (!image) {\n    return res.status(404).json({ error: 'Image not found' });\n  }\n\n  // Get the appropriate path\n  const pathField = type === 'thumbnail' ? 'pathThumbnail'\n                  : type === 'preview' ? 'pathPreview'\n                  : 'pathImage';\n  const stashUrl = image[pathField];\n\n  if (!stashUrl) {\n    return res.status(404).json({ error: 'Image path not available' });\n  }\n\n  // Proxy the request to Stash (reuse existing proxy utility)\n  await proxyStashRequest(stashUrl, req, res);\n});\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#images-controller","title":"Images Controller","text":"<p>File: <code>server/controllers/library/images.ts</code></p>"},{"location":"plans/2025-12-24-images-page-design/#query-architecture-with-gallery-inheritance","title":"Query Architecture with Gallery Inheritance","text":"<p>Uses CTEs (Common Table Expressions) for efficient gallery-umbrella inheritance:</p> <pre><code>const buildImageQuery = (filters, sort, pagination) =&gt; {\n  return `\n    WITH effective_performers AS (\n      -- Direct image performers\n      SELECT imageId, performerId FROM ImagePerformer\n      UNION\n      -- Inherited from galleries\n      SELECT ig.imageId, gp.performerId\n      FROM ImageGallery ig\n      JOIN GalleryPerformer gp ON ig.galleryId = gp.galleryId\n    ),\n    effective_tags AS (\n      -- Direct image tags\n      SELECT imageId, tagId FROM ImageTag\n      UNION\n      -- Inherited from galleries\n      SELECT ig.imageId, gt.tagId\n      FROM ImageGallery ig\n      JOIN GalleryTag gt ON ig.galleryId = gt.galleryId\n    ),\n    effective_studios AS (\n      -- Direct image studio\n      SELECT id as imageId, studioId FROM StashImage WHERE studioId IS NOT NULL\n      UNION\n      -- Inherited from galleries (if image has no studio)\n      SELECT ig.imageId, g.studioId\n      FROM ImageGallery ig\n      JOIN StashGallery g ON ig.galleryId = g.id\n      WHERE g.studioId IS NOT NULL\n    )\n    SELECT DISTINCT i.*\n    FROM StashImage i\n    WHERE i.deletedAt IS NULL\n      ${performerFilter ? 'AND i.id IN (SELECT imageId FROM effective_performers WHERE performerId IN (?))' : ''}\n      ${tagFilter ? 'AND i.id IN (SELECT imageId FROM effective_tags WHERE tagId IN (?))' : ''}\n      ${studioFilter ? 'AND i.id IN (SELECT imageId FROM effective_studios WHERE studioId IN (?))' : ''}\n    ORDER BY ${sortColumn} ${sortDirection}\n    LIMIT ? OFFSET ?\n  `;\n};\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#endpoints","title":"Endpoints","text":"Endpoint Method Description <code>/api/library/images</code> POST Find images with filters/sort/pagination <code>/api/library/images/:id</code> GET Get single image with hydrated relationships <code>/api/library/images/minimal</code> POST Minimal list for dropdowns <code>/api/library/images/:id/rating</code> POST Set user rating (existing) <code>/api/library/images/:id/favorite</code> POST Toggle favorite (existing)"},{"location":"plans/2025-12-24-images-page-design/#filter-support","title":"Filter Support","text":"<p>Matching Stash's ImageFilterType:</p> Filter Type Description <code>title</code> text Search title <code>code</code> text Search code <code>details</code> text Search details <code>photographer</code> text Search photographer <code>rating100</code> numeric User rating comparison <code>o_counter</code> numeric O-counter comparison <code>date</code> date Date range filter <code>created_at</code> timestamp Creation time filter <code>updated_at</code> timestamp Update time filter <code>performers</code> multi-select Filter by performers (with gallery inheritance) <code>tags</code> multi-select Filter by tags (with gallery inheritance) <code>studios</code> hierarchical Filter by studio (with gallery inheritance) <code>galleries</code> multi-select Filter to specific galleries <code>organized</code> boolean Organized status <code>resolution</code> enum Resolution filter <code>orientation</code> enum Portrait/landscape/square <code>favorite</code> boolean User favorites"},{"location":"plans/2025-12-24-images-page-design/#sort-options","title":"Sort Options","text":"Sort Field Description <code>title</code> Alphabetical by title <code>date</code> By date field <code>rating</code> By user rating <code>path</code> By file path <code>filesize</code> By file size <code>o_counter</code> By o-counter <code>created_at</code> By creation time <code>updated_at</code> By update time <code>random</code> Random order <code>tag_count</code> By number of tags <code>performer_count</code> By number of performers"},{"location":"plans/2025-12-24-images-page-design/#frontend","title":"Frontend","text":""},{"location":"plans/2025-12-24-images-page-design/#navigation","title":"Navigation","text":"<p>Add \"Images\" to sidebar after \"Galleries\". Respects existing user preferences for hiding/reordering menu items.</p>"},{"location":"plans/2025-12-24-images-page-design/#images-page","title":"Images Page","text":"<p>File: <code>client/src/components/pages/Images.jsx</code></p> <p>Components: - Grid view using existing <code>CardGrid</code> component - Filter bar with chips for performers, tags, studios, galleries - Sort dropdown matching Stash's options - Search box for text search - Pagination</p>"},{"location":"plans/2025-12-24-images-page-design/#image-card","title":"Image Card","text":"<p>Displays: - Thumbnail image (via proxy endpoint) - Title (or filename if no title) - Resolution badge - Rating stars (if rated) - Favorite indicator - Gallery indicator icon (if image belongs to a gallery)</p>"},{"location":"plans/2025-12-24-images-page-design/#lightbox-integration","title":"Lightbox Integration","text":"<p>Clicking an image opens the existing Lightbox component from GalleryDetail. Future enhancements will add metadata display in pillarbox/letterbox spaces.</p>"},{"location":"plans/2025-12-24-images-page-design/#api-integration","title":"API Integration","text":"<pre><code>// client/src/services/api.js\nfindImages: async (params) =&gt; apiPost('/library/images', params),\ngetImage: async (id) =&gt; apiGet(`/library/images/${id}`),\ngetImageUrl: (imageId, type = 'thumbnail') =&gt; `/api/proxy/image/${imageId}/${type}`,\n</code></pre>"},{"location":"plans/2025-12-24-images-page-design/#entity-detail-page-integration","title":"Entity Detail Page Integration","text":""},{"location":"plans/2025-12-24-images-page-design/#performer-studio-tag-detail-pages","title":"Performer, Studio, Tag Detail Pages","text":"<p>Add \"Images\" tab/section showing images associated with that entity (respecting gallery-umbrella inheritance).</p> <ul> <li>Uses <code>findImages</code> API with entity filter pre-applied</li> <li>Shows grid of thumbnails</li> <li>Clicking opens lightbox</li> </ul>"},{"location":"plans/2025-12-24-images-page-design/#gallerydetail-page","title":"GalleryDetail Page","text":"<p>Refactor <code>getGalleryImages</code> endpoint to query Peek's database instead of Stash API directly. Continue using existing lightbox component.</p>"},{"location":"plans/2025-12-24-images-page-design/#content-restrictions","title":"Content Restrictions","text":"<p>Following existing patterns:</p> <ul> <li>Tag-based restrictions: Images respect INCLUDE/EXCLUDE rules, including inherited gallery tags</li> <li>Hidden entities: Images with hidden performers/tags/studios or in hidden galleries are filtered</li> <li>Empty entity filtering: Soft-deleted images hidden from non-admins</li> <li>Admin bypass: Admins skip content restrictions but still see hidden entity filtering</li> </ul>"},{"location":"plans/2025-12-24-images-page-design/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/2025-12-24-images-page-design/#phase-1-database-sync","title":"Phase 1: Database &amp; Sync","text":"<ol> <li>Create migration for new fields and indexes</li> <li>Update Prisma schema</li> <li>Update sync service for new fields</li> <li>Update stashapp-api if needed</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-2-backend-api","title":"Phase 2: Backend API","text":"<ol> <li>Create image proxy endpoint</li> <li>Create images controller with CTE queries</li> <li>Add routes</li> <li>Refactor GalleryDetail to use local DB</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-3-frontend","title":"Phase 3: Frontend","text":"<ol> <li>Add Images to navigation</li> <li>Create Images page with grid/filters/sort</li> <li>Integrate lightbox</li> <li>Add Images tab to entity detail pages</li> </ol>"},{"location":"plans/2025-12-24-images-page-design/#phase-4-polish","title":"Phase 4: Polish","text":"<ol> <li>Test with large datasets</li> <li>Optimize queries if needed</li> <li>Add any missing filter/sort options</li> </ol>"},{"location":"plans/2025-12-24-images-page-implementation/","title":"Images Page Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add an Images page that displays all images (standalone and gallery-associated) with filtering, sorting, and gallery-umbrella inheritance for metadata.</p> <p>Architecture: Refactor existing images controller to query Peek's local SQLite database instead of Stash API. Use CTEs for efficient gallery-umbrella inheritance. Add new frontend page following the Galleries page pattern.</p> <p>Tech Stack: TypeScript/Express backend, React frontend, SQLite with Prisma, existing CardGrid/Lightbox components.</p>"},{"location":"plans/2025-12-24-images-page-implementation/#task-1-database-migration-add-missing-fields","title":"Task 1: Database Migration - Add Missing Fields","text":"<p>Files: - Create: <code>server/prisma/migrations/2025XXXX_add_image_gallery_fields/migration.sql</code> - Modify: <code>server/prisma/schema.prisma</code></p> <p>Step 1: Create migration file</p> <p>Create <code>server/prisma/migrations/20251224100000_add_image_gallery_fields/migration.sql</code>:</p> <pre><code>-- Add missing fields to StashImage\nALTER TABLE \"StashImage\" ADD COLUMN \"code\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"details\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"photographer\" TEXT;\nALTER TABLE \"StashImage\" ADD COLUMN \"urls\" TEXT;\n\n-- Add missing fields to StashGallery\nALTER TABLE \"StashGallery\" ADD COLUMN \"photographer\" TEXT;\nALTER TABLE \"StashGallery\" ADD COLUMN \"urls\" TEXT;\n\n-- Performance indexes for gallery-umbrella queries\nCREATE INDEX IF NOT EXISTS \"ImageGallery_imageId_idx\" ON \"ImageGallery\"(\"imageId\");\nCREATE INDEX IF NOT EXISTS \"GalleryPerformer_galleryId_idx\" ON \"GalleryPerformer\"(\"galleryId\");\nCREATE INDEX IF NOT EXISTS \"GalleryTag_galleryId_idx\" ON \"GalleryTag\"(\"galleryId\");\nCREATE INDEX IF NOT EXISTS \"StashGallery_studioId_deletedAt_idx\" ON \"StashGallery\"(\"studioId\", \"deletedAt\");\nCREATE INDEX IF NOT EXISTS \"StashImage_title_idx\" ON \"StashImage\"(\"title\");\nCREATE INDEX IF NOT EXISTS \"StashImage_browse_idx\" ON \"StashImage\"(\"deletedAt\", \"stashCreatedAt\" DESC);\n</code></pre> <p>Step 2: Update Prisma schema</p> <p>In <code>server/prisma/schema.prisma</code>, find the <code>StashImage</code> model and add:</p> <pre><code>model StashImage {\n  id              String    @id\n  stashInstanceId String?\n  title           String?\n  code            String?       // NEW\n  details         String?       // NEW\n  photographer    String?       // NEW\n  urls            String?       // NEW (JSON array)\n  date            String?\n  studioId        String?\n  rating100       Int?\n  oCounter        Int       @default(0)\n  organized       Boolean   @default(false)\n  filePath        String?\n  width           Int?\n  height          Int?\n  fileSize        BigInt?\n  pathThumbnail   String?\n  pathPreview     String?\n  pathImage       String?\n  stashCreatedAt  DateTime?\n  stashUpdatedAt  DateTime?\n  syncedAt        DateTime  @default(now())\n  deletedAt       DateTime?\n\n  performers ImagePerformer[]\n  tags       ImageTag[]\n  galleries  ImageGallery[]\n\n  @@index([studioId])\n  @@index([date])\n  @@index([rating100])\n  @@index([stashUpdatedAt])\n  @@index([deletedAt])\n  @@index([title])\n  @@index([deletedAt, stashCreatedAt(sort: Desc)])\n}\n</code></pre> <p>Find the <code>StashGallery</code> model and add:</p> <pre><code>model StashGallery {\n  // ... existing fields ...\n  photographer    String?       // NEW\n  urls            String?       // NEW (JSON array)\n  // ... rest of model ...\n}\n</code></pre> <p>Step 3: Run migration</p> <p>Run: <code>cd server &amp;&amp; npx prisma migrate dev --name add_image_gallery_fields</code></p> <p>Expected: Migration applies successfully, Prisma client regenerated.</p> <p>Step 4: Commit</p> <pre><code>git add server/prisma/migrations server/prisma/schema.prisma\ngit commit -m \"feat: add missing image/gallery fields and performance indexes\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-2-update-sync-service-image-fields","title":"Task 2: Update Sync Service - Image Fields","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:1840-1891</code></p> <p>Step 1: Update processImagesBatch INSERT statement</p> <p>Find the <code>processImagesBatch</code> method around line 1840. Update the SQL INSERT to include new fields.</p> <p>Change the values template from:</p> <pre><code>return `(\n  '${this.escape(image.id)}',\n  ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n  ${this.escapeNullable(image.title)},\n  ${this.escapeNullable(image.date)},\n  // ... existing fields ...\n)`;\n</code></pre> <p>To:</p> <pre><code>return `(\n  '${this.escape(image.id)}',\n  ${stashInstanceId ? `'${this.escape(stashInstanceId)}'` : 'NULL'},\n  ${this.escapeNullable(image.title)},\n  ${this.escapeNullable(image.code)},\n  ${this.escapeNullable(image.details)},\n  ${this.escapeNullable(image.photographer)},\n  ${this.escapeNullable(image.urls ? JSON.stringify(image.urls) : null)},\n  ${this.escapeNullable(image.date)},\n  // ... rest of existing fields ...\n)`;\n</code></pre> <p>Update the INSERT column list to include: <code>code, details, photographer, urls</code></p> <p>Update the ON CONFLICT SET clause to include the new fields.</p> <p>Step 2: Verify sync fetches new fields</p> <p>Check that stashapp-api's <code>findImages</code> query includes <code>code</code>, <code>details</code>, <code>photographer</code>, <code>urls</code> fields. If not, this requires updating stashapp-api first.</p> <p>Step 3: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --grep \"StashSyncService\"</code></p> <p>Expected: Existing tests pass.</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: sync code, details, photographer, urls for images\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-3-update-sync-service-gallery-fields","title":"Task 3: Update Sync Service - Gallery Fields","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts</code> (processGalleriesBatch method)</p> <p>Step 1: Find processGalleriesBatch method</p> <p>Search for <code>processGalleriesBatch</code> in the file.</p> <p>Step 2: Update INSERT statement</p> <p>Add <code>photographer</code> and <code>urls</code> to the INSERT column list and values.</p> <pre><code>${this.escapeNullable(gallery.photographer)},\n${this.escapeNullable(gallery.urls ? JSON.stringify(gallery.urls) : null)},\n</code></pre> <p>Step 3: Update ON CONFLICT clause</p> <p>Add the new fields to the SET clause.</p> <p>Step 4: Commit</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"feat: sync photographer and urls for galleries\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-4-add-image-proxy-endpoint","title":"Task 4: Add Image Proxy Endpoint","text":"<p>Files: - Modify: <code>server/controllers/proxy.ts</code> - Modify: <code>server/routes/proxy.ts</code> (or wherever proxy routes are defined)</p> <p>Step 1: Add proxyImage controller function</p> <p>Add to <code>server/controllers/proxy.ts</code>:</p> <pre><code>/**\n * Proxy image requests by image ID and type\n * GET /api/proxy/image/:imageId/:type\n * :type = \"thumbnail\" | \"preview\" | \"image\"\n */\nexport const proxyImage = async (req: Request, res: Response) =&gt; {\n  const { imageId, type } = req.params;\n\n  if (!imageId) {\n    return res.status(400).json({ error: \"Missing image ID\" });\n  }\n\n  const validTypes = [\"thumbnail\", \"preview\", \"image\"];\n  if (!type || !validTypes.includes(type)) {\n    return res.status(400).json({ error: \"Invalid image type. Must be: thumbnail, preview, or image\" });\n  }\n\n  // Get image from database\n  const image = await prisma.stashImage.findFirst({\n    where: { id: imageId, deletedAt: null },\n  });\n\n  if (!image) {\n    return res.status(404).json({ error: \"Image not found\" });\n  }\n\n  // Get the appropriate path\n  const pathMap: Record&lt;string, string | null&gt; = {\n    thumbnail: image.pathThumbnail,\n    preview: image.pathPreview,\n    image: image.pathImage,\n  };\n  const stashPath = pathMap[type];\n\n  if (!stashPath) {\n    return res.status(404).json({ error: `Image ${type} path not available` });\n  }\n\n  let stashUrl: string;\n  let apiKey: string;\n\n  try {\n    stashUrl = stashInstanceManager.getBaseUrl();\n    apiKey = stashInstanceManager.getApiKey();\n  } catch {\n    logger.error(\"No Stash instance configured\");\n    return res.status(500).json({ error: \"Stash configuration missing\" });\n  }\n\n  // Acquire concurrency slot before making request\n  await acquireConcurrencySlot();\n\n  try {\n    // Construct full Stash URL with API key\n    const fullUrl = `${stashUrl}${stashPath}${stashPath.includes(\"?\") ? \"&amp;\" : \"?\"}apikey=${apiKey}`;\n\n    logger.debug(\"Proxying image request\", {\n      imageId,\n      type,\n      url: fullUrl.replace(apiKey, \"***\"),\n    });\n\n    const urlObj = new URL(fullUrl);\n    const httpModule = urlObj.protocol === \"https:\" ? https : http;\n    const agent = getAgentForUrl(urlObj);\n\n    const proxyReq = httpModule.get(fullUrl, { agent }, (proxyRes) =&gt; {\n      if (proxyRes.headers[\"content-type\"]) {\n        res.setHeader(\"Content-Type\", proxyRes.headers[\"content-type\"]);\n      }\n      if (proxyRes.headers[\"content-length\"]) {\n        res.setHeader(\"Content-Length\", proxyRes.headers[\"content-length\"]);\n      }\n      // Cache images for 24 hours\n      res.setHeader(\"Cache-Control\", \"public, max-age=86400\");\n      res.status(proxyRes.statusCode || 200);\n      proxyRes.pipe(res);\n      proxyRes.on(\"end\", releaseConcurrencySlot);\n      proxyRes.on(\"error\", releaseConcurrencySlot);\n    });\n\n    proxyReq.on(\"error\", (error: Error) =&gt; {\n      releaseConcurrencySlot();\n      logger.error(\"Error proxying image\", { imageId, type, error: error.message });\n      if (!res.headersSent) {\n        res.status(500).json({ error: \"Proxy request failed\" });\n      }\n    });\n\n    proxyReq.setTimeout(30000, () =&gt; {\n      releaseConcurrencySlot();\n      proxyReq.destroy();\n      if (!res.headersSent) {\n        res.status(504).json({ error: \"Proxy request timeout\" });\n      }\n    });\n  } catch (error) {\n    releaseConcurrencySlot();\n    logger.error(\"Error proxying image\", { error });\n    if (!res.headersSent) {\n      res.status(500).json({ error: \"Internal server error\" });\n    }\n  }\n};\n</code></pre> <p>Step 2: Add route</p> <p>Find the proxy routes file and add:</p> <pre><code>router.get(\"/image/:imageId/:type\", proxyImage);\n</code></pre> <p>Step 3: Add prisma import</p> <p>Add at top of <code>proxy.ts</code>:</p> <pre><code>import prisma from \"../prisma/singleton.js\";\n</code></pre> <p>Step 4: Test manually</p> <p>Start server and test: <code>curl http://localhost:3000/api/proxy/image/123/thumbnail</code></p> <p>Expected: Returns 404 if image doesn't exist, or proxies image if it does.</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/proxy.ts server/routes/proxy.ts\ngit commit -m \"feat: add image proxy endpoint\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-5-refactor-images-controller-database-queries","title":"Task 5: Refactor Images Controller - Database Queries","text":"<p>Files: - Modify: <code>server/controllers/library/images.ts</code></p> <p>Step 1: Add StashEntityService methods for images</p> <p>First, check if <code>StashEntityService</code> already has <code>getAllImages</code>, <code>getImage</code>, <code>getImagesByIds</code> methods. If not, add them following the pattern of <code>getAllGalleries</code>.</p> <p>Step 2: Rewrite findImages to use local database</p> <p>Replace the current implementation that queries Stash API with one that queries the local database using CTEs for gallery inheritance.</p> <pre><code>import type { Response } from \"express\";\nimport { AuthenticatedRequest } from \"../../middleware/auth.js\";\nimport prisma from \"../../prisma/singleton.js\";\nimport { stashEntityService } from \"../../services/StashEntityService.js\";\nimport { emptyEntityFilterService } from \"../../services/EmptyEntityFilterService.js\";\nimport { filteredEntityCacheService } from \"../../services/FilteredEntityCacheService.js\";\nimport { userRestrictionService } from \"../../services/UserRestrictionService.js\";\nimport { expandStudioIds, expandTagIds } from \"../../utils/hierarchyUtils.js\";\nimport { logger } from \"../../utils/logger.js\";\nimport { buildStashEntityUrl } from \"../../utils/stashUrl.js\";\n\n// ... keep existing calculateEntityImageCount function ...\n\n/**\n * Find images endpoint - queries local database with gallery-umbrella inheritance\n */\nexport const findImages = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const { filter, image_filter, ids } = req.body;\n\n    const sortField = filter?.sort || \"title\";\n    const sortDirection = filter?.direction || \"ASC\";\n    const page = filter?.page || 1;\n    const perPage = filter?.per_page || 40;\n    const searchQuery = filter?.q || \"\";\n\n    // Step 1: Get all images from cache/database\n    let images = await stashEntityService.getAllImages();\n\n    if (images.length === 0) {\n      logger.warn(\"Image cache not initialized, returning empty result\");\n      return res.json({\n        findImages: {\n          count: 0,\n          images: [],\n        },\n      });\n    }\n\n    // Step 2: Merge with user data (ratings/favorites)\n    images = await mergeImagesWithUserData(images, userId);\n\n    // Step 3: Apply content restrictions\n    const requestingUser = req.user;\n    images = await userRestrictionService.filterImagesForUser(\n      images,\n      userId,\n      requestingUser?.role === \"ADMIN\"\n    );\n\n    // Step 4: Apply search query\n    if (searchQuery) {\n      const lowerQuery = searchQuery.toLowerCase();\n      images = images.filter((img) =&gt; {\n        const title = img.title || \"\";\n        const details = img.details || \"\";\n        const photographer = img.photographer || \"\";\n        return (\n          title.toLowerCase().includes(lowerQuery) ||\n          details.toLowerCase().includes(lowerQuery) ||\n          photographer.toLowerCase().includes(lowerQuery)\n        );\n      });\n    }\n\n    // Step 5: Apply filters with gallery-umbrella inheritance\n    images = await applyImageFiltersWithInheritance(images, image_filter, ids);\n\n    // Step 6: Sort\n    images = sortImages(images, sortField, sortDirection);\n\n    // Step 7: Paginate\n    const total = images.length;\n    const startIndex = (page - 1) * perPage;\n    const endIndex = startIndex + perPage;\n    const paginatedImages = images.slice(startIndex, endIndex);\n\n    // Step 8: Add stashUrl to each image\n    const imagesWithStashUrl = paginatedImages.map((image) =&gt; ({\n      ...image,\n      stashUrl: buildStashEntityUrl(\"image\", image.id),\n    }));\n\n    res.json({\n      findImages: {\n        count: total,\n        images: imagesWithStashUrl,\n      },\n    });\n  } catch (error) {\n    logger.error(\"Error in findImages\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n\n/**\n * Apply image filters with gallery-umbrella inheritance\n */\nasync function applyImageFiltersWithInheritance(\n  images: any[],\n  filters: any,\n  ids?: string[]\n): Promise&lt;any[]&gt; {\n  if (!filters &amp;&amp; !ids) return images;\n\n  let filtered = images;\n\n  // Filter by IDs\n  if (ids &amp;&amp; Array.isArray(ids) &amp;&amp; ids.length &gt; 0) {\n    const idSet = new Set(ids);\n    filtered = filtered.filter((img) =&gt; idSet.has(img.id));\n  }\n\n  // Filter by favorite\n  if (filters?.favorite !== undefined) {\n    filtered = filtered.filter((img) =&gt; img.favorite === filters.favorite);\n  }\n\n  // Filter by rating100\n  if (filters?.rating100) {\n    const { modifier, value, value2 } = filters.rating100;\n    filtered = filtered.filter((img) =&gt; {\n      const rating = img.rating100 || 0;\n      if (modifier === \"GREATER_THAN\") return rating &gt; value;\n      if (modifier === \"LESS_THAN\") return rating &lt; value;\n      if (modifier === \"EQUALS\") return rating === value;\n      if (modifier === \"NOT_EQUALS\") return rating !== value;\n      if (modifier === \"BETWEEN\") return rating &gt;= value &amp;&amp; rating &lt;= value2;\n      return true;\n    });\n  }\n\n  // Filter by performers (with gallery inheritance)\n  if (filters?.performers?.value) {\n    const performerIds = new Set(filters.performers.value.map(String));\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct performers\n      if (img.performers?.some((p: any) =&gt; performerIds.has(String(p.id)))) {\n        return true;\n      }\n      // Check gallery performers (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.performers?.some((p: any) =&gt; performerIds.has(String(p.id)))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by tags (with gallery inheritance)\n  if (filters?.tags?.value) {\n    const expandedTagIds = new Set(\n      await expandTagIds(\n        filters.tags.value.map(String),\n        filters.tags.depth ?? 0\n      )\n    );\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct tags\n      if (img.tags?.some((t: any) =&gt; expandedTagIds.has(String(t.id)))) {\n        return true;\n      }\n      // Check gallery tags (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.tags?.some((t: any) =&gt; expandedTagIds.has(String(t.id)))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by studios (with gallery inheritance)\n  if (filters?.studios?.value) {\n    const expandedStudioIds = new Set(\n      await expandStudioIds(\n        filters.studios.value.map(String),\n        filters.studios.depth ?? 0\n      )\n    );\n    filtered = filtered.filter((img) =&gt; {\n      // Check direct studio\n      if (img.studio &amp;&amp; expandedStudioIds.has(String(img.studio.id))) {\n        return true;\n      }\n      // Check gallery studio (inheritance)\n      if (img.galleries?.some((g: any) =&gt;\n        g.studio &amp;&amp; expandedStudioIds.has(String(g.studio.id))\n      )) {\n        return true;\n      }\n      return false;\n    });\n  }\n\n  // Filter by specific galleries\n  if (filters?.galleries?.value) {\n    const galleryIds = new Set(filters.galleries.value.map(String));\n    filtered = filtered.filter((img) =&gt;\n      img.galleries?.some((g: any) =&gt; galleryIds.has(String(g.id)))\n    );\n  }\n\n  return filtered;\n}\n\n/**\n * Sort images\n */\nfunction sortImages(images: any[], sortField: string, sortDirection: string): any[] {\n  const direction = sortDirection === \"DESC\" ? -1 : 1;\n\n  return images.sort((a, b) =&gt; {\n    let aVal, bVal;\n\n    switch (sortField) {\n      case \"title\":\n        aVal = (a.title || a.filePath || \"\").toLowerCase();\n        bVal = (b.title || b.filePath || \"\").toLowerCase();\n        break;\n      case \"date\":\n        aVal = a.date || \"\";\n        bVal = b.date || \"\";\n        break;\n      case \"rating\":\n      case \"rating100\":\n        aVal = a.rating100 || 0;\n        bVal = b.rating100 || 0;\n        break;\n      case \"o_counter\":\n        aVal = a.oCounter || 0;\n        bVal = b.oCounter || 0;\n        break;\n      case \"filesize\":\n        aVal = Number(a.fileSize) || 0;\n        bVal = Number(b.fileSize) || 0;\n        break;\n      case \"path\":\n        aVal = (a.filePath || \"\").toLowerCase();\n        bVal = (b.filePath || \"\").toLowerCase();\n        break;\n      case \"created_at\":\n        aVal = a.stashCreatedAt || \"\";\n        bVal = b.stashCreatedAt || \"\";\n        break;\n      case \"updated_at\":\n        aVal = a.stashUpdatedAt || \"\";\n        bVal = b.stashUpdatedAt || \"\";\n        break;\n      case \"random\":\n        return Math.random() - 0.5;\n      default:\n        aVal = (a.title || \"\").toLowerCase();\n        bVal = (b.title || \"\").toLowerCase();\n    }\n\n    if (aVal &lt; bVal) return -1 * direction;\n    if (aVal &gt; bVal) return 1 * direction;\n    return 0;\n  });\n}\n\n/**\n * Merge images with user rating/favorite data\n */\nasync function mergeImagesWithUserData(images: any[], userId: number): Promise&lt;any[]&gt; {\n  const ratings = await prisma.imageRating.findMany({ where: { userId } });\n\n  const ratingMap = new Map(\n    ratings.map((r) =&gt; [\n      r.imageId,\n      {\n        rating: r.rating,\n        rating100: r.rating,\n        favorite: r.favorite,\n      },\n    ])\n  );\n\n  return images.map((image) =&gt; ({\n    ...image,\n    rating: null,\n    rating100: null,\n    favorite: false,\n    ...ratingMap.get(image.id),\n  }));\n}\n</code></pre> <p>Step 3: Add findImageById endpoint</p> <pre><code>/**\n * Find single image by ID\n */\nexport const findImageById = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  try {\n    const userId = req.user?.id;\n    const { id } = req.params;\n\n    const image = await stashEntityService.getImage(id);\n\n    if (!image) {\n      return res.status(404).json({ error: \"Image not found\" });\n    }\n\n    // Merge with user data\n    const images = await mergeImagesWithUserData([image], userId);\n    const mergedImage = images[0];\n\n    res.json(mergedImage);\n  } catch (error) {\n    logger.error(\"Error in findImageById\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find image\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add server/controllers/library/images.ts\ngit commit -m \"refactor: images controller to use local database with gallery inheritance\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-6-add-stashentityservice-image-methods","title":"Task 6: Add StashEntityService Image Methods","text":"<p>Files: - Modify: <code>server/services/StashEntityService.ts</code></p> <p>Step 1: Add getAllImages method</p> <p>Find where <code>getAllGalleries</code> is defined and add similar methods for images:</p> <pre><code>/**\n * Get all images from cache\n */\nasync getAllImages(): Promise&lt;NormalizedImage[]&gt; {\n  const cached = await prisma.stashImage.findMany({\n    where: { deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached.map(this.normalizeImage.bind(this));\n}\n\n/**\n * Get single image by ID\n */\nasync getImage(id: string): Promise&lt;NormalizedImage | null&gt; {\n  const cached = await prisma.stashImage.findFirst({\n    where: { id, deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached ? this.normalizeImage(cached) : null;\n}\n\n/**\n * Get images by IDs\n */\nasync getImagesByIds(ids: string[]): Promise&lt;NormalizedImage[]&gt; {\n  const cached = await prisma.stashImage.findMany({\n    where: { id: { in: ids }, deletedAt: null },\n    include: {\n      performers: { include: { performer: true } },\n      tags: { include: { tag: true } },\n      galleries: { include: { gallery: true } },\n    },\n  });\n  return cached.map(this.normalizeImage.bind(this));\n}\n\n/**\n * Normalize image from database to API format\n */\nprivate normalizeImage(dbImage: any): NormalizedImage {\n  return {\n    id: dbImage.id,\n    title: dbImage.title,\n    code: dbImage.code,\n    details: dbImage.details,\n    photographer: dbImage.photographer,\n    urls: dbImage.urls ? JSON.parse(dbImage.urls) : [],\n    date: dbImage.date,\n    rating100: dbImage.rating100,\n    o_counter: dbImage.oCounter,\n    organized: dbImage.organized,\n    file_path: dbImage.filePath,\n    width: dbImage.width,\n    height: dbImage.height,\n    file_size: dbImage.fileSize ? Number(dbImage.fileSize) : null,\n    paths: {\n      thumbnail: dbImage.pathThumbnail,\n      preview: dbImage.pathPreview,\n      image: dbImage.pathImage,\n    },\n    created_at: dbImage.stashCreatedAt?.toISOString(),\n    updated_at: dbImage.stashUpdatedAt?.toISOString(),\n    studio: dbImage.studioId ? { id: dbImage.studioId } : null,\n    performers: dbImage.performers?.map((ip: any) =&gt; ({\n      id: ip.performer.id,\n      name: ip.performer.name,\n    })) || [],\n    tags: dbImage.tags?.map((it: any) =&gt; ({\n      id: it.tag.id,\n      name: it.tag.name,\n    })) || [],\n    galleries: dbImage.galleries?.map((ig: any) =&gt; ({\n      id: ig.gallery.id,\n      title: ig.gallery.title,\n    })) || [],\n  };\n}\n</code></pre> <p>Step 2: Add NormalizedImage type</p> <p>In <code>server/types/index.ts</code>, add:</p> <pre><code>export interface NormalizedImage {\n  id: string;\n  title: string | null;\n  code: string | null;\n  details: string | null;\n  photographer: string | null;\n  urls: string[];\n  date: string | null;\n  rating100: number | null;\n  o_counter: number;\n  organized: boolean;\n  file_path: string | null;\n  width: number | null;\n  height: number | null;\n  file_size: number | null;\n  paths: {\n    thumbnail: string | null;\n    preview: string | null;\n    image: string | null;\n  };\n  created_at: string | null;\n  updated_at: string | null;\n  studio: { id: string } | null;\n  performers: { id: string; name: string }[];\n  tags: { id: string; name: string }[];\n  galleries: { id: string; title: string | null }[];\n  // User data (merged)\n  rating?: number | null;\n  favorite?: boolean;\n}\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add server/services/StashEntityService.ts server/types/index.ts\ngit commit -m \"feat: add image methods to StashEntityService\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-7-add-image-routes","title":"Task 7: Add Image Routes","text":"<p>Files: - Modify: <code>server/routes/library/images.ts</code></p> <p>Step 1: Add additional routes</p> <pre><code>import express from \"express\";\nimport { findImages, findImageById } from \"../../controllers/library/images.js\";\nimport { authenticateToken, requireCacheReady } from \"../../middleware/auth.js\";\nimport { authenticated } from \"../../utils/routeHelpers.js\";\n\nconst router = express.Router();\n\n// Find images (with filters, pagination, sorting)\nrouter.post(\n  \"/images\",\n  authenticateToken,\n  requireCacheReady,\n  authenticated(findImages)\n);\n\n// Get single image by ID\nrouter.get(\n  \"/images/:id\",\n  authenticateToken,\n  requireCacheReady,\n  authenticated(findImageById)\n);\n\nexport default router;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/routes/library/images.ts\ngit commit -m \"feat: add image routes\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-8-add-navigation-item","title":"Task 8: Add Navigation Item","text":"<p>Files: - Modify: <code>client/src/constants/navigation.js</code></p> <p>Step 1: Add Images nav item after Galleries</p> <p>Find the <code>NAV_DEFINITIONS</code> array and add after the galleries entry:</p> <pre><code>{\n  key: \"images\",\n  name: \"Images\",\n  path: \"/images\",\n  icon: \"image\",\n  description: \"Browse all images in your library\",\n},\n</code></pre> <p>Step 2: Update Sidebar getCurrentPage</p> <p>In <code>client/src/components/ui/Sidebar.jsx</code>, find <code>getCurrentPage</code> function and add:</p> <pre><code>if (path.startsWith(\"/images\")) return \"Images\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/constants/navigation.js client/src/components/ui/Sidebar.jsx\ngit commit -m \"feat: add Images to navigation\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-9-create-images-page-component","title":"Task 9: Create Images Page Component","text":"<p>Files: - Create: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Create the Images page</p> <p>Follow the Galleries.jsx pattern:</p> <pre><code>import { useRef, useState } from \"react\";\nimport { useLocation, useNavigate, useSearchParams } from \"react-router-dom\";\nimport deepEqual from \"fast-deep-equal\";\nimport { STANDARD_GRID_CONTAINER_CLASSNAMES } from \"../../constants/grids.js\";\nimport { useAuth } from \"../../hooks/useAuth.js\";\nimport { useInitialFocus } from \"../../hooks/useFocusTrap.js\";\nimport { useGridColumns } from \"../../hooks/useGridColumns.js\";\nimport { usePageTitle } from \"../../hooks/usePageTitle.js\";\nimport { useGridPageTVNavigation } from \"../../hooks/useGridPageTVNavigation.js\";\nimport { libraryApi } from \"../../services/api.js\";\nimport { ImageCard } from \"../cards/index.js\";\nimport {\n  SyncProgressBanner,\n  ErrorMessage,\n  PageHeader,\n  PageLayout,\n  SearchControls,\n} from \"../ui/index.js\";\n\nconst getImages = async (query) =&gt; {\n  const params = {\n    filter: {\n      page: query.page || 1,\n      per_page: query.per_page || 24,\n      sort: query.sort || \"title\",\n      direction: query.direction || \"ASC\",\n      q: query.q || \"\",\n    },\n    image_filter: {},\n  };\n\n  // Add filters\n  if (query.performers?.length) {\n    params.image_filter.performers = { value: query.performers };\n  }\n  if (query.tags?.length) {\n    params.image_filter.tags = { value: query.tags };\n  }\n  if (query.studios?.length) {\n    params.image_filter.studios = { value: query.studios };\n  }\n  if (query.galleries?.length) {\n    params.image_filter.galleries = { value: query.galleries };\n  }\n  if (query.favorite !== undefined) {\n    params.image_filter.favorite = query.favorite;\n  }\n  if (query.rating100) {\n    params.image_filter.rating100 = query.rating100;\n  }\n\n  const result = await libraryApi.findImages(params);\n  return {\n    images: result?.findImages?.images || [],\n    count: result?.findImages?.count || 0,\n  };\n};\n\nconst Images = () =&gt; {\n  usePageTitle(\"Images\");\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [searchParams] = useSearchParams();\n  const pageRef = useRef(null);\n  const gridRef = useRef(null);\n  const { isAuthenticated, isLoading: isAuthLoading } = useAuth();\n  const columns = useGridColumns(\"images\");\n\n  const [lastQuery, setLastQuery] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const [initMessage, setInitMessage] = useState(null);\n\n  const handleQueryChange = async (newQuery, retryCount = 0) =&gt; {\n    if (isAuthLoading || !isAuthenticated) {\n      return;\n    }\n\n    if (lastQuery &amp;&amp; deepEqual(newQuery, lastQuery)) {\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setLastQuery(newQuery);\n      setError(null);\n      setInitMessage(null);\n      const result = await getImages(newQuery);\n      setData(result);\n      setIsLoading(false);\n    } catch (err) {\n      if (err.isInitializing &amp;&amp; retryCount &lt; 60) {\n        setInitMessage(\"Server is syncing library, please wait...\");\n        setTimeout(() =&gt; {\n          handleQueryChange(newQuery, retryCount + 1);\n        }, 5000);\n        return;\n      }\n      setError(err.message || \"An error occurred\");\n      setIsLoading(false);\n    }\n  };\n\n  const currentImages = data?.images || [];\n  const totalCount = data?.count || 0;\n\n  const urlPerPage = parseInt(searchParams.get(\"per_page\")) || 24;\n  const totalPages = Math.ceil(totalCount / urlPerPage);\n\n  // TV Navigation\n  const {\n    isTVMode,\n    _tvNavigation,\n    searchControlsProps,\n    gridItemProps,\n  } = useGridPageTVNavigation({\n    items: currentImages,\n    columns,\n    onNavigate: (item) =&gt; {\n      // Open lightbox instead of navigating\n      // TODO: Implement lightbox opening\n    },\n    gridRef,\n    currentPage: parseInt(searchParams.get(\"page\")) || 1,\n    totalPages,\n    navigate,\n    location,\n  });\n\n  useInitialFocus(pageRef, \".search-input\");\n\n  return (\n    &lt;PageLayout ref={pageRef}&gt;\n      &lt;SyncProgressBanner /&gt;\n\n      &lt;div className={STANDARD_GRID_CONTAINER_CLASSNAMES}&gt;\n        &lt;PageHeader\n          title=\"Images\"\n          count={totalCount}\n          isLoading={isLoading}\n        /&gt;\n\n        &lt;SearchControls\n          entityType=\"image\"\n          onQueryChange={handleQueryChange}\n          sortOptions={[\n            { value: \"title\", label: \"Title\" },\n            { value: \"date\", label: \"Date\" },\n            { value: \"rating\", label: \"Rating\" },\n            { value: \"path\", label: \"Path\" },\n            { value: \"filesize\", label: \"File Size\" },\n            { value: \"created_at\", label: \"Created\" },\n            { value: \"updated_at\", label: \"Updated\" },\n            { value: \"random\", label: \"Random\" },\n          ]}\n          defaultSort=\"title\"\n          filterTypes={[\"performers\", \"tags\", \"studios\", \"galleries\", \"favorite\", \"rating\"]}\n          {...searchControlsProps}\n        /&gt;\n\n        {initMessage &amp;&amp; (\n          &lt;div className=\"text-center py-8 text-muted-foreground\"&gt;\n            {initMessage}\n          &lt;/div&gt;\n        )}\n\n        {error &amp;&amp; &lt;ErrorMessage message={error} /&gt;}\n\n        {!error &amp;&amp; !initMessage &amp;&amp; (\n          &lt;div\n            ref={gridRef}\n            className=\"grid gap-4\"\n            style={{\n              gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,\n            }}\n          &gt;\n            {currentImages.map((image, index) =&gt; (\n              &lt;ImageCard\n                key={image.id}\n                image={image}\n                {...gridItemProps(index)}\n              /&gt;\n            ))}\n          &lt;/div&gt;\n        )}\n\n        {!isLoading &amp;&amp; currentImages.length === 0 &amp;&amp; !error &amp;&amp; (\n          &lt;div className=\"text-center py-8 text-muted-foreground\"&gt;\n            No images found\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/PageLayout&gt;\n  );\n};\n\nexport default Images;\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"feat: create Images page component\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-10-create-imagecard-component","title":"Task 10: Create ImageCard Component","text":"<p>Files: - Create: <code>client/src/components/cards/ImageCard.jsx</code> - Modify: <code>client/src/components/cards/index.js</code></p> <p>Step 1: Create ImageCard component</p> <pre><code>import { useState } from \"react\";\nimport { ThemedIcon } from \"../icons/index.js\";\nimport { RatingDisplay } from \"../ui/index.js\";\n\n/**\n * Get proxied image URL\n */\nconst getImageUrl = (imageId, type = \"thumbnail\") =&gt; {\n  return `/api/proxy/image/${imageId}/${type}`;\n};\n\n/**\n * Format resolution string\n */\nconst formatResolution = (width, height) =&gt; {\n  if (!width || !height) return null;\n  if (height &gt;= 2160) return \"4K\";\n  if (height &gt;= 1440) return \"1440p\";\n  if (height &gt;= 1080) return \"1080p\";\n  if (height &gt;= 720) return \"720p\";\n  if (height &gt;= 480) return \"480p\";\n  return `${width}x${height}`;\n};\n\nconst ImageCard = ({ image, onClick, ...props }) =&gt; {\n  const [imageError, setImageError] = useState(false);\n\n  const handleClick = () =&gt; {\n    if (onClick) {\n      onClick(image);\n    }\n  };\n\n  const resolution = formatResolution(image.width, image.height);\n  const hasGallery = image.galleries?.length &gt; 0;\n\n  return (\n    &lt;div\n      className=\"group relative aspect-[3/4] overflow-hidden rounded-lg bg-card cursor-pointer transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-primary\"\n      onClick={handleClick}\n      tabIndex={0}\n      {...props}\n    &gt;\n      {/* Image */}\n      {!imageError ? (\n        &lt;img\n          src={getImageUrl(image.id, \"thumbnail\")}\n          alt={image.title || \"Image\"}\n          className=\"h-full w-full object-cover\"\n          loading=\"lazy\"\n          onError={() =&gt; setImageError(true)}\n        /&gt;\n      ) : (\n        &lt;div className=\"flex h-full w-full items-center justify-center bg-muted\"&gt;\n          &lt;ThemedIcon name=\"image\" className=\"h-12 w-12 text-muted-foreground\" /&gt;\n        &lt;/div&gt;\n      )}\n\n      {/* Overlay with info */}\n      &lt;div className=\"absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity\"&gt;\n        &lt;div className=\"absolute bottom-0 left-0 right-0 p-3\"&gt;\n          &lt;h3 className=\"text-sm font-medium text-white line-clamp-2\"&gt;\n            {image.title || \"Untitled\"}\n          &lt;/h3&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Badges */}\n      &lt;div className=\"absolute top-2 left-2 flex gap-1\"&gt;\n        {resolution &amp;&amp; (\n          &lt;span className=\"px-1.5 py-0.5 text-xs font-medium bg-black/60 text-white rounded\"&gt;\n            {resolution}\n          &lt;/span&gt;\n        )}\n        {hasGallery &amp;&amp; (\n          &lt;span className=\"px-1.5 py-0.5 bg-black/60 text-white rounded\"&gt;\n            &lt;ThemedIcon name=\"gallery-vertical\" className=\"h-3 w-3\" /&gt;\n          &lt;/span&gt;\n        )}\n      &lt;/div&gt;\n\n      {/* Favorite indicator */}\n      {image.favorite &amp;&amp; (\n        &lt;div className=\"absolute top-2 right-2\"&gt;\n          &lt;ThemedIcon name=\"heart\" className=\"h-4 w-4 text-red-500 fill-red-500\" /&gt;\n        &lt;/div&gt;\n      )}\n\n      {/* Rating */}\n      {image.rating100 &gt; 0 &amp;&amp; (\n        &lt;div className=\"absolute bottom-2 right-2\"&gt;\n          &lt;RatingDisplay rating={image.rating100} size=\"sm\" /&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ImageCard;\n</code></pre> <p>Step 2: Export from index</p> <p>Add to <code>client/src/components/cards/index.js</code>:</p> <pre><code>export { default as ImageCard } from \"./ImageCard.jsx\";\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/components/cards/ImageCard.jsx client/src/components/cards/index.js\ngit commit -m \"feat: create ImageCard component\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-11-add-route-to-app","title":"Task 11: Add Route to App","text":"<p>Files: - Modify: <code>client/src/App.jsx</code></p> <p>Step 1: Import Images page</p> <p>Add import:</p> <pre><code>import Images from \"./components/pages/Images.jsx\";\n</code></pre> <p>Step 2: Add route</p> <p>Find where routes are defined and add after Galleries:</p> <pre><code>&lt;Route path=\"/images\" element={&lt;Images /&gt;} /&gt;\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add client/src/App.jsx\ngit commit -m \"feat: add Images route to App\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-12-integrate-lightbox-with-images-page","title":"Task 12: Integrate Lightbox with Images Page","text":"<p>Files: - Modify: <code>client/src/components/pages/Images.jsx</code></p> <p>Step 1: Import Lightbox</p> <p>Check how GalleryDetail uses Lightbox and import the same component.</p> <p>Step 2: Add lightbox state</p> <pre><code>const [lightboxOpen, setLightboxOpen] = useState(false);\nconst [lightboxIndex, setLightboxIndex] = useState(0);\n\nconst handleImageClick = (image) =&gt; {\n  const index = currentImages.findIndex((img) =&gt; img.id === image.id);\n  setLightboxIndex(index);\n  setLightboxOpen(true);\n};\n</code></pre> <p>Step 3: Add Lightbox component</p> <pre><code>{lightboxOpen &amp;&amp; (\n  &lt;Lightbox\n    images={currentImages.map((img) =&gt; ({\n      id: img.id,\n      src: getImageUrl(img.id, \"image\"),\n      thumbnail: getImageUrl(img.id, \"thumbnail\"),\n      title: img.title,\n    }))}\n    initialIndex={lightboxIndex}\n    onClose={() =&gt; setLightboxOpen(false)}\n  /&gt;\n)}\n</code></pre> <p>Step 4: Pass onClick to ImageCard</p> <pre><code>&lt;ImageCard\n  key={image.id}\n  image={image}\n  onClick={handleImageClick}\n  {...gridItemProps(index)}\n/&gt;\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add client/src/components/pages/Images.jsx\ngit commit -m \"feat: integrate lightbox with Images page\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-13-refactor-gallerydetail-to-use-local-database","title":"Task 13: Refactor GalleryDetail to Use Local Database","text":"<p>Files: - Modify: <code>server/controllers/library/galleries.ts:600-669</code></p> <p>Step 1: Update getGalleryImages</p> <p>Replace the Stash API query with a local database query:</p> <pre><code>export const getGalleryImages = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n  try {\n    const { galleryId } = req.params;\n    const userId = req.user?.id;\n\n    if (!userId) {\n      return res.status(401).json({ error: \"Unauthorized\" });\n    }\n\n    // Query images from local database\n    const images = await prisma.stashImage.findMany({\n      where: {\n        deletedAt: null,\n        galleries: {\n          some: { galleryId },\n        },\n      },\n      include: {\n        performers: { include: { performer: true } },\n        tags: { include: { tag: true } },\n      },\n      orderBy: { filePath: \"asc\" },\n    });\n\n    // Transform to API format\n    const transformedImages = images.map((image) =&gt; ({\n      id: image.id,\n      title: image.title,\n      paths: {\n        thumbnail: `/api/proxy/image/${image.id}/thumbnail`,\n        preview: `/api/proxy/image/${image.id}/preview`,\n        image: `/api/proxy/image/${image.id}/image`,\n      },\n      width: image.width,\n      height: image.height,\n      rating100: image.rating100,\n      o_counter: image.oCounter,\n      performers: image.performers.map((ip) =&gt; ({\n        id: ip.performer.id,\n        name: ip.performer.name,\n      })),\n      tags: image.tags.map((it) =&gt; ({\n        id: it.tag.id,\n        name: it.tag.name,\n      })),\n    }));\n\n    // Merge with user data\n    const mergedImages = await mergeImagesWithUserData(transformedImages, userId);\n\n    res.json({\n      images: mergedImages,\n      count: mergedImages.length,\n    });\n  } catch (error) {\n    logger.error(\"Error fetching gallery images\", {\n      galleryId: req.params.galleryId,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to fetch gallery images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add server/controllers/library/galleries.ts\ngit commit -m \"refactor: GalleryDetail images to use local database\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-14-add-images-tab-to-entity-detail-pages","title":"Task 14: Add Images Tab to Entity Detail Pages","text":"<p>Files: - Modify: <code>client/src/components/pages/PerformerDetail.jsx</code> - Modify: <code>client/src/components/pages/StudioDetail.jsx</code> - Modify: <code>client/src/components/pages/TagDetail.jsx</code></p> <p>Step 1: Check existing tab implementation</p> <p>Look at how Galleries tab is implemented on these pages.</p> <p>Step 2: Add Images tab</p> <p>Follow the same pattern - add \"Images\" to the tabs array and render an images grid when that tab is selected, using the same <code>findImages</code> API with the appropriate entity filter.</p> <p>Step 3: Commit</p> <pre><code>git add client/src/components/pages/PerformerDetail.jsx client/src/components/pages/StudioDetail.jsx client/src/components/pages/TagDetail.jsx\ngit commit -m \"feat: add Images tab to entity detail pages\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#task-15-test-and-verify","title":"Task 15: Test and Verify","text":"<p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass.</p> <p>Step 2: Run client build</p> <p>Run: <code>cd client &amp;&amp; npm run build</code></p> <p>Expected: Build succeeds with no errors.</p> <p>Step 3: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint &amp;&amp; cd ../client &amp;&amp; npm run lint</code></p> <p>Expected: No linting errors.</p> <p>Step 4: Manual testing</p> <ol> <li>Start the server and client</li> <li>Navigate to Images page</li> <li>Verify images load</li> <li>Test filters (performers, tags, studios, galleries)</li> <li>Test sorting options</li> <li>Click an image to verify lightbox opens</li> <li>Navigate to Performer/Studio/Tag detail pages</li> <li>Verify Images tab appears and works</li> </ol> <p>Step 5: Final commit</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup and testing\"\n</code></pre>"},{"location":"plans/2025-12-24-images-page-implementation/#summary","title":"Summary","text":"<p>This plan implements the Images page feature in 15 tasks:</p> <ol> <li>Database migration for new fields</li> <li>Sync service update for images</li> <li>Sync service update for galleries</li> <li>Image proxy endpoint</li> <li>Images controller refactor</li> <li>StashEntityService image methods</li> <li>Image routes</li> <li>Navigation item</li> <li>Images page component</li> <li>ImageCard component</li> <li>App route</li> <li>Lightbox integration</li> <li>GalleryDetail refactor</li> <li>Entity detail page tabs</li> <li>Testing and verification</li> </ol> <p>Each task is a small, focused change that can be completed and committed independently.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/","title":"Content Exclusion Limit Fix","text":"<p>Issue: #200 (Part 2) - Tag exclusions capped at 500 items Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#problem","title":"Problem","text":"<p>Content restriction exclusions configured in user settings are being truncated to 500 items. Users with extensive tag exclusions see excluded content appearing when browsing.</p> <p>User logs show: <pre><code>\"computed 1531 exclusions in 9ms\"\n\"Exclusion set truncated to 500 items\"\n\"originalSize\": 1531\n</code></pre></p> <p>This defeats the purpose of content restrictions for users with many exclusions.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In <code>SceneQueryBuilder.buildExclusionFilter()</code>, there's a hardcoded limit:</p> <pre><code>// SceneQueryBuilder.ts:96-114\nprivate buildExclusionFilter(excludedIds: Set&lt;string&gt;): FilterClause {\n  const ids = Array.from(excludedIds);\n\n  if (ids.length &lt;= 500) {\n    // Direct IN clause for smaller sets\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n    return {\n      sql: `s.id NOT IN (${placeholders})`,\n      params: ids,\n    };\n  }\n\n  // For larger sets - TRUNCATES to 500!\n  const placeholders = ids.slice(0, 500).map(() =&gt; \"?\").join(\", \");\n  logger.warn(\"Exclusion set truncated to 500 items\", {\n    originalSize: ids.length,\n  });\n  return {\n    sql: `s.id NOT IN (${placeholders})`,\n    params: ids.slice(0, 500),\n  };\n}\n</code></pre> <p>The comment mentions \"consider pre-computing a materialized view\" but no alternative is implemented.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#solution-options","title":"Solution Options","text":""},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-a-chunked-not-in-clauses-recommended","title":"Option A: Chunked NOT IN Clauses (Recommended)","text":"<p>Split the exclusion set into chunks and combine with AND:</p> <pre><code>WHERE s.id NOT IN (chunk1) AND s.id NOT IN (chunk2) AND ...\n</code></pre> <p>SQLite handles each chunk efficiently, and combining with AND maintains correct semantics.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-b-temp-table-with-left-join","title":"Option B: Temp Table with LEFT JOIN","text":"<p>Create a temporary table with excluded IDs and use a LEFT JOIN:</p> <pre><code>CREATE TEMP TABLE excluded_scenes (id TEXT);\nINSERT INTO excluded_scenes VALUES (...);\n\nSELECT ... FROM StashScene s\nLEFT JOIN excluded_scenes e ON s.id = e.id\nWHERE e.id IS NULL;\n</code></pre> <p>Trade-off: Adds complexity with temp table lifecycle management.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#option-c-subquery-with-values","title":"Option C: Subquery with VALUES","text":"<p>Use a subquery with inline VALUES:</p> <pre><code>WHERE s.id NOT IN (SELECT id FROM (VALUES ('id1'), ('id2'), ...))\n</code></pre> <p>Trade-off: SQLite VALUES syntax has limits and this may not work well with very large sets.</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#design-decision","title":"Design Decision","text":"<p>Use Option A - Chunked NOT IN clauses.</p> <p>Rationale: - Simple to implement - No temp table management - SQLite handles multiple NOT IN clauses efficiently - Easy to understand and debug - Chunk size of 500 is safe for SQLite parameter limits</p>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#1-update-buildexclusionfilter-method","title":"1. Update buildExclusionFilter method","text":"<pre><code>private buildExclusionFilter(excludedIds: Set&lt;string&gt;): FilterClause {\n  if (!excludedIds || excludedIds.size === 0) {\n    return { sql: \"\", params: [] };\n  }\n\n  const ids = Array.from(excludedIds);\n  const CHUNK_SIZE = 500;\n\n  if (ids.length &lt;= CHUNK_SIZE) {\n    // Single IN clause for small sets\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n    return {\n      sql: `s.id NOT IN (${placeholders})`,\n      params: ids,\n    };\n  }\n\n  // Chunk large sets into multiple NOT IN clauses\n  const clauses: string[] = [];\n  const allParams: string[] = [];\n\n  for (let i = 0; i &lt; ids.length; i += CHUNK_SIZE) {\n    const chunk = ids.slice(i, i + CHUNK_SIZE);\n    const placeholders = chunk.map(() =&gt; \"?\").join(\", \");\n    clauses.push(`s.id NOT IN (${placeholders})`);\n    allParams.push(...chunk);\n  }\n\n  logger.debug(\"Large exclusion set chunked\", {\n    totalSize: ids.length,\n    chunks: clauses.length,\n  });\n\n  return {\n    sql: `(${clauses.join(\" AND \")})`,\n    params: allParams,\n  };\n}\n</code></pre>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#2-add-integration-test","title":"2. Add integration test","text":"<p>Add a test case that verifies exclusion works with &gt;500 items:</p> <pre><code>it(\"should handle large exclusion sets (&gt;500 items)\", async () =&gt; {\n  // Create 600 excluded scene IDs\n  const excludedIds = new Set(\n    Array.from({ length: 600 }, (_, i) =&gt; `excluded-${i}`)\n  );\n\n  const result = await sceneQueryBuilder.execute({\n    userId: 1,\n    excludedSceneIds: excludedIds,\n    sort: \"created_at\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n  });\n\n  // Verify none of the excluded IDs appear in results\n  for (const scene of result.scenes) {\n    expect(excludedIds.has(scene.id)).toBe(false);\n  }\n});\n</code></pre>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>server/services/SceneQueryBuilder.ts</code></li> <li>Update <code>buildExclusionFilter()</code> method</li> <li><code>server/tests/services/SceneQueryBuilder.integration.test.ts</code></li> <li>Add test for large exclusion sets</li> </ul>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Each chunk adds an AND clause, but SQLite query optimizer handles this efficiently</li> <li>Log at debug level to avoid spam in production</li> <li>Consider adding metrics to track exclusion set sizes in production</li> </ul>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#testing","title":"Testing","text":"<ol> <li>Create user with &gt;500 tag exclusions</li> <li>Browse scenes and verify excluded content does not appear</li> <li>Check logs for \"Large exclusion set chunked\" debug message</li> <li>Verify query performance is acceptable (should be similar to current)</li> </ol>"},{"location":"plans/2025-12-26-exclusion-limit-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert to the original truncation behavior. The only risk is performance degradation with very large exclusion sets.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/","title":"Incremental Sync Per-Entity Timestamp Fix","text":"<p>Issue: #200 (Part 1) - Full performer sync on every incremental sync Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#problem","title":"Problem","text":"<p>Every scheduled incremental sync performs a complete resync of all performers (1,947 entities taking 10+ minutes), even when no performers have changed. The user's logs show the sync timestamp remains unchanged across multiple sync cycles:</p> <pre><code>\"since\":\"2025-12-17T08:18:12.430Z\" (unchanged across all syncs)\nPerformers synced: 1,947 consistently\nDuration: 663-996 seconds per sync\n</code></pre> <p>The application becomes unavailable for ~10 minutes during each hourly sync.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In <code>StashSyncService.incrementalSync()</code>, the code retrieves the last sync timestamp using <code>getLastSyncTime()</code>:</p> <pre><code>// StashSyncService.ts:405\nconst lastSync = await this.getLastSyncTime(stashInstanceId);\n</code></pre> <p>This method only queries the scene entity type's timestamp:</p> <pre><code>// StashSyncService.ts:2158-2167\nprivate async getLastSyncTime(stashInstanceId?: string): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: {\n      stashInstanceId: stashInstanceId || null,\n      entityType: \"scene\", // &lt;-- Only looks at scene!\n    },\n  });\n  return syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n}\n</code></pre> <p>This same timestamp is then used for ALL entity types (performers, tags, studios, etc.):</p> <pre><code>// StashSyncService.ts:429\nresult = await this.syncPerformers(stashInstanceId, false, lastSync);\n</code></pre> <p>The database schema stores per-entity-type timestamps (<code>SyncState.entityType</code>), but <code>incrementalSync()</code> ignores them.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#solution","title":"Solution","text":"<p>Replace <code>incrementalSync()</code> with per-entity timestamp logic, similar to what <code>smartIncrementalSync()</code> already does correctly.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#option-a-refactor-incrementalsync-to-use-per-entity-timestamps-recommended","title":"Option A: Refactor incrementalSync to Use Per-Entity Timestamps (Recommended)","text":"<p>Modify <code>incrementalSync()</code> to: 1. Loop through each entity type 2. Get that entity type's specific last sync timestamp using <code>getEntitySyncState()</code> 3. Only sync entities changed since that timestamp</p> <p>This matches how <code>smartIncrementalSync()</code> works but without the change count check.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#option-b-replace-incrementalsync-with-smartincrementalsync","title":"Option B: Replace incrementalSync with smartIncrementalSync","text":"<p>Change the scheduler to call <code>smartIncrementalSync()</code> instead of <code>incrementalSync()</code>.</p> <p>Trade-off: <code>smartIncrementalSync</code> does an extra API call per entity type to check change counts before syncing. This adds latency but can skip entity types with zero changes entirely.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#design-decision","title":"Design Decision","text":"<p>Use Option A - Refactor <code>incrementalSync()</code> to use per-entity timestamps.</p> <p>Rationale: - Maintains separation between \"smart\" sync (checks change counts, used on startup) and regular incremental sync (used on schedule) - Avoids extra API calls on every scheduled sync - Fixes the core bug without changing sync behavior</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-incremental-sync-fix-design/#1-refactor-incrementalsync-method","title":"1. Refactor incrementalSync method","text":"<p>Replace the single <code>getLastSyncTime()</code> call with per-entity lookups:</p> <pre><code>async incrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n  // ... existing setup code ...\n\n  const entityTypes: EntityType[] = [\n    \"tag\", \"studio\", \"performer\", \"group\", \"gallery\", \"scene\", \"image\",\n  ];\n\n  for (const entityType of entityTypes) {\n    this.checkAbort();\n\n    // Get THIS entity type's last sync timestamp\n    const syncState = await this.getEntitySyncState(stashInstanceId, entityType);\n    const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n    if (!lastSync) {\n      // Never synced - do full sync for this entity type\n      const result = await this.syncEntityType(entityType, stashInstanceId, true);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"full\", result);\n    } else {\n      // Incremental sync using this entity's timestamp\n      const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n      results.push(result);\n      await this.saveSyncState(stashInstanceId, \"incremental\", result);\n    }\n  }\n\n  // ... rest of method ...\n}\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#2-remove-getlastsynctime-method","title":"2. Remove getLastSyncTime method","text":"<p>This method is no longer needed after the refactor. Remove it to prevent future misuse.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#3-add-logging-for-visibility","title":"3. Add logging for visibility","text":"<p>Log which timestamp is being used for each entity type:</p> <pre><code>logger.info(`${entityType}: syncing changes since ${lastSync.toISOString()}`);\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>server/services/StashSyncService.ts</code></li> <li>Refactor <code>incrementalSync()</code> method</li> <li>Remove <code>getLastSyncTime()</code> method</li> </ul>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#testing","title":"Testing","text":"<ol> <li>Run a full sync to establish baseline timestamps</li> <li>Wait for scheduled incremental sync</li> <li>Verify logs show different timestamps per entity type</li> <li>Verify performer sync only fetches changed performers (count should be 0 or minimal if nothing changed)</li> <li>Verify total sync time is greatly reduced when no changes exist</li> </ol>"},{"location":"plans/2025-12-26-incremental-sync-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert the <code>incrementalSync()</code> changes. The <code>smartIncrementalSync()</code> method remains unchanged as a fallback.</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/","title":"Incremental Sync Per-Entity Timestamp Fix - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix incremental sync to use per-entity timestamps instead of a single scene timestamp, preventing unnecessary full syncs of unchanged entities.</p> <p>Architecture: Refactor <code>incrementalSync()</code> to loop through entity types and look up each entity's own last sync timestamp via <code>getEntitySyncState()</code>. Remove the broken <code>getLastSyncTime()</code> method that only queries scenes.</p> <p>Tech Stack: TypeScript, Prisma, Node.js</p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-1-add-unit-test-for-per-entity-timestamp-logic","title":"Task 1: Add Unit Test for Per-Entity Timestamp Logic","text":"<p>Files: - Create: <code>server/services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Step 1: Create the test file with per-entity timestamp test</p> <pre><code>/**\n * Unit Tests for StashSyncService\n *\n * Tests the incremental sync logic without requiring a real Stash instance.\n */\nimport { describe, it, expect, vi, beforeEach, afterEach } from \"vitest\";\n\n// Mock prisma before importing the service\nconst mockPrisma = {\n  syncState: {\n    findFirst: vi.fn(),\n    findMany: vi.fn(),\n    update: vi.fn(),\n    create: vi.fn(),\n  },\n  syncSettings: {\n    findFirst: vi.fn(),\n  },\n  $executeRawUnsafe: vi.fn(),\n};\n\nvi.mock(\"../../prisma/singleton.js\", () =&gt; ({\n  default: mockPrisma,\n}));\n\n// Mock the stash instance manager\nvi.mock(\"../StashInstanceManager.js\", () =&gt; ({\n  stashInstanceManager: {\n    getDefault: vi.fn(() =&gt; ({\n      findTags: vi.fn().mockResolvedValue({ findTags: { tags: [], count: 0 } }),\n      findStudios: vi.fn().mockResolvedValue({ findStudios: { studios: [], count: 0 } }),\n      findPerformers: vi.fn().mockResolvedValue({ findPerformers: { performers: [], count: 0 } }),\n      findGroups: vi.fn().mockResolvedValue({ findGroups: { groups: [], count: 0 } }),\n      findGalleries: vi.fn().mockResolvedValue({ findGalleries: { galleries: [], count: 0 } }),\n      findScenesCompact: vi.fn().mockResolvedValue({ findScenes: { scenes: [], count: 0 } }),\n      findImages: vi.fn().mockResolvedValue({ findImages: { images: [], count: 0 } }),\n    })),\n    hasInstances: vi.fn(() =&gt; true),\n  },\n}));\n\n// Mock user stats service\nvi.mock(\"../UserStatsService.js\", () =&gt; ({\n  userStatsService: {\n    rebuildAllStats: vi.fn().mockResolvedValue(undefined),\n  },\n}));\n\ndescribe(\"StashSyncService\", () =&gt; {\n  beforeEach(() =&gt; {\n    vi.clearAllMocks();\n  });\n\n  describe(\"incrementalSync\", () =&gt; {\n    it(\"should use per-entity timestamps, not a single global timestamp\", async () =&gt; {\n      // Import after mocks are set up\n      const { stashSyncService } = await import(\"../StashSyncService.js\");\n\n      // Set up different timestamps for different entity types\n      const tagTimestamp = new Date(\"2025-12-20T10:00:00Z\");\n      const performerTimestamp = new Date(\"2025-12-22T15:00:00Z\");\n      const sceneTimestamp = new Date(\"2025-12-25T08:00:00Z\");\n\n      mockPrisma.syncState.findFirst.mockImplementation(({ where }) =&gt; {\n        if (where.entityType === \"tag\") {\n          return Promise.resolve({ lastIncrementalSync: tagTimestamp, lastFullSync: null });\n        }\n        if (where.entityType === \"performer\") {\n          return Promise.resolve({ lastIncrementalSync: performerTimestamp, lastFullSync: null });\n        }\n        if (where.entityType === \"scene\") {\n          return Promise.resolve({ lastIncrementalSync: sceneTimestamp, lastFullSync: null });\n        }\n        // Return timestamps for other entity types\n        return Promise.resolve({ lastIncrementalSync: new Date(\"2025-12-24T12:00:00Z\"), lastFullSync: null });\n      });\n\n      // Run incremental sync\n      await stashSyncService.incrementalSync();\n\n      // Verify that findFirst was called for each entity type (not just scene)\n      const findFirstCalls = mockPrisma.syncState.findFirst.mock.calls;\n\n      // Should have calls for: tag, studio, performer, group, gallery, scene, image\n      const entityTypesQueried = findFirstCalls.map((call) =&gt; call[0]?.where?.entityType);\n\n      expect(entityTypesQueried).toContain(\"tag\");\n      expect(entityTypesQueried).toContain(\"performer\");\n      expect(entityTypesQueried).toContain(\"scene\");\n      expect(entityTypesQueried).toContain(\"studio\");\n      expect(entityTypesQueried).toContain(\"group\");\n      expect(entityTypesQueried).toContain(\"gallery\");\n      expect(entityTypesQueried).toContain(\"image\");\n    });\n\n    it(\"should perform full sync for entity types that have never been synced\", async () =&gt; {\n      const { stashSyncService } = await import(\"../StashSyncService.js\");\n\n      // Tags have been synced, but performers have not\n      mockPrisma.syncState.findFirst.mockImplementation(({ where }) =&gt; {\n        if (where.entityType === \"tag\") {\n          return Promise.resolve({\n            lastIncrementalSync: new Date(\"2025-12-20T10:00:00Z\"),\n            lastFullSync: null,\n          });\n        }\n        // No sync state for other entities\n        return Promise.resolve(null);\n      });\n\n      await stashSyncService.incrementalSync();\n\n      // Verify sync state was created/updated for entities\n      expect(mockPrisma.syncState.findFirst).toHaveBeenCalled();\n    });\n  });\n});\n</code></pre> <p>Step 2: Run the test to verify it fails</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Expected: FAIL - The current implementation only queries \"scene\" entity type, so the test expecting per-entity queries will fail.</p> <p>Step 3: Commit the failing test</p> <pre><code>git add server/services/__tests__/StashSyncService.unit.test.ts\ngit commit -m \"test: add failing test for per-entity sync timestamps\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-2-refactor-incrementalsync-to-use-per-entity-timestamps","title":"Task 2: Refactor incrementalSync to Use Per-Entity Timestamps","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:393-480</code></p> <p>Step 1: Replace the incrementalSync method</p> <p>Find the <code>incrementalSync</code> method (around line 393) and replace it entirely with:</p> <pre><code>  /**\n   * Incremental sync - fetches only changed entities\n   * Uses per-entity-type timestamps so each entity type syncs from its own last sync time\n   */\n  async incrementalSync(stashInstanceId?: string): Promise&lt;SyncResult[]&gt; {\n    if (this.syncInProgress) {\n      logger.warn(\"Sync already in progress, skipping\");\n      return [];\n    }\n\n    this.syncInProgress = true;\n    this.abortController = new AbortController();\n    const startTime = Date.now();\n    const results: SyncResult[] = [];\n\n    try {\n      logger.info(\"Starting incremental sync with per-entity timestamps...\");\n\n      // Entity types in dependency order (tags first since others reference them)\n      const entityTypes: EntityType[] = [\n        \"tag\",\n        \"studio\",\n        \"performer\",\n        \"group\",\n        \"gallery\",\n        \"scene\",\n        \"image\",\n      ];\n\n      for (const entityType of entityTypes) {\n        this.checkAbort();\n\n        // Get THIS entity type's last sync timestamp\n        const syncState = await this.getEntitySyncState(stashInstanceId, entityType);\n        const lastSync = syncState?.lastFullSync || syncState?.lastIncrementalSync;\n\n        if (!lastSync) {\n          // Never synced - do full sync for this entity type only\n          logger.info(`${entityType}: No previous sync, syncing all`);\n          const result = await this.syncEntityType(entityType, stashInstanceId, true);\n          results.push(result);\n          await this.saveSyncState(stashInstanceId, \"full\", result);\n        } else {\n          // Incremental sync using this entity's own timestamp\n          logger.info(`${entityType}: syncing changes since ${lastSync.toISOString()}`);\n          const result = await this.syncEntityType(entityType, stashInstanceId, false, lastSync);\n          results.push(result);\n          await this.saveSyncState(stashInstanceId, \"incremental\", result);\n        }\n      }\n\n      // Rebuild user stats to reflect current entity relationships\n      logger.info(\"Rebuilding user stats after sync...\");\n      await userStatsService.rebuildAllStats();\n      logger.info(\"User stats rebuild complete\");\n\n      const duration = Date.now() - startTime;\n      logger.info(\"Incremental sync completed\", {\n        durationMs: duration,\n        results: results.map((r) =&gt; ({ type: r.entityType, synced: r.synced })),\n      });\n\n      return results;\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n\n      if (errorMsg === \"Sync aborted\") {\n        logger.info(\"Incremental sync aborted by user\");\n      } else {\n        logger.error(\"Incremental sync failed\", { error: errorMsg });\n      }\n\n      throw error;\n    } finally {\n      this.syncInProgress = false;\n      this.abortController = null;\n    }\n  }\n</code></pre> <p>Step 2: Run the unit test to verify it passes</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService.unit.test.ts</code></p> <p>Expected: PASS - The refactored method now queries per-entity timestamps.</p> <p>Step 3: Commit the refactored method</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"fix: use per-entity timestamps in incrementalSync\n\nPreviously, incrementalSync used a single timestamp from the scene\nentity type for all entities. This caused full re-syncs of performers,\ntags, etc. even when they hadn't changed.\n\nNow each entity type uses its own lastFullSync/lastIncrementalSync\ntimestamp, matching how smartIncrementalSync already works.\n\nFixes #200 (Part 1)\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-3-remove-obsolete-getlastsynctime-method","title":"Task 3: Remove Obsolete getLastSyncTime Method","text":"<p>Files: - Modify: <code>server/services/StashSyncService.ts:2158-2167</code></p> <p>Step 1: Find and remove the getLastSyncTime method</p> <p>Locate the <code>getLastSyncTime</code> method (around line 2158) and delete it entirely:</p> <pre><code>// DELETE THIS ENTIRE METHOD:\nprivate async getLastSyncTime(stashInstanceId?: string): Promise&lt;Date | null&gt; {\n  const syncState = await prisma.syncState.findFirst({\n    where: {\n      stashInstanceId: stashInstanceId || null,\n      entityType: \"scene\", // Use scene as the reference entity type\n    },\n  });\n\n  return syncState?.lastFullSync || syncState?.lastIncrementalSync || null;\n}\n</code></pre> <p>Step 2: Verify no other code references this method</p> <p>Run: <code>cd server &amp;&amp; grep -r \"getLastSyncTime\" --include=\"*.ts\" .</code></p> <p>Expected: No matches (the only caller was in <code>incrementalSync</code> which we refactored).</p> <p>Step 3: Run all sync-related tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run services/__tests__/StashSyncService</code></p> <p>Expected: All tests pass.</p> <p>Step 4: Commit the removal</p> <pre><code>git add server/services/StashSyncService.ts\ngit commit -m \"refactor: remove obsolete getLastSyncTime method\n\nThis method was the root cause of the bug - it only queried the scene\nentity type's timestamp, ignoring per-entity timestamps. With the\nincrementalSync refactor, it's no longer needed.\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-4-run-linting-and-full-test-suite","title":"Task 4: Run Linting and Full Test Suite","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code></p> <p>Expected: No errors.</p> <p>Step 2: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code></p> <p>Expected: All tests pass.</p> <p>Step 3: Fix any issues and commit if needed</p> <p>If there are any lint or test failures, fix them and commit:</p> <pre><code>git add -A\ngit commit -m \"fix: address lint/test issues from sync refactor\"\n</code></pre>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#task-5-manual-verification-optional-requires-running-server","title":"Task 5: Manual Verification (Optional - Requires Running Server)","text":"<p>Files: - None (manual testing)</p> <p>Step 1: Start the server</p> <p>Run: <code>cd server &amp;&amp; npm run dev</code></p> <p>Step 2: Trigger a sync and check logs</p> <p>Look for log messages like: <pre><code>tag: syncing changes since 2025-12-25T10:00:00.000Z\nstudio: syncing changes since 2025-12-25T10:00:00.000Z\nperformer: syncing changes since 2025-12-25T10:00:00.000Z\n</code></pre></p> <p>Each entity type should show its OWN timestamp, not the same timestamp for all.</p> <p>Step 3: Verify sync counts are minimal</p> <p>If nothing has changed in Stash, each entity type should sync 0 items: <pre><code>Performers synced: 0 in 0.5s\nTags synced: 0 in 0.3s\n</code></pre></p>"},{"location":"plans/2025-12-26-incremental-sync-fix-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li><code>incrementalSync()</code> now uses per-entity timestamps via <code>getEntitySyncState()</code></li> <li>The broken <code>getLastSyncTime()</code> method is removed</li> <li>Each entity type logs which timestamp it's using for visibility</li> <li>Entity types with no previous sync get a full sync for that type only</li> <li>Scheduled syncs should complete in seconds instead of 10+ minutes when nothing has changed</li> </ol>"},{"location":"plans/2025-12-26-random-sort-fix-design/","title":"Random Sort Randomization Fix","text":"<p>Issue: #200 (Part 3) - Random sort not actually random Date: 2025-12-26 Status: Draft</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#problem","title":"Problem","text":"<p>Despite configuring \"Random\" as the default sort order, scenes display in identical order on repeated visits. The \"random\" order is deterministic per user, producing the same results every time.</p> <p>User reports:</p> <p>\"Identical query logs with identical 'sort':'random' parameter produce consistent results across separate calls\"</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#root-cause-analysis","title":"Root Cause Analysis","text":"<p>In the scenes controller, the random seed is set to just the user ID:</p> <pre><code>// scenes.ts:906\nrandomSeed: userId, // Stable random per user\n</code></pre> <p>This makes the random order deterministic - the same user always sees the same \"random\" order because the seed never changes.</p> <p>The carousel controller does this correctly:</p> <pre><code>// carousel.ts:327\nrandomSeed: sort === 'random' ? userId + Date.now() : userId,\n</code></pre> <p>By adding <code>Date.now()</code>, carousels get different random orders on each request.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#design-considerations","title":"Design Considerations","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#the-pagination-problem","title":"The Pagination Problem","text":"<p>True randomness on every request breaks pagination. If the order changes between page 1 and page 2 requests, users would see duplicate or missing items.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#session-based-randomness","title":"Session-Based Randomness","text":"<p>The solution is to make randomness stable within a browsing session but different across sessions: - Same session = same random order (pagination works) - New session = new random order (users see variety)</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#what-defines-a-session","title":"What Defines a \"Session\"?","text":"<p>Options: 1. Time-based window - Seed changes every N minutes 2. Client-provided seed - Client sends a seed that persists during browsing 3. Request parameter - Client explicitly requests \"reshuffle\"</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#design-decision","title":"Design Decision","text":"<p>Use client-provided session seed with automatic refresh</p> <p>The client will: 1. Generate a random seed on page load (stored in component state or URL) 2. Pass this seed with all scene requests 3. Generate a new seed when user explicitly clicks \"Shuffle\" or revisits the page</p> <p>This gives users control while maintaining pagination stability.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#1-add-randomseed-query-parameter-to-api","title":"1. Add randomSeed query parameter to API","text":"<p>Update the scenes endpoint to accept an optional <code>randomSeed</code> parameter:</p> <pre><code>// scenes.ts - in findScenes handler\nconst randomSeed = req.query.randomSeed\n  ? parseInt(String(req.query.randomSeed), 10)\n  : undefined;\n\n// When building query options\nrandomSeed: sortField === 'random'\n  ? (randomSeed ?? userId + Date.now())  // Use provided seed or generate new\n  : userId,\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#2-update-scenequerybuilder-for-better-randomization","title":"2. Update SceneQueryBuilder for better randomization","text":"<p>The current random formula is: <pre><code>((CAST(substr(s.id, 1, 8) AS INTEGER) * 1103515245 + ${randomSeed}) % 2147483647)\n</code></pre></p> <p>This assumes scene IDs are numeric strings. If IDs are UUIDs or alphanumeric, the CAST may fail or produce collisions.</p> <p>Improve with a hash-based approach: <pre><code>// Use a simple string hash of the full ID\n((CAST(\n  (unicode(substr(s.id, 1, 1)) * 31 +\n   unicode(substr(s.id, 2, 1)) * 17 +\n   unicode(substr(s.id, 3, 1)) * 13 +\n   unicode(substr(s.id, 4, 1)) * 7 +\n   unicode(substr(s.id, 5, 1))) AS INTEGER\n) * 1103515245 + ${randomSeed}) % 2147483647)\n</code></pre></p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#3-client-side-generate-and-persist-random-seed","title":"3. Client-side: Generate and persist random seed","text":"<p>In the scenes browse component:</p> <pre><code>// Generate seed on mount or when user requests shuffle\nconst [randomSeed, setRandomSeed] = useState(() =&gt;\n  Math.floor(Math.random() * 2147483647)\n);\n\n// Pass to API\nconst fetchScenes = async (page: number) =&gt; {\n  const params = new URLSearchParams({\n    sort: 'random',\n    randomSeed: String(randomSeed),\n    page: String(page),\n  });\n  // ...\n};\n\n// Shuffle button handler\nconst handleShuffle = () =&gt; {\n  setRandomSeed(Math.floor(Math.random() * 2147483647));\n  // Refetch will happen via useEffect dependency\n};\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#4-optional-add-shuffle-button-to-ui","title":"4. Optional: Add Shuffle button to UI","text":"<p>Add a shuffle button when random sort is active:</p> <pre><code>{sort === 'random' &amp;&amp; (\n  &lt;Button onClick={handleShuffle} variant=\"ghost\" size=\"sm\"&gt;\n    &lt;ShuffleIcon className=\"w-4 h-4 mr-1\" /&gt;\n    Shuffle\n  &lt;/Button&gt;\n)}\n</code></pre>"},{"location":"plans/2025-12-26-random-sort-fix-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-26-random-sort-fix-design/#server","title":"Server","text":"<ul> <li><code>server/controllers/library/scenes.ts</code></li> <li>Accept <code>randomSeed</code> query parameter</li> <li>Use provided seed or generate time-based default</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-design/#client","title":"Client","text":"<ul> <li><code>client/src/components/pages/ScenesBrowse.jsx</code> (or equivalent)</li> <li>Generate random seed on mount</li> <li>Pass seed to API calls</li> <li>Add optional Shuffle button</li> <li><code>client/src/hooks/useScenes.ts</code> (if exists)</li> <li>Pass randomSeed parameter through</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-design/#alternative-minimal-fix-server-only","title":"Alternative: Minimal Fix (Server-Only)","text":"<p>If client changes are not desired, a simpler server-only fix:</p> <pre><code>// scenes.ts:906\nrandomSeed: sortField === 'random'\n  ? userId + Math.floor(Date.now() / (5 * 60 * 1000))  // Changes every 5 minutes\n  : userId,\n</code></pre> <p>This gives new random orders every 5 minutes while maintaining pagination stability within that window.</p> <p>Trade-off: Users can't control when to shuffle, and pagination may break at the 5-minute boundary.</p>"},{"location":"plans/2025-12-26-random-sort-fix-design/#testing","title":"Testing","text":"<ol> <li>Browse scenes with random sort</li> <li>Navigate to page 2, verify no duplicates from page 1</li> <li>Refresh the page or wait for seed timeout</li> <li>Verify order has changed from previous session</li> <li>If Shuffle button implemented, verify it triggers re-randomization</li> </ol>"},{"location":"plans/2025-12-26-random-sort-fix-design/#rollback-plan","title":"Rollback Plan","text":"<p>If issues arise, revert to the stable <code>userId</code> seed. Users will have deterministic \"random\" order, which is the current behavior.</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/","title":"Random Sort Randomization Fix - Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix random sort so users see different random orders on each page visit while maintaining pagination stability within a session, following Stash's proven implementation pattern.</p> <p>Architecture: Client generates an 8-digit random seed when sort changes to \"random\", embeds it in the sort parameter as <code>random_&lt;seed&gt;</code>. Server parses the seed and uses it for deterministic ordering. Same seed = same order across pagination and direction toggles.</p> <p>Tech Stack: React (client), Express/TypeScript (server), SQLite (database)</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#summary","title":"Summary","text":"<p>The current implementation uses <code>randomSeed: userId</code> which produces identical \"random\" orders every time. Stash solves this elegantly by embedding the seed in the sort parameter itself (<code>random_12345678</code>). This plan follows their proven pattern.</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#stashs-approach-reference","title":"Stash's Approach (Reference)","text":"<p>From <code>~/code/stash</code>: - Client: <code>filter.ts</code> - generates seed as <code>Math.floor(Math.random() * 10 ** 8)</code> - API format: Sort parameter is <code>\"random_12345678\"</code> instead of just <code>\"random\"</code> - Server: <code>sql.go</code> - parses seed from sort string, uses formula for deterministic order - Direction toggle: Same seed, just ASC/DESC changes - reversed order of same results - Reshuffle: Reset seed to -1, regenerate on next query</p>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#server","title":"Server","text":"<ul> <li><code>server/controllers/library/scenes.ts</code> - Parse <code>random_&lt;seed&gt;</code> from sort parameter</li> <li><code>server/services/SceneQueryBuilder.ts</code> - Update buildSortClause to accept seed separately</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#client","title":"Client","text":"<ul> <li><code>client/src/components/ui/SearchControls.jsx</code> - Generate seed, embed in sort parameter</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#tests","title":"Tests","text":"<ul> <li><code>server/tests/services/SceneQueryBuilder.integration.test.ts</code> - Test different seeds</li> </ul>"},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-1-update-server-to-parse-random_-format","title":"Task 1: Update Server to Parse random_ Format <p>Files: - Modify: <code>server/controllers/library/scenes.ts:860-920</code></p> <p>Step 1: Read the current implementation</p> <p>Review lines 860-920 to understand current sort handling.</p> <p>Step 2: Add seed parsing logic</p> <p>Before calling sceneQueryBuilder, parse the sort parameter:</p> <pre><code>// Around line 875, after extracting sortField\nlet randomSeed: number | undefined;\nlet actualSortField = sortField;\n\n// Parse random_&lt;seed&gt; format (e.g., \"random_12345678\")\nif (sortField.startsWith('random_')) {\n  const seedStr = sortField.slice(7); // Remove \"random_\" prefix\n  const parsedSeed = parseInt(seedStr, 10);\n  if (!isNaN(parsedSeed)) {\n    randomSeed = parsedSeed % 1e8; // Cap at 10^8 like Stash does\n    actualSortField = 'random';\n  }\n} else if (sortField === 'random') {\n  // Plain \"random\" without seed - generate time-based seed\n  randomSeed = (userId + Date.now()) % 1e8;\n}\n\n// Then use actualSortField and randomSeed in the query\n</code></pre> <p>Step 3: Update the sceneQueryBuilder.execute call</p> <pre><code>const result = await sceneQueryBuilder.execute({\n  userId,\n  filters,\n  excludedSceneIds: excludedIds,\n  sort: actualSortField,  // Use \"random\" not \"random_12345\"\n  sortDirection: sortDirection.toUpperCase() as \"ASC\" | \"DESC\",\n  page,\n  perPage,\n  randomSeed: actualSortField === 'random' ? randomSeed : userId,\n});\n</code></pre> <p>Step 4: Build and verify</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: TypeScript compiles successfully</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat: parse random_&lt;seed&gt; format from sort parameter\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-2-update-scenequerybuilder-random-formula","title":"Task 2: Update SceneQueryBuilder Random Formula <p>Files: - Modify: <code>server/services/SceneQueryBuilder.ts:1100-1102</code></p> <p>Step 1: Read current random sort implementation</p> <p>The current formula at line 1101: <pre><code>random: `((CAST(substr(s.id, 1, 8) AS INTEGER) * 1103515245 + ${randomSeed || 12345}) % 2147483647) ${dir}`,\n</code></pre></p> <p>Step 2: Update to match Stash's formula</p> <p>Stash uses a more robust formula that handles string IDs better: <pre><code>// Stash formula: ((id+seed)*(id+seed)*52959209 + (id+seed)*1047483763) % 2147483647\nrandom: `(((CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * (CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * 52959209 + (CAST(substr(s.id, 1, 8) AS INTEGER) + ${randomSeed || 12345}) * 1047483763) % 2147483647) ${dir}`,\n</code></pre></p> <p>This formula: - Adds seed to ID first (better distribution) - Uses multiplication for better randomization - Matches Stash's proven algorithm</p> <p>Step 3: Build and verify</p> <p>Run: <code>cd server &amp;&amp; npm run build</code> Expected: TypeScript compiles successfully</p> <p>Step 4: Commit</p> <pre><code>git add server/services/SceneQueryBuilder.ts\ngit commit -m \"refactor: use Stash's random sort formula for better distribution\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-3-generate-and-embed-seed-in-client-searchcontrols","title":"Task 3: Generate and Embed Seed in Client SearchControls <p>Files: - Modify: <code>client/src/components/ui/SearchControls.jsx</code></p> <p>Step 1: Add randomSeed state</p> <p>Near the top of the component, after other useState declarations (around line 98):</p> <pre><code>// Random seed for stable pagination when sorting by random\n// -1 means uninitialized, will be generated when needed\nconst [randomSeed, setRandomSeed] = useState(-1);\n</code></pre> <p>Step 2: Create helper to get sort with seed</p> <p>Add a helper function inside the component:</p> <pre><code>// Get sort value, embedding random seed when needed\nconst getSortWithSeed = useCallback((sort) =&gt; {\n  if (sort === 'random') {\n    let seed = randomSeed;\n    if (seed === -1) {\n      // Generate new 8-digit seed\n      seed = Math.floor(Math.random() * 1e8);\n      setRandomSeed(seed);\n    }\n    return `random_${seed}`;\n  }\n  return sort;\n}, [randomSeed]);\n</code></pre> <p>Step 3: Update handleSortChange to reset seed on sort type change</p> <p>Modify handleSortChange (around line 618):</p> <pre><code>const handleSortChange = (field) =&gt; {\n  let newSortDirection = \"DESC\";\n  let newSortField = sortField;\n\n  // If same field, toggle direction (keep same seed for random)\n  if (field === sortField) {\n    newSortDirection = sortDirection === \"ASC\" ? \"DESC\" : \"ASC\";\n  } else {\n    // New field, default to DESC\n    newSortField = field;\n\n    // Reset random seed when changing TO or FROM random sort\n    if (field === 'random' || sortField === 'random') {\n      setRandomSeed(-1);\n    }\n  }\n  setSort([newSortField, newSortDirection]);\n\n  // Build query with seed-embedded sort\n  const query = {\n    filter: {\n      direction: newSortDirection,\n      page: currentPage,\n      per_page: perPage,\n      q: searchText,\n      sort: getSortWithSeed(newSortField),\n    },\n    ...buildFilter(artifactType, filters, unitPreference),\n  };\n\n  onQueryChange(query);\n};\n</code></pre> <p>Step 4: Update all query building to use getSortWithSeed</p> <p>There are multiple places where queries are built. Each needs to use <code>getSortWithSeed(sortField)</code> instead of just <code>sortField</code>:</p> <ol> <li><code>initializeState()</code> - line ~342</li> <li><code>clearFilters()</code> - line ~408</li> <li><code>handleFilterSubmit()</code> - line ~436</li> <li><code>handleRemoveFilter()</code> - line ~464</li> <li><code>handleLoadPreset()</code> - line ~538</li> <li><code>handlePageChange()</code> - line ~561</li> <li><code>handleChangeSearchText()</code> - line ~604</li> <li><code>handleSortChange()</code> - line ~633 (already done above)</li> <li><code>handlePerPageChange()</code> - line ~656</li> </ol> <p>For each, change: <pre><code>sort: sortField,\n</code></pre> to: <pre><code>sort: getSortWithSeed(sortField),\n</code></pre></p> <p>Step 5: Handle preset loading - reset seed</p> <p>In handleLoadPreset (around line 531), reset the seed when loading a preset:</p> <pre><code>const handleLoadPreset = useCallback(\n  (preset) =&gt; {\n    setCurrentPage(1);\n    setFilters({ ...permanentFilters, ...preset.filters });\n    setSort([preset.sort, preset.direction]);\n\n    // Reset random seed when loading preset (like Stash does)\n    setRandomSeed(-1);\n\n    // ... rest of function\n  },\n  [/* deps */]\n);\n</code></pre> <p>Step 6: Test locally</p> <p>Run: <code>cd client &amp;&amp; npm run dev</code> Test: - Navigate to scenes, select random sort - Check network tab - sort should be <code>random_XXXXXXXX</code> - Navigate pages - same seed used - Toggle direction - same seed, just direction changes - Change to different sort, then back to random - new seed</p> <p>Step 7: Commit</p> <pre><code>git add client/src/components/ui/SearchControls.jsx\ngit commit -m \"feat: embed random seed in sort parameter for stable pagination\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-4-add-integration-tests","title":"Task 4: Add Integration Tests <p>Files: - Modify: <code>server/tests/services/SceneQueryBuilder.integration.test.ts</code></p> <p>Step 1: Add test for different seeds producing different orders</p> <pre><code>it(\"should return different results with different random seeds\", async () =&gt; {\n  const seed1 = 11111111;\n  const seed2 = 99999999;\n\n  const result1 = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed1,\n  });\n\n  const result2 = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed2,\n  });\n\n  // Different seeds should give different orders\n  if (result1.scenes.length &gt;= 3 &amp;&amp; result2.scenes.length &gt;= 3) {\n    const order1 = result1.scenes.map((s) =&gt; s.id).join(\",\");\n    const order2 = result2.scenes.map((s) =&gt; s.id).join(\",\");\n    expect(order1).not.toEqual(order2);\n  }\n});\n\nit(\"should reverse order when direction changes with same seed\", async () =&gt; {\n  const seed = 12345678;\n\n  const ascResult = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"ASC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed,\n  });\n\n  const descResult = await sceneQueryBuilder.execute({\n    userId: 1,\n    sort: \"random\",\n    sortDirection: \"DESC\",\n    page: 1,\n    perPage: 10,\n    randomSeed: seed,\n  });\n\n  // Same seed with opposite directions should give reversed order\n  if (ascResult.scenes.length &gt;= 2 &amp;&amp; descResult.scenes.length &gt;= 2) {\n    const ascIds = ascResult.scenes.map((s) =&gt; s.id);\n    const descIds = descResult.scenes.map((s) =&gt; s.id);\n    expect(ascIds).toEqual(descIds.reverse());\n  }\n});\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>cd server &amp;&amp; npm test -- --run SceneQueryBuilder.integration</code> Expected: All tests pass</p> <p>Step 3: Commit</p> <pre><code>git add server/tests/services/SceneQueryBuilder.integration.test.ts\ngit commit -m \"test: add tests for random seed variation and direction reversal\"\n</code></pre>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-5-run-full-test-suite-and-lint","title":"Task 5: Run Full Test Suite and Lint <p>Step 1: Run server tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run client tests</p> <p>Run: <code>cd client &amp;&amp; npm test -- --run</code> Expected: All tests pass</p> <p>Step 3: Run linting</p> <p>Run: <code>cd server &amp;&amp; npm run lint &amp;&amp; cd ../client &amp;&amp; npm run lint</code> Expected: No lint errors</p> <p>Step 4: Build both projects</p> <p>Run: <code>cd server &amp;&amp; npm run build &amp;&amp; cd ../client &amp;&amp; npm run build</code> Expected: Both build successfully</p>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#task-6-manual-testing-checklist","title":"Task 6: Manual Testing Checklist <ol> <li>Random sort produces different orders on page refresh:</li> <li>Navigate to Scenes page with random sort</li> <li>Note the order of first few scenes</li> <li>Refresh the page (F5)</li> <li> <p>Verify order has changed (new seed generated on mount)</p> </li> <li> <p>Pagination remains stable within session:</p> </li> <li>Set random sort</li> <li>Note scene IDs on page 1</li> <li>Go to page 2</li> <li>Go back to page 1</li> <li> <p>Verify same scenes appear</p> </li> <li> <p>Direction toggle reverses same results:</p> </li> <li>Set random sort, note order: A, B, C</li> <li>Toggle direction (click sort direction button)</li> <li> <p>Verify order is reversed: C, B, A (same scenes, reversed)</p> </li> <li> <p>Changing sort type generates new seed:</p> </li> <li>Set random sort, note order</li> <li>Change to date sort</li> <li>Change back to random sort</li> <li> <p>Verify order is different (new seed)</p> </li> <li> <p>Loading preset resets seed:</p> </li> <li>Set random sort, note order</li> <li>Save as preset</li> <li>Change pages</li> <li>Load the preset</li> <li>Verify order is different (seed was reset)</li> </ol>","text":""},{"location":"plans/2025-12-26-random-sort-fix-implementation/#future-enhancement-shuffle-button","title":"Future Enhancement: Shuffle Button <p>Following Stash's pattern, a future PR could add a shuffle button when random sort is active:</p> <pre><code>{sortField === 'random' &amp;&amp; (\n  &lt;Button\n    onClick={() =&gt; {\n      setRandomSeed(-1);\n      // Trigger refetch\n    }}\n    variant=\"ghost\"\n    size=\"sm\"\n    title=\"Shuffle\"\n  &gt;\n    &lt;ShuffleIcon className=\"w-4 h-4\" /&gt;\n  &lt;/Button&gt;\n)}\n</code></pre> <p>This is out of scope for the initial fix.</p>","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/","title":"Images Page Fixes Design","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#overview","title":"Overview","text":"<p>Fixes and enhancements for the Images page feature discovered during testing.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#issues-identified","title":"Issues Identified","text":"# Issue Root Cause Fix Type 1 Lightbox doesn't load full-size image Images.jsx maps to <code>src</code> but Lightbox expects <code>paths.image</code> Bug fix 2 Favorite not persisting for images API exists but need to verify call is made correctly Bug fix 3 O Counter not clickable on ImageCard <code>CardRatingRow</code> only allows interactive O counter for scenes Feature add 4 O Counter missing from Lightbox Lightbox doesn't have O counter controls Feature add 5 Image view history New feature - track when images are viewed in lightbox Feature add"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-details","title":"Fix Details","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-1-lightbox-full-size-image-not-loading","title":"Fix 1: Lightbox Full-Size Image Not Loading","text":"<p>Problem: In <code>Images.jsx</code> line 167-176, images are mapped with <code>src</code> property but Lightbox expects <code>paths.image</code>:</p> <pre><code>// Current (wrong)\nimages={currentImages.map((img) =&gt; ({\n  src: img.paths?.image || `/api/proxy/image/${img.id}/image`,\n  ...\n}))}\n\n// Lightbox expects (line 214)\nconst imageSrc = currentImage?.paths?.image || currentImage?.paths?.preview;\n</code></pre> <p>Fix: Change the mapping to use <code>paths</code> object structure that Lightbox expects.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-2-favorite-not-persisting","title":"Fix 2: Favorite Not Persisting","text":"<p>Problem: The backend code is correct - <code>ImageRating</code> stores per-user favorites. Need to verify the Lightbox API call succeeds and data refreshes properly.</p> <p>Investigation: Check if <code>libraryApi.updateFavorite(\"image\", ...)</code> is called correctly and if Images page state updates after Lightbox interaction.</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-3-o-counter-on-imagecard-clickable","title":"Fix 3: O Counter on ImageCard (Clickable)","text":"<p>Current state: <code>CardRatingRow</code> only allows interactive O counter for scenes (line 511: <code>const isScene = entityType === \"scene\"</code>).</p> <p>Required changes: 1. Create <code>ImageViewHistory</code> model in schema (similar to <code>WatchHistory</code>) 2. Add <code>incrementImageOCounter</code> endpoint in a new <code>imageViewHistory.ts</code> controller 3. Update <code>CardRatingRow</code> to allow interactive O counter for images 4. Pass <code>initialOCounter</code> to ImageCard's <code>ratingControlsProps</code></p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-4-o-counter-in-lightbox","title":"Fix 4: O Counter in Lightbox","text":"<p>Current state: Lightbox has Rating and Favorite controls but no O Counter.</p> <p>Required changes: 1. Add <code>OCounterButton</code> component to Lightbox controls 2. Wire up the increment API call 3. Update parent state via <code>onImagesUpdate</code> callback</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#fix-5-image-view-history","title":"Fix 5: Image View History","text":"<p>New feature: Track when images are viewed in lightbox, similar to scene play history.</p> <p>Schema addition: <pre><code>model ImageViewHistory {\n  id        Int      @id @default(autoincrement())\n  userId    Int\n  imageId   String\n\n  viewCount   Int  @default(0)\n  viewHistory Json @default(\"[]\") // Array of timestamps\n  oCount      Int  @default(0)\n  oHistory    Json @default(\"[]\")\n\n  lastViewedAt DateTime?\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, imageId])\n  @@index([userId])\n  @@index([imageId])\n}\n</code></pre></p> <p>Behavior: - <code>viewCount</code>/<code>viewHistory</code>: Incremented when image is viewed in Lightbox (automatic) - <code>oCount</code>/<code>oHistory</code>: Incremented when user clicks O counter (manual) - Optional sync to Stash for O counter if user has <code>syncToStash</code> enabled</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#data-flow","title":"Data Flow","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#per-user-data-model","title":"Per-User Data Model","text":"<p>All image interaction data (rating, favorite, O counter, view history) is stored per-user in Peek: - <code>ImageRating</code>: rating, favorite (existing) - <code>ImageViewHistory</code>: viewCount, viewHistory, oCount, oHistory (new)</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#stash-sync-optional","title":"Stash Sync (Optional)","text":"<p>When user has <code>syncToStash</code> enabled: - Rating: Syncs to Stash via <code>imageUpdate</code> - O Counter: Syncs to Stash via <code>imageIncrementO</code> - Favorite: Peek-only (Stash doesn't support favorite for images) - View History: Peek-only</p>"},{"location":"plans/2025-12-29-images-page-fixes-design/#files-to-modify","title":"Files to Modify","text":""},{"location":"plans/2025-12-29-images-page-fixes-design/#backend","title":"Backend","text":"<ul> <li><code>server/prisma/schema.prisma</code> - Add ImageViewHistory model</li> <li><code>server/controllers/imageViewHistory.ts</code> - New controller for O counter and view tracking</li> <li><code>server/routes/imageViewHistory.ts</code> - New routes</li> <li><code>server/routes/index.ts</code> - Register new routes</li> </ul>"},{"location":"plans/2025-12-29-images-page-fixes-design/#frontend","title":"Frontend","text":"<ul> <li><code>client/src/components/pages/Images.jsx</code> - Fix Lightbox image mapping</li> <li><code>client/src/components/ui/Lightbox.jsx</code> - Add O counter control</li> <li><code>client/src/components/ui/CardComponents.jsx</code> - Allow interactive O counter for images</li> <li><code>client/src/components/cards/ImageCard.jsx</code> - Pass O counter to ratingControlsProps</li> <li><code>client/src/services/api.js</code> - Add image O counter API methods</li> </ul>"},{"location":"plans/2026-01-02-image-query-builder/","title":"ImageQueryBuilder Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the memory-intensive <code>getAllImages()</code> pattern with SQL-native querying that filters, sorts, and paginates at the database level.</p> <p>Architecture: Create <code>ImageQueryBuilder</code> service mirroring <code>SceneQueryBuilder</code>. It builds parameterized SQL queries with JOINs to <code>ImageRating</code>, <code>ImageViewHistory</code>, and <code>UserExcludedEntity</code> tables. The controller calls <code>imageQueryBuilder.execute()</code> which returns only the requested page of results.</p> <p>Tech Stack: TypeScript, Prisma raw SQL (<code>$queryRawUnsafe</code>), SQLite</p>"},{"location":"plans/2026-01-02-image-query-builder/#context","title":"Context","text":""},{"location":"plans/2026-01-02-image-query-builder/#the-problem","title":"The Problem","text":"<p>The current <code>findImages</code> controller in <code>server/controllers/library/images.ts</code>: 1. Loads ALL images via <code>stashEntityService.getAllImages()</code> (line 296) 2. Filters in JavaScript (~100 lines of in-memory logic) 3. Sorts in JavaScript (~70 lines) 4. Paginates in JavaScript</p> <p>With 50k+ images, this causes memory spikes and slow responses.</p>"},{"location":"plans/2026-01-02-image-query-builder/#the-solution","title":"The Solution","text":"<p><code>ImageQueryBuilder</code> will: - Query <code>StashImage</code> directly via SQL - JOIN to <code>ImageRating</code> and <code>ImageViewHistory</code> for user data - JOIN to <code>UserExcludedEntity</code> for exclusion filtering - Use subqueries on <code>ImagePerformer</code>, <code>ImageTag</code> for filter conditions - Return only the paginated page</p>"},{"location":"plans/2026-01-02-image-query-builder/#key-differences-from-scenequerybuilder","title":"Key Differences from SceneQueryBuilder","text":"<ol> <li>User data tables: <code>ImageRating</code> and <code>ImageViewHistory</code> (not <code>SceneRating</code> and <code>WatchHistory</code>)</li> <li>Simpler tag filtering: No <code>inheritedTagIds</code> column - just query <code>ImageTag</code> junction table</li> <li>No groups filter: Images don't have groups</li> <li>Gallery filter: Images can be filtered by gallery membership</li> </ol>"},{"location":"plans/2026-01-02-image-query-builder/#task-1-create-imagequerybuilder-with-basic-structure","title":"Task 1: Create ImageQueryBuilder with Basic Structure","text":"<p>Files: - Create: <code>server/services/ImageQueryBuilder.ts</code> - Test: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Create <code>server/services/__tests__/ImageQueryBuilder.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport { imageQueryBuilder } from \"../ImageQueryBuilder.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\ndescribe(\"ImageQueryBuilder\", () =&gt; {\n  const testUserId = 9999;\n\n  beforeEach(async () =&gt; {\n    // Create test user\n    await prisma.user.create({\n      data: { id: testUserId, username: \"test-iqb\", password: \"test\" },\n    });\n\n    // Create test images\n    await prisma.stashImage.createMany({\n      data: [\n        { id: \"img-1\", title: \"Image One\", stashCreatedAt: new Date(\"2024-01-01\") },\n        { id: \"img-2\", title: \"Image Two\", stashCreatedAt: new Date(\"2024-01-02\") },\n        { id: \"img-3\", title: \"Image Three\", stashCreatedAt: new Date(\"2024-01-03\") },\n      ],\n    });\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.stashImage.deleteMany({ where: { id: { startsWith: \"img-\" } } });\n    await prisma.user.deleteMany({ where: { id: testUserId } });\n  });\n\n  describe(\"execute\", () =&gt; {\n    it(\"returns paginated images with total count\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 2,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images).toHaveLength(2);\n      expect(result.images[0].id).toBe(\"img-3\"); // Most recent first\n    });\n\n    it(\"respects page parameter\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 2,\n        perPage: 2,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images).toHaveLength(1);\n      expect(result.images[0].id).toBe(\"img-1\"); // Third image on page 2\n    });\n  });\n});\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL with \"Cannot find module '../ImageQueryBuilder.js'\"</p> <p>Step 3: Write minimal implementation</p> <p>Create <code>server/services/ImageQueryBuilder.ts</code>:</p> <pre><code>/**\n * ImageQueryBuilder - SQL-native image querying\n *\n * Builds parameterized SQL queries for image filtering, sorting, and pagination.\n * Eliminates the need to load all images into memory.\n */\nimport prisma from \"../prisma/singleton.js\";\nimport { logger } from \"../utils/logger.js\";\n\n// Filter clause builder result\ninterface FilterClause {\n  sql: string;\n  params: (string | number | boolean)[];\n}\n\n// Query builder options\nexport interface ImageQueryOptions {\n  userId: number;\n  filters?: ImageFilter;\n  applyExclusions?: boolean; // Default true - use pre-computed exclusions\n  sort: string;\n  sortDirection: \"ASC\" | \"DESC\";\n  page: number;\n  perPage: number;\n  randomSeed?: number;\n}\n\n// Image filter type\nexport interface ImageFilter {\n  ids?: { value: string[]; modifier?: string };\n  favorite?: boolean;\n  rating100?: { value: number; value2?: number; modifier: string };\n  o_counter?: { value: number; value2?: number; modifier: string };\n  performers?: { value: string[]; modifier?: string };\n  tags?: { value: string[]; modifier?: string; depth?: number };\n  studios?: { value: string[]; modifier?: string; depth?: number };\n  galleries?: { value: string[]; modifier?: string };\n  q?: string; // Search query\n}\n\n// Query result\nexport interface ImageQueryResult {\n  images: any[];\n  total: number;\n}\n\n/**\n * Builds and executes SQL queries for image filtering\n */\nclass ImageQueryBuilder {\n  // Column list for SELECT - all StashImage fields plus user data\n  private readonly SELECT_COLUMNS = `\n    i.id, i.title, i.code, i.details, i.photographer, i.urls, i.date,\n    i.studioId, i.rating100 AS stashRating100, i.oCounter AS stashOCounter,\n    i.organized, i.filePath, i.width, i.height, i.fileSize,\n    i.pathThumbnail, i.pathPreview, i.pathImage,\n    i.stashCreatedAt, i.stashUpdatedAt,\n    r.rating AS userRating, r.favorite AS userFavorite,\n    v.viewCount AS userViewCount, v.oCount AS userOCount,\n    v.lastViewedAt AS userLastViewedAt\n  `.trim();\n\n  // Base FROM clause with user data JOINs\n  private buildFromClause(\n    userId: number,\n    applyExclusions: boolean = true\n  ): { sql: string; params: number[] } {\n    const baseJoins = `\n        FROM StashImage i\n        LEFT JOIN ImageRating r ON i.id = r.imageId AND r.userId = ?\n        LEFT JOIN ImageViewHistory v ON i.id = v.imageId AND v.userId = ?\n    `.trim();\n\n    if (applyExclusions) {\n      return {\n        sql: `${baseJoins}\n        LEFT JOIN UserExcludedEntity e ON e.userId = ? AND e.entityType = 'image' AND e.entityId = i.id`,\n        params: [userId, userId, userId],\n      };\n    }\n\n    return {\n      sql: baseJoins,\n      params: [userId, userId],\n    };\n  }\n\n  // Base WHERE clause (always filter deleted, optionally filter excluded)\n  private buildBaseWhere(applyExclusions: boolean = true): FilterClause {\n    if (applyExclusions) {\n      return {\n        sql: \"i.deletedAt IS NULL AND e.id IS NULL\",\n        params: [],\n      };\n    }\n    return {\n      sql: \"i.deletedAt IS NULL\",\n      params: [],\n    };\n  }\n\n  // Build sort clause\n  private buildSortClause(sort: string, dir: \"ASC\" | \"DESC\"): string {\n    const sortMap: Record&lt;string, string&gt; = {\n      title: `COALESCE(i.title, i.filePath) ${dir}`,\n      date: `i.date ${dir}`,\n      rating: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      rating100: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      o_counter: `COALESCE(v.oCount, i.oCounter, 0) ${dir}`,\n      filesize: `COALESCE(i.fileSize, 0) ${dir}`,\n      path: `i.filePath ${dir}`,\n      created_at: `i.stashCreatedAt ${dir}`,\n      updated_at: `i.stashUpdatedAt ${dir}`,\n    };\n\n    const sortExpr = sortMap[sort] || sortMap[\"created_at\"];\n    return `${sortExpr}, i.id ${dir}`;\n  }\n\n  async execute(options: ImageQueryOptions): Promise&lt;ImageQueryResult&gt; {\n    const startTime = Date.now();\n    const { userId, page, perPage, applyExclusions = true, filters } = options;\n\n    // Build FROM clause with optional exclusion JOIN\n    const fromClause = this.buildFromClause(userId, applyExclusions);\n\n    // Build WHERE clauses\n    const whereClauses: FilterClause[] = [this.buildBaseWhere(applyExclusions)];\n\n    // Combine WHERE clauses\n    const whereSQL = whereClauses\n      .map((c) =&gt; c.sql)\n      .filter(Boolean)\n      .join(\" AND \");\n    const whereParams = whereClauses.flatMap((c) =&gt; c.params);\n\n    // Build sort\n    const sortClause = this.buildSortClause(\n      options.sort,\n      options.sortDirection\n    );\n\n    // Calculate offset\n    const offset = (page - 1) * perPage;\n\n    // Build main query\n    const sql = `\n      SELECT ${this.SELECT_COLUMNS}\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n      ORDER BY ${sortClause}\n      LIMIT ? OFFSET ?\n    `;\n\n    const params = [...fromClause.params, ...whereParams, perPage, offset];\n\n    logger.debug(\"ImageQueryBuilder.execute\", {\n      whereClauseCount: whereClauses.length,\n      applyExclusions,\n      sort: options.sort,\n      paramCount: params.length,\n    });\n\n    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Count query\n    const countSql = `\n      SELECT COUNT(DISTINCT i.id) as total\n      ${fromClause.sql}\n      WHERE ${whereSQL}\n    `;\n    const countParams = [...fromClause.params, ...whereParams];\n    const countResult = await prisma.$queryRawUnsafe&lt;{ total: number }[]&gt;(\n      countSql,\n      ...countParams\n    );\n    const total = Number(countResult[0]?.total || 0);\n\n    const duration = Date.now() - startTime;\n    logger.debug(\"ImageQueryBuilder.execute completed\", {\n      total,\n      returned: rows.length,\n      durationMs: duration,\n    });\n\n    return { images: rows, total };\n  }\n}\n\n// Export singleton instance\nexport const imageQueryBuilder = new ImageQueryBuilder();\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add ImageQueryBuilder with basic pagination\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-2-add-user-data-filters-favorite-rating-o_counter","title":"Task 2: Add User Data Filters (favorite, rating, o_counter)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to <code>server/services/__tests__/ImageQueryBuilder.test.ts</code>:</p> <pre><code>  describe(\"user data filters\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Add user ratings\n      await prisma.imageRating.createMany({\n        data: [\n          { userId: testUserId, imageId: \"img-1\", rating: 80, favorite: true },\n          { userId: testUserId, imageId: \"img-2\", rating: 40, favorite: false },\n        ],\n      });\n      // Add view history\n      await prisma.imageViewHistory.createMany({\n        data: [\n          { userId: testUserId, imageId: \"img-1\", oCount: 5, viewCount: 10 },\n          { userId: testUserId, imageId: \"img-3\", oCount: 2, viewCount: 3 },\n        ],\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageRating.deleteMany({ where: { userId: testUserId } });\n      await prisma.imageViewHistory.deleteMany({ where: { userId: testUserId } });\n    });\n\n    it(\"filters by favorite\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { favorite: true },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by rating100 GREATER_THAN\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { rating100: { value: 50, modifier: \"GREATER_THAN\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by o_counter GREATER_THAN\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { o_counter: { value: 3, modifier: \"GREATER_THAN\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - filters not implemented</p> <p>Step 3: Add filter implementations</p> <p>Add these methods to <code>ImageQueryBuilder</code> class in <code>server/services/ImageQueryBuilder.ts</code>:</p> <pre><code>  // Build favorite filter\n  private buildFavoriteFilter(favorite: boolean | undefined): FilterClause {\n    if (favorite === undefined) {\n      return { sql: \"\", params: [] };\n    }\n    return {\n      sql: favorite ? \"r.favorite = 1\" : \"(r.favorite = 0 OR r.favorite IS NULL)\",\n      params: [],\n    };\n  }\n\n  // Build rating filter\n  private buildRatingFilter(\n    filter: { value: number; value2?: number; modifier: string } | undefined\n  ): FilterClause {\n    if (!filter) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier } = filter;\n    const ratingExpr = \"COALESCE(r.rating, i.rating100, 0)\";\n\n    switch (modifier) {\n      case \"GREATER_THAN\":\n        return { sql: `${ratingExpr} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${ratingExpr} &lt; ?`, params: [value] };\n      case \"EQUALS\":\n        return { sql: `${ratingExpr} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${ratingExpr} != ?`, params: [value] };\n      case \"BETWEEN\":\n        return { sql: `${ratingExpr} BETWEEN ? AND ?`, params: [value, value2 ?? value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build o_counter filter\n  private buildOCounterFilter(\n    filter: { value: number; value2?: number; modifier: string } | undefined\n  ): FilterClause {\n    if (!filter) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value, value2, modifier } = filter;\n    const oExpr = \"COALESCE(v.oCount, i.oCounter, 0)\";\n\n    switch (modifier) {\n      case \"GREATER_THAN\":\n        return { sql: `${oExpr} &gt; ?`, params: [value] };\n      case \"LESS_THAN\":\n        return { sql: `${oExpr} &lt; ?`, params: [value] };\n      case \"EQUALS\":\n        return { sql: `${oExpr} = ?`, params: [value] };\n      case \"NOT_EQUALS\":\n        return { sql: `${oExpr} != ?`, params: [value] };\n      case \"BETWEEN\":\n        return { sql: `${oExpr} BETWEEN ? AND ?`, params: [value, value2 ?? value] };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update the <code>execute</code> method to use these filters:</p> <pre><code>    // Add user data filters\n    if (filters?.favorite !== undefined) {\n      const favoriteFilter = this.buildFavoriteFilter(filters.favorite);\n      if (favoriteFilter.sql) whereClauses.push(favoriteFilter);\n    }\n\n    if (filters?.rating100) {\n      const ratingFilter = this.buildRatingFilter(filters.rating100);\n      if (ratingFilter.sql) whereClauses.push(ratingFilter);\n    }\n\n    if (filters?.o_counter) {\n      const oCounterFilter = this.buildOCounterFilter(filters.o_counter);\n      if (oCounterFilter.sql) whereClauses.push(oCounterFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add user data filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-3-add-entity-filters-performers-tags-studios-galleries","title":"Task 3: Add Entity Filters (performers, tags, studios, galleries)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to test file:</p> <pre><code>  describe(\"entity filters\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Create performers\n      await prisma.stashPerformer.createMany({\n        data: [\n          { id: \"perf-1\", name: \"Performer One\" },\n          { id: \"perf-2\", name: \"Performer Two\" },\n        ],\n      });\n      // Create tags\n      await prisma.stashTag.createMany({\n        data: [\n          { id: \"tag-1\", name: \"Tag One\" },\n          { id: \"tag-2\", name: \"Tag Two\" },\n        ],\n      });\n      // Create studio\n      await prisma.stashStudio.create({\n        data: { id: \"studio-1\", name: \"Studio One\" },\n      });\n      // Create gallery\n      await prisma.stashGallery.create({\n        data: { id: \"gallery-1\", title: \"Gallery One\" },\n      });\n\n      // Link performers to images\n      await prisma.imagePerformer.createMany({\n        data: [\n          { imageId: \"img-1\", performerId: \"perf-1\" },\n          { imageId: \"img-2\", performerId: \"perf-2\" },\n        ],\n      });\n      // Link tags to images\n      await prisma.imageTag.createMany({\n        data: [\n          { imageId: \"img-1\", tagId: \"tag-1\" },\n          { imageId: \"img-2\", tagId: \"tag-2\" },\n        ],\n      });\n      // Set studio on image\n      await prisma.stashImage.update({\n        where: { id: \"img-1\" },\n        data: { studioId: \"studio-1\" },\n      });\n      // Link image to gallery\n      await prisma.imageGallery.create({\n        data: { imageId: \"img-1\", galleryId: \"gallery-1\" },\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageGallery.deleteMany({});\n      await prisma.imagePerformer.deleteMany({});\n      await prisma.imageTag.deleteMany({});\n      await prisma.stashGallery.deleteMany({ where: { id: \"gallery-1\" } });\n      await prisma.stashStudio.deleteMany({ where: { id: \"studio-1\" } });\n      await prisma.stashTag.deleteMany({ where: { id: { startsWith: \"tag-\" } } });\n      await prisma.stashPerformer.deleteMany({ where: { id: { startsWith: \"perf-\" } } });\n    });\n\n    it(\"filters by performer INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { performers: { value: [\"perf-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by tag INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { tags: { value: [\"tag-2\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-2\");\n    });\n\n    it(\"filters by studio INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { studios: { value: [\"studio-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n\n    it(\"filters by gallery INCLUDES\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { galleries: { value: [\"gallery-1\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-1\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - entity filters not implemented</p> <p>Step 3: Add entity filter implementations</p> <p>Add these methods to <code>ImageQueryBuilder</code>:</p> <pre><code>  // Build performer filter\n  private buildPerformerFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImagePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `i.id IN (\n            SELECT imageId FROM ImagePerformer\n            WHERE performerId IN (${placeholders})\n            GROUP BY imageId\n            HAVING COUNT(DISTINCT performerId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImagePerformer WHERE performerId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build tag filter\n  private buildTagFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImageTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"INCLUDES_ALL\":\n        return {\n          sql: `i.id IN (\n            SELECT imageId FROM ImageTag\n            WHERE tagId IN (${placeholders})\n            GROUP BY imageId\n            HAVING COUNT(DISTINCT tagId) = ?\n          )`,\n          params: [...ids, ids.length],\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImageTag WHERE tagId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build studio filter\n  private buildStudioFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.studioId IN (${placeholders})`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `(i.studioId IS NULL OR i.studioId NOT IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n\n  // Build gallery filter\n  private buildGalleryFilter(\n    filter: { value?: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (SELECT imageId FROM ImageGallery WHERE galleryId IN (${placeholders}))`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (SELECT imageId FROM ImageGallery WHERE galleryId IN (${placeholders}))`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update <code>execute</code> to use entity filters:</p> <pre><code>    // Add entity filters\n    if (filters?.performers) {\n      const performerFilter = this.buildPerformerFilter(filters.performers);\n      if (performerFilter.sql) whereClauses.push(performerFilter);\n    }\n\n    if (filters?.tags) {\n      const tagFilter = this.buildTagFilter(filters.tags);\n      if (tagFilter.sql) whereClauses.push(tagFilter);\n    }\n\n    if (filters?.studios) {\n      const studioFilter = this.buildStudioFilter(filters.studios);\n      if (studioFilter.sql) whereClauses.push(studioFilter);\n    }\n\n    if (filters?.galleries) {\n      const galleryFilter = this.buildGalleryFilter(filters.galleries);\n      if (galleryFilter.sql) whereClauses.push(galleryFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add entity filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-4-add-search-query-and-id-filters","title":"Task 4: Add Search Query and ID Filters","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing tests</p> <p>Add to test file:</p> <pre><code>  describe(\"search and ID filters\", () =&gt; {\n    it(\"filters by search query\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { q: \"Two\" },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(1);\n      expect(result.images[0].id).toBe(\"img-2\");\n    });\n\n    it(\"filters by IDs\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        filters: { ids: { value: [\"img-1\", \"img-3\"], modifier: \"INCLUDES\" } },\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(2);\n      expect(result.images.map((i: any) =&gt; i.id).sort()).toEqual([\"img-1\", \"img-3\"].sort());\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL</p> <p>Step 3: Add implementations</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  // Build search query filter\n  private buildSearchFilter(q: string | undefined): FilterClause {\n    if (!q || q.trim() === \"\") {\n      return { sql: \"\", params: [] };\n    }\n\n    const searchTerm = `%${q.trim()}%`;\n    return {\n      sql: `(\n        i.title LIKE ? OR\n        i.details LIKE ? OR\n        i.photographer LIKE ? OR\n        i.filePath LIKE ?\n      )`,\n      params: [searchTerm, searchTerm, searchTerm, searchTerm],\n    };\n  }\n\n  // Build ID filter\n  private buildIdFilter(\n    filter: { value: string[]; modifier?: string } | undefined\n  ): FilterClause {\n    if (!filter || !filter.value || filter.value.length === 0) {\n      return { sql: \"\", params: [] };\n    }\n\n    const { value: ids, modifier = \"INCLUDES\" } = filter;\n    const placeholders = ids.map(() =&gt; \"?\").join(\", \");\n\n    switch (modifier) {\n      case \"INCLUDES\":\n        return {\n          sql: `i.id IN (${placeholders})`,\n          params: ids,\n        };\n      case \"EXCLUDES\":\n        return {\n          sql: `i.id NOT IN (${placeholders})`,\n          params: ids,\n        };\n      default:\n        return { sql: \"\", params: [] };\n    }\n  }\n</code></pre> <p>Update <code>execute</code> to use these filters:</p> <pre><code>    // Add search filter\n    if (filters?.q) {\n      const searchFilter = this.buildSearchFilter(filters.q);\n      if (searchFilter.sql) whereClauses.push(searchFilter);\n    }\n\n    // Add ID filter\n    if (filters?.ids) {\n      const idFilter = this.buildIdFilter(filters.ids);\n      if (idFilter.sql) whereClauses.push(idFilter);\n    }\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add search and ID filters to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-5-add-random-sort-with-seed","title":"Task 5: Add Random Sort with Seed","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to test file:</p> <pre><code>  describe(\"random sort\", () =&gt; {\n    it(\"returns stable random order with seed\", async () =&gt; {\n      const result1 = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"random\",\n        sortDirection: \"ASC\",\n        page: 1,\n        perPage: 10,\n        randomSeed: 12345,\n      });\n\n      const result2 = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"random\",\n        sortDirection: \"ASC\",\n        page: 1,\n        perPage: 10,\n        randomSeed: 12345,\n      });\n\n      // Same seed should produce same order\n      expect(result1.images.map((i: any) =&gt; i.id)).toEqual(\n        result2.images.map((i: any) =&gt; i.id)\n      );\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL</p> <p>Step 3: Update sort clause to handle random</p> <p>Update <code>buildSortClause</code> method:</p> <pre><code>  // Build sort clause\n  private buildSortClause(\n    sort: string,\n    dir: \"ASC\" | \"DESC\",\n    randomSeed?: number\n  ): string {\n    // Handle random sort with seed\n    if (sort === \"random\" &amp;&amp; randomSeed !== undefined) {\n      // Use deterministic random based on seed and id\n      // Formula: (id_numeric * seed) % large_prime gives stable ordering\n      return `((CAST(i.id AS INTEGER) * ${randomSeed}) % 2147483647) ${dir}, i.id ${dir}`;\n    }\n\n    const sortMap: Record&lt;string, string&gt; = {\n      title: `COALESCE(i.title, i.filePath) ${dir}`,\n      date: `i.date ${dir}`,\n      rating: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      rating100: `COALESCE(r.rating, i.rating100, 0) ${dir}`,\n      o_counter: `COALESCE(v.oCount, i.oCounter, 0) ${dir}`,\n      filesize: `COALESCE(i.fileSize, 0) ${dir}`,\n      path: `i.filePath ${dir}`,\n      created_at: `i.stashCreatedAt ${dir}`,\n      updated_at: `i.stashUpdatedAt ${dir}`,\n      random: `RANDOM()`, // Fallback for random without seed\n    };\n\n    const sortExpr = sortMap[sort] || sortMap[\"created_at\"];\n    return `${sortExpr}, i.id ${dir}`;\n  }\n</code></pre> <p>Update the call in <code>execute</code>:</p> <pre><code>    const sortClause = this.buildSortClause(\n      options.sort,\n      options.sortDirection,\n      options.randomSeed\n    );\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add random sort with seed to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-6-add-exclusion-filtering-test","title":"Task 6: Add Exclusion Filtering Test","text":"<p>Files: - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the test</p> <p>Add to test file:</p> <pre><code>  describe(\"exclusion filtering\", () =&gt; {\n    beforeEach(async () =&gt; {\n      // Exclude img-2 for the test user\n      await prisma.userExcludedEntity.create({\n        data: {\n          userId: testUserId,\n          entityType: \"image\",\n          entityId: \"img-2\",\n          reason: \"hidden\",\n        },\n      });\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.userExcludedEntity.deleteMany({ where: { userId: testUserId } });\n    });\n\n    it(\"excludes images when applyExclusions is true (default)\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(2);\n      expect(result.images.map((i: any) =&gt; i.id)).not.toContain(\"img-2\");\n    });\n\n    it(\"includes all images when applyExclusions is false\", async () =&gt; {\n      const result = await imageQueryBuilder.execute({\n        userId: testUserId,\n        applyExclusions: false,\n        sort: \"created_at\",\n        sortDirection: \"DESC\",\n        page: 1,\n        perPage: 10,\n      });\n\n      expect(result.total).toBe(3);\n      expect(result.images.map((i: any) =&gt; i.id)).toContain(\"img-2\");\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS (exclusion logic already implemented in Task 1)</p> <p>Step 3: Commit</p> <pre><code>git add server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"test: add exclusion filtering tests for ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-7-add-getbyids-helper-method","title":"Task 7: Add getByIds Helper Method","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code> - Modify: <code>server/services/__tests__/ImageQueryBuilder.test.ts</code></p> <p>Step 1: Write the failing test</p> <p>Add to test file:</p> <pre><code>  describe(\"getByIds\", () =&gt; {\n    it(\"returns images by IDs with user data\", async () =&gt; {\n      await prisma.imageRating.create({\n        data: { userId: testUserId, imageId: \"img-1\", rating: 90, favorite: true },\n      });\n\n      const result = await imageQueryBuilder.getByIds({\n        userId: testUserId,\n        ids: [\"img-1\", \"img-3\"],\n      });\n\n      expect(result.images).toHaveLength(2);\n\n      const img1 = result.images.find((i: any) =&gt; i.id === \"img-1\");\n      expect(img1.userRating).toBe(90);\n      expect(img1.userFavorite).toBe(1); // SQLite returns 1 for true\n    });\n\n    afterEach(async () =&gt; {\n      await prisma.imageRating.deleteMany({ where: { userId: testUserId } });\n    });\n  });\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: FAIL - getByIds not defined</p> <p>Step 3: Add getByIds method</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  /**\n   * Get images by IDs with user data\n   */\n  async getByIds(options: { userId: number; ids: string[] }): Promise&lt;ImageQueryResult&gt; {\n    const { userId, ids } = options;\n\n    if (ids.length === 0) {\n      return { images: [], total: 0 };\n    }\n\n    return this.execute({\n      userId,\n      filters: { ids: { value: ids, modifier: \"INCLUDES\" } },\n      applyExclusions: false, // IDs explicitly requested, don't filter\n      sort: \"created_at\",\n      sortDirection: \"DESC\",\n      page: 1,\n      perPage: ids.length,\n    });\n  }\n</code></pre> <p>Also export the options type:</p> <pre><code>export interface ImageByIdsOptions {\n  userId: number;\n  ids: string[];\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts server/services/__tests__/ImageQueryBuilder.test.ts\ngit commit -m \"feat: add getByIds helper to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-8-update-images-controller-to-use-imagequerybuilder","title":"Task 8: Update Images Controller to Use ImageQueryBuilder","text":"<p>Files: - Modify: <code>server/controllers/library/images.ts</code></p> <p>Step 1: Update findImages to use ImageQueryBuilder</p> <p>Replace the entire <code>findImages</code> function in <code>server/controllers/library/images.ts</code>:</p> <pre><code>import { imageQueryBuilder, type ImageFilter } from \"../../services/ImageQueryBuilder.js\";\n\n/**\n * Find images endpoint - uses SQL-native ImageQueryBuilder\n */\nexport const findImages = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  const startTime = Date.now();\n  try {\n    const userId = req.user?.id;\n    const requestingUser = req.user;\n    const { filter, image_filter, ids } = req.body;\n\n    const sortFieldRaw = filter?.sort || \"title\";\n    const sortDirection = filter?.direction || \"ASC\";\n    const page = filter?.page || 1;\n    const perPage = filter?.per_page || 40;\n    const searchQuery = filter?.q || \"\";\n\n    // Parse random_&lt;seed&gt; format\n    let randomSeed: number | undefined;\n    let sortField = sortFieldRaw;\n\n    if (sortFieldRaw.startsWith(\"random_\")) {\n      const seedStr = sortFieldRaw.slice(7);\n      const parsedSeed = parseInt(seedStr, 10);\n      if (!isNaN(parsedSeed)) {\n        randomSeed = parsedSeed % 1e8;\n        sortField = \"random\";\n      }\n    } else if (sortFieldRaw === \"random\") {\n      randomSeed = (userId + Date.now()) % 1e8;\n    }\n\n    // Build filter object from request\n    const filters: ImageFilter = {};\n\n    if (searchQuery) {\n      filters.q = searchQuery;\n    }\n\n    if (ids &amp;&amp; Array.isArray(ids) &amp;&amp; ids.length &gt; 0) {\n      filters.ids = { value: ids, modifier: \"INCLUDES\" };\n    }\n\n    if (image_filter?.favorite !== undefined) {\n      filters.favorite = image_filter.favorite;\n    }\n\n    if (image_filter?.rating100) {\n      filters.rating100 = image_filter.rating100;\n    }\n\n    if (image_filter?.o_counter) {\n      filters.o_counter = image_filter.o_counter;\n    }\n\n    if (image_filter?.performers?.value) {\n      filters.performers = {\n        value: image_filter.performers.value.map(String),\n        modifier: image_filter.performers.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.tags?.value) {\n      filters.tags = {\n        value: image_filter.tags.value.map(String),\n        modifier: image_filter.tags.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.studios?.value) {\n      filters.studios = {\n        value: image_filter.studios.value.map(String),\n        modifier: image_filter.studios.modifier || \"INCLUDES\",\n      };\n    }\n\n    if (image_filter?.galleries?.value) {\n      filters.galleries = {\n        value: image_filter.galleries.value.map(String),\n        modifier: image_filter.galleries.modifier || \"INCLUDES\",\n      };\n    }\n\n    // Admins skip exclusions\n    const applyExclusions = requestingUser?.role !== \"ADMIN\";\n\n    // Execute query\n    const result = await imageQueryBuilder.execute({\n      userId,\n      filters,\n      applyExclusions,\n      sort: sortField,\n      sortDirection: sortDirection.toUpperCase() as \"ASC\" | \"DESC\",\n      page,\n      perPage,\n      randomSeed,\n    });\n\n    // Add stashUrl to each image\n    const imagesWithStashUrl = result.images.map((image) =&gt; ({\n      ...image,\n      stashUrl: buildStashEntityUrl(\"image\", image.id),\n    }));\n\n    const totalTime = Date.now() - startTime;\n    logger.debug(\"findImages completed\", {\n      totalTime: `${totalTime}ms`,\n      totalImages: result.total,\n      returnedImages: imagesWithStashUrl.length,\n      page,\n      perPage,\n    });\n\n    res.json({\n      findImages: {\n        count: result.total,\n        images: imagesWithStashUrl,\n      },\n    });\n  } catch (error) {\n    logger.error(\"Error in findImages\", {\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    });\n    res.status(500).json({\n      error: \"Failed to find images\",\n      details: error instanceof Error ? error.message : \"Unknown error\",\n    });\n  }\n};\n</code></pre> <p>Step 2: Remove unused imports and functions</p> <p>Remove these from <code>images.ts</code>: - <code>stashEntityService</code> import (if no longer used by findImageById) - <code>entityExclusionHelper</code> import - <code>expandStudioIds</code>, <code>expandTagIds</code> imports - <code>mergeImagesWithUserData</code> function - <code>applyImageFiltersWithInheritance</code> function - <code>sortImages</code> function</p> <p>Keep <code>findImageById</code> as-is for now (single image lookup can stay simple).</p> <p>Step 3: Run full test suite</p> <p>Run: <code>npm test</code> Expected: All tests pass</p> <p>Step 4: Manual verification</p> <p>Start the server and test the images page: 1. Navigate to images page 2. Apply filters (performer, tag, studio) 3. Test sorting options 4. Test random sort with pagination</p> <p>Step 5: Commit</p> <pre><code>git add server/controllers/library/images.ts\ngit commit -m \"refactor: replace in-memory filtering with ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-9-hydrate-related-entities-performers-tags-galleries-studio","title":"Task 9: Hydrate Related Entities (performers, tags, galleries, studio)","text":"<p>Files: - Modify: <code>server/services/ImageQueryBuilder.ts</code></p> <p>Step 1: Add hydration method</p> <p>The raw SQL returns flat data. We need to hydrate related entities for the API response.</p> <p>Add to <code>ImageQueryBuilder</code>:</p> <pre><code>  /**\n   * Hydrate image rows with related entities\n   */\n  private async hydrateImages(rows: any[]): Promise&lt;any[]&gt; {\n    if (rows.length === 0) return [];\n\n    const imageIds = rows.map((r) =&gt; r.id);\n\n    // Fetch all related data in parallel\n    const [performers, tags, galleries, studios] = await Promise.all([\n      prisma.imagePerformer.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { performer: true },\n      }),\n      prisma.imageTag.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { tag: true },\n      }),\n      prisma.imageGallery.findMany({\n        where: { imageId: { in: imageIds } },\n        include: { gallery: true },\n      }),\n      prisma.stashStudio.findMany({\n        where: { id: { in: rows.map((r) =&gt; r.studioId).filter(Boolean) } },\n      }),\n    ]);\n\n    // Build lookup maps\n    const performersByImage = new Map&lt;string, any[]&gt;();\n    for (const ip of performers) {\n      if (!performersByImage.has(ip.imageId)) {\n        performersByImage.set(ip.imageId, []);\n      }\n      performersByImage.get(ip.imageId)!.push(ip.performer);\n    }\n\n    const tagsByImage = new Map&lt;string, any[]&gt;();\n    for (const it of tags) {\n      if (!tagsByImage.has(it.imageId)) {\n        tagsByImage.set(it.imageId, []);\n      }\n      tagsByImage.get(it.imageId)!.push(it.tag);\n    }\n\n    const galleriesByImage = new Map&lt;string, any[]&gt;();\n    for (const ig of galleries) {\n      if (!galleriesByImage.has(ig.imageId)) {\n        galleriesByImage.set(ig.imageId, []);\n      }\n      galleriesByImage.get(ig.imageId)!.push(ig.gallery);\n    }\n\n    const studiosById = new Map(studios.map((s) =&gt; [s.id, s]));\n\n    // Hydrate each row\n    return rows.map((row) =&gt; ({\n      ...row,\n      performers: performersByImage.get(row.id) || [],\n      tags: tagsByImage.get(row.id) || [],\n      galleries: galleriesByImage.get(row.id) || [],\n      studio: row.studioId ? studiosById.get(row.studioId) : null,\n    }));\n  }\n</code></pre> <p>Update <code>execute</code> to use hydration:</p> <pre><code>    // Execute query\n    const rows = await prisma.$queryRawUnsafe&lt;any[]&gt;(sql, ...params);\n\n    // Hydrate with related entities\n    const hydratedImages = await this.hydrateImages(rows);\n\n    // ... count query ...\n\n    return { images: hydratedImages, total };\n</code></pre> <p>Step 2: Run tests</p> <p>Run: <code>npm test -- server/services/__tests__/ImageQueryBuilder.test.ts</code> Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add server/services/ImageQueryBuilder.ts\ngit commit -m \"feat: add entity hydration to ImageQueryBuilder\"\n</code></pre>"},{"location":"plans/2026-01-02-image-query-builder/#task-10-final-integration-test-and-cleanup","title":"Task 10: Final Integration Test and Cleanup","text":"<p>Files: - Test: <code>server/tests/controllers/images.integration.test.ts</code> (create)</p> <p>Step 1: Create integration test</p> <p>Create <code>server/tests/controllers/images.integration.test.ts</code>:</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from \"vitest\";\nimport request from \"supertest\";\nimport app from \"../../app.js\";\nimport prisma from \"../../prisma/singleton.js\";\n\ndescribe(\"Images API Integration\", () =&gt; {\n  const testUserId = 8888;\n  let authToken: string;\n\n  beforeEach(async () =&gt; {\n    // Create test user and get token\n    await prisma.user.create({\n      data: { id: testUserId, username: \"img-test\", password: \"test\" },\n    });\n    // Create test images\n    await prisma.stashImage.createMany({\n      data: [\n        { id: \"int-img-1\", title: \"Test Image One\", stashCreatedAt: new Date() },\n        { id: \"int-img-2\", title: \"Test Image Two\", stashCreatedAt: new Date() },\n      ],\n    });\n  });\n\n  afterEach(async () =&gt; {\n    await prisma.stashImage.deleteMany({ where: { id: { startsWith: \"int-img-\" } } });\n    await prisma.user.deleteMany({ where: { id: testUserId } });\n  });\n\n  it(\"returns paginated images\", async () =&gt; {\n    const response = await request(app)\n      .post(\"/api/library/images\")\n      .send({\n        filter: { page: 1, per_page: 10, sort: \"created_at\", direction: \"DESC\" },\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.findImages).toBeDefined();\n    expect(response.body.findImages.count).toBeGreaterThanOrEqual(2);\n  });\n});\n</code></pre> <p>Step 2: Run integration tests</p> <p>Run: <code>npm run test:integration -- server/tests/controllers/images.integration.test.ts</code> Expected: PASS</p> <p>Step 3: Run full test suite</p> <p>Run: <code>npm test &amp;&amp; npm run lint &amp;&amp; npm run build</code> Expected: All pass</p> <p>Step 4: Final commit</p> <pre><code>git add server/tests/controllers/images.integration.test.ts\ngit commit -m \"test: add images API integration tests\"\n</code></pre> <p>Plan complete and saved to <code>docs/plans/2026-01-02-image-query-builder.md</code>. Two execution options:</p> <p>1. Subagent-Driven (this session) - I dispatch fresh subagent per task, review between tasks, fast iteration</p> <p>2. Parallel Session (separate) - Open new session with executing-plans, batch execution with checkpoints</p> <p>Which approach?</p>"},{"location":"plans/2026-01-03-api-types-design/","title":"API Types Design","text":""},{"location":"plans/2026-01-03-api-types-design/#overview","title":"Overview","text":"<p>Add explicit TypeScript types for API request/response contracts across the peek-stash-browser server. This enables:</p> <ol> <li>Type safety - Compile-time validation of request/response shapes</li> <li>Self-documenting APIs - Types serve as living documentation</li> <li>Auto-generated docs - Simple script can extract types to markdown</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#current-state","title":"Current State","text":""},{"location":"plans/2026-01-03-api-types-design/#route-structure","title":"Route Structure","text":"<p>Routes are thin and delegate to controllers: <pre><code>// routes/library/scenes.ts\nrouter.post(\"/scenes\", requireCacheReady, authenticated(findScenes));\n</code></pre></p>"},{"location":"plans/2026-01-03-api-types-design/#controller-signatures","title":"Controller Signatures","text":"<p>Controllers use generic Express types with implicit shapes: <pre><code>export const findScenes = async (req: AuthenticatedRequest, res: Response) =&gt; {\n  const { filter, scene_filter, ids } = req.body;  // implicit\n  // ...\n  res.json({ findScenes: { count, scenes } });     // implicit\n}\n</code></pre></p>"},{"location":"plans/2026-01-03-api-types-design/#existing-types","title":"Existing Types","text":"<p>Strong types exist for entities (<code>NormalizedScene</code>, <code>PeekSceneFilter</code>, etc.) but not for API contracts.</p>"},{"location":"plans/2026-01-03-api-types-design/#proposed-design","title":"Proposed Design","text":""},{"location":"plans/2026-01-03-api-types-design/#1-type-organization","title":"1. Type Organization","text":"<p>Create <code>server/types/api/</code> directory with types per domain:</p> <pre><code>server/types/api/\n\u251c\u2500\u2500 index.ts           # Re-exports all API types\n\u251c\u2500\u2500 common.ts          # Shared types (pagination, errors)\n\u251c\u2500\u2500 library.ts         # Library endpoint types (scenes, performers, etc.)\n\u251c\u2500\u2500 auth.ts            # Auth endpoint types\n\u251c\u2500\u2500 playlists.ts       # Playlist endpoint types\n\u251c\u2500\u2500 carousels.ts       # Carousel endpoint types\n\u251c\u2500\u2500 ratings.ts         # Rating endpoint types\n\u251c\u2500\u2500 watchHistory.ts    # Watch history endpoint types\n\u251c\u2500\u2500 setup.ts           # Setup wizard endpoint types\n\u2514\u2500\u2500 user.ts            # User settings endpoint types\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#2-type-pattern","title":"2. Type Pattern","text":"<p>Each endpoint gets a request and response type:</p> <pre><code>// types/api/library.ts\n\nimport type { NormalizedScene, PeekSceneFilter } from \"../index.js\";\nimport type { PaginationFilter, PaginatedResponse } from \"./common.js\";\n\n// POST /api/library/scenes\nexport interface FindScenesRequest {\n  filter?: PaginationFilter;\n  scene_filter?: PeekSceneFilter;\n  ids?: string[];\n}\n\nexport interface FindScenesResponse {\n  findScenes: {\n    count: number;\n    scenes: NormalizedScene[];\n  };\n}\n\n// GET /api/library/scenes/:id/similar\nexport interface FindSimilarScenesParams {\n  id: string;\n}\n\nexport interface FindSimilarScenesQuery {\n  page?: string;\n}\n\nexport interface FindSimilarScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#3-common-types","title":"3. Common Types","text":"<pre><code>// types/api/common.ts\n\nexport interface PaginationFilter {\n  page?: number;\n  per_page?: number;\n  sort?: string;\n  direction?: \"ASC\" | \"DESC\";\n  q?: string;\n}\n\nexport interface PaginatedResponse&lt;T&gt; {\n  count: number;\n  items: T[];\n  page?: number;\n  perPage?: number;\n}\n\nexport interface ApiError {\n  error: string;\n  details?: string;\n  errorType?: string;\n}\n\nexport interface ApiSuccess {\n  success: true;\n  message?: string;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#4-typed-request-helper","title":"4. Typed Request Helper","text":"<p>Extend Express types to use our API types:</p> <pre><code>// types/api/express.ts\n\nimport type { Request, Response } from \"express\";\nimport type { RequestUser } from \"../../middleware/auth.js\";\n\nexport interface TypedRequest&lt;\n  TBody = unknown,\n  TParams = unknown,\n  TQuery = unknown\n&gt; extends Request {\n  body: TBody;\n  params: TParams;\n  query: TQuery;\n  user?: RequestUser;\n}\n\nexport interface TypedAuthRequest&lt;\n  TBody = unknown,\n  TParams = unknown,\n  TQuery = unknown\n&gt; extends TypedRequest&lt;TBody, TParams, TQuery&gt; {\n  user: RequestUser;  // Required, not optional\n}\n\nexport interface TypedResponse&lt;T&gt; extends Response {\n  json: (body: T) =&gt; this;\n}\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#5-controller-updates","title":"5. Controller Updates","text":"<p>Controllers become explicitly typed:</p> <pre><code>// controllers/library/scenes.ts\n\nimport type { TypedAuthRequest, TypedResponse } from \"../../types/api/express.js\";\nimport type {\n  FindScenesRequest,\n  FindScenesResponse,\n} from \"../../types/api/library.js\";\n\nexport const findScenes = async (\n  req: TypedAuthRequest&lt;FindScenesRequest&gt;,\n  res: TypedResponse&lt;FindScenesResponse&gt;\n) =&gt; {\n  // req.body is now typed as FindScenesRequest\n  // res.json() expects FindScenesResponse\n  const { filter, scene_filter, ids } = req.body;\n  // ...\n};\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#implementation-scope-library-routes-first","title":"Implementation Scope: Library Routes First","text":"<p>Focus on the library routes as the highest-value target:</p>"},{"location":"plans/2026-01-03-api-types-design/#library-routes-to-type","title":"Library Routes to Type","text":"Route Method Request Type Response Type <code>/library/scenes</code> POST <code>FindScenesRequest</code> <code>FindScenesResponse</code> <code>/library/scenes/:id</code> PUT <code>UpdateSceneRequest</code> <code>UpdateSceneResponse</code> <code>/library/scenes/:id/similar</code> GET params + query <code>FindSimilarScenesResponse</code> <code>/library/scenes/recommended</code> GET query <code>GetRecommendedScenesResponse</code> <code>/library/performers</code> POST <code>FindPerformersRequest</code> <code>FindPerformersResponse</code> <code>/library/performers/minimal</code> POST <code>FindPerformersMinimalRequest</code> <code>FindPerformersMinimalResponse</code> <code>/library/performers/:id</code> PUT <code>UpdatePerformerRequest</code> <code>UpdatePerformerResponse</code> <code>/library/studios</code> POST <code>FindStudiosRequest</code> <code>FindStudiosResponse</code> <code>/library/studios/minimal</code> POST <code>FindStudiosMinimalRequest</code> <code>FindStudiosMinimalResponse</code> <code>/library/tags</code> POST <code>FindTagsRequest</code> <code>FindTagsResponse</code> <code>/library/tags/minimal</code> POST <code>FindTagsMinimalRequest</code> <code>FindTagsMinimalResponse</code> <code>/library/galleries</code> POST <code>FindGalleriesRequest</code> <code>FindGalleriesResponse</code> <code>/library/galleries/:id</code> GET params <code>FindGalleryByIdResponse</code> <code>/library/galleries/:id/images</code> GET params + query <code>GetGalleryImagesResponse</code> <code>/library/galleries/minimal</code> POST <code>FindGalleriesMinimalRequest</code> <code>FindGalleriesMinimalResponse</code> <code>/library/groups</code> POST <code>FindGroupsRequest</code> <code>FindGroupsResponse</code> <code>/library/groups/minimal</code> POST <code>FindGroupsMinimalRequest</code> <code>FindGroupsMinimalResponse</code> <code>/library/images</code> POST <code>FindImagesRequest</code> <code>FindImagesResponse</code>"},{"location":"plans/2026-01-03-api-types-design/#test-coverage-audit","title":"Test Coverage Audit","text":""},{"location":"plans/2026-01-03-api-types-design/#current-test-coverage","title":"Current Test Coverage","text":"<p>The existing tests focus on services and filter logic, not HTTP contracts:</p> Test File What It Tests <code>tests/filters/sceneFilters.test.ts</code> <code>applyQuickSceneFilters()</code> function <code>tests/filters/sceneFiltersExpensive.test.ts</code> <code>applyExpensiveSceneFilters()</code> function <code>tests/filters/performerFilters.test.ts</code> Performer filter logic <code>tests/filters/galleryFilters.test.ts</code> Gallery filter logic <code>tests/filters/groupFilters.test.ts</code> Group filter logic <code>tests/filters/studioFilters.test.ts</code> Studio filter logic <code>tests/filters/tagFilters.test.ts</code> Tag filter logic <code>tests/services/SceneQueryBuilder.test.ts</code> SQL query builder <code>services/__tests__/StashEntityService.test.ts</code> Entity service <code>services/__tests__/StashSyncService.*.test.ts</code> Sync service <code>tests/utils/codecDetection.test.ts</code> Codec detection utility"},{"location":"plans/2026-01-03-api-types-design/#test-gap","title":"Test Gap","text":"<p>No HTTP-level integration tests exist. This means:</p> <ol> <li>Response shape changes could go undetected</li> <li>No validation that routes return expected structures</li> <li>Client/server contract is implicitly trusted</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#mitigation-strategy","title":"Mitigation Strategy","text":"<p>Adding API types provides compile-time safety, but we should also add lightweight response shape tests:</p> <pre><code>// tests/api/library.integration.test.ts\n\nimport { describe, it, expect } from \"vitest\";\nimport request from \"supertest\";\nimport { app } from \"../../initializers/api.js\";\n\ndescribe(\"POST /api/library/scenes\", () =&gt; {\n  it(\"returns expected response shape\", async () =&gt; {\n    const res = await request(app)\n      .post(\"/api/library/scenes\")\n      .set(\"Authorization\", `Bearer ${testToken}`)\n      .send({ filter: { page: 1, per_page: 10 } });\n\n    expect(res.status).toBe(200);\n    expect(res.body).toHaveProperty(\"findScenes\");\n    expect(res.body.findScenes).toHaveProperty(\"count\");\n    expect(res.body.findScenes).toHaveProperty(\"scenes\");\n    expect(Array.isArray(res.body.findScenes.scenes)).toBe(true);\n  });\n});\n</code></pre> <p>This is optional for Phase 1 but recommended as a follow-up.</p>"},{"location":"plans/2026-01-03-api-types-design/#implementation-plan","title":"Implementation Plan","text":""},{"location":"plans/2026-01-03-api-types-design/#phase-1-type-infrastructure-this-branch","title":"Phase 1: Type Infrastructure (this branch)","text":"<ol> <li>Create <code>types/api/</code> directory structure</li> <li>Add <code>common.ts</code> with shared types</li> <li>Add <code>express.ts</code> with typed request/response helpers</li> <li>Add <code>library.ts</code> with all library endpoint types</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#phase-2-controller-updates","title":"Phase 2: Controller Updates","text":"<ol> <li>Update library controllers to use typed request/response</li> <li>Fix any type errors that surface (these are bugs!)</li> <li>Run existing tests to ensure no regressions</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#phase-3-remaining-endpoints","title":"Phase 3: Remaining Endpoints","text":"<p>Apply same pattern to other route groups: - Auth routes - Playlist routes - Carousel routes - Rating routes - Watch history routes - Setup routes - User routes</p>"},{"location":"plans/2026-01-03-api-types-design/#phase-4-documentation-generator","title":"Phase 4: Documentation Generator","text":"<p>Simple script to extract API types to markdown: <pre><code>npm run generate-api-docs\n</code></pre></p> <p>Outputs <code>docs/development/api-reference.md</code> with: - All routes listed - Request/response types inline - Auto-updated from type definitions</p>"},{"location":"plans/2026-01-03-api-types-design/#dry-considerations","title":"DRY Considerations","text":""},{"location":"plans/2026-01-03-api-types-design/#reuse-existing-entity-types","title":"Reuse Existing Entity Types","text":"<p>Don't duplicate - import from existing type files:</p> <pre><code>import type {\n  NormalizedScene,\n  NormalizedPerformer,\n  PeekSceneFilter,\n  PeekPerformerFilter,\n} from \"../index.js\";\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#generic-response-wrappers","title":"Generic Response Wrappers","text":"<p>For consistent patterns like <code>{ success: true, entity: T }</code>:</p> <pre><code>export type SuccessResponse&lt;T extends string, V&gt; = {\n  success: true;\n} &amp; { [K in T]: V };\n\n// Usage:\ntype UpdateSceneResponse = SuccessResponse&lt;\"scene\", NormalizedScene&gt;;\n// Results in: { success: true; scene: NormalizedScene }\n</code></pre>"},{"location":"plans/2026-01-03-api-types-design/#filter-types","title":"Filter Types","text":"<p>Leverage existing filter types from <code>types/filters.ts</code> and <code>types/peekFilters.ts</code>.</p>"},{"location":"plans/2026-01-03-api-types-design/#risks-and-mitigations","title":"Risks and Mitigations","text":"Risk Impact Mitigation Type changes break client High Existing tests validate filter logic; add integration tests in Phase 4 Large refactor scope Medium Phase by route group; library first as highest value Type/runtime mismatch Medium TypeScript strict mode catches most issues Migration complexity Low Controllers only need signature changes; logic unchanged"},{"location":"plans/2026-01-03-api-types-design/#success-criteria","title":"Success Criteria","text":"<ol> <li>All library controllers have typed request/response signatures</li> <li>No new runtime errors introduced (existing tests pass)</li> <li>TypeScript catches at least one latent bug during migration</li> <li>Generated API docs reflect actual types</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#open-questions","title":"Open Questions","text":"<ol> <li>Should we validate request bodies at runtime? (e.g., with Zod)</li> <li>Pro: Catches malformed requests before they hit business logic</li> <li>Con: Adds runtime overhead and complexity</li> <li> <p>Recommendation: Defer to Phase 4; types are enough for now</p> </li> <li> <p>Should response types be strict or permissive?</p> </li> <li>Strict: <code>res.json()</code> only accepts exact type</li> <li>Permissive: Allow additional fields</li> <li>Recommendation: Start strict; loosen if needed</li> </ol>"},{"location":"plans/2026-01-03-api-types-design/#implementation-status","title":"Implementation Status","text":""},{"location":"plans/2026-01-03-api-types-design/#completed-phase-1-2026-01-03","title":"Completed (Phase 1 - 2026-01-03)","text":"<ul> <li> Type infrastructure (<code>types/api/common.ts</code>, <code>types/api/express.ts</code>)</li> <li> Library endpoint types (<code>types/api/library.ts</code>)</li> <li> API types index (<code>types/api/index.ts</code>)</li> <li> Scenes controller typed signatures</li> <li> Performers controller typed signatures</li> <li> Updated <code>authenticated()</code> helper for type compatibility</li> </ul> <p>Commits: - <code>feat(types): add common API types</code> - <code>feat(types): add typed Express request/response helpers</code> - <code>feat(types): add library API request/response types</code> - <code>feat(types): add API types index</code> - <code>feat(types): add typed signatures to scenes controller</code> - <code>feat(types): add typed signatures to performers controller</code> - <code>fix: remove unused imports from typed controllers</code></p> <p>Bugs Found During Migration: - <code>ids</code> filter format needed normalization (was <code>string[]</code>, expected <code>{ value: string[], modifier: string }</code>) - <code>groupIdForSort</code> needed parsing from string to number</p>"},{"location":"plans/2026-01-03-api-types-design/#remaining-future-phases","title":"Remaining (Future Phases)","text":"<ul> <li> Studios controller typed signatures</li> <li> Tags controller typed signatures</li> <li> Galleries controller typed signatures</li> <li> Groups controller typed signatures</li> <li> Images controller typed signatures</li> <li> Auth endpoints</li> <li> Playlist endpoints</li> <li> Carousel endpoints</li> <li> Rating endpoints</li> <li> Watch history endpoints</li> <li> Setup endpoints</li> <li> User endpoints</li> <li> API documentation generator script</li> </ul>"},{"location":"plans/2026-01-03-api-types-implementation/","title":"API Types Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add explicit TypeScript types for API request/response contracts to enable compile-time safety and self-documenting endpoints.</p> <p>Architecture: Create <code>server/types/api/</code> directory with typed request/response interfaces. Extend Express Request/Response types with generics. Update library controllers to use typed signatures.</p> <p>Tech Stack: TypeScript strict mode, Express.js types</p>"},{"location":"plans/2026-01-03-api-types-implementation/#task-1-create-common-api-types","title":"Task 1: Create Common API Types","text":"<p>Files: - Create: <code>server/types/api/common.ts</code></p> <p>Step 1: Create the common types file</p> <pre><code>// server/types/api/common.ts\n/**\n * Common API Types\n *\n * Shared types used across all API endpoints.\n */\n\n/**\n * Standard pagination filter accepted by most list endpoints\n */\nexport interface PaginationFilter {\n  page?: number;\n  per_page?: number;\n  sort?: string;\n  direction?: \"ASC\" | \"DESC\";\n  q?: string;\n}\n\n/**\n * Standard error response\n */\nexport interface ApiErrorResponse {\n  error: string;\n  details?: string;\n  errorType?: string;\n}\n\n/**\n * Standard success response with optional message\n */\nexport interface ApiSuccessResponse {\n  success: true;\n  message?: string;\n}\n\n/**\n * Cache not ready response (503)\n */\nexport interface CacheNotReadyResponse {\n  error: string;\n  message: string;\n  ready: false;\n}\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to common.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/common.ts\ngit commit -m \"feat(types): add common API types\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-2-create-typed-express-helpers","title":"Task 2: Create Typed Express Helpers","text":"<p>Files: - Create: <code>server/types/api/express.ts</code></p> <p>Step 1: Create typed Express request/response interfaces</p> <pre><code>// server/types/api/express.ts\n/**\n * Typed Express Request/Response Helpers\n *\n * Extends Express types to provide type safety for API handlers.\n */\nimport type { Request, Response } from \"express\";\nimport type { RequestUser } from \"../../middleware/auth.js\";\n\n/**\n * Typed request with body, params, and query generics\n */\nexport interface TypedRequest&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt; extends Request {\n  body: TBody;\n  params: TParams;\n  query: TQuery;\n  user?: RequestUser;\n}\n\n/**\n * Typed request that requires authentication\n * user is guaranteed to exist\n */\nexport interface TypedAuthRequest&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt; extends TypedRequest&lt;TBody, TParams, TQuery&gt; {\n  user: RequestUser;\n}\n\n/**\n * Typed response with json body generic\n * Note: Express Response.json returns Response, not the body type\n */\nexport type TypedResponse&lt;T&gt; = Response&lt;T&gt;;\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to express.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/express.ts\ngit commit -m \"feat(types): add typed Express request/response helpers\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-3-create-library-scenes-api-types","title":"Task 3: Create Library Scenes API Types","text":"<p>Files: - Create: <code>server/types/api/library.ts</code></p> <p>Step 1: Create library API types for scenes</p> <pre><code>// server/types/api/library.ts\n/**\n * Library API Types\n *\n * Request and response types for /api/library/* endpoints.\n */\nimport type {\n  NormalizedScene,\n  NormalizedPerformer,\n  NormalizedStudio,\n  NormalizedTag,\n  NormalizedGallery,\n  NormalizedGroup,\n  PeekSceneFilter,\n  PeekPerformerFilter,\n  PeekStudioFilter,\n  PeekTagFilter,\n  PeekGalleryFilter,\n  PeekGroupFilter,\n} from \"../index.js\";\nimport type { PaginationFilter, ApiErrorResponse } from \"./common.js\";\n\n// =============================================================================\n// SCENES\n// =============================================================================\n\n/**\n * POST /api/library/scenes - Find scenes with filters\n */\nexport interface FindScenesRequest {\n  filter?: PaginationFilter;\n  scene_filter?: PeekSceneFilter;\n  ids?: string[];\n}\n\nexport interface FindScenesResponse {\n  findScenes: {\n    count: number;\n    scenes: NormalizedScene[];\n  };\n}\n\n/**\n * GET /api/library/scenes/:id/similar - Find similar scenes\n */\nexport interface FindSimilarScenesParams {\n  id: string;\n}\n\nexport interface FindSimilarScenesQuery {\n  page?: string;\n}\n\nexport interface FindSimilarScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n}\n\n/**\n * GET /api/library/scenes/recommended - Get recommended scenes\n */\nexport interface GetRecommendedScenesQuery {\n  page?: string;\n  per_page?: string;\n}\n\nexport interface GetRecommendedScenesResponse {\n  scenes: NormalizedScene[];\n  count: number;\n  page: number;\n  perPage: number;\n  message?: string;\n  criteria?: {\n    favoritePerformers: number;\n    highlyRatedPerformers: number;\n    favoriteStudios: number;\n    highlyRatedStudios: number;\n    favoriteTags: number;\n    highlyRatedTags: number;\n    favoriteScenes: number;\n    highlyRatedScenes: number;\n  };\n}\n\n/**\n * PUT /api/library/scenes/:id - Update scene\n */\nexport interface UpdateSceneParams {\n  id: string;\n}\n\nexport interface UpdateSceneRequest {\n  title?: string;\n  details?: string;\n  date?: string;\n  rating100?: number;\n  studio_id?: string;\n  performer_ids?: string[];\n  tag_ids?: string[];\n  [key: string]: unknown; // Allow pass-through to Stash API\n}\n\nexport interface UpdateSceneResponse {\n  success: true;\n  scene: NormalizedScene;\n}\n\n// =============================================================================\n// PERFORMERS\n// =============================================================================\n\n/**\n * POST /api/library/performers - Find performers with filters\n */\nexport interface FindPerformersRequest {\n  filter?: PaginationFilter;\n  performer_filter?: PeekPerformerFilter;\n  ids?: string[];\n}\n\nexport interface FindPerformersResponse {\n  findPerformers: {\n    count: number;\n    performers: NormalizedPerformer[];\n  };\n}\n\n/**\n * POST /api/library/performers/minimal - Get minimal performer data\n */\nexport interface FindPerformersMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindPerformersMinimalResponse {\n  performers: Array&lt;{ id: string; name: string }&gt;;\n}\n\n/**\n * PUT /api/library/performers/:id - Update performer\n */\nexport interface UpdatePerformerParams {\n  id: string;\n}\n\nexport interface UpdatePerformerRequest {\n  name?: string;\n  details?: string;\n  [key: string]: unknown;\n}\n\nexport interface UpdatePerformerResponse {\n  success: true;\n  performer: NormalizedPerformer;\n}\n\n// =============================================================================\n// STUDIOS\n// =============================================================================\n\n/**\n * POST /api/library/studios - Find studios with filters\n */\nexport interface FindStudiosRequest {\n  filter?: PaginationFilter;\n  studio_filter?: PeekStudioFilter;\n  ids?: string[];\n}\n\nexport interface FindStudiosResponse {\n  findStudios: {\n    count: number;\n    studios: NormalizedStudio[];\n  };\n}\n\n/**\n * POST /api/library/studios/minimal - Get minimal studio data\n */\nexport interface FindStudiosMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindStudiosMinimalResponse {\n  studios: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// TAGS\n// =============================================================================\n\n/**\n * POST /api/library/tags - Find tags with filters\n */\nexport interface FindTagsRequest {\n  filter?: PaginationFilter;\n  tag_filter?: PeekTagFilter;\n  ids?: string[];\n}\n\nexport interface FindTagsResponse {\n  findTags: {\n    count: number;\n    tags: NormalizedTag[];\n  };\n}\n\n/**\n * POST /api/library/tags/minimal - Get minimal tag data\n */\nexport interface FindTagsMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindTagsMinimalResponse {\n  tags: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// GALLERIES\n// =============================================================================\n\n/**\n * POST /api/library/galleries - Find galleries with filters\n */\nexport interface FindGalleriesRequest {\n  filter?: PaginationFilter;\n  gallery_filter?: PeekGalleryFilter;\n  ids?: string[];\n}\n\nexport interface FindGalleriesResponse {\n  findGalleries: {\n    count: number;\n    galleries: NormalizedGallery[];\n  };\n}\n\n/**\n * GET /api/library/galleries/:id - Get single gallery\n */\nexport interface GetGalleryParams {\n  id: string;\n}\n\nexport interface GetGalleryResponse {\n  gallery: NormalizedGallery | null;\n}\n\n/**\n * GET /api/library/galleries/:id/images - Get gallery images\n */\nexport interface GetGalleryImagesParams {\n  id: string;\n}\n\nexport interface GetGalleryImagesQuery {\n  page?: string;\n  per_page?: string;\n}\n\nexport interface GetGalleryImagesResponse {\n  images: Array&lt;{\n    id: string;\n    title?: string;\n    files?: Array&lt;{ width?: number; height?: number }&gt;;\n    paths?: { thumbnail?: string };\n  }&gt;;\n  count: number;\n  page: number;\n  perPage: number;\n  totalPages: number;\n}\n\n/**\n * POST /api/library/galleries/minimal - Get minimal gallery data\n */\nexport interface FindGalleriesMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindGalleriesMinimalResponse {\n  galleries: Array&lt;{ id: string; title: string }&gt;;\n}\n\n// =============================================================================\n// GROUPS\n// =============================================================================\n\n/**\n * POST /api/library/groups - Find groups with filters\n */\nexport interface FindGroupsRequest {\n  filter?: PaginationFilter;\n  group_filter?: PeekGroupFilter;\n  ids?: string[];\n}\n\nexport interface FindGroupsResponse {\n  findGroups: {\n    count: number;\n    groups: NormalizedGroup[];\n  };\n}\n\n/**\n * POST /api/library/groups/minimal - Get minimal group data\n */\nexport interface FindGroupsMinimalRequest {\n  filter?: PaginationFilter;\n}\n\nexport interface FindGroupsMinimalResponse {\n  groups: Array&lt;{ id: string; name: string }&gt;;\n}\n\n// =============================================================================\n// IMAGES\n// =============================================================================\n\n/**\n * POST /api/library/images - Find images with filters\n */\nexport interface FindImagesRequest {\n  filter?: PaginationFilter;\n  image_filter?: Record&lt;string, unknown&gt;; // TODO: Add PeekImageFilter\n  ids?: string[];\n}\n\nexport interface FindImagesResponse {\n  findImages: {\n    count: number;\n    images: Array&lt;{\n      id: string;\n      title?: string;\n      rating100?: number;\n      favorite?: boolean;\n      o_counter?: number;\n      files?: Array&lt;{ width?: number; height?: number }&gt;;\n      paths?: { thumbnail?: string };\n      galleries?: Array&lt;{ id: string; title?: string }&gt;;\n      performers?: Array&lt;{ id: string; name: string }&gt;;\n      studio?: { id: string; name: string } | null;\n      tags?: Array&lt;{ id: string; name: string }&gt;;\n    }&gt;;\n  };\n}\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors related to library.ts</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/library.ts\ngit commit -m \"feat(types): add library API request/response types\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-4-create-api-types-index","title":"Task 4: Create API Types Index","text":"<p>Files: - Create: <code>server/types/api/index.ts</code></p> <p>Step 1: Create index file that re-exports all API types</p> <pre><code>// server/types/api/index.ts\n/**\n * API Types Index\n *\n * Re-exports all API request/response types for easy importing.\n *\n * Usage:\n *   import type { FindScenesRequest, FindScenesResponse } from \"../types/api/index.js\";\n */\n\n// Common types\nexport type {\n  PaginationFilter,\n  ApiErrorResponse,\n  ApiSuccessResponse,\n  CacheNotReadyResponse,\n} from \"./common.js\";\n\n// Express typed helpers\nexport type {\n  TypedRequest,\n  TypedAuthRequest,\n  TypedResponse,\n} from \"./express.js\";\n\n// Library endpoint types\nexport type {\n  // Scenes\n  FindScenesRequest,\n  FindScenesResponse,\n  FindSimilarScenesParams,\n  FindSimilarScenesQuery,\n  FindSimilarScenesResponse,\n  GetRecommendedScenesQuery,\n  GetRecommendedScenesResponse,\n  UpdateSceneParams,\n  UpdateSceneRequest,\n  UpdateSceneResponse,\n  // Performers\n  FindPerformersRequest,\n  FindPerformersResponse,\n  FindPerformersMinimalRequest,\n  FindPerformersMinimalResponse,\n  UpdatePerformerParams,\n  UpdatePerformerRequest,\n  UpdatePerformerResponse,\n  // Studios\n  FindStudiosRequest,\n  FindStudiosResponse,\n  FindStudiosMinimalRequest,\n  FindStudiosMinimalResponse,\n  // Tags\n  FindTagsRequest,\n  FindTagsResponse,\n  FindTagsMinimalRequest,\n  FindTagsMinimalResponse,\n  // Galleries\n  FindGalleriesRequest,\n  FindGalleriesResponse,\n  GetGalleryParams,\n  GetGalleryResponse,\n  GetGalleryImagesParams,\n  GetGalleryImagesQuery,\n  GetGalleryImagesResponse,\n  FindGalleriesMinimalRequest,\n  FindGalleriesMinimalResponse,\n  // Groups\n  FindGroupsRequest,\n  FindGroupsResponse,\n  FindGroupsMinimalRequest,\n  FindGroupsMinimalResponse,\n  // Images\n  FindImagesRequest,\n  FindImagesResponse,\n} from \"./library.js\";\n</code></pre> <p>Step 2: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Commit</p> <pre><code>git add server/types/api/index.ts\ngit commit -m \"feat(types): add API types index\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-5-update-scenes-controller-with-typed-signatures","title":"Task 5: Update Scenes Controller with Typed Signatures","text":"<p>Files: - Modify: <code>server/controllers/library/scenes.ts</code></p> <p>Step 1: Add imports for new types</p> <p>At the top of the file, after existing imports, add:</p> <pre><code>import type {\n  TypedAuthRequest,\n  TypedResponse,\n  FindScenesRequest,\n  FindScenesResponse,\n  FindSimilarScenesParams,\n  FindSimilarScenesQuery,\n  FindSimilarScenesResponse,\n  GetRecommendedScenesQuery,\n  GetRecommendedScenesResponse,\n  UpdateSceneParams,\n  UpdateSceneRequest,\n  UpdateSceneResponse,\n  ApiErrorResponse,\n} from \"../../types/api/index.js\";\n</code></pre> <p>Step 2: Update findScenes signature</p> <p>Change: <pre><code>export const findScenes = async (req: AuthenticatedRequest, res: Response) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findScenes = async (\n  req: TypedAuthRequest&lt;FindScenesRequest&gt;,\n  res: TypedResponse&lt;FindScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 3: Update findSimilarScenes signature</p> <p>Change: <pre><code>export const findSimilarScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findSimilarScenes = async (\n  req: TypedAuthRequest&lt;unknown, FindSimilarScenesParams, FindSimilarScenesQuery&gt;,\n  res: TypedResponse&lt;FindSimilarScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 4: Update getRecommendedScenes signature</p> <p>Change: <pre><code>export const getRecommendedScenes = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const getRecommendedScenes = async (\n  req: TypedAuthRequest&lt;unknown, Record&lt;string, string&gt;, GetRecommendedScenesQuery&gt;,\n  res: TypedResponse&lt;GetRecommendedScenesResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 5: Update updateScene signature</p> <p>Change: <pre><code>export const updateScene = async (req: AuthenticatedRequest, res: Response) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const updateScene = async (\n  req: TypedAuthRequest&lt;UpdateSceneRequest, UpdateSceneParams&gt;,\n  res: TypedResponse&lt;UpdateSceneResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 6: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors (or type errors that reveal bugs to fix)</p> <p>Step 7: Run existing tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 8: Commit</p> <pre><code>git add server/controllers/library/scenes.ts\ngit commit -m \"feat(types): add typed signatures to scenes controller\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-6-update-performers-controller-with-typed-signatures","title":"Task 6: Update Performers Controller with Typed Signatures","text":"<p>Files: - Modify: <code>server/controllers/library/performers.ts</code></p> <p>Step 1: Add imports for new types</p> <p>At the top of the file, after existing imports, add:</p> <pre><code>import type {\n  TypedAuthRequest,\n  TypedResponse,\n  FindPerformersRequest,\n  FindPerformersResponse,\n  FindPerformersMinimalRequest,\n  FindPerformersMinimalResponse,\n  UpdatePerformerParams,\n  UpdatePerformerRequest,\n  UpdatePerformerResponse,\n  ApiErrorResponse,\n} from \"../../types/api/index.js\";\n</code></pre> <p>Step 2: Update findPerformers signature</p> <p>Change: <pre><code>export const findPerformers = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findPerformers = async (\n  req: TypedAuthRequest&lt;FindPerformersRequest&gt;,\n  res: TypedResponse&lt;FindPerformersResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 3: Update findPerformersMinimal signature</p> <p>Change: <pre><code>export const findPerformersMinimal = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const findPerformersMinimal = async (\n  req: TypedAuthRequest&lt;FindPerformersMinimalRequest&gt;,\n  res: TypedResponse&lt;FindPerformersMinimalResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 4: Update updatePerformer signature</p> <p>Change: <pre><code>export const updatePerformer = async (\n  req: AuthenticatedRequest,\n  res: Response\n) =&gt; {\n</code></pre></p> <p>To: <pre><code>export const updatePerformer = async (\n  req: TypedAuthRequest&lt;UpdatePerformerRequest, UpdatePerformerParams&gt;,\n  res: TypedResponse&lt;UpdatePerformerResponse | ApiErrorResponse&gt;\n) =&gt; {\n</code></pre></p> <p>Step 5: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 6: Run existing tests</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 7: Commit</p> <pre><code>git add server/controllers/library/performers.ts\ngit commit -m \"feat(types): add typed signatures to performers controller\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-7-update-routehelpers-authenticated-wrapper","title":"Task 7: Update routeHelpers authenticated() Wrapper","text":"<p>Files: - Modify: <code>server/utils/routeHelpers.ts</code></p> <p>Step 1: Read current file</p> <p>Read the file to understand current implementation.</p> <p>Step 2: Update to support generic typed handlers</p> <p>The <code>authenticated()</code> wrapper should preserve type information. Update it to use generics:</p> <pre><code>import type { Response, NextFunction } from \"express\";\nimport type { TypedAuthRequest } from \"../types/api/index.js\";\n\n/**\n * Wrapper for authenticated route handlers\n * Ensures TypeScript knows req.user exists\n */\nexport function authenticated&lt;\n  TBody = unknown,\n  TParams extends Record&lt;string, string&gt; = Record&lt;string, string&gt;,\n  TQuery extends Record&lt;string, string | string[] | undefined&gt; = Record&lt;string, string | undefined&gt;\n&gt;(\n  handler: (\n    req: TypedAuthRequest&lt;TBody, TParams, TQuery&gt;,\n    res: Response,\n    next: NextFunction\n  ) =&gt; Promise&lt;void&gt; | void\n) {\n  return handler as (\n    req: TypedAuthRequest&lt;TBody, TParams, TQuery&gt;,\n    res: Response,\n    next: NextFunction\n  ) =&gt; Promise&lt;void&gt; | void;\n}\n</code></pre> <p>Step 3: Verify file compiles</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 4: Commit</p> <pre><code>git add server/utils/routeHelpers.ts\ngit commit -m \"refactor(types): update authenticated() helper to preserve type info\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#task-8-verify-all-tests-pass","title":"Task 8: Verify All Tests Pass","text":"<p>Files: - None (verification only)</p> <p>Step 1: Run full test suite</p> <p>Run: <code>cd server &amp;&amp; npm test</code> Expected: All tests pass</p> <p>Step 2: Run TypeScript check</p> <p>Run: <code>cd server &amp;&amp; npx tsc --noEmit</code> Expected: No errors</p> <p>Step 3: Run linter</p> <p>Run: <code>cd server &amp;&amp; npm run lint</code> Expected: No errors (or only pre-existing ones)</p>"},{"location":"plans/2026-01-03-api-types-implementation/#task-9-update-design-doc-status","title":"Task 9: Update Design Doc Status","text":"<p>Files: - Modify: <code>docs/plans/2026-01-03-api-types-design.md</code></p> <p>Step 1: Add implementation status</p> <p>Add a section at the end of the design doc:</p> <pre><code>## Implementation Status\n\n### Completed (Phase 1)\n- [x] Type infrastructure (`types/api/common.ts`, `types/api/express.ts`)\n- [x] Library endpoint types (`types/api/library.ts`)\n- [x] Scenes controller typed signatures\n- [x] Performers controller typed signatures\n- [x] Updated `authenticated()` helper\n\n### Remaining (Future Phases)\n- [ ] Studios controller typed signatures\n- [ ] Tags controller typed signatures\n- [ ] Galleries controller typed signatures\n- [ ] Groups controller typed signatures\n- [ ] Images controller typed signatures\n- [ ] Auth endpoints\n- [ ] Playlist endpoints\n- [ ] Carousel endpoints\n- [ ] Rating endpoints\n- [ ] Watch history endpoints\n- [ ] Setup endpoints\n- [ ] User endpoints\n- [ ] API documentation generator script\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add docs/plans/2026-01-03-api-types-design.md\ngit commit -m \"docs: update API types design with implementation status\"\n</code></pre>"},{"location":"plans/2026-01-03-api-types-implementation/#summary","title":"Summary","text":"<p>After completing all tasks:</p> <ol> <li>New files created:</li> <li><code>server/types/api/common.ts</code> - Shared API types</li> <li><code>server/types/api/express.ts</code> - Typed Express helpers</li> <li><code>server/types/api/library.ts</code> - Library endpoint types</li> <li> <p><code>server/types/api/index.ts</code> - Re-exports</p> </li> <li> <p>Files modified:</p> </li> <li><code>server/controllers/library/scenes.ts</code> - Typed signatures</li> <li><code>server/controllers/library/performers.ts</code> - Typed signatures</li> <li><code>server/utils/routeHelpers.ts</code> - Generic authenticated() helper</li> <li> <p><code>docs/plans/2026-01-03-api-types-design.md</code> - Status update</p> </li> <li> <p>Verification:</p> </li> <li>All existing tests pass</li> <li>TypeScript compiles without errors</li> <li> <p>Linter passes</p> </li> <li> <p>Next steps (future work):</p> </li> <li>Apply same pattern to remaining controllers</li> <li>Add remaining endpoint types (auth, playlists, etc.)</li> <li>Create documentation generator script</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/","title":"Multiple Stash Instances - Implementation Plan","text":"<p>Status: Deferred Created: 2025-11-25 Last Updated: 2025-11-25</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#overview","title":"Overview","text":"<p>This document outlines the implementation plan for supporting multiple Stash server instances in Peek, allowing users to aggregate content from multiple Stash libraries into a unified browsing experience.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#current-state-commit-1-complete","title":"Current State (Commit 1 Complete)","text":"<ul> <li><code>StashInstance</code> model exists in database with UUID primary key</li> <li><code>StashInstanceManager</code> service manages connections</li> <li>Single instance enforcement in place (<code>configs.length &gt; 1</code> throws error)</li> <li>Auto-migration from env vars to database on first startup</li> <li>Setup wizard allows configuring first Stash instance</li> <li>Server Settings shows current instance (read-only)</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#key-challenges","title":"Key Challenges","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#1-entity-id-collisions","title":"1. Entity ID Collisions","text":"<p>Stash uses auto-increment integer IDs per-instance. Scene ID <code>123</code> from Instance A is completely different from Scene ID <code>123</code> from Instance B.</p> <p>Options: - Composite key: Store <code>instanceId</code> + <code>sceneId</code> as separate columns (cleaner, preferred) - Prefixed ID: Concatenate as <code>{instanceId}_{sceneId}</code> string (simpler but messier)</p> <p>Decision: Use separate <code>instanceId</code> column for cleaner database architecture.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#2-entity-deduplication","title":"2. Entity Deduplication","text":"<p>The same performer/studio/tag may exist across multiple Stash instances: - Same performer with different local IDs - StashDB integration provides a common identifier (<code>stash_ids</code> field) - Need strategy to merge or deduplicate entities</p> <p>Considerations: - StashDB IDs can serve as deduplication key - If same StashDB ID exists on multiple instances, which one \"wins\"? - May need a \"primary\" instance concept for conflict resolution - Performers without StashDB IDs cannot be deduplicated automatically</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#3-filtering-across-instances","title":"3. Filtering Across Instances","text":"<p>Current filtering assumes single instance: - Tag filters reference tag IDs - Performer filters reference performer IDs - How do we filter when same logical entity has different IDs per instance?</p> <p>Options: - Filter by StashDB ID where available - Filter by name matching (fuzzy, less reliable) - Keep filters instance-scoped (simpler but less unified)</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#4-affected-entity-types","title":"4. Affected Entity Types","text":"<p>All Stash entities need instance tracking: - Scenes - Performers - Studios - Tags - Galleries - Groups - Images</p> <p>Each needs <code>instanceId</code> added to normalized types and cache storage.</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#5-proxy-and-streaming","title":"5. Proxy and Streaming","text":"<p>Must route requests to correct instance: - Image proxy needs to know which instance to fetch from - Video streaming needs to use correct instance's file paths - Already have <code>getBaseUrl(instanceId)</code> and <code>getApiKey(instanceId)</code> methods</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#6-user-data-mapping","title":"6. User Data Mapping","text":"<p>Current user data (ratings, watch history, favorites) uses Stash entity IDs: - <code>WatchHistory.sceneId</code> references a scene - <code>SceneRating.sceneId</code> references a scene - Need composite key or migration strategy</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#implementation-phases","title":"Implementation Phases","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#phase-1-backend-multi-instance-support","title":"Phase 1: Backend Multi-Instance Support","text":"<ol> <li>Remove single-instance enforcement in StashInstanceManager</li> <li>Add <code>instanceId</code> to normalized types (NormalizedScene, NormalizedPerformer, etc.)</li> <li>Update StashCacheManager to fetch from all instances and merge</li> <li>Update cache key strategy to use <code>instanceId:entityId</code> composite</li> <li>Add instance CRUD endpoints:</li> <li><code>GET /api/setup/stash-instances</code> - List all</li> <li><code>POST /api/setup/stash-instance</code> - Create (admin only)</li> <li><code>PUT /api/setup/stash-instance/:id</code> - Update</li> <li><code>DELETE /api/setup/stash-instance/:id</code> - Delete</li> <li>Trigger cache rebuild after any instance change</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-2-entity-identification-refactor","title":"Phase 2: Entity Identification Refactor","text":"<ol> <li>Update all controllers to handle composite entity references</li> <li>Update proxy controller to route to correct instance</li> <li>Update video controller to stream from correct instance</li> <li>Update user data tables to include instanceId in composite keys</li> <li>Create migration for existing user data</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-3-deduplication-system","title":"Phase 3: Deduplication System","text":"<ol> <li>Research StashDB ID availability in Stash GraphQL schema</li> <li>Implement deduplication logic:</li> <li>Fetch StashDB IDs for all entities</li> <li>Group entities by StashDB ID</li> <li>Designate primary instance for conflicts</li> <li>Update UI to show deduplicated entities</li> <li>Handle entities without StashDB IDs (keep separate)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#phase-4-ui-updates","title":"Phase 4: UI Updates","text":"<ol> <li>Update StashInstanceSection for full CRUD:</li> <li>List all instances with status indicators</li> <li>Add Instance button with connection test</li> <li>Edit instance (name, URL, API key)</li> <li>Delete instance with confirmation</li> <li>Enable/disable toggle per instance</li> <li>Update filters to work across instances</li> <li>Show instance badge on entities (optional, for debugging)</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#database-schema-changes","title":"Database Schema Changes","text":"<pre><code>// Already exists\nmodel StashInstance {\n  id        String   @id @default(uuid())\n  name      String\n  url       String\n  apiKey    String\n  enabled   Boolean  @default(true)\n  priority  Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\n// Needs update - add instanceId to composite unique\nmodel WatchHistory {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\nmodel SceneRating {\n  id          Int      @id @default(autoincrement())\n  userId      Int\n  instanceId  String   // NEW\n  sceneId     String\n  // ... other fields\n\n  @@unique([userId, instanceId, sceneId])\n}\n\n// Similar changes for PerformerRating, StudioRating, etc.\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#normalized-type-changes","title":"Normalized Type Changes","text":"<pre><code>interface NormalizedScene {\n  id: string;\n  instanceId: string;  // NEW - which Stash instance this came from\n  // ... existing fields\n}\n\ninterface NormalizedPerformer {\n  id: string;\n  instanceId: string;  // NEW\n  stashDbId?: string;  // NEW - for deduplication\n  // ... existing fields\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#api-response-changes","title":"API Response Changes","text":"<p>Entities returned from API will include <code>instanceId</code>:</p> <pre><code>{\n  \"id\": \"12345\",\n  \"instanceId\": \"8dcbd5b1-73c1-4d1c-b3ce-0924c336e59f\",\n  \"title\": \"Scene Title\",\n  ...\n}\n</code></pre>"},{"location":"plans/MULTI_INSTANCE_STASH/#open-questions","title":"Open Questions","text":"<ol> <li>Should deduplication be automatic or user-controlled?</li> <li>Automatic based on StashDB ID?</li> <li> <p>Let users manually merge entities?</p> </li> <li> <p>How to handle conflicting metadata?</p> </li> <li>Same performer, different bios on different instances</li> <li> <p>Which instance's data takes precedence?</p> </li> <li> <p>Performance impact of multi-instance cache?</p> </li> <li>Cache size doubles/triples with multiple instances</li> <li> <p>Refresh time increases proportionally</p> </li> <li> <p>Should users be able to filter by instance?</p> </li> <li>\"Show only scenes from Instance A\"</li> <li>Useful for debugging, maybe not for regular use</li> </ol>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-1-single-stash-instance-only","title":"Alternative 1: Single Stash Instance Only","text":"<p>Keep the current single-instance design. Users with multiple Stash servers would need to consolidate into one Stash instance.</p> <p>Pros: Simpler, no ID collision issues Cons: Limits use cases, some users have legitimate multi-instance setups</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-2-instance-scoped-everything","title":"Alternative 2: Instance-Scoped Everything","text":"<p>Keep instances completely separate - user switches between instances like switching accounts.</p> <p>Pros: No collision issues, simpler implementation Cons: No unified library view, poor UX for users who want to see everything together</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#alternative-3-external-aggregation","title":"Alternative 3: External Aggregation","text":"<p>Recommend users use Stash's built-in library merging features instead.</p> <p>Pros: No Peek changes needed Cons: May not exist, shifts burden to user</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#estimated-effort","title":"Estimated Effort","text":"<ul> <li>Phase 1: 1-2 days</li> <li>Phase 2: 2-3 days</li> <li>Phase 3: 2-3 days</li> <li>Phase 4: 1-2 days</li> </ul> <p>Total: ~1 week of focused development</p>"},{"location":"plans/MULTI_INSTANCE_STASH/#dependencies","title":"Dependencies","text":"<ul> <li>Understanding of StashDB ID structure in Stash GraphQL</li> <li>Testing with multiple actual Stash instances</li> <li>User feedback on deduplication preferences</li> </ul>"},{"location":"plans/MULTI_INSTANCE_STASH/#references","title":"References","text":"<ul> <li>Stash GraphQL Schema</li> <li>StashDB Integration Docs</li> <li>Commit 1: <code>291b428</code> - Single instance database storage</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/","title":"TikTok/Reels Implementation Analysis","text":""},{"location":"plans/REELS_IMPLEMENTATION/#overview","title":"Overview","text":"<p>This document analyzes what it would take to implement a TikTok/Reels-like experience in Peek, based on user requests referencing Stash TV and StashReels.</p> <p>Important: This would be a separate page/view, not replacing any existing functionality.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#what-users-want","title":"What Users Want","text":"<p>Based on StashReels and Stash TV implementations:</p>"},{"location":"plans/REELS_IMPLEMENTATION/#core-experience","title":"Core Experience","text":"<ul> <li>Vertical swipe/scroll through videos</li> <li>Auto-play when video comes into view</li> <li>Tap to pause/play</li> <li>Minimal, non-intrusive UI</li> <li>Filter-based playlists (use saved Stash filters)</li> <li>Infinite scrolling to load more content</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#key-features","title":"Key Features","text":"<ul> <li>Mute/unmute toggle</li> <li>Quality selector</li> <li>Fullscreen mode</li> <li>O-counter button</li> <li>Rating stars</li> <li>Video scrubbing with thumbnails</li> <li>Performer/tag links</li> <li>Scene info overlay (hideable)</li> <li>Landscape rotation support</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#technical-architecture","title":"Technical Architecture","text":""},{"location":"plans/REELS_IMPLEMENTATION/#route-page-structure","title":"Route &amp; Page Structure","text":"<pre><code>/reels (new page)\n  - Query params: ?filter=xyz&amp;index=123\n  - Separate from scene browse/grid view\n  - Can deep-link to specific position\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#navigation-integration","title":"Navigation Integration","text":"<pre><code>Current Navigation:\n- Home\n- Scenes (grid view)\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n\nWith Reels Added:\n- Home\n- Scenes (grid view) \u2190 unchanged\n- Reels \u2190 NEW PAGE\n- Performers\n- Studios\n- Tags\n- Playlists\n- Watch History\n- Settings\n</code></pre>"},{"location":"plans/REELS_IMPLEMENTATION/#core-components","title":"Core Components","text":"<p>ReelsPage Component: - Main container with vertical scroll - Manages playlist state (current filter, scenes) - Handles pagination/infinite scroll - Filter selection UI</p> <p>ReelItem Component: - Simplified video player for each scene - Auto-play when in viewport (Intersection Observer) - Pause when scrolled away - Minimal overlay controls - Scene metadata display</p> <p>ReelsControls Component: - Floating UI for global controls - Filter/playlist selector - Settings panel - Exit button</p>"},{"location":"plans/REELS_IMPLEMENTATION/#critical-technical-challenges","title":"Critical Technical Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#1-memory-management-most-important","title":"1. Memory Management (MOST IMPORTANT)","text":"<p>Video.js players consume significant RAM. Cannot have 50 players initialized at once.</p> <p>Solution: Only render 3-5 video elements at a time - Current video (playing) - Next video (pre-buffering) - Previous video (for smooth back-scroll) - Dispose players that scroll out of range</p> <p>StashReels Approach:</p> <p>\"Loads only 11 scenes at once\u2014current scene plus five before and after\u2014to optimize browser memory\"</p> <p>Recommended Strategy:</p> <pre><code>Viewport:\n  [Video -2] \u2190 disposed, removed from DOM\n  [Video -1] \u2190 rendered but paused, player initialized\n  [Video  0] \u2190 CURRENT, playing, HLS session active\n  [Video +1] \u2190 rendered, pre-buffering, HLS starting\n  [Video +2] \u2190 rendered element, no player yet\n  [Video +3] \u2190 disposed, removed from DOM\n</code></pre> <p>Rules: - Only 3-4 Video.js players initialized - Only 1-2 active transcoding sessions - Dispose players &gt;2 positions away - Use Intersection Observer threshold for triggering</p>"},{"location":"plans/REELS_IMPLEMENTATION/#2-transcoding-session-management","title":"2. Transcoding Session Management","text":"<p>Each video creates HLS transcoding session. Can't have 20+ FFmpeg processes running.</p> <p>Solution: - Cleanup sessions immediately on scroll away - Pre-start transcoding for next video - Limit to 2-3 active sessions max - Extend <code>TranscodingManager</code> with session priority system</p>"},{"location":"plans/REELS_IMPLEMENTATION/#3-auto-play-restrictions","title":"3. Auto-Play Restrictions","text":"<p>Mobile browsers block autoplay without user interaction. iOS Safari is particularly restrictive.</p> <p>Solution: - First video requires user tap - After that, can auto-play with muted default - Unmute button shows when needed - Fallback UI: \"Tap to play\" message</p>"},{"location":"plans/REELS_IMPLEMENTATION/#4-scroll-performance","title":"4. Scroll Performance","text":"<p>Need smooth 60fps scrolling with videos.</p> <p>Solution: - CSS scroll-snap-type - Intersection Observer (not scroll events) - GPU-accelerated transforms - Virtual scrolling if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-advantages","title":"Implementation Advantages","text":""},{"location":"plans/REELS_IMPLEMENTATION/#what-peek-already-has","title":"What Peek Already Has \u2705","text":"<ul> <li>Video.js integration - Can reuse player setup</li> <li>HLS transcoding system - TranscodingManager ready</li> <li>Quality selection - Already implemented</li> <li>O-counter + rating - Existing buttons/tracking</li> <li>Watch history - Track viewed reels</li> <li>Scene metadata - Performers, tags, descriptions</li> <li>Theme system - Dark/light modes work</li> <li>Auth system - User preferences</li> <li>Mobile responsive - Touch-friendly UI</li> <li>Saved filters from Stash - Can fetch via GraphQL</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#whats-new-need-to-build","title":"What's New (Need to Build) \ud83c\udd95","text":"<ul> <li>Vertical scroll container - With snap points</li> <li>Intersection Observer logic - Trigger play/pause</li> <li>Player lifecycle management - Create/dispose on scroll</li> <li>Gesture handling - Swipe up/down, double-tap</li> <li>Prefetch strategy - Pre-buffer next video</li> <li>Memory monitoring - Track and cleanup aggressively</li> <li>Playlist management - Filter selection, pagination</li> <li>Minimal UI overlay - Different from full player</li> <li>Infinite scroll pagination - Load more scenes</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#implementation-effort-estimate","title":"Implementation Effort Estimate","text":""},{"location":"plans/REELS_IMPLEMENTATION/#phase-1-mvp-5-7-days","title":"Phase 1: MVP (5-7 days)","text":"<ul> <li>Basic vertical scroll with 3 videos</li> <li>Simple auto-play/pause on scroll</li> <li>Minimal controls (mute, close, O-counter)</li> <li>Single filter (e.g., \"Recently Added\")</li> <li>Desktop + mobile basic support</li> </ul> <p>Deliverable: Can swipe through videos with basic playback</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-2-full-features-5-7-days","title":"Phase 2: Full Features (5-7 days)","text":"<ul> <li>Filter selection modal</li> <li>Infinite scroll pagination</li> <li>Full controls (quality, scrubber, fullscreen)</li> <li>Rating integration</li> <li>Scene info overlay</li> <li>Memory optimization</li> <li>Prefetch next video</li> </ul> <p>Deliverable: Feature-complete reels experience</p>"},{"location":"plans/REELS_IMPLEMENTATION/#phase-3-polish-3-5-days","title":"Phase 3: Polish (3-5 days)","text":"<ul> <li>Mobile gesture improvements (double-tap, swipe velocity)</li> <li>Keyboard shortcuts (arrow keys, space)</li> <li>Performance tuning (virtual scrolling if needed)</li> <li>iOS Safari fixes (autoplay, fullscreen)</li> <li>User preferences (default filter, default quality, mute state)</li> <li>Analytics/tracking</li> <li>Error states (network issues, empty playlists)</li> </ul> <p>Deliverable: Production-ready, polished experience</p> <p>Total Estimate: 13-19 days</p>"},{"location":"plans/REELS_IMPLEMENTATION/#key-technical-decisions","title":"Key Technical Decisions","text":""},{"location":"plans/REELS_IMPLEMENTATION/#scroll-implementation","title":"Scroll Implementation","text":"<p>Option A: Native CSS Scroll Snap (Recommended) <pre><code>.reels-container {\n  scroll-snap-type: y mandatory;\n  overflow-y: scroll;\n}\n\n.reel-item {\n  scroll-snap-align: start;\n  height: 100vh;\n}\n</code></pre></p> <p>Pros: Native, smooth, performant Cons: Less control over snap behavior</p> <p>Option B: Custom Scroll Logic Use wheel/touch events with programmatic scrolling</p> <p>Pros: Full control Cons: Complex, hard to get right, performance issues</p> <p>Recommendation: Start with Option A, fall back to B if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#video-player-approach","title":"Video Player Approach","text":"<p>Option A: Reuse existing <code>VideoPlayer</code> component - Pros: Less code duplication - Cons: Component is complex, has unused features for reels</p> <p>Option B: Create simplified <code>ReelVideoPlayer</code> - Pros: Optimized for reels, cleaner, lighter - Cons: Some code duplication</p> <p>Recommendation: Option B - Create <code>ReelVideoPlayer</code> that shares core Video.js setup but removes unnecessary UI (playlist controls, chapter markers, etc.)</p>"},{"location":"plans/REELS_IMPLEMENTATION/#state-management","title":"State Management","text":"<p>Relatively simple state: <pre><code>{\n  filter: currentFilterId,\n  scenes: [...scene IDs...],\n  currentIndex: 123,\n  hasMore: true,\n  loading: false,\n  muted: true,\n  quality: \"720p\"\n}\n</code></pre></p> <p>Recommendation: React Context or simple useState, no need for Redux/Zustand yet</p>"},{"location":"plans/REELS_IMPLEMENTATION/#transcoding-quality","title":"Transcoding Quality","text":"<p>Users on mobile may want lower quality for data usage.</p> <p>Options: 1. Default to 480p for reels 2. Remember user's last quality selection 3. Auto-select based on connection speed 4. Allow per-reel quality override</p> <p>Recommendation: Start with user's last selected quality, add auto-select later if needed</p>"},{"location":"plans/REELS_IMPLEMENTATION/#risks-challenges","title":"Risks &amp; Challenges","text":""},{"location":"plans/REELS_IMPLEMENTATION/#high-risk","title":"High Risk","text":"<ol> <li>Memory leaks - Video.js players not properly disposed</li> <li>Transcoding overload - Too many FFmpeg sessions crash server</li> <li>iOS autoplay - Safari blocks autoplay, breaks experience</li> <li>Janky scroll - Videos lag during scroll</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#medium-risk","title":"Medium Risk","text":"<ol> <li>Network handling - Slow connections, failed loads</li> <li>Empty states - No scenes match filter</li> <li>Battery drain - Continuous video playback on mobile</li> <li>User getting \"lost\" - Infinite scroll, no clear endpoint</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#mitigation-strategies","title":"Mitigation Strategies","text":"<ul> <li>Extensive memory profiling during development</li> <li>TranscodingManager session limits</li> <li>Fallback UI for autoplay failures (\"Tap to play\")</li> <li>Virtual scrolling if performance issues</li> <li>\"You've reached the end\" message after X videos</li> <li>Exit button always visible</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#user-experience-considerations","title":"User Experience Considerations","text":""},{"location":"plans/REELS_IMPLEMENTATION/#must-haves","title":"Must-Haves","text":"<ul> <li>\u26a1 Fast response - Video plays within 500ms of scroll</li> <li>\ud83c\udfaf Clear controls - Obvious how to mute, exit, etc.</li> <li>\ud83d\udcf1 Touch-friendly - Large tap targets, intuitive gestures</li> <li>\ud83d\udd01 Smooth transitions - No blank frames between videos</li> <li>\ud83d\udeaa Easy exit - Back button, close button work intuitively</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#nice-to-haves","title":"Nice-to-Haves","text":"<ul> <li>\u2328\ufe0f Keyboard shortcuts - Space (pause), arrows (next/prev)</li> <li>\ud83d\uddb1\ufe0f Mouse wheel - Desktop users can scroll with wheel</li> <li>\ud83d\udcca Progress indicator - \"Video 5 of 47\" or similar</li> <li>\ud83d\udd16 Remember position - Resume where you left off</li> <li>\ud83c\udfa8 Visual polish - Transitions, animations</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#integration-with-existing-features","title":"Integration with Existing Features","text":""},{"location":"plans/REELS_IMPLEMENTATION/#reuse-existing-components","title":"Reuse Existing Components","text":"<ul> <li><code>SceneStats</code> component (O-counter, rating)</li> <li><code>SceneMetadata</code> component (performers, tags)</li> <li><code>libraryApi</code> service (fetch scenes)</li> <li><code>watchHistoryApi</code> (track views)</li> <li><code>TranscodingManager</code> (HLS sessions)</li> <li>Quality selector UI</li> <li>Auth/theme contexts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#new-components","title":"New Components","text":"<ul> <li><code>ReelsPage.jsx</code> - Main page container</li> <li><code>ReelVideoPlayer.jsx</code> - Simplified player based on <code>VideoPlayer</code></li> <li><code>ReelItem.jsx</code> - Individual reel in scroll container</li> <li><code>ReelsControls.jsx</code> - Floating control UI</li> <li><code>useReelsPlayer.js</code> - Player lifecycle hook</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#modifications-needed","title":"Modifications Needed","text":"<ul> <li>Extend <code>TranscodingManager</code> with session priority (reels vs regular playback)</li> <li>Add reels-specific watch tracking (mark as viewed after X seconds)</li> <li>Add user preferences for reels (default filter, mute state, quality)</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#benefits-of-being-a-separate-page","title":"Benefits of Being a Separate Page","text":""},{"location":"plans/REELS_IMPLEMENTATION/#zero-risk-to-existing-features","title":"Zero Risk to Existing Features","text":"<ul> <li>All current pages (Scenes, Scene Detail, Playlists, etc.) remain untouched</li> <li>If reels page has bugs, doesn't affect main browsing</li> <li>Can be feature-flagged or hidden behind settings if needed</li> <li>Easy to disable if issues arise</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#simpler-implementation","title":"Simpler Implementation","text":"<ul> <li>Don't need to refactor existing components</li> <li>Can use completely different layout/structure</li> <li>Can ignore desktop optimizations if mobile-focused</li> <li>Different routing, different state management</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#gradual-rollout","title":"Gradual Rollout","text":"<ul> <li>Can release as \"beta\" feature</li> <li>Add nav link only when ready</li> <li>Can gather feedback without disrupting existing workflows</li> <li>Easy to A/B test</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#resource-isolation","title":"Resource Isolation","text":"<ul> <li>Reels page uses its own Video.js players (separate from scene detail)</li> <li>Can set different transcoding limits for reels vs regular playback</li> <li>Memory cleanup when navigating away (unmount entire page)</li> <li>No shared state conflicts</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#mobile-first-design","title":"Mobile-First Design","text":"<ul> <li>Can optimize entirely for mobile without breaking desktop scene browsing</li> <li>Different UI paradigms (vertical vs grid) don't conflict</li> <li>Touch gestures won't interfere with click interactions elsewhere</li> </ul>"},{"location":"plans/REELS_IMPLEMENTATION/#rollback-safety","title":"Rollback Safety","text":"<p>If reels page has critical bugs: <pre><code>// In navigation or route config\nconst REELS_ENABLED = import.meta.env.VITE_ENABLE_REELS === 'true';\n\n// Or user setting\nif (user.preferences.showReels) {\n  // Show reels nav link\n}\n</code></pre></p> <p>Can disable without affecting anything else.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#recommended-implementation-path","title":"Recommended Implementation Path","text":""},{"location":"plans/REELS_IMPLEMENTATION/#option-a-mvp-first-recommended","title":"Option A: MVP First (Recommended)","text":"<ol> <li>Validate Demand - Confirm multiple users requesting this</li> <li>Build MVP (3-5 days):</li> <li>Single hardcoded filter (\"Recently Added\")</li> <li>No infinite scroll (just load 20 videos)</li> <li>Basic controls only</li> <li>Desktop-first (mobile later)</li> <li>User Testing - Get feedback before full build</li> <li>Iterate - Build out full features based on feedback</li> </ol>"},{"location":"plans/REELS_IMPLEMENTATION/#option-b-full-build","title":"Option B: Full Build","text":"<p>Skip MVP, build complete feature over 2-3 weeks. Higher risk but faster time-to-complete if MVP would be approved anyway.</p>"},{"location":"plans/REELS_IMPLEMENTATION/#success-criteria","title":"Success Criteria","text":"<p>Technical: - Memory usage stays under 500MB even after 50+ videos viewed - Max 2-3 concurrent transcoding sessions - Smooth 60fps scroll on mobile devices - Video starts within 500ms of scroll</p> <p>User Experience: - 80%+ of users can navigate without instructions - &lt;5% bounce rate on reels page - Average session length &gt;5 minutes - Positive feedback in Discord/GitHub</p>"},{"location":"plans/REELS_IMPLEMENTATION/#conclusion","title":"Conclusion","text":"<p>Arguments For: - \ud83d\udc4d High user engagement (TikTok proves the UX works) - \ud83d\udc4d Differentiates Peek from Stash - \ud83d\udc4d Mobile-first feature (Peek's strength) - \ud83d\udc4d Peek has good infrastructure already (video player, transcoding) - \ud83d\udc4d Can be isolated page (low risk to existing features)</p> <p>Arguments Against: - \ud83d\udc4e Significant effort (2-3 weeks full-time) - \ud83d\udc4e Performance risks (memory, transcoding load) - \ud83d\udc4e Ongoing maintenance (iOS Safari bugs, etc.) - \ud83d\udc4e StashReels already exists for Stash users - \ud83d\udc4e May encourage mindless consumption</p> <p>Recommendation: If you have 2-3 weeks of development time and users are actively requesting this, it's worth building. Start with a minimal MVP to validate the approach, then iterate based on feedback.</p> <p>The key to success will be: 1. Aggressive memory management - Only 3-5 players max 2. Transcoding limits - Max 2 concurrent sessions 3. Mobile testing early - iOS Safari will be the pain point 4. Performance profiling - Measure memory/CPU continuously</p> <p>Last Updated: 2025-10-30 Status: Analysis complete, awaiting decision to proceed</p>"},{"location":"reference/faq/","title":"Frequently Asked Questions","text":"<p>Common questions about Peek Stash Browser.</p>"},{"location":"reference/faq/#general","title":"General","text":""},{"location":"reference/faq/#what-is-peek","title":"What is Peek?","text":"<p>Peek is a modern web application for browsing and streaming Stash media content with real-time HLS transcoding. It provides a fast, responsive interface with adaptive quality streaming.</p>"},{"location":"reference/faq/#how-is-peek-different-from-stash","title":"How is Peek different from Stash?","text":"<p>Peek is a browser/player focused on video playback, while Stash is a comprehensive media organizer. Peek:</p> <ul> <li>Focuses on smooth video playback with adaptive streaming</li> <li>Provides a simplified, browsing-focused interface</li> <li>Uses real-time transcoding for universal compatibility</li> <li>Complements Stash rather than replacing it</li> </ul>"},{"location":"reference/faq/#does-peek-modify-my-stash-library","title":"Does Peek modify my Stash library?","text":"<p>No. Peek is read-only. It connects to Stash's GraphQL API to read data but never modifies your library, files, or metadata.</p>"},{"location":"reference/faq/#installation","title":"Installation","text":""},{"location":"reference/faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<ul> <li>unRAID: Community Applications or manual Docker install</li> <li>Docker: Any platform supporting Docker</li> <li>Development: Node.js 18+ on Windows/Mac/Linux</li> </ul>"},{"location":"reference/faq/#do-i-need-a-separate-database-server","title":"Do I need a separate database server?","text":"<p>No. Peek uses embedded SQLite. No PostgreSQL, MySQL, or other database server needed.</p>"},{"location":"reference/faq/#can-i-run-peek-and-stash-on-the-same-server","title":"Can I run Peek and Stash on the same server?","text":"<p>Yes. They run as separate containers and don't conflict.</p>"},{"location":"reference/faq/#video-playback","title":"Video Playback","text":""},{"location":"reference/faq/#why-does-transcoding-take-so-long","title":"Why does transcoding take so long?","text":"<p>Transcoding is CPU-intensive. Performance depends on:</p> <ul> <li>Server CPU power</li> <li>Storage I/O speed (SSD vs HDD vs network)</li> <li>Original video codec and resolution</li> <li>Target quality selected</li> </ul> <p>For best performance, use local SSD storage and allocate 2-4 CPU cores.</p>"},{"location":"reference/faq/#can-i-play-videos-directly-without-transcoding","title":"Can I play videos directly without transcoding?","text":"<p>Yes! Direct play is available when your browser supports the video codec. Use the quality selector and choose Direct to play the original file without transcoding.</p> <p>When to use Direct: - Fastest playback (no transcoding delay) - Highest quality (original file) - Browser supports the video format</p> <p>When to use transcoding: - Browser doesn't support the format - Want adaptive quality (switch between 720p/480p/360p) - Slower network connections</p>"},{"location":"reference/faq/#can-i-download-the-original-video-file","title":"Can I download the original video file?","text":"<p>Not yet. Video downloads are planned for a future release. Currently, you can only stream videos through Peek's player.</p>"},{"location":"reference/faq/#configuration","title":"Configuration","text":""},{"location":"reference/faq/#where-are-my-settings-stored","title":"Where are my settings stored?","text":"<ul> <li>User preferences: SQLite database in <code>/app/data/peek-db.db</code></li> <li>Server config: Environment variables</li> <li>Temp files: <code>/app/data/hls-cache/</code> (auto-cleaned)</li> </ul>"},{"location":"reference/faq/#how-do-i-backup-my-data","title":"How do I backup my data?","text":"<pre><code># Backup SQLite database\ndocker exec peek-stash-browser sqlite3 /app/data/peek-db.db \".backup /app/data/backup.db\"\n\n# Copy backup out of container\ndocker cp peek-stash-browser:/app/data/backup.db ./peek-backup.db\n</code></pre>"},{"location":"reference/faq/#can-i-customize-the-theme","title":"Can I customize the theme?","text":"<p>Yes! Peek includes several built-in themes and a custom theme editor.</p> <p>Built-in Themes: - Light Mode - Dark Mode (default) - Deep Purple - The Hub</p> <p>Custom Theme Editor: 1. Go to Settings \u2192 My Settings 2. Scroll to Custom Themes section 3. Create your own theme by choosing colors 4. Customize fonts, backgrounds, text colors, and more 5. Save and apply your custom theme</p> <p>Toggle between themes using the theme icon in the navigation bar.</p>"},{"location":"reference/faq/#performance","title":"Performance","text":""},{"location":"reference/faq/#how-many-concurrent-streams-can-peek-handle","title":"How many concurrent streams can Peek handle?","text":"<p>Depends on server CPU:</p> <ul> <li>2 CPU cores: 1-2 streams at 720p</li> <li>4 CPU cores: 3-4 streams at 720p</li> <li>6+ CPU cores: 5+ streams at 720p</li> </ul> <p>Lower qualities (480p, 360p) require less CPU and support more concurrent streams.</p>"},{"location":"reference/faq/#why-is-my-media-loading-slowly","title":"Why is my media loading slowly?","text":"<p>Check storage speed:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>If &lt; 50 MB/s, media is likely on: - Network share (SMB/NFS) - Move to local storage - Slow HDD - Upgrade to SSD - USB drive - Use internal storage</p>"},{"location":"reference/faq/#how-much-disk-space-does-peek-need","title":"How much disk space does Peek need?","text":"<ul> <li>App data: ~100 MB (database, config)</li> <li>Temp files: ~50-100 MB per quality per minute of video</li> <li>Recommendation: 5-10 GB for temp storage on busy servers</li> </ul> <p>Temp files are automatically cleaned up after 30 minutes.</p>"},{"location":"reference/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/faq/#videos-wont-play","title":"Videos won't play","text":"<ol> <li>Check FFmpeg is installed: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Verify path mapping is correct</li> <li>Check file permissions on media</li> <li>Review backend logs for errors</li> </ol> <p>See: Troubleshooting Guide</p>"},{"location":"reference/faq/#cant-connect-to-stash","title":"Can't connect to Stash","text":"<ol> <li>Verify <code>STASH_URL</code> is correct and accessible from container</li> <li>Check Stash API key is valid</li> <li>Test connectivity: <code>docker exec peek-stash-browser curl http://stash:9999/graphql</code></li> </ol>"},{"location":"reference/faq/#login-doesnt-work","title":"Login doesn't work","text":"<ul> <li>Check cookies are enabled</li> <li>Verify <code>JWT_SECRET</code> is set</li> <li>Try incognito mode</li> <li>Clear browser cache</li> </ul>"},{"location":"reference/faq/#features","title":"Features","text":""},{"location":"reference/faq/#how-do-playlists-work","title":"How do playlists work?","text":"<p>Playlists are fully available! Create custom playlists of your favorite scenes.</p> <p>Creating a Playlist: 1. Click Playlists in the navigation 2. Click Create Playlist 3. Enter a name and description 4. Click Create</p> <p>Adding Scenes: - Click the + icon on any scene card - Select the playlist to add it to - Or go to a scene's detail page and click Add to Playlist</p> <p>Playing Playlists: - Click a playlist to view its scenes - Click Play to start from the beginning - Use Shuffle to randomize playback order - Use Repeat (all or one) for continuous playback - Reorder scenes by dragging them in edit mode</p> <p>Learn More</p> <p>See the Complete Playlists Guide for detailed instructions on managing and playing playlists.</p>"},{"location":"reference/faq/#does-peek-track-watch-history","title":"Does Peek track watch history?","text":"<p>Yes! Peek automatically tracks your viewing progress and lets you resume playback from where you left off.</p> <p>Features: - Automatic progress tracking during playback - Resume from any device (synced to your user account) - \"Continue Watching\" section on home page - Progress bars on scene cards - Clear history for individual scenes or all at once</p> <p>Learn More</p> <p>See the Watch History Guide for complete details on managing your watch history.</p>"},{"location":"reference/faq/#can-i-use-keyboard-navigation","title":"Can I use keyboard navigation?","text":"<p>Yes! Peek supports complete keyboard navigation, perfect for TV remotes or wireless keyboards.</p> <p>Key features: - Arrow keys navigate scene grids and lists - Enter to select/play - Video player keyboard shortcuts (Space, arrows, F for fullscreen) - Playlist controls (N for next, P for previous) - TV Mode optimized for couch browsing</p> <p>Learn More</p> <p>See the Keyboard Navigation Guide for all keyboard shortcuts and TV mode setup.</p>"},{"location":"reference/faq/#can-i-use-peek-on-mobile","title":"Can I use Peek on mobile?","text":"<p>Yes. The web interface is responsive and works on mobile browsers. A dedicated mobile app is not currently planned.</p>"},{"location":"reference/faq/#does-peek-support-hardware-transcoding","title":"Does Peek support hardware transcoding?","text":"<p>Not yet. Hardware-accelerated transcoding (GPU) is planned for a future release to improve performance and reduce CPU usage.</p>"},{"location":"reference/faq/#can-i-use-peek-without-stash","title":"Can I use Peek without Stash?","text":"<p>No. Peek requires a Stash server for media library management and metadata. Peek is designed as a companion to Stash, not a replacement.</p>"},{"location":"reference/faq/#security","title":"Security","text":""},{"location":"reference/faq/#is-peek-secure","title":"Is Peek secure?","text":"<p>Peek includes: - JWT authentication - Bcrypt password hashing - Read-only media access - Session management</p> <p>Important: Change the default admin password immediately!</p>"},{"location":"reference/faq/#should-i-expose-peek-to-the-internet","title":"Should I expose Peek to the internet?","text":"<p>No. Peek is designed for local network use. For remote access: - Use VPN - Use reverse proxy with authentication layer - Don't expose directly to internet</p>"},{"location":"reference/faq/#support","title":"Support","text":""},{"location":"reference/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> <li>GitHub Issues: Bug reports and feature requests</li> <li>Stash Discord: #third-party-integrations channel</li> </ul>"},{"location":"reference/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<ol> <li>Search existing issues first</li> <li>Gather logs and error messages</li> <li>Create detailed issue on GitHub</li> <li>Include: version, platform, steps to reproduce</li> </ol> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#can-i-contribute","title":"Can I contribute?","text":"<p>Yes! Contributions are welcome: - Code improvements - Bug fixes - Documentation - Translations (future)</p> <p>See: GitHub Issues</p>"},{"location":"reference/faq/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Install Peek</li> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Create and manage custom playlists</li> <li>Troubleshooting - Fix common issues</li> </ul>"},{"location":"reference/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and solutions for Peek Stash Browser.</p>"},{"location":"reference/troubleshooting/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"reference/troubleshooting/#container-wont-start","title":"Container Won't Start","text":"<p>Check logs first:</p> <pre><code>docker logs peek-stash-browser\n</code></pre> <p>Common causes:</p> <ul> <li>Missing required environment variables (<code>STASH_URL</code>, <code>STASH_API_KEY</code>)</li> <li>Invalid <code>STASH_URL</code> (not accessible from container)</li> <li>Port conflicts (6969 already in use)</li> <li>Missing volume mappings</li> </ul> <p>Solution:</p> <pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove container\ndocker rm peek-stash-browser\n\n# Recreate with correct configuration\n# (use your template or docker-compose)\n</code></pre>"},{"location":"reference/troubleshooting/#cant-connect-to-stash","title":"Can't Connect to Stash","text":"<p>Test connectivity from container:</p> <pre><code>docker exec peek-stash-browser curl -X POST http://your-stash-ip:9999/graphql \\\n  -H \"Content-Type: application/json\" \\\n  -H \"ApiKey: your-api-key-12345\" \\\n  -d '{\n    \"query\": \"query FindTags { findTags(filter: { per_page: 1 }) { count tags { id name } } }\"\n  }'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>STASH_URL</code> is correct and accessible</li> <li>Check Stash API key is valid (Settings \u2192 Security \u2192 API Key)</li> <li>Ensure Stash GraphQL endpoint is enabled</li> <li>Check firewall rules between containers</li> </ul>"},{"location":"reference/troubleshooting/#video-playback","title":"Video Playback","text":""},{"location":"reference/troubleshooting/#videos-wont-play","title":"Videos Won't Play","text":"<ol> <li>Check FFmpeg: <code>docker exec peek-stash-browser ffmpeg -version</code></li> <li>Check file permissions: <code>docker exec peek-stash-browser ls -la /app/media</code></li> <li>Verify path mapping: Go to Settings \u2192 Path Mappings and use \"Test Path\" button</li> <li>Check media is mounted: <code>docker exec peek-stash-browser ls /app/media</code></li> <li>Check backend logs: <code>docker logs peek-stash-browser</code></li> </ol>"},{"location":"reference/troubleshooting/#slow-transcoding","title":"Slow Transcoding","text":"<p>Check I/O performance:</p> <pre><code>docker exec peek-stash-browser dd if=/app/media/test.mp4 of=/dev/null bs=1M count=100\n</code></pre> <p>Expected: 50+ MB/s for good performance</p> <p>Solutions:</p> <ul> <li>Move media to local storage (not network share)</li> <li>Use SSD for media and temp files</li> <li>Reduce quality preset</li> <li>Allocate more CPU to container</li> </ul>"},{"location":"reference/troubleshooting/#authentication","title":"Authentication","text":""},{"location":"reference/troubleshooting/#cant-login","title":"Can't Login","text":"<ul> <li>Verify username/password</li> <li>Check if cookies are enabled in browser</li> <li>Clear browser cache and cookies</li> <li>Try incognito/private browsing mode</li> </ul>"},{"location":"reference/troubleshooting/#session-expires-immediately","title":"Session Expires Immediately","text":"<ul> <li>Check <code>JWT_SECRET</code> is set</li> <li>Verify <code>SECURE_COOKIES</code> matches your setup (false for HTTP)</li> <li>Clear browser cookies</li> <li>Check system clock is correct</li> </ul>"},{"location":"reference/troubleshooting/#network-performance","title":"Network &amp; Performance","text":""},{"location":"reference/troubleshooting/#slow-page-loading","title":"Slow Page Loading","text":"<ul> <li>Check server CPU/memory usage</li> <li>Clear browser cache</li> <li>Verify network speed</li> <li>Check for console errors (F12 \u2192 Console)</li> </ul>"},{"location":"reference/troubleshooting/#images-not-loading","title":"Images Not Loading","text":"<ul> <li>Check Stash is accessible</li> <li>Verify <code>STASH_URL</code> is correct</li> <li>Check browser console for CORS errors</li> <li>Try clearing cache</li> </ul>"},{"location":"reference/troubleshooting/#database","title":"Database","text":""},{"location":"reference/troubleshooting/#database-locked-error","title":"Database Locked Error","text":"<pre><code># Stop container\ndocker stop peek-stash-browser\n\n# Remove lock file\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db-wal\n\n# Restart container\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#reset-database","title":"Reset Database","text":"<p>This Deletes All Data</p> <p>This will delete all users, preferences, and playlists.</p> <pre><code>docker stop peek-stash-browser\ndocker run --rm -v peek-data:/app/data busybox rm /app/data/peek-db.db\ndocker start peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#logs-debugging","title":"Logs &amp; Debugging","text":""},{"location":"reference/troubleshooting/#viewing-logs","title":"Viewing Logs","text":"<pre><code># All logs\ndocker logs peek-stash-browser\n\n# Follow logs (live)\ndocker logs -f peek-stash-browser\n\n# Last 100 lines\ndocker logs --tail 100 peek-stash-browser\n</code></pre>"},{"location":"reference/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Add to environment variables:</p> <pre><code>LOG_LEVEL=debug\n</code></pre>"},{"location":"reference/troubleshooting/#browser-console","title":"Browser Console","text":"<p>Check browser console for frontend errors:</p> <ol> <li>Press F12 to open DevTools</li> <li>Click Console tab</li> <li>Look for red errors</li> <li>Copy error messages when reporting issues</li> </ol>"},{"location":"reference/troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"reference/troubleshooting/#ffmpeg-not-found","title":"\"FFmpeg not found\"","text":"<p>Solution: FFmpeg should be included in the official image. If you see this error: - Pull the latest image: <code>docker pull carrotwaxr/peek-stash-browser:latest</code> - Rebuild your container with the latest image</p>"},{"location":"reference/troubleshooting/#path-not-found-or-path-related-errors","title":"\"Path not found\" or path-related errors","text":"<p>Solution: Check your path mappings: 1. Go to Settings \u2192 Path Mappings in Peek 2. Click Test Path for each mapping 3. Verify paths are accessible 4. Make sure media volumes are mounted to your container</p>"},{"location":"reference/troubleshooting/#session-not-found","title":"\"Session not found\"","text":"<p>Solution: Session expired (30 min timeout). Refresh page and try again.</p>"},{"location":"reference/troubleshooting/#unauthorized","title":"\"Unauthorized\"","text":"<p>Solution: Token expired. Logout and login again.</p>"},{"location":"reference/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"reference/troubleshooting/#before-asking-for-help","title":"Before Asking for Help","text":"<ol> <li>Check this troubleshooting guide</li> <li>Search existing GitHub Issues</li> <li>Check browser console for errors</li> <li>Gather logs and error messages</li> </ol>"},{"location":"reference/troubleshooting/#creating-a-bug-report","title":"Creating a Bug Report","text":"<p>Include:</p> <ul> <li>Peek version: Check Settings \u2192 About</li> <li>Platform: unRAID / Docker / Development</li> <li>Browser: Chrome 120 / Firefox 121 / etc.</li> <li>Stash version: Your Stash server version</li> <li>Error logs: Backend and browser console</li> <li>Steps to reproduce: Detailed steps</li> <li>Screenshots: If applicable</li> </ul>"},{"location":"reference/troubleshooting/#where-to-get-help","title":"Where to Get Help","text":"<ul> <li>GitHub Issues: https://github.com/carrotwaxr/peek-stash-browser/issues</li> <li>Stash Discord: #third-party-integrations channel</li> <li>Documentation: https://carrotwaxr.github.io/peek-stash-browser</li> </ul>"},{"location":"reference/troubleshooting/#next-steps","title":"Next Steps","text":"<ul> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/custom-carousels/","title":"Custom Carousels","text":"<p>Create personalized homepage carousels using a visual query builder. Custom carousels let you define filter rules to automatically curate collections of scenes based on performers, tags, ratings, and more.</p>"},{"location":"user-guide/custom-carousels/#creating-a-custom-carousel","title":"Creating a Custom Carousel","text":"<ol> <li>Navigate to Settings \u2192 Homepage Carousels</li> <li>Click Create Carousel</li> <li>Configure your carousel:</li> <li>Title: Give your carousel a descriptive name</li> <li>Icon: Choose from a selection of icons</li> <li>Filter Rules: Add one or more rules to define which scenes appear</li> <li> <p>Sort: Choose how scenes are ordered (Random, Recently Added, etc.)</p> </li> <li> <p>Click Preview to see matching scenes</p> </li> <li>Click Save once you're satisfied with the preview</li> </ol>"},{"location":"user-guide/custom-carousels/#filter-rules","title":"Filter Rules","text":"<p>Each rule consists of a filter type, comparison operator, and value. All rules must match (AND logic) for a scene to appear in the carousel.</p>"},{"location":"user-guide/custom-carousels/#available-filters","title":"Available Filters","text":"Filter Description Performers Scenes featuring specific performers Tags Scenes with specific tags Studio Scenes from a specific studio Collections Scenes in specific groups/collections Rating Scenes within a rating range (0-100) Duration Scene length in minutes Resolution Video quality (480p, 720p, 1080p, etc.) Play Count Number of times you've watched O Count Your O count for the scene Favorite Scenes Only your favorited scenes Favorite Performers Scenes with your favorite performers Favorite Studios Scenes from your favorite studios Favorite Tags Scenes with your favorite tags Created Date When the scene was added Scene Date The scene's release date Last Played Date When you last watched Performer Age Performer age at time of scene Performer Count Number of performers in scene Bitrate Video bitrate in Mbps Title Contains Text search in scene title Details Contains Text search in scene description"},{"location":"user-guide/custom-carousels/#comparison-operators","title":"Comparison Operators","text":"<p>Different filter types support different operators:</p> <ul> <li>Entity filters (Performers, Tags, etc.): includes any of, includes all of, excludes</li> <li>Numeric filters (Rating, Duration, etc.): between, greater than, less than</li> <li>Boolean filters (Favorites): is true / is false</li> <li>Text filters: contains</li> </ul>"},{"location":"user-guide/custom-carousels/#managing-carousels","title":"Managing Carousels","text":""},{"location":"user-guide/custom-carousels/#reordering","title":"Reordering","text":"<p>Use the up/down arrow buttons next to each carousel to change the display order on your homepage.</p>"},{"location":"user-guide/custom-carousels/#visibility","title":"Visibility","text":"<p>Click the eye icon to show/hide individual carousels. Hidden carousels remain saved but won't appear on the homepage.</p>"},{"location":"user-guide/custom-carousels/#editing","title":"Editing","text":"<p>Click the pencil icon on any custom carousel to modify its rules, title, or icon.</p>"},{"location":"user-guide/custom-carousels/#deleting","title":"Deleting","text":"<p>Click the trash icon to delete a custom carousel. This action cannot be undone.</p>"},{"location":"user-guide/custom-carousels/#limits","title":"Limits","text":"<ul> <li>Maximum of 15 custom carousels per user</li> <li>Each carousel displays up to 12 scenes</li> <li>All filter rules use AND logic (scenes must match all rules)</li> </ul>"},{"location":"user-guide/custom-carousels/#tips","title":"Tips","text":"<ul> <li>Start simple: Begin with one or two rules and add more as needed</li> <li>Use Preview: Always preview before saving to ensure your rules work as expected</li> <li>Random sort: Great for variety - shows different scenes each time you visit</li> <li>Combine with favorites: Create carousels for \"Highly rated scenes with favorite performers\"</li> <li>Content restrictions: Custom carousels respect your hidden items and content restrictions</li> </ul>"},{"location":"user-guide/custom-carousels/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/custom-carousels/#carousel-shows-no-scenes-found","title":"Carousel shows \"No scenes found\"","text":"<ul> <li>Your filter rules may be too restrictive</li> <li>Try relaxing some rules or using different operators</li> <li>Check that you have scenes matching your criteria</li> </ul>"},{"location":"user-guide/custom-carousels/#carousel-not-appearing-on-homepage","title":"Carousel not appearing on homepage","text":"<ul> <li>Make sure the carousel is enabled (eye icon should be visible, not crossed out)</li> <li>Try refreshing the page</li> <li>Check Settings \u2192 Homepage Carousels to verify it's toggled on</li> </ul>"},{"location":"user-guide/external-player/","title":"External Player","text":"<p>Peek allows you to open scenes in external media players like VLC for enhanced playback features such as hardware acceleration, subtitle support, and advanced playback controls.</p>"},{"location":"user-guide/external-player/#platform-compatibility","title":"Platform Compatibility","text":"Platform Status Notes Android \u2705 Works Opens app chooser for any installed video player iOS \u2705 Works Opens directly in VLC (requires VLC for iOS) Windows (Edge/Chrome) \u2705 Works Requires protocol handler setup (see below) Windows (Firefox) \u26a0\ufe0f Limited May not work due to Firefox's protocol handling macOS \ud83d\udd2c Untested Should work with protocol handler Linux \ud83d\udd2c Untested Should work with protocol handler <p>Help Us Test</p> <p>We need community feedback on platform compatibility. If you test on a platform not marked as \"Works\", please report your results on GitHub so we can update this documentation.</p>"},{"location":"user-guide/external-player/#using-the-external-player-button","title":"Using the External Player Button","text":"<p>On the scene page, you'll find an external player button (external link icon) next to the \"View in Stash\" button. The behavior differs by platform:</p>"},{"location":"user-guide/external-player/#mobile-devices","title":"Mobile Devices","text":"<ul> <li>Android: Tapping the button opens a dialog to choose any installed video player app (VLC, MX Player, etc.)</li> <li>iOS: Tapping the button opens the scene directly in VLC (requires VLC for iOS to be installed)</li> </ul>"},{"location":"user-guide/external-player/#desktop-windowsmaclinux","title":"Desktop (Windows/Mac/Linux)","text":"<p>The button becomes a combo button with two parts:</p> <ol> <li>Main button (external link icon): Opens the scene in VLC</li> <li>Dropdown arrow: Click to reveal additional options:</li> <li>Copy Stream URL: Copies the direct stream URL to your clipboard</li> </ol>"},{"location":"user-guide/external-player/#setting-up-vlc-protocol-handler-desktop","title":"Setting Up VLC Protocol Handler (Desktop)","text":"<p>For the \"Open in VLC\" button to work on desktop, you need to install a protocol handler that registers the <code>vlc://</code> URL scheme with your operating system.</p> <p>Why is this needed? VLC doesn't natively understand <code>vlc://</code> URLs. The protocol handler intercepts these URLs, strips the <code>vlc://</code> prefix, and passes the actual video URL to VLC.</p>"},{"location":"user-guide/external-player/#windows-setup-recommended-method","title":"Windows Setup (Recommended Method)","text":"<p>The most reliable method for Windows is using a registry file with a PowerShell script. This approach handles URL encoding issues that browsers introduce.</p>"},{"location":"user-guide/external-player/#step-1-create-the-registry-file","title":"Step 1: Create the Registry File","text":"<ol> <li>Open Notepad</li> <li>Paste the following content:</li> </ol> <pre><code>Windows Registry Editor Version 5.00\n\n[HKEY_CLASSES_ROOT\\vlc]\n@=\"URL:VLC Protocol\"\n\"URL Protocol\"=\"\"\n\n[HKEY_CLASSES_ROOT\\vlc\\DefaultIcon]\n@=\"C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe,0\"\n\n[HKEY_CLASSES_ROOT\\vlc\\shell]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open]\n\n[HKEY_CLASSES_ROOT\\vlc\\shell\\open\\command]\n@=\"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -WindowStyle Hidden -Command \\\"&amp; {$url='%1' -replace '^vlc://' -replace '^http//', 'http://' -replace '^https//', 'https://'; Start-Process -FilePath 'C:\\\\Program Files\\\\VideoLAN\\\\VLC\\\\vlc.exe' -ArgumentList $url}\\\"\"\n</code></pre> <ol> <li>Save as <code>vlc-protocol.reg</code> (make sure to select \"All Files\" as the file type)</li> </ol> <p>Adjust VLC Path if Needed</p> <p>If VLC is installed in a different location (e.g., <code>C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe</code>), update both paths in the registry file accordingly.</p>"},{"location":"user-guide/external-player/#step-2-install-the-registry-entries","title":"Step 2: Install the Registry Entries","text":"<ol> <li>Double-click the <code>vlc-protocol.reg</code> file</li> <li>Click \"Yes\" when prompted by User Account Control</li> <li>Click \"Yes\" when asked to confirm adding to the registry</li> <li>You should see \"The keys and values contained in [path] have been successfully added to the registry\"</li> </ol>"},{"location":"user-guide/external-player/#step-3-test-it","title":"Step 3: Test It","text":"<ol> <li>Open Peek in Edge or Chrome</li> <li>Navigate to a scene</li> <li>Click the external player button</li> <li>When prompted, allow the browser to open the VLC handler</li> <li>VLC should open and start playing the video</li> </ol>"},{"location":"user-guide/external-player/#how-the-powershell-script-works","title":"How the PowerShell Script Works","text":"<p>The PowerShell command in the registry performs these transformations:</p> <ol> <li>Removes the <code>vlc://</code> prefix from the URL</li> <li>Fixes <code>http//</code> \u2192 <code>http://</code> (browsers strip the colon for security)</li> <li>Fixes <code>https//</code> \u2192 <code>https://</code></li> <li>Launches VLC with the corrected URL</li> </ol>"},{"location":"user-guide/external-player/#alternative-third-party-protocol-handlers","title":"Alternative: Third-Party Protocol Handlers","text":"<p>These tools may also work, though results vary:</p> <ul> <li>player-protocol - Supports VLC and PotPlayer</li> <li>vlc-protocol - VLC-specific handler</li> </ul>"},{"location":"user-guide/external-player/#macos-setup","title":"macOS Setup","text":"<p>macOS users can try:</p> <ol> <li>Install a protocol handler like player-protocol</li> <li>Or use the \"Copy Stream URL\" fallback method</li> </ol> <p>macOS Testers Needed</p> <p>If you've successfully set up VLC protocol handling on macOS, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#linux-setup","title":"Linux Setup","text":"<p>Linux users can register protocol handlers via <code>xdg-mime</code> or desktop files. A typical approach:</p> <ol> <li>Create a <code>.desktop</code> file for handling <code>x-scheme-handler/vlc</code></li> <li>Register it with <code>xdg-mime default vlc-handler.desktop x-scheme-handler/vlc</code></li> </ol> <p>Linux Testers Needed</p> <p>If you've successfully set up VLC protocol handling on Linux, please share your method on GitHub.</p>"},{"location":"user-guide/external-player/#copying-the-stream-url-fallback-method","title":"Copying the Stream URL (Fallback Method)","text":"<p>If you don't want to set up a protocol handler, or it's not working on your platform, you can use the \"Copy Stream URL\" option:</p> <ol> <li>Click the dropdown arrow on the external player button</li> <li>Select \"Copy Stream URL\"</li> <li>Open VLC manually</li> <li>Go to Media \u2192 Open Network Stream (Ctrl+N on Windows/Linux, Cmd+N on macOS)</li> <li>Paste the URL and click Play</li> </ol> <p>This method works on all platforms without any additional setup.</p>"},{"location":"user-guide/external-player/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/external-player/#open-in-vlc-doesnt-work-windows","title":"\"Open in VLC\" doesn't work (Windows)","text":"<ol> <li>Check browser: Try Edge or Chrome instead of Firefox</li> <li>Verify registry: Open <code>regedit</code> and check that <code>HKEY_CLASSES_ROOT\\vlc</code> exists</li> <li>Check VLC path: Ensure the path in the registry matches your VLC installation</li> <li>Use fallback: Copy the stream URL and open it manually in VLC</li> </ol>"},{"location":"user-guide/external-player/#firefox-doesnt-open-vlc-windows","title":"Firefox doesn't open VLC (Windows)","text":"<p>Firefox handles custom protocols differently from Edge/Chrome and may not respect Windows registry protocol handlers. Known workarounds:</p> <ul> <li>Use Edge or Chrome for the \"Open in VLC\" feature</li> <li>Use the \"Copy Stream URL\" fallback method</li> <li>Set <code>network.protocol-handler.expose.vlc</code> to <code>false</code> in <code>about:config</code> (results may vary)</li> </ul> <p>Known Issue</p> <p>Firefox on Windows currently doesn't reliably support the <code>vlc://</code> protocol even with the registry handler installed. We're tracking this issue and welcome any solutions from the community.</p>"},{"location":"user-guide/external-player/#video-wont-play-in-vlc","title":"Video won't play in VLC","text":"<ul> <li>Ensure VLC is up to date (version 3.0 or later recommended)</li> <li>The stream URL goes through Peek's proxy, which should handle authentication automatically</li> <li>Try the \"Copy Stream URL\" method to verify the URL works</li> </ul>"},{"location":"user-guide/external-player/#android-no-app-found-to-handle-the-link","title":"Android: No app found to handle the link","text":"<ul> <li>Install a video player app (VLC, MX Player, etc.)</li> <li>The Android intent system should show a list of compatible apps</li> </ul>"},{"location":"user-guide/external-player/#ios-link-doesnt-open-vlc","title":"iOS: Link doesn't open VLC","text":"<ul> <li>Ensure VLC for iOS is installed from the App Store</li> <li>The <code>vlc-x-callback://</code> scheme is only supported by VLC</li> <li>Other iOS video players are not currently supported</li> </ul>"},{"location":"user-guide/external-player/#technical-details","title":"Technical Details","text":""},{"location":"user-guide/external-player/#url-formats-by-platform","title":"URL Formats by Platform","text":"Platform URL Format Example Android Intent URI <code>intent://host#Intent;action=android.intent.action.VIEW;scheme=https;type=video/mp4;...</code> iOS VLC x-callback <code>vlc-x-callback://x-callback-url/stream?url=...</code> Desktop VLC protocol <code>vlc://https://peek.example.com/api/scene/123/proxy-stream/stream</code>"},{"location":"user-guide/external-player/#stream-url","title":"Stream URL","text":"<p>The stream URL points to Peek's proxy endpoint, not directly to Stash. This ensures:</p> <ul> <li>API keys are not exposed in URLs</li> <li>Authentication is handled by Peek</li> <li>The URL format is: <code>{peek-url}/api/scene/{sceneId}/proxy-stream/stream</code></li> </ul>"},{"location":"user-guide/external-player/#contributing","title":"Contributing","text":"<p>If you've found a solution for a platform or browser that's not working, please:</p> <ol> <li>Open an issue with your platform details</li> <li>Describe the steps you took to get it working</li> <li>We'll update this documentation to help other users</li> </ol>"},{"location":"user-guide/hidden-items/","title":"Hidden Items","text":""},{"location":"user-guide/hidden-items/#overview","title":"Overview","text":"<p>The Hidden Items feature allows you to hide specific content from your personal view without affecting other users. Unlike Content Restrictions (which are admin-controlled), Hidden Items are entirely user-controlled and work for all users including admins.</p> <p>Key Difference from Content Restrictions: - Content Restrictions: Set by admins, restrict what a user CAN see (e.g., exclude certain tags/studios) - Hidden Items: Set by users themselves, hide individual items they don't want to see</p>"},{"location":"user-guide/hidden-items/#how-to-hide-items","title":"How to Hide Items","text":""},{"location":"user-guide/hidden-items/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Click the three-dot menu (\u22ee) on any scene card</li> <li>Select \"Hide Scene\"</li> <li>Confirm in the dialog (or check \"Don't ask again\" to skip future confirmations)</li> </ol>"},{"location":"user-guide/hidden-items/#from-entity-cards","title":"From Entity Cards","text":"<p>The same three-dot menu is available on: - Performer cards - Studio cards - Tag cards - Group/Collection cards - Gallery cards</p>"},{"location":"user-guide/hidden-items/#bulk-actions-scenes","title":"Bulk Actions (Scenes)","text":"<ol> <li>Enable multi-select mode by clicking the checkbox icon</li> <li>Select multiple scenes</li> <li>Click \"Hide Selected\" in the bulk action bar</li> </ol>"},{"location":"user-guide/hidden-items/#managing-hidden-items","title":"Managing Hidden Items","text":""},{"location":"user-guide/hidden-items/#viewing-hidden-items","title":"Viewing Hidden Items","text":"<ol> <li>Go to My Settings</li> <li>Scroll to the \"Hidden Items\" section</li> <li>Click View Hidden Items</li> </ol>"},{"location":"user-guide/hidden-items/#restoring-hidden-items","title":"Restoring Hidden Items","text":"<p>From the Hidden Items page: - Click Restore on individual items to unhide them - Click Restore All to restore all hidden items at once - Use the tabs to filter by entity type (Scenes, Performers, Studios, etc.)</p>"},{"location":"user-guide/hidden-items/#dont-ask-again","title":"Don't Ask Again","text":"<p>If you frequently hide items and want to skip the confirmation dialog: 1. Check \"Don't ask me again\" when hiding an item, OR 2. Go to My Settings &gt; Hidden Items section 3. Check \"Don't ask for confirmation when hiding items\"</p> <p>You can toggle this setting on/off at any time.</p>"},{"location":"user-guide/hidden-items/#how-it-works","title":"How It Works","text":""},{"location":"user-guide/hidden-items/#for-regular-users","title":"For Regular Users","text":"<ul> <li>Hidden items are filtered from all views (search, carousels, recommendations)</li> <li>Hidden items persist across sessions and page refreshes</li> <li>Other users are not affected by your hidden items</li> </ul>"},{"location":"user-guide/hidden-items/#for-admin-users","title":"For Admin Users","text":"<ul> <li>Admins can hide content for themselves just like regular users</li> <li>Content Restrictions (INCLUDE/EXCLUDE rules) are bypassed for admins</li> <li>Hidden Items filtering is ALWAYS applied, even for admins</li> <li>This allows admins to maintain full admin access while personalizing their own view</li> </ul>"},{"location":"user-guide/hidden-items/#cascading-behavior","title":"Cascading Behavior","text":"<p>When you hide an entity: - Hiding a Scene: Only that scene is hidden - Hiding a Performer: That performer and scenes where they appear may be affected - Hiding a Studio: That studio and scenes from it may be affected - Hiding a Tag: That tag and related content may be affected</p> <p>Note: The exact cascading behavior depends on your Content Restrictions settings and whether hidden entities are the only content associated with related items.</p>"},{"location":"user-guide/hidden-items/#faq","title":"FAQ","text":""},{"location":"user-guide/hidden-items/#can-i-accidentally-hide-something-important","title":"Can I accidentally hide something important?","text":"<p>You can always restore hidden items from My Settings &gt; View Hidden Items. The Restore All button makes it easy to undo bulk actions.</p>"},{"location":"user-guide/hidden-items/#do-hidden-items-count-toward-my-stats","title":"Do hidden items count toward my stats?","text":"<p>Hidden items are excluded from most views but may still appear in certain statistics or reports.</p>"},{"location":"user-guide/hidden-items/#can-admins-see-what-ive-hidden","title":"Can admins see what I've hidden?","text":"<p>Admins can see that you have hidden items (via database access) but the hidden items feature is designed for personal use. Each user's hidden items are private to them.</p>"},{"location":"user-guide/hidden-items/#what-happens-if-content-ive-hidden-is-updated-in-stash","title":"What happens if content I've hidden is updated in Stash?","text":"<p>Hidden items remain hidden even if the underlying content is modified in Stash. The hiding is based on entity ID, not content characteristics.</p> <p>Document Version: 1.0 Last Updated: 2025-01-21</p>"},{"location":"user-guide/keyboard-navigation/","title":"Keyboard Navigation &amp; TV Mode","text":"<p>Peek provides complete keyboard navigation, making it perfect for TV remotes, wireless keyboards, or couch browsing.</p>"},{"location":"user-guide/keyboard-navigation/#why-keyboard-navigation","title":"Why Keyboard Navigation?","text":"<ul> <li>TV Mode - Use Peek on your TV with just a remote</li> <li>Accessibility - Full keyboard support for users who prefer or require it</li> <li>Efficiency - Navigate faster without reaching for the mouse</li> <li>Couch Browsing - Control everything from your couch with a wireless keyboard</li> </ul>"},{"location":"user-guide/keyboard-navigation/#global-navigation","title":"Global Navigation","text":""},{"location":"user-guide/keyboard-navigation/#primary-navigation-keys","title":"Primary Navigation Keys","text":"Key Action <code>Tab</code> Move to next focusable element <code>Shift+Tab</code> Move to previous focusable element <code>Enter</code> Activate/click the focused element <code>Space</code> Activate buttons (also play/pause in video player) <code>Escape</code> Go back or close modals"},{"location":"user-guide/keyboard-navigation/#arrow-key-navigation","title":"Arrow Key Navigation","text":"<p>Arrow keys navigate through grid layouts and lists:</p> Key Action <code>\u2191</code> Move focus up (in grids and lists) <code>\u2193</code> Move focus down (in grids and lists) <code>\u2190</code> Move focus left (in grids) <code>\u2192</code> Move focus right (in grids) <p>Grid Navigation: - Scene grids automatically respond to arrow keys - Focus moves intelligently between rows and columns - Works on Scenes, Performers, Studios, Tags pages</p> <p>List Navigation: - Arrow up/down navigates vertical lists - Works in playlists, search results, settings</p>"},{"location":"user-guide/keyboard-navigation/#scene-browsing","title":"Scene Browsing","text":""},{"location":"user-guide/keyboard-navigation/#scene-grid-navigation","title":"Scene Grid Navigation","text":"<p>Navigating scene cards:</p> <ol> <li>Use <code>Tab</code> or arrow keys to focus a scene card</li> <li>Press <code>Enter</code> to open the scene detail page</li> <li>Press <code>Escape</code> to go back to the grid</li> </ol> <p>Quick actions on scene cards:</p> Key Action <code>Enter</code> Open scene detail page <code>P</code> Play scene immediately (when focused) <code>+</code> Add to playlist (opens playlist selector) <code>F</code> Toggle favorite (when supported)"},{"location":"user-guide/keyboard-navigation/#scene-detail-page","title":"Scene Detail Page","text":"<p>While viewing scene details:</p> Key Action <code>Space</code> or <code>Enter</code> Play video <code>Escape</code> Return to previous page <code>Tab</code> Navigate between action buttons"},{"location":"user-guide/keyboard-navigation/#video-player-controls","title":"Video Player Controls","text":""},{"location":"user-guide/keyboard-navigation/#playback-controls","title":"Playback Controls","text":"Key Action <code>Space</code> or <code>K</code> Play/Pause <code>\u2190</code> Seek backward 10 seconds <code>\u2192</code> Seek forward 10 seconds <code>Shift+\u2190</code> Seek backward 5 seconds <code>Shift+\u2192</code> Seek forward 5 seconds <code>Home</code> Jump to beginning <code>End</code> Jump to end <code>0-9</code> Jump to 0%-90% of video <p>Examples: - Press <code>5</code> to jump to 50% of the video - Press <code>0</code> to jump to the start - Press <code>9</code> to jump to 90%</p>"},{"location":"user-guide/keyboard-navigation/#volume-controls","title":"Volume Controls","text":"Key Action <code>\u2191</code> Increase volume <code>\u2193</code> Decrease volume <code>M</code> Mute/unmute"},{"location":"user-guide/keyboard-navigation/#display-controls","title":"Display Controls","text":"Key Action <code>F</code> Toggle fullscreen <code>Escape</code> Exit fullscreen <code>T</code> Toggle theater mode (when available)"},{"location":"user-guide/keyboard-navigation/#playlist-playback","title":"Playlist Playback","text":"<p>While playing a playlist:</p> Key Action <code>N</code> or <code>Shift+\u2192</code> Next scene in playlist <code>P</code> or <code>Shift+\u2190</code> Previous scene in playlist <code>S</code> Toggle shuffle <code>R</code> Cycle repeat mode (Off \u2192 All \u2192 One) <code>Escape</code> Exit playlist playback"},{"location":"user-guide/keyboard-navigation/#search-filtering","title":"Search &amp; Filtering","text":""},{"location":"user-guide/keyboard-navigation/#search-box","title":"Search Box","text":"Key Action <code>/</code> or <code>Ctrl+F</code> Focus search box (from anywhere) <code>Escape</code> Clear search and exit search box <code>Enter</code> Submit search / apply filters <code>\u2193</code> Move to search results (from search box)"},{"location":"user-guide/keyboard-navigation/#filter-controls","title":"Filter Controls","text":"<p>While using filters:</p> Key Action <code>Tab</code> Move between filter options <code>Space</code> Toggle checkbox filters <code>Enter</code> Apply filters <code>Escape</code> Close filter panel"},{"location":"user-guide/keyboard-navigation/#playlists","title":"Playlists","text":""},{"location":"user-guide/keyboard-navigation/#playlist-management","title":"Playlist Management","text":"Key Action <code>N</code> Create new playlist (when on Playlists page) <code>Enter</code> Open focused playlist <code>Delete</code> Delete focused playlist (with confirmation)"},{"location":"user-guide/keyboard-navigation/#editing-playlists","title":"Editing Playlists","text":"<p>In edit mode:</p> Key Action <code>Tab</code> Navigate between scenes <code>Delete</code> Remove focused scene from playlist <code>Escape</code> Exit edit mode <code>Enter</code> Save changes <p>Reordering scenes: - Use mouse drag-and-drop for reordering - Keyboard reordering not currently supported</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode","title":"TV Mode","text":""},{"location":"user-guide/keyboard-navigation/#what-is-tv-mode","title":"What is TV Mode?","text":"<p>TV Mode is Peek's interface optimized for TV remotes and couch browsing:</p> <ul> <li>Large Focus Indicators - Easy to see what's selected from across the room</li> <li>Remote-Friendly Navigation - Arrow keys and Enter are all you need</li> <li>Auto-Scroll - Page scrolls to keep focused element visible</li> <li>Simplified Controls - Reduced clutter, bigger buttons</li> </ul>"},{"location":"user-guide/keyboard-navigation/#using-peek-on-tv","title":"Using Peek on TV","text":"<p>Recommended setup:</p> <ol> <li>Connect a computer to your TV (HDMI)</li> <li>Access Peek via web browser on that computer</li> <li>Use a wireless keyboard or TV remote (with keyboard features)</li> <li>Navigate entirely with arrow keys and Enter</li> </ol> <p>Popular remote options: - Amazon Fire TV remote (with Alexa) - Android TV remote apps - Wireless keyboards (Logitech K400, etc.) - Smart TV keyboards - Game controllers (via browser support)</p>"},{"location":"user-guide/keyboard-navigation/#tv-mode-tips","title":"TV Mode Tips","text":"<ol> <li>Use fullscreen browser mode (F11) for immersive experience</li> <li>Enable auto-hide cursor in your OS settings</li> <li>Increase font size in browser settings (Ctrl +)</li> <li>Use dark theme for better viewing in dark rooms</li> <li>Disable screen saver on your PC/TV</li> </ol>"},{"location":"user-guide/keyboard-navigation/#settings-navigation","title":"Settings Navigation","text":""},{"location":"user-guide/keyboard-navigation/#navigating-settings-pages","title":"Navigating Settings Pages","text":"Key Action <code>Tab</code> Move between settings sections <code>Enter</code> Open/edit focused setting <code>Space</code> Toggle switches and checkboxes <code>Escape</code> Cancel without saving"},{"location":"user-guide/keyboard-navigation/#saving-settings","title":"Saving Settings","text":"Key Action <code>Enter</code> Save changes (when focused on Save button) <code>Escape</code> Cancel changes"},{"location":"user-guide/keyboard-navigation/#modal-dialogs","title":"Modal Dialogs","text":""},{"location":"user-guide/keyboard-navigation/#dialog-controls","title":"Dialog Controls","text":"Key Action <code>Enter</code> Confirm action (OK, Save, Submit) <code>Escape</code> Cancel and close dialog <code>Tab</code> Navigate between dialog buttons <p>Examples: - Delete confirmation dialogs - Playlist selector - Add to playlist modal - Login form</p>"},{"location":"user-guide/keyboard-navigation/#accessibility-features","title":"Accessibility Features","text":""},{"location":"user-guide/keyboard-navigation/#focus-indicators","title":"Focus Indicators","text":"<p>Peek shows clear visual focus indicators:</p> <ul> <li>Blue outline around focused elements</li> <li>Highlighted cards when focused in grids</li> <li>Button highlights when focused</li> <li>Scale effect on focused scene cards</li> </ul>"},{"location":"user-guide/keyboard-navigation/#screen-reader-support","title":"Screen Reader Support","text":"<p>Basic screen reader support:</p> <ul> <li>Alt text on images</li> <li>ARIA labels on buttons and controls</li> <li>Semantic HTML for proper navigation</li> <li>Keyboard-accessible everything</li> </ul> <p>Screen Reader Support</p> <p>Screen reader support is improving but may not be perfect. Please report accessibility issues on GitHub.</p>"},{"location":"user-guide/keyboard-navigation/#customizing-keyboard-shortcuts","title":"Customizing Keyboard Shortcuts","text":"<p>Currently not customizable. Keyboard shortcuts are built-in and cannot be changed.</p> <p>Future enhancement: Custom keyboard shortcuts may be added in a future update.</p>"},{"location":"user-guide/keyboard-navigation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/keyboard-navigation/#keyboard-navigation-not-working","title":"Keyboard navigation not working","text":"<p>Solution: - Click anywhere in the browser window to focus it - Try pressing <code>Tab</code> to activate focus mode - Check if a modal or dialog is open (press <code>Escape</code>) - Disable browser extensions that may interfere - Try a different browser</p>"},{"location":"user-guide/keyboard-navigation/#focus-indicator-not-visible","title":"Focus indicator not visible","text":"<p>Solution: - Your browser theme may be hiding focus outlines - Try a different theme in Peek (Settings \u2192 My Settings) - Check browser zoom level (Ctrl + 0 to reset) - Report as a bug if it persists</p>"},{"location":"user-guide/keyboard-navigation/#arrow-keys-scroll-page-instead-of-navigating","title":"Arrow keys scroll page instead of navigating","text":"<p>Solution: - Click on the scene grid to focus it first - Use <code>Tab</code> to focus an element, then arrow keys work - Some areas use <code>Tab</code> navigation only</p>"},{"location":"user-guide/keyboard-navigation/#video-player-shortcuts-not-working","title":"Video player shortcuts not working","text":"<p>Solution: - Make sure video player is focused (click on it) - Some shortcuts only work during playback - Check if another app is intercepting keys - Try clicking the video before using shortcuts</p>"},{"location":"user-guide/keyboard-navigation/#tips-for-power-users","title":"Tips for Power Users","text":""},{"location":"user-guide/keyboard-navigation/#speed-navigation","title":"Speed Navigation","text":"<ol> <li>Use <code>/</code> to search instantly from any page</li> <li>Use number keys (0-9) to scrub through videos quickly</li> <li>Press <code>Escape</code> repeatedly to navigate back multiple levels</li> <li>Use <code>Tab + Enter</code> combo for rapid clicking</li> </ol>"},{"location":"user-guide/keyboard-navigation/#couch-potato-mode","title":"Couch Potato Mode","text":"<p>Perfect setup for couch browsing:</p> <ol> <li>Open Peek in fullscreen (F11)</li> <li>Create a \"Favorites\" playlist</li> <li>Start playlist playback</li> <li>Use only these keys:</li> <li><code>Space</code> - Play/Pause</li> <li><code>N</code> - Next video</li> <li><code>P</code> - Previous video</li> <li><code>\u2191/\u2193</code> - Volume</li> <li><code>F</code> - Fullscreen on/off</li> </ol>"},{"location":"user-guide/keyboard-navigation/#workflow-optimization","title":"Workflow Optimization","text":"<p>Browse and queue efficiently:</p> <ol> <li>Navigate scene grid with arrow keys</li> <li>Press <code>+</code> on scenes you want to watch</li> <li>Add all to \"Watch Later\" playlist</li> <li>Open playlist and press Play</li> <li>Lean back and enjoy</li> </ol>"},{"location":"user-guide/keyboard-navigation/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Playlists - Create and manage custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"},{"location":"user-guide/playlists/","title":"Playlists","text":"<p>Create and manage custom playlists to organize your favorite scenes.</p>"},{"location":"user-guide/playlists/#creating-a-playlist","title":"Creating a Playlist","text":"<ol> <li>Click Playlists in the navigation menu</li> <li>Click the Create Playlist button</li> <li>Enter a name for your playlist</li> <li>Optionally add a description</li> <li>Click Create</li> </ol> <p>Your new playlist is now ready to use!</p>"},{"location":"user-guide/playlists/#adding-scenes-to-playlists","title":"Adding Scenes to Playlists","text":"<p>There are two ways to add scenes to your playlists:</p>"},{"location":"user-guide/playlists/#from-scene-cards","title":"From Scene Cards","text":"<ol> <li>Find a scene you want to add (on any page with scene cards)</li> <li>Click the + (plus) icon on the scene card</li> <li>Select the playlist you want to add it to</li> <li>The scene is added instantly!</li> </ol>"},{"location":"user-guide/playlists/#from-scene-detail-page","title":"From Scene Detail Page","text":"<ol> <li>Click on a scene to open its detail page</li> <li>Click the Add to Playlist button</li> <li>Select the playlist you want to add it to</li> <li>Done!</li> </ol> <p>Multiple Playlists</p> <p>You can add the same scene to multiple playlists. Great for organizing scenes by different themes or moods!</p>"},{"location":"user-guide/playlists/#managing-your-playlists","title":"Managing Your Playlists","text":""},{"location":"user-guide/playlists/#viewing-playlist-contents","title":"Viewing Playlist Contents","text":"<ol> <li>Click Playlists in the navigation</li> <li>Click on any playlist to see its scenes</li> <li>Scroll through to see all scenes in the playlist</li> </ol>"},{"location":"user-guide/playlists/#editing-playlist-details","title":"Editing Playlist Details","text":"<ol> <li>Open a playlist</li> <li>Click the Edit button (pencil icon)</li> <li>Change the name or description</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#reordering-scenes","title":"Reordering Scenes","text":"<p>Want to change the playback order?</p> <ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Drag and drop scenes to reorder them</li> <li>Click Save when done</li> </ol> <p>The playlist will play scenes in the order you've arranged them.</p>"},{"location":"user-guide/playlists/#removing-scenes","title":"Removing Scenes","text":"<ol> <li>Open a playlist</li> <li>Click Edit mode</li> <li>Click the \u00d7 (remove) icon on any scene</li> <li>Confirm removal</li> <li>Click Save</li> </ol>"},{"location":"user-guide/playlists/#deleting-a-playlist","title":"Deleting a Playlist","text":"<p>Permanent Action</p> <p>Deleting a playlist cannot be undone. The scenes themselves are not deleted, just the playlist.</p> <ol> <li>Open the playlist you want to delete</li> <li>Click the Delete button (trash icon)</li> <li>Confirm deletion</li> <li>The playlist is permanently removed</li> </ol>"},{"location":"user-guide/playlists/#playing-playlists","title":"Playing Playlists","text":""},{"location":"user-guide/playlists/#basic-playback","title":"Basic Playback","text":"<ol> <li>Open a playlist</li> <li>Click the Play button</li> <li>Playback starts with the first scene</li> <li>When a scene ends, the next scene plays automatically</li> </ol>"},{"location":"user-guide/playlists/#shuffle-mode","title":"Shuffle Mode","text":"<p>Randomize the playback order:</p> <ol> <li>Open a playlist</li> <li>Click the Shuffle button (shuffle icon)</li> <li>Playlist will play scenes in random order</li> <li>Click Shuffle again to turn it off</li> </ol> <p>Shuffle Tip</p> <p>Shuffle is perfect for long playlists when you want variety!</p>"},{"location":"user-guide/playlists/#repeat-modes","title":"Repeat Modes","text":"<p>Choose how playback repeats:</p> <p>Repeat Off (default) - Playlist plays once and stops</p> <p>Repeat All - When playlist ends, it starts over from the beginning - Continues until you stop it</p> <p>Repeat One - Current scene repeats continuously - Great for favorite scenes!</p> <p>To change repeat mode: 1. Open a playlist 2. Click the Repeat button 3. Click again to cycle through modes: Off \u2192 All \u2192 One \u2192 Off</p>"},{"location":"user-guide/playlists/#navigation-during-playback","title":"Navigation During Playback","text":"<p>While watching a playlist:</p> <ul> <li>Next Scene: Click the next button or press N</li> <li>Previous Scene: Click the previous button or press P</li> <li>Exit Playlist: Click the back button to return to browsing</li> </ul>"},{"location":"user-guide/playlists/#playlist-tips-tricks","title":"Playlist Tips &amp; Tricks","text":""},{"location":"user-guide/playlists/#organization-ideas","title":"Organization Ideas","text":"<ul> <li>By Performer: Create playlists for your favorite performers</li> <li>By Studio: Group scenes from specific studios</li> <li>By Theme: Organize by categories or tags</li> <li>Watch Later: Save scenes you want to watch later</li> <li>Best Of: Curate your absolute favorites</li> <li>Mood-Based: Create playlists for different moods or occasions</li> </ul>"},{"location":"user-guide/playlists/#quick-access","title":"Quick Access","text":"<p>Your playlists are always accessible from: - The Playlists page (shows all playlists) - Any scene's Add to Playlist menu - The + icon on scene cards</p>"},{"location":"user-guide/playlists/#playlist-size","title":"Playlist Size","text":"<p>There's no limit to how many: - Playlists you can create - Scenes you can add to a playlist - Playlists a single scene can be in</p>"},{"location":"user-guide/playlists/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/playlists/#scene-wont-add-to-playlist","title":"Scene won't add to playlist","text":"<ul> <li>Make sure you're logged in</li> <li>Check that the playlist still exists</li> <li>Try refreshing the page</li> </ul>"},{"location":"user-guide/playlists/#playlist-wont-play","title":"Playlist won't play","text":"<ul> <li>Verify the playlist has scenes in it</li> <li>Check that you can play individual scenes</li> <li>Make sure your path mappings are configured correctly</li> </ul>"},{"location":"user-guide/playlists/#changes-arent-saving","title":"Changes aren't saving","text":"<ul> <li>Make sure to click Save after editing</li> <li>Check your internet connection</li> <li>Try refreshing and making changes again</li> </ul>"},{"location":"user-guide/playlists/#next-steps","title":"Next Steps","text":"<ul> <li>Watch History - Resume playback from where you left off</li> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Troubleshooting - Fix common issues</li> <li>FAQ - Frequently asked questions</li> </ul>"},{"location":"user-guide/watch-history/","title":"Watch History &amp; Resume Playback","text":"<p>Peek automatically tracks your viewing progress and lets you resume playback exactly where you left off.</p>"},{"location":"user-guide/watch-history/#how-watch-history-works","title":"How Watch History Works","text":""},{"location":"user-guide/watch-history/#automatic-tracking","title":"Automatic Tracking","text":"<p>Peek tracks your progress automatically while you watch:</p> <ul> <li>Progress is saved every few seconds during playback</li> <li>No manual action needed - just watch normally</li> <li>Per-user tracking - each user has their own watch history</li> <li>Syncs across devices - resume on any device where you're logged in</li> </ul>"},{"location":"user-guide/watch-history/#what-gets-tracked","title":"What Gets Tracked","text":"<p>For each scene you watch, Peek remembers:</p> <ul> <li>Current position - Exact timestamp where you stopped</li> <li>Total progress - Percentage watched (e.g., 65% complete)</li> <li>Last watched date - When you last viewed this scene</li> <li>Watch count - How many times you've watched it</li> </ul>"},{"location":"user-guide/watch-history/#resume-playback","title":"Resume Playback","text":""},{"location":"user-guide/watch-history/#automatic-resume","title":"Automatic Resume","text":"<p>When you click Play on a scene you've partially watched:</p> <ol> <li>Video player opens</li> <li>You see a \"Resume from [timestamp]\" notification</li> <li>Player automatically jumps to where you left off</li> <li>Click \"Start from beginning\" if you prefer to restart</li> </ol> <p>Quick Resume</p> <p>The resume prompt appears for 5 seconds. If you do nothing, playback continues from your last position automatically!</p>"},{"location":"user-guide/watch-history/#from-scene-cards","title":"From Scene Cards","text":"<p>Scene cards show your progress visually:</p> <ul> <li>Progress bar at the bottom of the thumbnail</li> <li>Percentage indicator (e.g., \"65% watched\")</li> <li>Blue progress bar fills from left to right as you watch</li> </ul> <p>To resume from a scene card: 1. Find the scene (look for the progress bar) 2. Click Play 3. Playback resumes automatically</p>"},{"location":"user-guide/watch-history/#continue-watching","title":"Continue Watching","text":""},{"location":"user-guide/watch-history/#quick-access-to-in-progress-scenes","title":"Quick Access to In-Progress Scenes","text":"<p>The Continue Watching section shows all partially-watched scenes:</p> <p>Location: Home page (top section)</p> <p>What appears here: - Scenes you've started but not finished - Sorted by most recently watched - Shows progress percentage - Limited to your last 20 in-progress scenes</p> <p>To resume: 1. Go to Home page 2. Find the scene in Continue Watching 3. Click Play 4. Resumes from where you stopped</p> <p>Fast Resume</p> <p>Continue Watching is the fastest way to pick up where you left off!</p>"},{"location":"user-guide/watch-history/#when-scenes-disappear-from-continue-watching","title":"When Scenes Disappear from Continue Watching","text":"<p>A scene is removed from Continue Watching when: - You watch to completion (95%+ watched counts as complete) - You manually clear watch history for that scene - It falls outside your last 20 in-progress scenes</p>"},{"location":"user-guide/watch-history/#managing-watch-history","title":"Managing Watch History","text":""},{"location":"user-guide/watch-history/#viewing-your-history","title":"Viewing Your History","text":"<p>Full watch history coming in future update. Currently:</p> <ul> <li>View in-progress scenes via Continue Watching on home page</li> <li>See progress bars on scene cards throughout the app</li> <li>Check scene detail page for watch progress</li> </ul>"},{"location":"user-guide/watch-history/#marking-as-watched","title":"Marking as Watched","text":"<p>To mark a scene as fully watched without watching it:</p> <ol> <li>Open the scene detail page</li> <li>Seek to the end of the video (last 5%)</li> <li>Let it play for a few seconds</li> <li>Scene is marked as watched</li> </ol> <p>Or manually skip to 95%+ completion to trigger \"watched\" status.</p>"},{"location":"user-guide/watch-history/#clearing-watch-history","title":"Clearing Watch History","text":"<p>For a single scene:</p> <ol> <li>Open the scene detail page</li> <li>Click the \u22ee (three dots) menu</li> <li>Select \"Clear watch history\"</li> <li>Progress is reset to 0%</li> </ol> <p>For all scenes:</p> <ol> <li>Go to Settings \u2192 My Settings</li> <li>Scroll to Watch History section</li> <li>Click \"Clear all watch history\"</li> <li>Confirm the action</li> <li>All progress is reset</li> </ol> <p>Cannot Be Undone</p> <p>Clearing watch history is permanent. You cannot restore cleared progress.</p>"},{"location":"user-guide/watch-history/#privacy-data","title":"Privacy &amp; Data","text":""},{"location":"user-guide/watch-history/#whats-stored","title":"What's Stored","text":"<p>Watch history is stored in Peek's database:</p> <ul> <li>User ID - Associated with your account</li> <li>Scene ID - Which scene you watched</li> <li>Progress position - Timestamp (in seconds)</li> <li>Last watched date - When you last viewed it</li> <li>Watch count - Total number of views</li> </ul>"},{"location":"user-guide/watch-history/#whats-not-stored","title":"What's NOT Stored","text":"<ul> <li>No video file access logs - Peek doesn't log file system access</li> <li>No sharing with Stash - Watch history stays in Peek only</li> <li>No external tracking - History never leaves your Peek instance</li> </ul>"},{"location":"user-guide/watch-history/#privacy-controls","title":"Privacy Controls","text":"<ul> <li>Per-user isolation - You only see your own history</li> <li>Admin cannot see - Even admins can't view other users' watch history</li> <li>Clear anytime - You control your history data</li> </ul>"},{"location":"user-guide/watch-history/#watch-history-tips","title":"Watch History Tips","text":""},{"location":"user-guide/watch-history/#efficient-binge-watching","title":"Efficient Binge Watching","text":"<ol> <li>Start watching scenes you want to explore</li> <li>Switch between different scenes freely</li> <li>Return to Continue Watching to resume any of them</li> <li>No need to finish in one sitting</li> </ol>"},{"location":"user-guide/watch-history/#organize-with-playlists","title":"Organize with Playlists","text":"<p>Combine watch history with playlists:</p> <ol> <li>Create a \"To Watch\" playlist</li> <li>Add scenes you plan to watch later</li> <li>Watch them at your own pace</li> <li>Progress tracked automatically</li> <li>Resume from Continue Watching or the playlist</li> </ol>"},{"location":"user-guide/watch-history/#track-rewatches","title":"Track Rewatches","text":"<p>Want to rewatch a favorite scene?</p> <ol> <li>Click Play on an already-watched scene</li> <li>Choose \"Start from beginning\" when prompted</li> <li>Watch count increments</li> <li>New progress tracked</li> </ol>"},{"location":"user-guide/watch-history/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/watch-history/#resume-not-working","title":"Resume not working","text":"<p>Solution: - Make sure you're logged in (watch history is per-user) - Check that you watched for at least 10 seconds (minimum tracking threshold) - Verify you're using the same user account - Try refreshing the page</p>"},{"location":"user-guide/watch-history/#progress-bar-not-showing","title":"Progress bar not showing","text":"<p>Solution: - Progress may not appear if you only watched a few seconds - Progress bars require at least 5% completion to display - Try playing the video for longer - Clear browser cache if progress seems stuck</p>"},{"location":"user-guide/watch-history/#continue-watching-is-empty","title":"Continue Watching is empty","text":"<p>Possible reasons: - You haven't started watching any scenes yet - All your in-progress scenes are completed - You cleared your watch history - You're using a different user account</p>"},{"location":"user-guide/watch-history/#progress-resets-unexpectedly","title":"Progress resets unexpectedly","text":"<p>Solution: - Check if someone else cleared watch history (admin action) - Verify you're logged in (anonymous users don't save history) - Check browser console for errors (F12 \u2192 Console) - Report as a bug if it persists</p>"},{"location":"user-guide/watch-history/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>While watching a video:</p> Key Action <code>\u2190</code> Seek backward 10s <code>\u2192</code> Seek forward 10s <code>Space</code> Play/Pause <code>F</code> Toggle fullscreen <code>M</code> Mute/unmute <p>See the Keyboard Navigation Guide for complete shortcuts.</p>"},{"location":"user-guide/watch-history/#next-steps","title":"Next Steps","text":"<ul> <li>Keyboard Navigation - Complete keyboard shortcuts and TV mode</li> <li>Playlists - Organize scenes into custom playlists</li> <li>Quick Start Guide - Get started with Peek</li> </ul>"}]}