generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  password  String // Will be hashed
  role      UserRole @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User preferences
  preferredQuality        String? @default("auto") // "auto", "1080p", "720p", "480p", "360p"
  preferredPlaybackMode   String? @default("auto") // "auto", "direct", "transcode"
  preferredPreviewQuality String? @default("sprite") // "sprite", "webp", "mp4" - Card preview quality (sprite=low quality, webp/mp4=high quality with sprite fallback)
  wallPlayback            String? @default("autoplay") // "autoplay", "hover", "static" - Wall view preview behavior
  enableCast              Boolean @default(true) // Enable Chromecast/AirPlay plugins
  theme                   String? @default("dark") // "dark", "light", "purple", etc.
  carouselPreferences     Json? // Array of {id, enabled, order} for homepage carousels
  navPreferences          Json? // Array of {id, enabled, order} for navigation menu items
  filterPresets           Json? // Object with keys: scene, performer, studio, tag, group, gallery - each containing array of saved presets
  defaultFilterPresets    Json? // Object with keys: scene, performer, studio, tag, group, gallery - values are preset IDs
  unitPreference          String? @default("metric") // "metric" or "imperial" for measurement display
  tableColumnDefaults     Json? // Object with keys: scene, performer, studio, tag, group, gallery, image - each containing {visible: string[], order: string[]}
  cardDisplaySettings     Json? // Object with per-entity-type card display toggles: {scene: {showCodeOnCard, showDescriptionOnCard, ...}, performer: {...}, ...}
  landingPagePreference   Json? @default("{\"pages\":[\"home\"],\"randomize\":false}")
  lightboxDoubleTapAction String? @default("favorite") // "favorite", "o_counter", or "fullscreen" - action on double-tap/double-click in image lightbox

  // First-login setup wizard tracking
  setupCompleted    Boolean   @default(false)
  setupCompletedAt  DateTime?

  // Watch history settings
  minimumPlayPercent Int     @default(20) // Percent of video to watch before incrementing play_count (0-100)
  syncToStash        Boolean @default(false) // Admin-only: Sync this user's activity to Stash

  // Future features
  watchHistory WatchHistory[]
  playlists    Playlist[]
  customThemes CustomTheme[]

  // Per-user ratings and favorites
  sceneRatings     SceneRating[]
  performerRatings PerformerRating[]
  studioRatings    StudioRating[]
  tagRatings       TagRating[]
  galleryRatings   GalleryRating[]
  groupRatings     GroupRating[]
  imageRatings     ImageRating[]
  imageViewHistory ImageViewHistory[]

  // Merge reconciliation audit records
  mergeRecords MergeRecord[]

  // Content restrictions
  contentRestrictions UserContentRestriction[]

  // Hidden entities (user-level hiding)
  hiddenEntities           UserHiddenEntity[]
  hideConfirmationDisabled Boolean            @default(false) // Don't show hide confirmation dialog

  // Permission overrides (null = inherit from groups, true/false = explicit override)
  canShareOverride             Boolean?
  canDownloadFilesOverride     Boolean?
  canDownloadPlaylistsOverride Boolean?

  // Recovery key for password reset (stored plaintext for user viewing)
  recoveryKey String?

  // Group memberships relation
  groupMemberships UserGroupMembership[]

  // Pre-computed exclusions cache
  excludedEntities UserExcludedEntity[]
  entityStats      UserEntityStats[]

  // Custom carousels
  customCarousels UserCarousel[]

  // Downloads
  downloads            Download[]

  // Stash instance selection (which instances user sees content from)
  stashInstances UserStashInstance[]
}

model UserGroup {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?

  // Permission defaults for group members
  canShare             Boolean @default(false)
  canDownloadFiles     Boolean @default(false)
  canDownloadPlaylists Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members UserGroupMembership[]
  playlistShares PlaylistShare[]
}

model UserGroupMembership {
  id      Int       @id @default(autoincrement())
  userId  Int
  groupId Int
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  group   UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
}

model WatchHistory {
  id         Int     @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID (null for legacy single-instance data)
  sceneId    String  // Stash scene ID

  // Playback tracking (syncs with Stash)
  playCount    Int       @default(0) // Number of 5+ minute sessions
  playDuration Float     @default(0) // Total seconds watched (cumulative across all sessions)
  resumeTime   Float? // Last playback position in seconds
  lastPlayedAt DateTime? // Last time this scene was played

  // O Counter tracking (syncs with Stash)
  oCount   Int  @default(0) // Total O counter increments
  oHistory Json @default("[]") // Array of timestamp strings when O was incremented

  // Detailed play session history for analytics
  playHistory Json @default("[]") // Array of {startTime, endTime, quality, duration, seekEvents: [{time, from, to}]}

  // Legacy fields (deprecated, use fields above)
  watchedAt DateTime @default(now())
  position  Int      @default(0)
  duration  Int?
  completed Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, sceneId])
  @@index([userId])
  @@index([sceneId])
  @@index([lastPlayedAt])
}

model Playlist {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  userId      Int
  isPublic    Boolean  @default(false)
  shuffle     Boolean  @default(false)
  repeat      String   @default("none") // "none", "all", "one"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user  User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  items PlaylistItem[]
  shares PlaylistShare[]

  @@index([userId])
  @@index([updatedAt])
}

model PlaylistShare {
  id         Int       @id @default(autoincrement())
  playlistId Int
  groupId    Int
  sharedAt   DateTime  @default(now())

  playlist   Playlist  @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  group      UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([playlistId, groupId])
  @@index([groupId])
}

model PlaylistItem {
  id         Int      @id @default(autoincrement())
  playlistId Int
  instanceId String? // Stash instance ID (for cross-instance playlists)
  sceneId    String  // Stash scene ID
  position   Int // Order in playlist
  addedAt    DateTime @default(now())

  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, instanceId, sceneId])
  @@index([playlistId, position])
}

model CustomTheme {
  id        Int      @id @default(autoincrement())
  userId    Int
  name      String // User-defined theme name (e.g., "My Purple Theme")
  config    Json // Complete theme config: {mode, fonts, colors, accents, status}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
}

model SceneRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  sceneId    String  // Stash scene ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, sceneId])
  @@index([userId])
  @@index([sceneId])
  @@index([favorite])
  @@index([rating])
}

model PerformerRating {
  id          Int      @id @default(autoincrement())
  userId      Int
  instanceId  String? // Stash instance ID
  performerId String  // Stash performer ID
  rating      Int? // 0-100, null if not rated
  favorite    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, performerId])
  @@index([userId])
  @@index([performerId])
  @@index([favorite])
  @@index([rating])
}

model StudioRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  studioId   String  // Stash studio ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, studioId])
  @@index([userId])
  @@index([studioId])
  @@index([favorite])
  @@index([rating])
}

model TagRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  tagId      String  // Stash tag ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, tagId])
  @@index([userId])
  @@index([tagId])
  @@index([favorite])
  @@index([rating])
}

model GalleryRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  galleryId  String  // Stash gallery ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, galleryId])
  @@index([userId])
  @@index([galleryId])
  @@index([favorite])
  @@index([rating])
}

model GroupRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  groupId    String  // Stash group ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, groupId])
  @@index([userId])
  @@index([groupId])
  @@index([favorite])
  @@index([rating])
}

model ImageRating {
  id         Int      @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  imageId    String  // Stash image ID
  rating     Int? // 0-100, null if not rated
  favorite   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, imageId])
  @@index([userId])
  @@index([imageId])
  @@index([favorite])
  @@index([rating])
}

model ImageViewHistory {
  id         Int     @id @default(autoincrement())
  userId     Int
  instanceId String? // Stash instance ID
  imageId    String  // Stash image ID

  // View tracking (incremented when image is viewed in Lightbox)
  viewCount   Int      @default(0)
  viewHistory Json     @default("[]") // Array of timestamp strings

  // O Counter tracking (syncs with Stash)
  oCount   Int  @default(0)
  oHistory Json @default("[]") // Array of timestamp strings

  lastViewedAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId, imageId])
  @@index([userId])
  @@index([imageId])
  @@index([lastViewedAt])
}

model UserContentRestriction {
  id            Int      @id @default(autoincrement())
  userId        Int
  entityType    String // 'groups' | 'tags' | 'studios' | 'galleries'
  mode          String // 'INCLUDE' | 'EXCLUDE'
  entityIds     String // JSON array of entity IDs (stringified)
  restrictEmpty Boolean  @default(false) // If true, restrict items with no entities of this type
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType])
  @@index([userId])
}

// Performance optimization: Pre-computed per-user statistics
// These tables cache aggregated stats from watch history to avoid expensive real-time calculations

model UserPerformerStats {
  id          Int    @id @default(autoincrement())
  userId      Int
  instanceId  String @default("")
  performerId String // Stash performer ID

  // Aggregated statistics from all scenes featuring this performer
  oCounter     Int       @default(0) // Total O counter increments
  playCount    Int       @default(0) // Total play count
  lastPlayedAt DateTime? // Most recent playback timestamp
  lastOAt      DateTime? // Most recent O timestamp

  updatedAt DateTime @updatedAt

  @@unique([userId, instanceId, performerId])
  @@index([userId])
  @@index([performerId])
  @@index([instanceId])
}

model UserStudioStats {
  id         Int    @id @default(autoincrement())
  userId     Int
  instanceId String @default("")
  studioId   String // Stash studio ID

  // Aggregated statistics from all scenes produced by this studio
  oCounter  Int @default(0) // Total O counter increments
  playCount Int @default(0) // Total play count

  updatedAt DateTime @updatedAt

  @@unique([userId, instanceId, studioId])
  @@index([userId])
  @@index([studioId])
  @@index([instanceId])
}

model UserTagStats {
  id         Int    @id @default(autoincrement())
  userId     Int
  instanceId String @default("")
  tagId      String // Stash tag ID

  // Aggregated statistics from all scenes tagged with this tag
  oCounter  Int @default(0) // Total O counter increments
  playCount Int @default(0) // Total play count

  updatedAt DateTime @updatedAt

  @@unique([userId, instanceId, tagId])
  @@index([userId])
  @@index([tagId])
  @@index([instanceId])
}

// Pre-computed percentile rankings for user stats "Top" lists
// Refreshed on login or when engagement changes significantly
model UserEntityRanking {
  id         Int    @id @default(autoincrement())
  userId     Int
  instanceId String @default("")
  entityType String // 'performer' | 'studio' | 'tag' | 'scene'
  entityId   String // Stash entity ID

  // Raw engagement metrics (for display)
  playCount    Int   @default(0)
  playDuration Float @default(0) // seconds
  oCount       Int   @default(0)

  // Computed ranking data
  engagementScore  Float @default(0) // Raw weighted score: (oCount Ã— 5) + (normalizedDuration) + (playCount)
  libraryPresence  Int   @default(1) // Number of scenes in library for this entity
  engagementRate   Float @default(0) // engagementScore / libraryPresence
  percentileRank   Float @default(0) // 0-100, where 100 = top ranked among user's engaged entities of this type

  updatedAt DateTime @updatedAt

  @@unique([userId, instanceId, entityType, entityId])
  @@index([userId, entityType, percentileRank(sort: Desc)])
  @@index([userId, entityType])
  @@index([instanceId])
}

enum UserRole {
  ADMIN
  USER
}

enum DownloadType {
  SCENE
  IMAGE
  PLAYLIST
}

enum DownloadStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  EXPIRED
}

model Download {
  id          Int            @id @default(autoincrement())

  userId      Int
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  type        DownloadType
  status      DownloadStatus @default(PENDING)

  // For playlist downloads
  playlistId  Int?

  // For individual downloads
  entityType  String?        // "scene" or "image"
  entityId    String?

  fileName    String
  fileSize    BigInt?
  filePath    String?        // Server path to completed zip (playlists only)
  progress    Int            @default(0) // 0-100
  error       String?

  createdAt   DateTime       @default(now())
  completedAt DateTime?
  expiresAt   DateTime?      // 24h after completion for playlists

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
}

model UserHiddenEntity {
  id         Int      @id @default(autoincrement())
  userId     Int
  entityType String // 'scene' | 'performer' | 'studio' | 'tag' | 'group' | 'gallery' | 'image'
  entityId   String // Stash entity ID
  hiddenAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType, entityId])
  @@index([userId])
  @@index([entityType])
  @@index([entityId])
}

// Pre-computed exclusions (refreshed on sync/restriction changes)
// This is a derived/cached table - can be rebuilt anytime from UserContentRestriction + UserHiddenEntity
model UserExcludedEntity {
  id         Int      @id @default(autoincrement())
  userId     Int
  entityType String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'
  entityId   String   // Stash entity ID

  reason     String   // 'restricted', 'hidden', 'cascade', 'empty'
  computedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType, entityId])
  @@index([userId, entityType])
  @@index([entityType, entityId])
  @@index([userId, entityType, reason]) // For groupBy stats queries
}

// Pre-computed visible counts (avoids expensive COUNT queries)
model UserEntityStats {
  id           Int      @id @default(autoincrement())
  userId       Int
  entityType   String   // 'scene', 'performer', 'studio', 'tag', 'group', 'gallery', 'image'
  visibleCount Int      // total - excluded
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType])
}

// Track which data migrations have been applied
model DataMigration {
  id        Int      @id @default(autoincrement())
  name      String   @unique // Migration identifier (e.g., "001_rebuild_user_stats")
  appliedAt DateTime @default(now())
}

// Stash server instance configuration
// Supports multiple Stash servers for aggregated library view
model StashInstance {
  id          String   @id @default(uuid()) // Immutable UUID, used in all references
  name        String   @default("Default") // Display name only, can be renamed freely
  description String? // Helps users understand what content is on this instance
  url         String // GraphQL endpoint (e.g., http://stash:9999/graphql)
  apiKey      String // API key for authentication
  enabled     Boolean  @default(true) // Can disable without deleting
  priority    Int      @default(0) // For ordering (lower = higher priority)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  userSelections UserStashInstance[]
}

// Tracks which Stash instances each user wants to see content from
// Users select instances during first-login setup (#321) or in User Preferences
model UserStashInstance {
  id         Int           @id @default(autoincrement())
  userId     Int
  instanceId String
  createdAt  DateTime      @default(now())

  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  instance StashInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([userId, instanceId])
  @@index([userId])
  @@index([instanceId])
}

// User-defined custom carousels for homepage
// Each carousel is a saved scene query with display settings
model UserCarousel {
  id     String @id @default(uuid())
  userId Int
  title  String
  icon   String @default("Film") // Lucide icon name (e.g., "Film", "Heart", "Star")

  // Query definition (same format as buildSceneFilter output)
  rules     Json // Scene filter object for findScenes API
  sort      String @default("random") // Sort field (random, created_at, rating, etc.)
  direction String @default("DESC") // Sort direction (ASC or DESC)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================================================
// CACHED STASH ENTITIES
// These tables store synced data from Stash for scalable querying
// ============================================================================

model StashScene {
  id              String  // Stash scene ID
  stashInstanceId String // Which Stash server

  // === Core fields (indexed) ===
  title     String?
  code      String?
  date      String? // YYYY-MM-DD
  studioId  String?
  rating100 Int?
  duration  Int? // seconds (from primary file)
  organized Boolean @default(false)

  // === Content fields ===
  details  String? // Scene description
  director String? // Director name
  urls     String? // JSON array of URLs

  // === Primary file metadata ===
  filePath       String? // Primary file path
  fileBitRate    Int? // bits/second
  fileFrameRate  Float? // fps
  fileWidth      Int? // pixels
  fileHeight     Int? // pixels
  fileVideoCodec String? // e.g., "h264", "hevc"
  fileAudioCodec String? // e.g., "aac", "ac3"
  fileSize       BigInt? // bytes (can be > 4GB)

  // === Stash paths (raw, transformed at read time) ===
  pathScreenshot  String? // Screenshot URL path
  pathPreview     String? // Preview video path
  pathSprite      String? // Sprite sheet path
  pathVtt         String? // VTT chapter path
  pathChaptersVtt String? // Chapters VTT path
  pathStream      String? // Primary stream path
  pathCaption     String? // Caption path (deprecated - use captions array)

  // === Caption metadata (for multi-language support) ===
  captions String? // JSON: [{language_code, caption_type}]

  // === Stream data (small JSON array) ===
  streams String? // JSON: [{url, mime_type, label}]

  // === Stash counter data ===
  oCounter     Int   @default(0) // Stash o_counter
  playCount    Int   @default(0) // Stash play_count
  playDuration Float @default(0) // Stash play_duration

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Inherited tags (denormalized for filtering) ===
  inheritedTagIds String? // JSON array of tag IDs from performers, studio, groups

  // === Fingerprint data (for merge detection) ===
  phash   String? // Primary perceptual hash (from first file)
  phashes String? // JSON array of all phashes if scene has multiple files

  // === Junction table relations ===
  performers ScenePerformer[]
  tags       SceneTag[]
  groups     SceneGroup[]
  galleries  SceneGallery[]
  clips      StashClip[]

  @@index([studioId])
  @@index([date])
  @@index([stashCreatedAt])
  @@index([stashUpdatedAt])
  @@index([rating100])
  @@index([duration])
  @@index([deletedAt])
  @@index([oCounter])
  @@index([playCount])
  @@index([phash])
  // Compound indexes for efficient browse queries (deletedAt filter + sort)
  @@index([deletedAt, stashCreatedAt(sort: Desc)], map: "StashScene_browse_idx")
  @@index([deletedAt, stashUpdatedAt(sort: Desc)], map: "StashScene_browse_updated_idx")
  @@index([deletedAt, date(sort: Desc)], map: "StashScene_browse_date_idx")
  @@index([deletedAt, title], map: "StashScene_browse_title_idx")
  @@index([deletedAt, duration(sort: Desc)], map: "StashScene_browse_duration_idx")
  @@id([id, stashInstanceId])
}

model StashPerformer {
  id              String
  stashInstanceId String 
  // === Deduplication (StashDB IDs) ===
  stashIds String? // JSON array of {endpoint, stash_id} pairs

  // === Core fields ===
  name           String
  disambiguation String?
  gender         String?
  birthdate      String?
  favorite       Boolean @default(false)
  rating100      Int?

  // === Counts (synced from Stash) ===
  sceneCount   Int @default(0)
  imageCount   Int @default(0)
  galleryCount Int @default(0)
  groupCount   Int @default(0)

  // === Extended fields ===
  details      String? // Biography
  aliasList    String? // JSON array of aliases
  country      String?
  ethnicity    String?
  hairColor    String?
  eyeColor     String?
  heightCm     Int? // Height in cm
  weightKg     Int? // Weight in kg
  measurements String? // e.g., "34D-24-34"
  fakeTits     String? // Breast type: "Natural", "Augmented", etc.
  tattoos      String?
  piercings    String?
  careerLength String?
  deathDate    String?
  url          String? // Homepage

  // === Stash paths (raw, transformed at read time) ===
  imagePath String? // Profile image path

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  scenes    ScenePerformer[]
  images    ImagePerformer[]
  galleries GalleryPerformer[]
  tags      PerformerTag[]

  @@index([name])
  @@index([gender])
  @@index([favorite])
  @@index([rating100])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@id([id, stashInstanceId])
}

model StashStudio {
  id              String
  stashInstanceId String 
  // === Deduplication (StashDB IDs) ===
  stashIds String? // JSON array of {endpoint, stash_id} pairs

  // === Core fields ===
  name      String
  parentId  String?
  favorite  Boolean @default(false)
  rating100 Int?

  // === Counts (synced from Stash) ===
  sceneCount     Int @default(0)
  imageCount     Int @default(0)
  galleryCount   Int @default(0)
  performerCount Int @default(0)
  groupCount     Int @default(0)

  // === Extended fields ===
  details String? // Studio description
  url     String? // Studio website

  // === Stash paths (raw, transformed at read time) ===
  imagePath String? // Logo image path

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  tags      StudioTag[]
  images    StashImage[]
  galleries StashGallery[]

  @@index([name])
  @@index([parentId])
  @@index([favorite])
  @@index([rating100])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@id([id, stashInstanceId])
}

model StashTag {
  id              String
  stashInstanceId String 
  // === Deduplication (StashDB IDs) ===
  stashIds String? // JSON array of {endpoint, stash_id} pairs

  // === Core fields ===
  name     String
  favorite Boolean @default(false)
  color    String? // Hex color from Stash (e.g., "#ff0000")

  // === Counts (synced from Stash) ===
  sceneCount       Int @default(0)
  imageCount       Int @default(0)
  galleryCount     Int @default(0)
  performerCount   Int @default(0)
  studioCount      Int @default(0)
  groupCount       Int @default(0)
  sceneMarkerCount Int @default(0)

  // === Computed counts (calculated after sync) ===
  sceneCountViaPerformers Int @default(0) // Scenes where a performer has this tag

  // === Extended fields ===
  description String? // Tag description
  aliases     String? // JSON array of alias strings
  parentIds   String? // JSON array of parent tag IDs

  // === Stash paths (raw, transformed at read time) ===
  imagePath String? // Tag image path

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  scenes     SceneTag[]
  images     ImageTag[]
  performers PerformerTag[]
  studios    StudioTag[]
  galleries  GalleryTag[]
  groups     GroupTag[]

  // Clip relations
  clipsAsPrimary StashClip[]  @relation("ClipPrimaryTag")
  clipTags       ClipTag[]    @relation("ClipTags")

  @@index([name])
  @@index([favorite])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@id([id, stashInstanceId])
}

model StashGroup {
  id              String
  stashInstanceId String 
  // === Core fields ===
  name      String
  date      String?
  studioId  String?
  rating100 Int?
  duration  Int?

  // === Counts (synced from Stash) ===
  sceneCount     Int @default(0)
  performerCount Int @default(0)

  // === Extended fields ===
  director String?
  synopsis String?
  urls     String? // JSON array of URLs

  // === Stash paths (raw, transformed at read time) ===
  frontImagePath String? // Front cover image
  backImagePath  String? // Back cover image

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  scenes SceneGroup[]
  tags   GroupTag[]

  @@index([name])
  @@index([date])
  @@index([studioId])
  @@index([rating100])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@id([id, stashInstanceId])
}

model StashGallery {
  id              String
  stashInstanceId String 
  // === Core fields ===
  title            String?
  date             String?
  studioId         String?
  studioInstanceId String?
  rating100        Int?
  coverImageId     String? // Stash image ID of the cover image (for dimension lookup)

  // === Counts (synced from Stash) ===
  imageCount Int @default(0)

  // === Extended fields ===
  details      String? // Gallery description
  url          String? // Gallery URL (deprecated)
  code         String? // Gallery code
  photographer String?
  urls         String? // JSON array of URLs

  // === File metadata ===
  folderPath   String? // Folder path if folder-based
  fileBasename String? // First file's basename (for zip galleries)

  // === Stash paths (raw, transformed at read time) ===
  coverPath String? // Cover image path

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  studio     StashStudio?     @relation(fields: [studioId, studioInstanceId], references: [id, stashInstanceId])
  scenes     SceneGallery[]
  images     ImageGallery[]
  performers GalleryPerformer[]
  tags       GalleryTag[]

  @@index([title])
  @@index([date])
  @@index([studioId])
  @@index([rating100])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@index([coverImageId])
  @@id([id, stashInstanceId])
}

model StashImage {
  id              String
  stashInstanceId String 
  // === Core fields ===
  title            String?
  code             String?
  details          String?
  photographer     String?
  urls             String? // JSON array of URLs
  date             String?
  studioId         String?
  studioInstanceId String?
  rating100        Int?
  oCounter         Int     @default(0)
  organized        Boolean @default(false)

  // === File metadata ===
  filePath String? // Image file path
  width    Int?
  height   Int?
  fileSize BigInt? // bytes

  // === Stash paths (raw, transformed at read time) ===
  pathThumbnail String? // Thumbnail URL path
  pathPreview   String? // Preview URL path
  pathImage     String? // Full image URL path

  // === Sync metadata ===
  stashCreatedAt DateTime?
  stashUpdatedAt DateTime?
  syncedAt       DateTime  @default(now())
  deletedAt      DateTime?

  // === Relations ===
  studio     StashStudio?     @relation(fields: [studioId, studioInstanceId], references: [id, stashInstanceId])
  performers ImagePerformer[]
  tags       ImageTag[]
  galleries  ImageGallery[]

  @@index([studioId])
  @@index([date])
  @@index([rating100])
  @@index([stashUpdatedAt])
  @@index([deletedAt])
  @@index([title])
  @@index([deletedAt, stashCreatedAt(sort: Desc)])
  @@id([id, stashInstanceId])
}

model StashClip {
  id              String   // Stash marker ID
  stashInstanceId String
  sceneId         String
  sceneInstanceId String

  scene StashScene @relation(fields: [sceneId, sceneInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  // === Core fields ===
  title           String?
  seconds         Float    // Start position in video (seconds)
  endSeconds      Float?   // Optional end position (seconds)

  // === Tag relations ===
  primaryTagId         String?
  primaryTagInstanceId String?

  primaryTag StashTag? @relation("ClipPrimaryTag", fields: [primaryTagId, primaryTagInstanceId], references: [id, stashInstanceId])
  tags       ClipTag[]

  // === Preview generation status ===
  previewPath     String?  // Stash preview URL path
  screenshotPath  String?  // Stash screenshot URL path
  streamPath      String?  // Stash stream URL path
  isGenerated     Boolean  @default(false)
  generationCheckedAt DateTime?

  // === Sync metadata ===
  stashCreatedAt  DateTime?
  stashUpdatedAt  DateTime?
  syncedAt        DateTime @default(now())
  deletedAt       DateTime?

  @@index([sceneId])
  @@index([primaryTagId])
  @@index([isGenerated, deletedAt])
  @@index([deletedAt, stashCreatedAt(sort: Desc)])
  @@id([id, stashInstanceId])
}

model ClipTag {
  clipId         String
  clipInstanceId String
  tagId          String
  tagInstanceId  String

  clip StashClip @relation(fields: [clipId, clipInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag  StashTag  @relation("ClipTags", fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([clipId, clipInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([clipId, clipInstanceId])
}

// Junction tables for efficient many-to-many queries

model ScenePerformer {
  sceneId             String
  sceneInstanceId     String
  performerId         String
  performerInstanceId String

  scene     StashScene     @relation(fields: [sceneId, sceneInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  performer StashPerformer @relation(fields: [performerId, performerInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([sceneId, sceneInstanceId, performerId, performerInstanceId])
  @@index([performerId, performerInstanceId])
  @@index([sceneId, sceneInstanceId])
}

model SceneTag {
  sceneId         String
  sceneInstanceId String
  tagId           String
  tagInstanceId   String

  scene StashScene @relation(fields: [sceneId, sceneInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag   StashTag   @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([sceneId, sceneInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([sceneId, sceneInstanceId])
}

model SceneGroup {
  sceneId         String
  sceneInstanceId String
  groupId         String
  groupInstanceId String
  sceneIndex      Int?

  scene StashScene @relation(fields: [sceneId, sceneInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  group StashGroup @relation(fields: [groupId, groupInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([sceneId, sceneInstanceId, groupId, groupInstanceId])
  @@index([groupId, groupInstanceId])
  @@index([sceneId, sceneInstanceId])
}

model SceneGallery {
  sceneId           String
  sceneInstanceId   String
  galleryId         String
  galleryInstanceId String

  scene   StashScene   @relation(fields: [sceneId, sceneInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  gallery StashGallery @relation(fields: [galleryId, galleryInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([sceneId, sceneInstanceId, galleryId, galleryInstanceId])
  @@index([galleryId, galleryInstanceId])
  @@index([sceneId, sceneInstanceId])
}

model ImagePerformer {
  imageId             String
  imageInstanceId     String
  performerId         String
  performerInstanceId String

  image     StashImage     @relation(fields: [imageId, imageInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  performer StashPerformer @relation(fields: [performerId, performerInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([imageId, imageInstanceId, performerId, performerInstanceId])
  @@index([performerId, performerInstanceId])
  @@index([imageId, imageInstanceId])
}

model ImageTag {
  imageId         String
  imageInstanceId String
  tagId           String
  tagInstanceId   String

  image StashImage @relation(fields: [imageId, imageInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag   StashTag   @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([imageId, imageInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([imageId, imageInstanceId])
}

model ImageGallery {
  imageId           String
  imageInstanceId   String
  galleryId         String
  galleryInstanceId String

  image   StashImage   @relation(fields: [imageId, imageInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  gallery StashGallery @relation(fields: [galleryId, galleryInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([imageId, imageInstanceId, galleryId, galleryInstanceId])
  @@index([galleryId, galleryInstanceId])
  @@index([imageId, imageInstanceId])
}

model GalleryPerformer {
  galleryId           String
  galleryInstanceId   String
  performerId         String
  performerInstanceId String

  gallery   StashGallery   @relation(fields: [galleryId, galleryInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  performer StashPerformer @relation(fields: [performerId, performerInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([galleryId, galleryInstanceId, performerId, performerInstanceId])
  @@index([performerId, performerInstanceId])
  @@index([galleryId, galleryInstanceId])
}

model PerformerTag {
  performerId         String
  performerInstanceId String
  tagId               String
  tagInstanceId       String

  performer StashPerformer @relation(fields: [performerId, performerInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag       StashTag       @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([performerId, performerInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([performerId, performerInstanceId])
}

model StudioTag {
  studioId         String
  studioInstanceId String
  tagId            String
  tagInstanceId    String

  studio StashStudio @relation(fields: [studioId, studioInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag              StashTag    @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([studioId, studioInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([studioId, studioInstanceId])
}

model GalleryTag {
  galleryId         String
  galleryInstanceId String
  tagId             String
  tagInstanceId     String

  gallery StashGallery @relation(fields: [galleryId, galleryInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag     StashTag     @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([galleryId, galleryInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([galleryId, galleryInstanceId])
}

model GroupTag {
  groupId         String
  groupInstanceId String
  tagId           String
  tagInstanceId   String

  group StashGroup @relation(fields: [groupId, groupInstanceId], references: [id, stashInstanceId], onDelete: Cascade)
  tag   StashTag   @relation(fields: [tagId, tagInstanceId], references: [id, stashInstanceId], onDelete: Cascade)

  @@id([groupId, groupInstanceId, tagId, tagInstanceId])
  @@index([tagId, tagInstanceId])
  @@index([groupId, groupInstanceId])
}

// Sync state tracking per entity type
model SyncState {
  id              Int     @id @default(autoincrement())
  stashInstanceId String?
  entityType      String // 'scene', 'performer', etc.

  // Raw timestamp strings from Stash's maxUpdatedAt - stored exactly as received
  // These are the source of truth for "since" queries to Stash
  // Format: RFC3339 with timezone offset, e.g., "2025-12-28T10:47:03-08:00"
  lastFullSyncTimestamp        String?
  lastIncrementalSyncTimestamp String?

  // Timestamps for UI display (actual UTC time when sync occurred)
  lastFullSyncActual        DateTime?
  lastIncrementalSyncActual DateTime?

  lastSyncCount       Int       @default(0)
  lastSyncDurationMs  Int?
  lastError           String?
  totalEntities       Int       @default(0)

  @@unique([stashInstanceId, entityType])
}

// Sync settings (admin configurable)
model SyncSettings {
  id                     Int     @id @default(1) // Singleton
  syncIntervalMinutes    Int     @default(60) // Default 60 min (current behavior)
  enableScanSubscription Boolean @default(true) // Subscribe to scanCompleteSubscribe
  enablePluginWebhook    Boolean @default(false) // Accept webhook from Stash plugin

  updatedAt DateTime @updatedAt
}

// ============================================================================
// Merge Reconciliation
// ============================================================================

model MergeRecord {
  id              String   @id @default(uuid())
  sourceSceneId   String // The scene that was merged away (soft-deleted)
  targetSceneId   String // The scene it was merged into (survivor)
  matchedByPhash  String? // The phash that linked them (null if manual)

  // User data that was transferred
  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Transfer details
  playCountTransferred    Int     @default(0)
  playDurationTransferred Float   @default(0)
  oCountTransferred       Int     @default(0)
  ratingTransferred       Int?
  favoriteTransferred     Boolean @default(false)

  // Audit
  reconciledAt DateTime @default(now())
  reconciledBy Int? // Admin user ID (null if automatic)
  automatic    Boolean  @default(true) // true = sync-time, false = manual

  createdAt DateTime @default(now())

  @@index([sourceSceneId])
  @@index([targetSceneId])
  @@index([userId])
}
